{
    "address": "0xc1a86faf36cd3c934a892e033e6a306ff29d8fc8",
    "net": {
        "id": "30",
        "name": "RSK Mainnet"
    },
    "name": "CalculatedPriceProvider",
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        }
    },
    "version": "0.6.12+commit.27d51765",
    "source": "/*\nCopyright MOC Investments Corp. 2020. All rights reserved.\n \nYou acknowledge and agree that MOC Investments Corp. (“MOC”) (or MOC’s licensors) own all legal right, title and\ninterest in and to the work, software, application, source code, documentation and any other documents in this\nrepository (collectively, the “Program”), including any intellectual property rights which subsist in the\nProgram (whether those rights happen to be registered or not, and wherever in the world those rights may exist),\nwhether in source code or any other form.\n \nSubject to the limited license below, you may not (and you may not permit anyone else to) distribute, publish, copy,\nmodify, merge, combine with another program, create derivative works of, reverse engineer, decompile or otherwise\nattempt to extract the source code of, the Program or any part thereof, except that you may contribute to\nthis repository.\n \nYou are granted a non-exclusive, non-transferable, non-sublicensable license to distribute, publish, copy, modify,\nmerge, combine with another program or create derivative works of the Program (such resulting program, collectively,\nthe “Resulting Program”) solely for Non-Commercial Use as long as you:\n 1. give prominent notice (“Notice”) with each copy of the Resulting Program that the Program is used in the Resulting\n  Program and that the Program is the copyright of MOC Investments Corp.; and\n 2. subject the Resulting Program and any distribution, publication, copy, modification, merger therewith,\n  combination with another program or derivative works thereof to the same Notice requirement and Non-Commercial\n  Use restriction set forth herein.\n \n“Non-Commercial Use” means each use as described in clauses (1)-(3) below, as reasonably determined by MOC Investments\nCorp. in its sole discretion:\n 1. personal use for research, personal study, private entertainment, hobby projects or amateur pursuits, in each\n case without any anticipated commercial application;\n 2. use by any charitable organization, educational institution, public research organization, public safety or health\n organization, environmental protection organization or government institution; or\n 3. the number of monthly active users of the Resulting Program across all versions thereof and platforms globally\n do not exceed 10,000 at any time.\n \nYou will not use any trade mark, service mark, trade name, logo of MOC Investments Corp. or any other company or\norganization in a way that is likely or intended to cause confusion about the owner or authorized user of such marks,\nnames or logos.\n \nIf you have any questions, comments or interest in pursuing any other use cases, please reach out to us\nat moc.license@moneyonchain.com.\n\n*/\n\npragma solidity 0.6.12;\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n    /**\n      @notice Override this function with a recipe of the changes to be done when this ChangeContract\n      is executed\n     */\n    function execute() external;\n}\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor {\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @dev This function should be protected somehow to only execute changes that\n      benefit the system. This decision process is independent of this architechture\n      therefore is independent of this interface too\n      @param changeContract Address of the contract that will execute the changes\n     */\n    function executeChange(ChangeContract changeContract) external;\n\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @param _changer Address of the contract that will execute the changes\n     */\n    function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n\n/**\n * @dev Interface of the old MOC Oracle\n */\ninterface IPriceProvider {\n    // Legacy function compatible with old MOC Oracle.\n    // returns a tuple (uint256, bool) that corresponds\n    // to the price and if it is not expired.\n    function peek() external view returns (bytes32, bool);\n\n    // Return the current price.\n    function getPrice() external view returns (uint256);\n\n    // Return if the price is not expired.\n    function getIsValid() external view returns (bool);\n\n    // Returns the block number of the last publication.\n    function getLastPublicationBlock() external view returns (uint256);\n\n    // Return the result of getPrice, getIsValid and getLastPublicationBlock at once.\n    function getPriceInfo()\n        external\n        view\n        returns (\n            uint256 price,\n            bool isValid,\n            uint256 lastPubBlock\n        );\n}\n\n\n/// @title PPrice\ninterface IPriceProviderRegisterEntry {\n    enum IPriceProviderType {None, Published, Calculated}\n\n    /// @notice return the type of provider\n    function getPriceProviderType() external pure returns (IPriceProviderType);\n}\n\n\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed {\n    /**\n      @notice The address of the contract which governs this one\n     */\n    IGovernor public governor;\n\n    string private constant NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n    /**\n      @notice Modifier that protects the function\n      @dev You should use this modifier in any function that should be called through\n      the governance system\n     */\n    modifier onlyAuthorizedChanger() {\n        require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n        _;\n    }\n\n    /**\n      @notice Initialize the contract with the basic settings\n      @dev This initialize replaces the constructor but it is not called automatically.\n      It is necessary because of the upgradeability of the contracts\n      @param _governor Governor address\n     */\n    function _initialize(IGovernor _governor) internal {\n        governor = _governor;\n    }\n\n    /**\n      @notice Change the contract's governor. Should be called through the old governance system\n      @param newIGovernor New governor address\n     */\n    function changeIGovernor(IGovernor newIGovernor) external onlyAuthorizedChanger {\n        governor = newIGovernor;\n    }\n\n    /**\n      @notice This method is used by a change contract to access the storage freely even without a setter.\n      @param data the serialized function arguments\n     */\n    function delegateCallToChanger(bytes calldata data)\n        external\n        onlyAuthorizedChanger\n        returns (bytes memory)\n    {\n        address changerContrat = msg.sender;\n        (bool success, bytes memory result) = changerContrat.delegatecall(\n            abi.encodeWithSignature(\"impersonate(bytes)\", data)\n        );\n        require(success, \"Error in delegate call\");\n        return result;\n    }\n\n    // Leave a gap betweeen inherited contracts variables in order to be\n    // able to add more variables in them later\n    uint256[50] private upgradeGap;\n}\n\n\n\n\n/**\n  @notice Based on heavily on EnumberableSet, but with the ability to clear all the contents.\n */\nlibrary AddressSetLib {\n    using SafeMath for uint256;\n\n    struct AddressSet {\n        // Storage of set values\n        address[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(address => uint256) _indexes;\n    }\n\n    function init() internal pure returns (AddressSet memory) {\n        return AddressSet({_values: new address[](0)});\n    }\n\n    /**\n     * @dev Removes all value from a set. O(N).\n     *\n     */\n    function clear(AddressSet storage set) internal {\n        for (uint256 i = 0; i < set._values.length; i++) {\n            delete set._indexes[set._values[i]];\n        }\n        delete set._values;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        if (!contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            address lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1;\n            // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        require(set._values.length > index, \"index out of bounds\");\n        return set._values[index];\n    }\n\n    /**\n     * @dev Returns the set contents as an array\n     */\n    function asArray(AddressSet storage set)\n        internal\n        view\n        returns (address[] memory selectedOracles)\n    {\n        return set._values;\n    }\n}\n\n\n/**\n  @dev An iterable mapping of addresses to boolean, used to check if an address is whitelisted.\n */\ncontract IIterableWhitelist {\n    /**\n      @notice Modifier that protects the function\n      @dev You should use this modifier in any function that should be filtered by the whitelist\n     */\n    modifier whitelistedOrExternal(IterableWhitelistLib.IterableWhitelistData storage self) {\n        // We use address(1) to allow calls from outside the block chain to peek\n        // The call must use msg.sender == 1 (or { from: 1 }) something that only can be done from\n        // outside the blockchain.\n        require(\n            msg.sender == address(1) || IterableWhitelistLib._isWhitelisted(self, msg.sender),\n            \"Address is not whitelisted\"\n        );\n        _;\n    }\n\n    /**\n      @notice Modifier that protects the function\n      @dev You should use this modifier in any function that should be filtered by the whitelist\n     */\n    modifier onlyWhitelisted(IterableWhitelistLib.IterableWhitelistData storage self) {\n        require(\n            IterableWhitelistLib._isWhitelisted(self, msg.sender),\n            \"Address is not whitelisted\"\n        );\n        _;\n    }\n}\n\nlibrary IterableWhitelistLib {\n    using AddressSetLib for AddressSetLib.AddressSet;\n\n    struct IterableWhitelistData {\n        AddressSetLib.AddressSet _inner;\n    }\n\n    /**\n     * @dev Check if an account is whitelisted\n     * @return Bool\n     */\n    function _isWhitelisted(IterableWhitelistData storage self, address account)\n        internal\n        view\n        returns (bool)\n    {\n        require(account != address(0), \"Account must not be 0x0\");\n        return self._inner.contains(account);\n    }\n\n    /**\n     * @dev Add account to whitelist\n     */\n    function _addToWhitelist(IterableWhitelistData storage self, address account) internal {\n        require(account != address(0), \"Account must not be 0x0\");\n        bool added = self._inner.add(account);\n        require(added, \"Account already whitelisted\");\n    }\n\n    /**\n     * @dev Remove account to whitelist\n     */\n    function _removeFromWhitelist(IterableWhitelistData storage self, address account) internal {\n        require(account != address(0), \"Account must not be 0x0\");\n        bool removed = self._inner.remove(account);\n        require(removed, \"Missing account\");\n    }\n\n    /// @notice Returns the count of whitelisted addresses.\n    function _getWhiteListLen(IterableWhitelistData storage self) internal view returns (uint256) {\n        return self._inner.length();\n    }\n\n    /// @notice Returns the address at index.\n    /// @param idx index to query.\n    function _getWhiteListAtIndex(IterableWhitelistData storage self, uint256 idx)\n        internal\n        view\n        returns (address)\n    {\n        return self._inner.at(idx);\n    }\n}\n\n\n\n/// @title This contract gets the price from some IPriceProviders and do the math to calculate\n/// a deduced price, for example RIFBTC and BTCUSD gives the price of RIFUSD\nlibrary CalculatedPriceProviderLib {\n    using SafeMath for uint256;\n    struct CalculatedPriceProviderData {\n        IPriceProvider[] multiplyBy;\n        IPriceProvider[] divideBy;\n        uint256 multiplicator;\n        uint256 divisor;\n    }\n\n    uint256 public constant MAX_INT = 2**256 - 1;\n\n    /**\n    Contract creation.\n\n    @param _multiplicator base value used to scale the result by multiplying it.\n    @param _multiplyBy list of IPriceProvider to query the price and then multiply the result\n    @param _divisor base value used to scale the result by dividing it.\n    @param _divideBy list of IPriceProvider to query the and then divide the result\n    */\n    function _initialize(\n        CalculatedPriceProviderData storage self,\n        uint256 _multiplicator,\n        IPriceProvider[] memory _multiplyBy,\n        uint256 _divisor,\n        IPriceProvider[] memory _divideBy\n    ) internal {\n        self.multiplicator = _multiplicator;\n        self.multiplyBy = _multiplyBy;\n        self.divisor = _divisor;\n        self.divideBy = _divideBy;\n    }\n\n    /**\n    Get the calculated price\n\n    */\n    function _getPriceInfo(CalculatedPriceProviderData storage self)\n        internal\n        view\n        returns (\n            uint256 price,\n            bool isValid,\n            uint256 lastPubBlock\n        )\n    {\n        uint256 den;\n        (den, isValid, lastPubBlock) = _multiplyAll(self.multiplicator, self.multiplyBy);\n\n        (uint256 div, bool valid, uint256 pubBlock) = _multiplyAll(self.divisor, self.divideBy);\n        lastPubBlock = min(lastPubBlock, pubBlock);\n        if (!isValid || !valid || div == 0) {\n            return (0, false, lastPubBlock);\n        }\n        return (den.div(div), true, lastPubBlock);\n    }\n\n    /**\n    Multiply a base val by the result of calling peek in the providers contacts\n\n    @param val a base value used to scale things up.this\n    @param providers a list of IPriceProvider that are queried for prices, all the prices are multiplied.\n    */\n    function _multiplyAll(uint256 val, IPriceProvider[] memory providers)\n        internal\n        view\n        returns (\n            uint256 price,\n            bool isValid,\n            uint256 lastPubBlock\n        )\n    {\n        lastPubBlock = MAX_INT;\n        isValid = true;\n        uint256 current;\n        bool valid;\n        uint256 pubBlock;\n        for (uint256 i = 0; i < providers.length; i++) {\n            (current, valid, pubBlock) = providers[i].getPriceInfo();\n            if (!valid) {\n                isValid = false;\n            }\n            val = val.mul(uint256(current));\n            lastPubBlock = min(lastPubBlock, pubBlock);\n        }\n        return (val, isValid, lastPubBlock);\n    }\n\n    function min(uint256 a, uint256 b) private pure returns (uint256) {\n        if (a < b) {\n            return a;\n        }\n        return b;\n    }\n}\n\n\n/// @title This contract gets the price from some IPriceProviders and do the math to calculate\n/// a deduced price, for example RIFBTC and BTCUSD gives the price of RIFUSD\ncontract CalculatedPriceProviderStorage is Initializable, Governed, IIterableWhitelist {\n    using SafeMath for uint256;\n    using IterableWhitelistLib for IterableWhitelistLib.IterableWhitelistData;\n    using CalculatedPriceProviderLib for CalculatedPriceProviderLib.CalculatedPriceProviderData;\n\n    IterableWhitelistLib.IterableWhitelistData internal iterableWhitelistData;\n\n    CalculatedPriceProviderLib.CalculatedPriceProviderData internal calculatedPriceProviderData;\n\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    // solhint-disable-next-line no-empty-blocks\n    constructor() internal {}\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n\n\n/// @title This contract gets the price from some IPriceProviders and do the math to calculate\n/// a deduced price, for example RIFBTC and BTCUSD gives the price of RIFUSD\ncontract CalculatedPriceProvider is\n    CalculatedPriceProviderStorage,\n    IPriceProvider,\n    IPriceProviderRegisterEntry\n{\n    using SafeMath for uint256;\n\n    /**\n    Contract creation.\n\n    @param _governor The address of the contract which governs this one\n    @param _wlist Initial whitelist addresses\n    @param _multiplicator base value used to scale the result by multiplying it.\n    @param _multiplyBy list of IPriceProvider to query the price and then multiply the result\n    @param _divisor base value used to scale the result by dividing it.\n    @param _divideBy list of IPriceProvider to query the and then divide the result\n    */\n    function initialize(\n        IGovernor _governor,\n        address[] calldata _wlist,\n        uint256 _multiplicator,\n        IPriceProvider[] calldata _multiplyBy,\n        uint256 _divisor,\n        IPriceProvider[] calldata _divideBy\n    ) external initializer {\n        _initialize(_governor);\n        calculatedPriceProviderData._initialize(_multiplicator, _multiplyBy, _divisor, _divideBy);\n        for (uint256 i = 0; i < _wlist.length; i++) {\n            iterableWhitelistData._addToWhitelist(_wlist[i]);\n        }\n    }\n\n    /**\n     * @dev Add to the list of contracts that can stake in this contract\n     * @param  _whitelisted - the override coinPair\n     */\n    function addToWhitelist(address _whitelisted) external onlyAuthorizedChanger() {\n        iterableWhitelistData._addToWhitelist(_whitelisted);\n    }\n\n    /**\n     * @dev Remove from the list of contracts that can stake in this contract\n     * @param _whitelisted - the override coinPair\n     */\n    function removeFromWhitelist(address _whitelisted) external onlyAuthorizedChanger() {\n        iterableWhitelistData._removeFromWhitelist(_whitelisted);\n    }\n\n    /// @notice Returns the count of whitelisted addresses.\n    function getWhiteListLen() external view returns (uint256) {\n        return iterableWhitelistData._getWhiteListLen();\n    }\n\n    /// @notice Returns the address at index.\n    /// @param _idx index to query.\n    function getWhiteListAtIndex(uint256 _idx) external view returns (address) {\n        return iterableWhitelistData._getWhiteListAtIndex(_idx);\n    }\n\n    /// @notice return the type of provider\n    function getPriceProviderType() external override pure returns (IPriceProviderType) {\n        return IPriceProviderType.Calculated;\n    }\n\n    /// @notice Return the current price, compatible with old MOC Oracle\n    function peek()\n        external\n        override\n        view\n        whitelistedOrExternal(iterableWhitelistData)\n        returns (bytes32, bool)\n    {\n        (uint256 price, bool valid, ) = calculatedPriceProviderData._getPriceInfo();\n        return (bytes32(price), valid);\n    }\n\n    // Return the current price.\n    function getPrice() external override view returns (uint256) {\n        (uint256 price, , ) = calculatedPriceProviderData._getPriceInfo();\n        return uint256(price);\n    }\n\n    // Return if the price is not expired.\n    function getIsValid() external override view returns (bool) {\n        (, bool valid, ) = calculatedPriceProviderData._getPriceInfo();\n        return valid;\n    }\n\n    // Returns the block number of the last publication.\n    function getLastPublicationBlock() external override view returns (uint256) {\n        (, , uint256 lastPubBlock) = calculatedPriceProviderData._getPriceInfo();\n        return lastPubBlock;\n    }\n\n    // Return the result of getPrice, getIsValid and getLastPublicationBlock at once.\n    function getPriceInfo()\n        external\n        override\n        view\n        returns (\n            uint256 price,\n            bool isValid,\n            uint256 lastPubBlock\n        )\n    {\n        return calculatedPriceProviderData._getPriceInfo();\n    }\n}\n\n",
    "imports": [
        {
            "name": "CalculatedPriceProviderFlat.sol",
            "contents": "/*\nCopyright MOC Investments Corp. 2020. All rights reserved.\n \nYou acknowledge and agree that MOC Investments Corp. (“MOC”) (or MOC’s licensors) own all legal right, title and\ninterest in and to the work, software, application, source code, documentation and any other documents in this\nrepository (collectively, the “Program”), including any intellectual property rights which subsist in the\nProgram (whether those rights happen to be registered or not, and wherever in the world those rights may exist),\nwhether in source code or any other form.\n \nSubject to the limited license below, you may not (and you may not permit anyone else to) distribute, publish, copy,\nmodify, merge, combine with another program, create derivative works of, reverse engineer, decompile or otherwise\nattempt to extract the source code of, the Program or any part thereof, except that you may contribute to\nthis repository.\n \nYou are granted a non-exclusive, non-transferable, non-sublicensable license to distribute, publish, copy, modify,\nmerge, combine with another program or create derivative works of the Program (such resulting program, collectively,\nthe “Resulting Program”) solely for Non-Commercial Use as long as you:\n 1. give prominent notice (“Notice”) with each copy of the Resulting Program that the Program is used in the Resulting\n  Program and that the Program is the copyright of MOC Investments Corp.; and\n 2. subject the Resulting Program and any distribution, publication, copy, modification, merger therewith,\n  combination with another program or derivative works thereof to the same Notice requirement and Non-Commercial\n  Use restriction set forth herein.\n \n“Non-Commercial Use” means each use as described in clauses (1)-(3) below, as reasonably determined by MOC Investments\nCorp. in its sole discretion:\n 1. personal use for research, personal study, private entertainment, hobby projects or amateur pursuits, in each\n case without any anticipated commercial application;\n 2. use by any charitable organization, educational institution, public research organization, public safety or health\n organization, environmental protection organization or government institution; or\n 3. the number of monthly active users of the Resulting Program across all versions thereof and platforms globally\n do not exceed 10,000 at any time.\n \nYou will not use any trade mark, service mark, trade name, logo of MOC Investments Corp. or any other company or\norganization in a way that is likely or intended to cause confusion about the owner or authorized user of such marks,\nnames or logos.\n \nIf you have any questions, comments or interest in pursuing any other use cases, please reach out to us\nat moc.license@moneyonchain.com.\n\n*/\n\npragma solidity 0.6.12;\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n    /**\n      @notice Override this function with a recipe of the changes to be done when this ChangeContract\n      is executed\n     */\n    function execute() external;\n}\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor {\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @dev This function should be protected somehow to only execute changes that\n      benefit the system. This decision process is independent of this architechture\n      therefore is independent of this interface too\n      @param changeContract Address of the contract that will execute the changes\n     */\n    function executeChange(ChangeContract changeContract) external;\n\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @param _changer Address of the contract that will execute the changes\n     */\n    function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n\n/**\n * @dev Interface of the old MOC Oracle\n */\ninterface IPriceProvider {\n    // Legacy function compatible with old MOC Oracle.\n    // returns a tuple (uint256, bool) that corresponds\n    // to the price and if it is not expired.\n    function peek() external view returns (bytes32, bool);\n\n    // Return the current price.\n    function getPrice() external view returns (uint256);\n\n    // Return if the price is not expired.\n    function getIsValid() external view returns (bool);\n\n    // Returns the block number of the last publication.\n    function getLastPublicationBlock() external view returns (uint256);\n\n    // Return the result of getPrice, getIsValid and getLastPublicationBlock at once.\n    function getPriceInfo()\n        external\n        view\n        returns (\n            uint256 price,\n            bool isValid,\n            uint256 lastPubBlock\n        );\n}\n\n\n/// @title PPrice\ninterface IPriceProviderRegisterEntry {\n    enum IPriceProviderType {None, Published, Calculated}\n\n    /// @notice return the type of provider\n    function getPriceProviderType() external pure returns (IPriceProviderType);\n}\n\n\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed {\n    /**\n      @notice The address of the contract which governs this one\n     */\n    IGovernor public governor;\n\n    string private constant NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n    /**\n      @notice Modifier that protects the function\n      @dev You should use this modifier in any function that should be called through\n      the governance system\n     */\n    modifier onlyAuthorizedChanger() {\n        require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n        _;\n    }\n\n    /**\n      @notice Initialize the contract with the basic settings\n      @dev This initialize replaces the constructor but it is not called automatically.\n      It is necessary because of the upgradeability of the contracts\n      @param _governor Governor address\n     */\n    function _initialize(IGovernor _governor) internal {\n        governor = _governor;\n    }\n\n    /**\n      @notice Change the contract's governor. Should be called through the old governance system\n      @param newIGovernor New governor address\n     */\n    function changeIGovernor(IGovernor newIGovernor) external onlyAuthorizedChanger {\n        governor = newIGovernor;\n    }\n\n    /**\n      @notice This method is used by a change contract to access the storage freely even without a setter.\n      @param data the serialized function arguments\n     */\n    function delegateCallToChanger(bytes calldata data)\n        external\n        onlyAuthorizedChanger\n        returns (bytes memory)\n    {\n        address changerContrat = msg.sender;\n        (bool success, bytes memory result) = changerContrat.delegatecall(\n            abi.encodeWithSignature(\"impersonate(bytes)\", data)\n        );\n        require(success, \"Error in delegate call\");\n        return result;\n    }\n\n    // Leave a gap betweeen inherited contracts variables in order to be\n    // able to add more variables in them later\n    uint256[50] private upgradeGap;\n}\n\n\n\n\n/**\n  @notice Based on heavily on EnumberableSet, but with the ability to clear all the contents.\n */\nlibrary AddressSetLib {\n    using SafeMath for uint256;\n\n    struct AddressSet {\n        // Storage of set values\n        address[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(address => uint256) _indexes;\n    }\n\n    function init() internal pure returns (AddressSet memory) {\n        return AddressSet({_values: new address[](0)});\n    }\n\n    /**\n     * @dev Removes all value from a set. O(N).\n     *\n     */\n    function clear(AddressSet storage set) internal {\n        for (uint256 i = 0; i < set._values.length; i++) {\n            delete set._indexes[set._values[i]];\n        }\n        delete set._values;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        if (!contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            address lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1;\n            // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        require(set._values.length > index, \"index out of bounds\");\n        return set._values[index];\n    }\n\n    /**\n     * @dev Returns the set contents as an array\n     */\n    function asArray(AddressSet storage set)\n        internal\n        view\n        returns (address[] memory selectedOracles)\n    {\n        return set._values;\n    }\n}\n\n\n/**\n  @dev An iterable mapping of addresses to boolean, used to check if an address is whitelisted.\n */\ncontract IIterableWhitelist {\n    /**\n      @notice Modifier that protects the function\n      @dev You should use this modifier in any function that should be filtered by the whitelist\n     */\n    modifier whitelistedOrExternal(IterableWhitelistLib.IterableWhitelistData storage self) {\n        // We use address(1) to allow calls from outside the block chain to peek\n        // The call must use msg.sender == 1 (or { from: 1 }) something that only can be done from\n        // outside the blockchain.\n        require(\n            msg.sender == address(1) || IterableWhitelistLib._isWhitelisted(self, msg.sender),\n            \"Address is not whitelisted\"\n        );\n        _;\n    }\n\n    /**\n      @notice Modifier that protects the function\n      @dev You should use this modifier in any function that should be filtered by the whitelist\n     */\n    modifier onlyWhitelisted(IterableWhitelistLib.IterableWhitelistData storage self) {\n        require(\n            IterableWhitelistLib._isWhitelisted(self, msg.sender),\n            \"Address is not whitelisted\"\n        );\n        _;\n    }\n}\n\nlibrary IterableWhitelistLib {\n    using AddressSetLib for AddressSetLib.AddressSet;\n\n    struct IterableWhitelistData {\n        AddressSetLib.AddressSet _inner;\n    }\n\n    /**\n     * @dev Check if an account is whitelisted\n     * @return Bool\n     */\n    function _isWhitelisted(IterableWhitelistData storage self, address account)\n        internal\n        view\n        returns (bool)\n    {\n        require(account != address(0), \"Account must not be 0x0\");\n        return self._inner.contains(account);\n    }\n\n    /**\n     * @dev Add account to whitelist\n     */\n    function _addToWhitelist(IterableWhitelistData storage self, address account) internal {\n        require(account != address(0), \"Account must not be 0x0\");\n        bool added = self._inner.add(account);\n        require(added, \"Account already whitelisted\");\n    }\n\n    /**\n     * @dev Remove account to whitelist\n     */\n    function _removeFromWhitelist(IterableWhitelistData storage self, address account) internal {\n        require(account != address(0), \"Account must not be 0x0\");\n        bool removed = self._inner.remove(account);\n        require(removed, \"Missing account\");\n    }\n\n    /// @notice Returns the count of whitelisted addresses.\n    function _getWhiteListLen(IterableWhitelistData storage self) internal view returns (uint256) {\n        return self._inner.length();\n    }\n\n    /// @notice Returns the address at index.\n    /// @param idx index to query.\n    function _getWhiteListAtIndex(IterableWhitelistData storage self, uint256 idx)\n        internal\n        view\n        returns (address)\n    {\n        return self._inner.at(idx);\n    }\n}\n\n\n\n/// @title This contract gets the price from some IPriceProviders and do the math to calculate\n/// a deduced price, for example RIFBTC and BTCUSD gives the price of RIFUSD\nlibrary CalculatedPriceProviderLib {\n    using SafeMath for uint256;\n    struct CalculatedPriceProviderData {\n        IPriceProvider[] multiplyBy;\n        IPriceProvider[] divideBy;\n        uint256 multiplicator;\n        uint256 divisor;\n    }\n\n    uint256 public constant MAX_INT = 2**256 - 1;\n\n    /**\n    Contract creation.\n\n    @param _multiplicator base value used to scale the result by multiplying it.\n    @param _multiplyBy list of IPriceProvider to query the price and then multiply the result\n    @param _divisor base value used to scale the result by dividing it.\n    @param _divideBy list of IPriceProvider to query the and then divide the result\n    */\n    function _initialize(\n        CalculatedPriceProviderData storage self,\n        uint256 _multiplicator,\n        IPriceProvider[] memory _multiplyBy,\n        uint256 _divisor,\n        IPriceProvider[] memory _divideBy\n    ) internal {\n        self.multiplicator = _multiplicator;\n        self.multiplyBy = _multiplyBy;\n        self.divisor = _divisor;\n        self.divideBy = _divideBy;\n    }\n\n    /**\n    Get the calculated price\n\n    */\n    function _getPriceInfo(CalculatedPriceProviderData storage self)\n        internal\n        view\n        returns (\n            uint256 price,\n            bool isValid,\n            uint256 lastPubBlock\n        )\n    {\n        uint256 den;\n        (den, isValid, lastPubBlock) = _multiplyAll(self.multiplicator, self.multiplyBy);\n\n        (uint256 div, bool valid, uint256 pubBlock) = _multiplyAll(self.divisor, self.divideBy);\n        lastPubBlock = min(lastPubBlock, pubBlock);\n        if (!isValid || !valid || div == 0) {\n            return (0, false, lastPubBlock);\n        }\n        return (den.div(div), true, lastPubBlock);\n    }\n\n    /**\n    Multiply a base val by the result of calling peek in the providers contacts\n\n    @param val a base value used to scale things up.this\n    @param providers a list of IPriceProvider that are queried for prices, all the prices are multiplied.\n    */\n    function _multiplyAll(uint256 val, IPriceProvider[] memory providers)\n        internal\n        view\n        returns (\n            uint256 price,\n            bool isValid,\n            uint256 lastPubBlock\n        )\n    {\n        lastPubBlock = MAX_INT;\n        isValid = true;\n        uint256 current;\n        bool valid;\n        uint256 pubBlock;\n        for (uint256 i = 0; i < providers.length; i++) {\n            (current, valid, pubBlock) = providers[i].getPriceInfo();\n            if (!valid) {\n                isValid = false;\n            }\n            val = val.mul(uint256(current));\n            lastPubBlock = min(lastPubBlock, pubBlock);\n        }\n        return (val, isValid, lastPubBlock);\n    }\n\n    function min(uint256 a, uint256 b) private pure returns (uint256) {\n        if (a < b) {\n            return a;\n        }\n        return b;\n    }\n}\n\n\n/// @title This contract gets the price from some IPriceProviders and do the math to calculate\n/// a deduced price, for example RIFBTC and BTCUSD gives the price of RIFUSD\ncontract CalculatedPriceProviderStorage is Initializable, Governed, IIterableWhitelist {\n    using SafeMath for uint256;\n    using IterableWhitelistLib for IterableWhitelistLib.IterableWhitelistData;\n    using CalculatedPriceProviderLib for CalculatedPriceProviderLib.CalculatedPriceProviderData;\n\n    IterableWhitelistLib.IterableWhitelistData internal iterableWhitelistData;\n\n    CalculatedPriceProviderLib.CalculatedPriceProviderData internal calculatedPriceProviderData;\n\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    // solhint-disable-next-line no-empty-blocks\n    constructor() internal {}\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n\n\n/// @title This contract gets the price from some IPriceProviders and do the math to calculate\n/// a deduced price, for example RIFBTC and BTCUSD gives the price of RIFUSD\ncontract CalculatedPriceProvider is\n    CalculatedPriceProviderStorage,\n    IPriceProvider,\n    IPriceProviderRegisterEntry\n{\n    using SafeMath for uint256;\n\n    /**\n    Contract creation.\n\n    @param _governor The address of the contract which governs this one\n    @param _wlist Initial whitelist addresses\n    @param _multiplicator base value used to scale the result by multiplying it.\n    @param _multiplyBy list of IPriceProvider to query the price and then multiply the result\n    @param _divisor base value used to scale the result by dividing it.\n    @param _divideBy list of IPriceProvider to query the and then divide the result\n    */\n    function initialize(\n        IGovernor _governor,\n        address[] calldata _wlist,\n        uint256 _multiplicator,\n        IPriceProvider[] calldata _multiplyBy,\n        uint256 _divisor,\n        IPriceProvider[] calldata _divideBy\n    ) external initializer {\n        _initialize(_governor);\n        calculatedPriceProviderData._initialize(_multiplicator, _multiplyBy, _divisor, _divideBy);\n        for (uint256 i = 0; i < _wlist.length; i++) {\n            iterableWhitelistData._addToWhitelist(_wlist[i]);\n        }\n    }\n\n    /**\n     * @dev Add to the list of contracts that can stake in this contract\n     * @param  _whitelisted - the override coinPair\n     */\n    function addToWhitelist(address _whitelisted) external onlyAuthorizedChanger() {\n        iterableWhitelistData._addToWhitelist(_whitelisted);\n    }\n\n    /**\n     * @dev Remove from the list of contracts that can stake in this contract\n     * @param _whitelisted - the override coinPair\n     */\n    function removeFromWhitelist(address _whitelisted) external onlyAuthorizedChanger() {\n        iterableWhitelistData._removeFromWhitelist(_whitelisted);\n    }\n\n    /// @notice Returns the count of whitelisted addresses.\n    function getWhiteListLen() external view returns (uint256) {\n        return iterableWhitelistData._getWhiteListLen();\n    }\n\n    /// @notice Returns the address at index.\n    /// @param _idx index to query.\n    function getWhiteListAtIndex(uint256 _idx) external view returns (address) {\n        return iterableWhitelistData._getWhiteListAtIndex(_idx);\n    }\n\n    /// @notice return the type of provider\n    function getPriceProviderType() external override pure returns (IPriceProviderType) {\n        return IPriceProviderType.Calculated;\n    }\n\n    /// @notice Return the current price, compatible with old MOC Oracle\n    function peek()\n        external\n        override\n        view\n        whitelistedOrExternal(iterableWhitelistData)\n        returns (bytes32, bool)\n    {\n        (uint256 price, bool valid, ) = calculatedPriceProviderData._getPriceInfo();\n        return (bytes32(price), valid);\n    }\n\n    // Return the current price.\n    function getPrice() external override view returns (uint256) {\n        (uint256 price, , ) = calculatedPriceProviderData._getPriceInfo();\n        return uint256(price);\n    }\n\n    // Return if the price is not expired.\n    function getIsValid() external override view returns (bool) {\n        (, bool valid, ) = calculatedPriceProviderData._getPriceInfo();\n        return valid;\n    }\n\n    // Returns the block number of the last publication.\n    function getLastPublicationBlock() external override view returns (uint256) {\n        (, , uint256 lastPubBlock) = calculatedPriceProviderData._getPriceInfo();\n        return lastPubBlock;\n    }\n\n    // Return the result of getPrice, getIsValid and getLastPublicationBlock at once.\n    function getPriceInfo()\n        external\n        override\n        view\n        returns (\n            uint256 price,\n            bool isValid,\n            uint256 lastPubBlock\n        )\n    {\n        return calculatedPriceProviderData._getPriceInfo();\n    }\n}\n\n",
            "file": "CalculatedPriceProviderFlat.sol"
        }
    ],
    "libraries": {},
    "creationData": {
        "blockHash": "0xeb95e2bbd094c09bd0db84c260825da8617a8c4f6a76e766ba29e15d6c072d04",
        "blockNumber": 3061969,
        "transactionHash": "0xbab4761108ddf930b3758742002859a2678ff152562c9cca30b6553fa17d9e26",
        "timestamp": 1611867268
    }
}