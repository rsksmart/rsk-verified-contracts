{
    "address": "0x24fba2281202c3aae95a3440c08c0050448508a6",
    "net": {
        "id": "30",
        "name": "RSK Mainnet"
    },
    "name": "VestingLogic",
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        }
    },
    "version": "0.5.17+commit.d19bba13",
    "source": "pragma solidity ^0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"../../openzeppelin/Ownable.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../Staking/Staking.sol\";\nimport \"../IFeeSharingProxy.sol\";\nimport \"./IVesting.sol\";\nimport \"../ApprovalReceiver.sol\";\nimport \"./VestingStorage.sol\";\n\ncontract VestingLogic is IVesting, VestingStorage, ApprovalReceiver {\n\tevent TokensStaked(address indexed caller, uint256 amount);\n\tevent VotesDelegated(address indexed caller, address delegatee);\n\tevent TokensWithdrawn(address indexed caller, address receiver);\n\tevent DividendsCollected(address indexed caller, address loanPoolToken, address receiver, uint32 maxCheckpoints);\n\tevent MigratedToNewStakingContract(address indexed caller, address newStakingContract);\n\n\t/**\n\t * @dev Throws if called by any account other than the token owner or the contract owner.\n\t */\n\tmodifier onlyOwners() {\n\t\trequire(msg.sender == tokenOwner || isOwner(), \"unauthorized\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the token owner.\n\t */\n\tmodifier onlyTokenOwner() {\n\t\trequire(msg.sender == tokenOwner, \"unauthorized\");\n\t\t_;\n\t}\n\n\t/**\n\t * @notice stakes tokens according to the vesting schedule\n\t * @param _amount the amount of tokens to stake\n\t * */\n\tfunction stakeTokens(uint256 _amount) public {\n\t\t_stakeTokens(msg.sender, _amount);\n\t}\n\n\t/**\n\t * @notice stakes tokens according to the vesting schedule\n\t * @dev this function will be invoked from receiveApproval\n\t * @dev SOV.approveAndCall -> this.receiveApproval -> this.stakeTokensWithApproval\n\t * @param _sender the sender of SOV.approveAndCall\n\t * @param _amount the amount of tokens to stake\n\t * */\n\tfunction stakeTokensWithApproval(address _sender, uint256 _amount) public onlyThisContract {\n\t\t_stakeTokens(_sender, _amount);\n\t}\n\n\tfunction _stakeTokens(address _sender, uint256 _amount) internal {\n\t\t//maybe better to allow staking unil the cliff was reached\n\t\tif (startDate == 0) {\n\t\t\tstartDate = staking.timestampToLockDate(block.timestamp);\n\t\t}\n\t\tendDate = staking.timestampToLockDate(block.timestamp + duration);\n\t\t//transfer the tokens to this contract\n\t\tbool success = SOV.transferFrom(_sender, address(this), _amount);\n\t\trequire(success);\n\t\t//allow the staking contract to access them\n\t\tSOV.approve(address(staking), _amount);\n\n\t\tstaking.stakesBySchedule(_amount, cliff, duration, FOUR_WEEKS, address(this), tokenOwner);\n\n\t\temit TokensStaked(_sender, _amount);\n\t}\n\n\t/**\n\t * @notice Delegate votes from `msg.sender` which are locked until lockDate to `delegatee`\n\t * @param _delegatee The address to delegate votes to\n\t */\n\tfunction delegate(address _delegatee) public onlyTokenOwner {\n\t\trequire(_delegatee != address(0), \"delegatee address invalid\");\n\n\t\t//withdraw for each unlocked position\n\t\tfor (uint256 i = startDate + cliff; i < endDate; i += FOUR_WEEKS) {\n\t\t\tstaking.delegate(_delegatee, i);\n\t\t}\n\t\temit VotesDelegated(msg.sender, _delegatee);\n\t}\n\n\t/**\n\t * @notice withdraws all tokens from the staking contract and forwards them to an address specified by the token owner\n\t * @param receiver the receiving address\n\t * @dev can be called only by owner\n\t * */\n\tfunction governanceWithdrawTokens(address receiver) public {\n\t\trequire(msg.sender == address(staking), \"unauthorized\");\n\n\t\t_withdrawTokens(receiver, true);\n\t}\n\n\t/**\n\t * @notice withdraws unlocked tokens from the staking contract and forwards them to an address specified by the token owner\n\t * @param receiver the receiving address\n\t **/\n\tfunction withdrawTokens(address receiver) public onlyOwners {\n\t\t_withdrawTokens(receiver, false);\n\t}\n\n\tfunction _withdrawTokens(address receiver, bool isGovernance) internal {\n\t\trequire(receiver != address(0), \"receiver address invalid\");\n\n\t\tuint96 stake;\n\t\t//usually we just need to iterate over the possible dates until now\n\t\tuint256 end;\n\t\t//in the unlikely case that all tokens have been unlocked early, allow to withdraw all of them.\n\t\tif (staking.allUnlocked() || isGovernance) {\n\t\t\tend = endDate;\n\t\t} else {\n\t\t\tend = block.timestamp;\n\t\t}\n\t\t//withdraw for each unlocked position\n\t\tfor (uint256 i = startDate + cliff; i <= end; i += FOUR_WEEKS) {\n\t\t\t//read amount to withdraw\n\t\t\tstake = staking.getPriorUserStakeByDate(address(this), i, block.number - 1);\n\t\t\t//withdraw if > 0\n\t\t\tif (stake > 0) {\n\t\t\t\tif (isGovernance) {\n\t\t\t\t\tstaking.governanceWithdraw(stake, i, receiver);\n\t\t\t\t} else {\n\t\t\t\t\tstaking.withdraw(stake, i, receiver);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\temit TokensWithdrawn(msg.sender, receiver);\n\t}\n\n\t/**\n\t * @dev collect dividends from fee sharing proxy\n\t */\n\tfunction collectDividends(\n\t\taddress _loanPoolToken,\n\t\tuint32 _maxCheckpoints,\n\t\taddress _receiver\n\t) public onlyOwners {\n\t\trequire(_receiver != address(0), \"receiver address invalid\");\n\t\t//invokes the fee sharing proxy\n\t\tfeeSharingProxy.withdraw(_loanPoolToken, _maxCheckpoints, _receiver);\n\t\temit DividendsCollected(msg.sender, _loanPoolToken, _receiver, _maxCheckpoints);\n\t}\n\n\t/**\n\t * @notice allows the owners to migrate the positions to a new staking contract\n\t * */\n\tfunction migrateToNewStakingContract() public onlyOwners {\n\t\tstaking.migrateToNewStakingContract();\n\t\tstaking = Staking(staking.newStakingContract());\n\t\temit MigratedToNewStakingContract(msg.sender, address(staking));\n\t}\n\n\tfunction _getToken() internal view returns (address) {\n\t\treturn address(SOV);\n\t}\n\n\tfunction _getSelectors() internal view returns (bytes4[] memory) {\n\t\tbytes4[] memory selectors = new bytes4[](1);\n\t\tselectors[0] = this.stakeTokensWithApproval.selector;\n\t\treturn selectors;\n\t}\n}\n",
    "imports": [
        {
            "name": "VestingLogic.sol",
            "contents": "pragma solidity ^0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"../../openzeppelin/Ownable.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../Staking/Staking.sol\";\nimport \"../IFeeSharingProxy.sol\";\nimport \"./IVesting.sol\";\nimport \"../ApprovalReceiver.sol\";\nimport \"./VestingStorage.sol\";\n\ncontract VestingLogic is IVesting, VestingStorage, ApprovalReceiver {\n\tevent TokensStaked(address indexed caller, uint256 amount);\n\tevent VotesDelegated(address indexed caller, address delegatee);\n\tevent TokensWithdrawn(address indexed caller, address receiver);\n\tevent DividendsCollected(address indexed caller, address loanPoolToken, address receiver, uint32 maxCheckpoints);\n\tevent MigratedToNewStakingContract(address indexed caller, address newStakingContract);\n\n\t/**\n\t * @dev Throws if called by any account other than the token owner or the contract owner.\n\t */\n\tmodifier onlyOwners() {\n\t\trequire(msg.sender == tokenOwner || isOwner(), \"unauthorized\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the token owner.\n\t */\n\tmodifier onlyTokenOwner() {\n\t\trequire(msg.sender == tokenOwner, \"unauthorized\");\n\t\t_;\n\t}\n\n\t/**\n\t * @notice stakes tokens according to the vesting schedule\n\t * @param _amount the amount of tokens to stake\n\t * */\n\tfunction stakeTokens(uint256 _amount) public {\n\t\t_stakeTokens(msg.sender, _amount);\n\t}\n\n\t/**\n\t * @notice stakes tokens according to the vesting schedule\n\t * @dev this function will be invoked from receiveApproval\n\t * @dev SOV.approveAndCall -> this.receiveApproval -> this.stakeTokensWithApproval\n\t * @param _sender the sender of SOV.approveAndCall\n\t * @param _amount the amount of tokens to stake\n\t * */\n\tfunction stakeTokensWithApproval(address _sender, uint256 _amount) public onlyThisContract {\n\t\t_stakeTokens(_sender, _amount);\n\t}\n\n\tfunction _stakeTokens(address _sender, uint256 _amount) internal {\n\t\t//maybe better to allow staking unil the cliff was reached\n\t\tif (startDate == 0) {\n\t\t\tstartDate = staking.timestampToLockDate(block.timestamp);\n\t\t}\n\t\tendDate = staking.timestampToLockDate(block.timestamp + duration);\n\t\t//transfer the tokens to this contract\n\t\tbool success = SOV.transferFrom(_sender, address(this), _amount);\n\t\trequire(success);\n\t\t//allow the staking contract to access them\n\t\tSOV.approve(address(staking), _amount);\n\n\t\tstaking.stakesBySchedule(_amount, cliff, duration, FOUR_WEEKS, address(this), tokenOwner);\n\n\t\temit TokensStaked(_sender, _amount);\n\t}\n\n\t/**\n\t * @notice Delegate votes from `msg.sender` which are locked until lockDate to `delegatee`\n\t * @param _delegatee The address to delegate votes to\n\t */\n\tfunction delegate(address _delegatee) public onlyTokenOwner {\n\t\trequire(_delegatee != address(0), \"delegatee address invalid\");\n\n\t\t//withdraw for each unlocked position\n\t\tfor (uint256 i = startDate + cliff; i < endDate; i += FOUR_WEEKS) {\n\t\t\tstaking.delegate(_delegatee, i);\n\t\t}\n\t\temit VotesDelegated(msg.sender, _delegatee);\n\t}\n\n\t/**\n\t * @notice withdraws all tokens from the staking contract and forwards them to an address specified by the token owner\n\t * @param receiver the receiving address\n\t * @dev can be called only by owner\n\t * */\n\tfunction governanceWithdrawTokens(address receiver) public {\n\t\trequire(msg.sender == address(staking), \"unauthorized\");\n\n\t\t_withdrawTokens(receiver, true);\n\t}\n\n\t/**\n\t * @notice withdraws unlocked tokens from the staking contract and forwards them to an address specified by the token owner\n\t * @param receiver the receiving address\n\t **/\n\tfunction withdrawTokens(address receiver) public onlyOwners {\n\t\t_withdrawTokens(receiver, false);\n\t}\n\n\tfunction _withdrawTokens(address receiver, bool isGovernance) internal {\n\t\trequire(receiver != address(0), \"receiver address invalid\");\n\n\t\tuint96 stake;\n\t\t//usually we just need to iterate over the possible dates until now\n\t\tuint256 end;\n\t\t//in the unlikely case that all tokens have been unlocked early, allow to withdraw all of them.\n\t\tif (staking.allUnlocked() || isGovernance) {\n\t\t\tend = endDate;\n\t\t} else {\n\t\t\tend = block.timestamp;\n\t\t}\n\t\t//withdraw for each unlocked position\n\t\tfor (uint256 i = startDate + cliff; i <= end; i += FOUR_WEEKS) {\n\t\t\t//read amount to withdraw\n\t\t\tstake = staking.getPriorUserStakeByDate(address(this), i, block.number - 1);\n\t\t\t//withdraw if > 0\n\t\t\tif (stake > 0) {\n\t\t\t\tif (isGovernance) {\n\t\t\t\t\tstaking.governanceWithdraw(stake, i, receiver);\n\t\t\t\t} else {\n\t\t\t\t\tstaking.withdraw(stake, i, receiver);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\temit TokensWithdrawn(msg.sender, receiver);\n\t}\n\n\t/**\n\t * @dev collect dividends from fee sharing proxy\n\t */\n\tfunction collectDividends(\n\t\taddress _loanPoolToken,\n\t\tuint32 _maxCheckpoints,\n\t\taddress _receiver\n\t) public onlyOwners {\n\t\trequire(_receiver != address(0), \"receiver address invalid\");\n\t\t//invokes the fee sharing proxy\n\t\tfeeSharingProxy.withdraw(_loanPoolToken, _maxCheckpoints, _receiver);\n\t\temit DividendsCollected(msg.sender, _loanPoolToken, _receiver, _maxCheckpoints);\n\t}\n\n\t/**\n\t * @notice allows the owners to migrate the positions to a new staking contract\n\t * */\n\tfunction migrateToNewStakingContract() public onlyOwners {\n\t\tstaking.migrateToNewStakingContract();\n\t\tstaking = Staking(staking.newStakingContract());\n\t\temit MigratedToNewStakingContract(msg.sender, address(staking));\n\t}\n\n\tfunction _getToken() internal view returns (address) {\n\t\treturn address(SOV);\n\t}\n\n\tfunction _getSelectors() internal view returns (bytes4[] memory) {\n\t\tbytes4[] memory selectors = new bytes4[](1);\n\t\tselectors[0] = this.stakeTokensWithApproval.selector;\n\t\treturn selectors;\n\t}\n}\n",
            "file": "VestingLogic.sol"
        },
        {
            "name": "IVesting.sol",
            "contents": "pragma solidity ^0.5.17;\n\ninterface IVesting {\n\tfunction duration() external returns (uint256);\n\n\tfunction endDate() external returns (uint256);\n\n\tfunction stakeTokens(uint256 amount) external;\n}\n"
        },
        {
            "name": "VestingStorage.sol",
            "contents": "pragma solidity ^0.5.17;\n\nimport \"../../openzeppelin/Ownable.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../Staking/Staking.sol\";\nimport \"../IFeeSharingProxy.sol\";\n\n/**\n * Vesting Storage Contract\n * @dev use Ownable as a parent to align storage structure for Logic and Proxy contracts\n */\ncontract VestingStorage is Ownable {\n\t///@notice the SOV token contract\n\tIERC20 public SOV;\n\t///@notice the staking contract address\n\tStaking public staking;\n\t///@notice the owner of the vested tokens\n\taddress public tokenOwner;\n\t//@notice fee sharing Proxy\n\tIFeeSharingProxy public feeSharingProxy;\n\t///@notice the cliff. after this time period the tokens begin to unlock\n\tuint256 public cliff;\n\t///@notice the duration. after this period all tokens will have been unlocked\n\tuint256 public duration;\n\t///@notice the start date of the vesting\n\tuint256 public startDate;\n\t///@notice the end date of the vesting\n\tuint256 public endDate;\n\t///@notice constant used for computing the vesting dates\n\tuint256 constant FOUR_WEEKS = 4 weeks;\n}\n"
        },
        {
            "name": "Context.sol",
            "contents": "pragma solidity >=0.5.0 <0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n\t// Empty internal constructor, to prevent people from mistakenly deploying\n\t// an instance of this contract, which should be used via inheritance.\n\tconstructor() internal {}\n\n\t// solhint-disable-previous-line no-empty-blocks\n\n\tfunction _msgSender() internal view returns (address payable) {\n\t\treturn msg.sender;\n\t}\n\n\tfunction _msgData() internal view returns (bytes memory) {\n\t\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\t\treturn msg.data;\n\t}\n}\n"
        },
        {
            "name": "Ownable.sol",
            "contents": "pragma solidity >=0.5.0 <0.6.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n\taddress private _owner;\n\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\t/**\n\t * @dev Initializes the contract setting the deployer as the initial owner.\n\t */\n\tconstructor() internal {\n\t\taddress msgSender = _msgSender();\n\t\t_owner = msgSender;\n\t\temit OwnershipTransferred(address(0), msgSender);\n\t}\n\n\t/**\n\t * @dev Returns the address of the current owner.\n\t */\n\tfunction owner() public view returns (address) {\n\t\treturn _owner;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the owner.\n\t */\n\tmodifier onlyOwner() {\n\t\trequire(isOwner(), \"unauthorized\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Returns true if the caller is the current owner.\n\t */\n\tfunction isOwner() public view returns (bool) {\n\t\treturn _msgSender() == _owner;\n\t}\n\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t * Can only be called by the current owner.\n\t */\n\tfunction transferOwnership(address newOwner) public onlyOwner {\n\t\t_transferOwnership(newOwner);\n\t}\n\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t */\n\tfunction _transferOwnership(address newOwner) internal {\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\t\temit OwnershipTransferred(_owner, newOwner);\n\t\t_owner = newOwner;\n\t}\n}\n"
        },
        {
            "name": "IERC20.sol",
            "contents": "/**\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0.\n */\n\npragma solidity >=0.5.0 <0.6.0;\n\ncontract IERC20 {\n\tstring public name;\n\tuint8 public decimals;\n\tstring public symbol;\n\n\tfunction totalSupply() public view returns (uint256);\n\n\tfunction balanceOf(address _who) public view returns (uint256);\n\n\tfunction transfer(address _to, uint256 _value) public returns (bool);\n\n\tfunction allowance(address _owner, address _spender) public view returns (uint256);\n\n\tfunction transferFrom(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _value\n\t) public returns (bool);\n\n\tfunction approve(address _spender, uint256 _value) public returns (bool);\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
        },
        {
            "name": "ApprovalReceiver.sol",
            "contents": "pragma solidity ^0.5.17;\n\nimport \"./ErrorDecoder.sol\";\nimport \"../token/IApproveAndCall.sol\";\n\n/**\n * Base contract for receiving approval from SOV token\n */\ncontract ApprovalReceiver is ErrorDecoder, IApproveAndCall {\n\tmodifier onlyThisContract() {\n\t\t//accepts calls only from receiveApproval function\n\t\trequire(msg.sender == address(this), \"unauthorized\");\n\t\t_;\n\t}\n\n\t/**\n\t * @notice receives approval from SOV token\n\t * @param _data the data will be used for low level call\n\t */\n\tfunction receiveApproval(\n\t\taddress _sender,\n\t\tuint256 _amount,\n\t\taddress _token,\n\t\tbytes calldata _data\n\t) external {\n\t\t//accepts calls only from SOV token\n\t\trequire(msg.sender == _getToken(), \"unauthorized\");\n\t\trequire(msg.sender == _token, \"unauthorized\");\n\n\t\t//only allowed methods\n\t\tbool isAllowed = false;\n\t\tbytes4[] memory selectors = _getSelectors();\n\t\tbytes4 sig = _getSig(_data);\n\t\tfor (uint256 i = 0; i < selectors.length; i++) {\n\t\t\tif (sig == selectors[i]) {\n\t\t\t\tisAllowed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequire(isAllowed, \"method is not allowed\");\n\n\t\t//check sender and amount\n\t\taddress sender;\n\t\tuint256 amount;\n\t\t(, sender, amount) = abi.decode(abi.encodePacked(bytes28(0), _data), (bytes32, address, uint256));\n\t\trequire(sender == _sender, \"sender mismatch\");\n\t\trequire(amount == _amount, \"amount mismatch\");\n\n\t\t_call(_data);\n\t}\n\n\t/**\n\t * @notice returns token address, only this address can be a sender for receiveApproval\n\t * @dev should be overridden in child contracts, otherwise error will be thrown\n\t */\n\tfunction _getToken() internal view returns (address) {\n\t\treturn address(0);\n\t}\n\n\t/**\n\t * @notice returns list of function selectors allowed to be invoked\n\t * @dev should be overridden in child contracts, otherwise error will be thrown\n\t */\n\tfunction _getSelectors() internal view returns (bytes4[] memory) {\n\t\treturn new bytes4[](0);\n\t}\n\n\tfunction _call(bytes memory _data) internal {\n\t\t//makes call and reads error message\n\t\t(bool success, bytes memory returnData) = address(this).call(_data);\n\t\tif (!success) {\n\t\t\tif (returnData.length <= ERROR_MESSAGE_SHIFT) {\n\t\t\t\trevert(\"receiveApproval: Transaction execution reverted.\");\n\t\t\t} else {\n\t\t\t\trevert(_addErrorMessage(\"receiveApproval: \", string(returnData)));\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction _getSig(bytes memory _data) internal pure returns (bytes4 sig) {\n\t\tassembly {\n\t\t\tsig := mload(add(_data, 32))\n\t\t}\n\t}\n}\n"
        },
        {
            "name": "IFeeSharingProxy.sol",
            "contents": "pragma solidity ^0.5.17;\n\ninterface IFeeSharingProxy {\n\tfunction withdrawFees(address _token) external;\n\n\tfunction transferTokens(address _token, uint96 _amount) external;\n\n\tfunction withdraw(\n\t\taddress _loanPoolToken,\n\t\tuint32 _maxCheckpoints,\n\t\taddress _receiver\n\t) external;\n}\n"
        },
        {
            "name": "Staking.sol",
            "contents": "pragma solidity ^0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"./WeightedStaking.sol\";\nimport \"./IStaking.sol\";\nimport \"../../rsk/RSKAddrValidator.sol\";\nimport \"../Vesting/ITeamVesting.sol\";\nimport \"../ApprovalReceiver.sol\";\n\ncontract Staking is IStaking, WeightedStaking, ApprovalReceiver {\n\t/**\n\t * @notice stakes the given amount for the given duration of time.\n\t * @param amount the number of tokens to stake\n\t * @param until timestamp indicating the date until which to stake\n\t * @param stakeFor the address to stake the tokens for or 0x0 if staking for oneself\n\t * @param delegatee the address of the delegatee or 0x0 if there is none.\n\t */\n\tfunction stake(\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) external {\n\t\t_stake(msg.sender, amount, until, stakeFor, delegatee, false);\n\t}\n\n\t/**\n\t * @notice stakes the given amount for the given duration of time.\n\t * @dev this function will be invoked from receiveApproval\n\t * @dev SOV.approveAndCall -> this.receiveApproval -> this.stakeWithApproval\n\t * @param sender the sender of SOV.approveAndCall\n\t * @param amount the number of tokens to stake\n\t * @param until timestamp indicating the date until which to stake\n\t * @param stakeFor the address to stake the tokens for or 0x0 if staking for oneself\n\t * @param delegatee the address of the delegatee or 0x0 if there is none.\n\t */\n\tfunction stakeWithApproval(\n\t\taddress sender,\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) public onlyThisContract {\n\t\t_stake(sender, amount, until, stakeFor, delegatee, false);\n\t}\n\n\tfunction _stake(\n\t\taddress sender,\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress stakeFor,\n\t\taddress delegatee,\n\t\tbool timeAdjusted\n\t) internal {\n\t\trequire(amount > 0, \"Staking::stake: amount of tokens to stake needs to be bigger than 0\");\n\n\t\tif (!timeAdjusted) {\n\t\t\tuntil = timestampToLockDate(until);\n\t\t}\n\t\trequire(until > block.timestamp, \"Staking::timestampToLockDate: staking period too short\");\n\n\t\t//stake for the sender if not specified otherwise\n\t\tif (stakeFor == address(0)) {\n\t\t\tstakeFor = sender;\n\t\t}\n\t\t//delegate for stakeFor if not specified otherwise\n\t\tif (delegatee == address(0)) {\n\t\t\tdelegatee = stakeFor;\n\t\t}\n\t\t//do not stake longer than the max duration\n\t\tif (!timeAdjusted) {\n\t\t\tuint256 latest = timestampToLockDate(block.timestamp + MAX_DURATION);\n\t\t\tif (until > latest) until = latest;\n\t\t}\n\n\t\tuint96 previousBalance = currentBalance(stakeFor, until);\n\t\t//increase stake\n\t\t_increaseStake(sender, amount, stakeFor, until);\n\n\t\tif (previousBalance == 0) {\n\t\t\t//regular delegation if it's a first stake\n\t\t\t_delegate(stakeFor, delegatee, until);\n\t\t} else {\n\t\t\taddress previousDelegatee = delegates[stakeFor][until];\n\t\t\tif (previousDelegatee != delegatee) {\n\t\t\t\t//update delegatee\n\t\t\t\tdelegates[stakeFor][until] = delegatee;\n\t\t\t\t//decrease stake on previous balance for previous delegatee\n\t\t\t\t_decreaseDelegateStake(previousDelegatee, until, previousBalance);\n\t\t\t\t//add previousBalance to amount\n\t\t\t\tamount = add96(previousBalance, amount, \"Staking::stake: balance overflow\");\n\t\t\t}\n\t\t\t//increase stake\n\t\t\t_increaseDelegateStake(delegatee, until, amount);\n\t\t}\n\t}\n\n\t/**\n\t * @notice extends the staking duration until the specified date\n\t * @param previousLock the old unlocking timestamp\n\t * @param until the new unlocking timestamp in S\n\t * */\n\tfunction extendStakingDuration(uint256 previousLock, uint256 until) public {\n\t\tuntil = timestampToLockDate(until);\n\t\trequire(previousLock <= until, \"Staking::extendStakingDuration: cannot reduce the staking duration\");\n\n\t\t//do not exceed the max duration, no overflow possible\n\t\tuint256 latest = timestampToLockDate(block.timestamp + MAX_DURATION);\n\t\tif (until > latest) until = latest;\n\n\t\t//update checkpoints\n\t\t//todo James: can reading stake at block.number -1 cause trouble with multiple tx in a block?\n\t\tuint96 amount = getPriorUserStakeByDate(msg.sender, previousLock, block.number - 1);\n\t\trequire(amount > 0, \"Staking::extendStakingDuration: nothing staked until the previous lock date\");\n\t\t_decreaseUserStake(msg.sender, previousLock, amount);\n\t\t_increaseUserStake(msg.sender, until, amount);\n\t\t_decreaseDailyStake(previousLock, amount);\n\t\t_increaseDailyStake(until, amount);\n\t\t//delegate might change: if there is already a delegate set for the until date, it will remain the delegate for this position\n\t\taddress delegateFrom = delegates[msg.sender][previousLock];\n\t\taddress delegateTo = delegates[msg.sender][until];\n\t\tif (delegateTo == address(0)) {\n\t\t\tdelegateTo = delegateFrom;\n\t\t\tdelegates[msg.sender][until] = delegateFrom;\n\t\t}\n\t\tdelegates[msg.sender][previousLock] = address(0);\n\t\t_decreaseDelegateStake(delegateFrom, previousLock, amount);\n\t\t_increaseDelegateStake(delegateTo, until, amount);\n\n\t\temit ExtendedStakingDuration(msg.sender, previousLock, until);\n\t}\n\n\tfunction _increaseStake(\n\t\taddress sender,\n\t\tuint96 amount,\n\t\taddress stakeFor,\n\t\tuint256 until\n\t) internal {\n\t\t//retrieve the SOV tokens\n\t\tbool success = SOVToken.transferFrom(sender, address(this), amount);\n\t\trequire(success);\n\n\t\t//increase staked balance\n\t\tuint96 balance = currentBalance(stakeFor, until);\n\t\tbalance = add96(balance, amount, \"Staking::increaseStake: balance overflow\");\n\n\t\t//update checkpoints\n\t\t_increaseDailyStake(until, amount);\n\t\t_increaseUserStake(stakeFor, until, amount);\n\n\t\temit TokensStaked(stakeFor, amount, until, balance);\n\t}\n\n\t/**\n\t * @notice stakes tokens according to the vesting schedule\n\t * @param amount the amount of tokens to stake\n\t * @param cliff the time interval to the first withdraw\n\t * @param duration the staking duration\n\t * @param intervalLength the length of each staking interval when cliff passed\n\t * @param stakeFor the address to stake the tokens for or 0x0 if staking for oneself\n\t * @param delegatee the address of the delegatee or 0x0 if there is none.\n\t * */\n\tfunction stakesBySchedule(\n\t\tuint256 amount,\n\t\tuint256 cliff,\n\t\tuint256 duration,\n\t\tuint256 intervalLength,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) public {\n\t\t//stake them until lock dates according to the vesting schedule\n\t\t//note: because staking is only possible in periods of 2 weeks, the total duration might\n\t\t//end up a bit shorter than specified depending on the date of staking.\n\t\tuint256 start = timestampToLockDate(block.timestamp + cliff);\n\t\tif (duration > MAX_DURATION) {\n\t\t\tduration = MAX_DURATION;\n\t\t}\n\t\tuint256 end = timestampToLockDate(block.timestamp + duration);\n\t\tuint256 numIntervals = (end - start) / intervalLength + 1;\n\t\tuint256 stakedPerInterval = amount / numIntervals;\n\t\t//stakedPerInterval might lose some dust on rounding. add it to the first staking date\n\t\tif (numIntervals > 1) {\n\t\t\t_stake(msg.sender, uint96(amount - stakedPerInterval * (numIntervals - 1)), start, stakeFor, delegatee, true);\n\t\t}\n\t\t//stake the rest in 4 week intervals\n\t\tfor (uint256 i = start + intervalLength; i <= end; i += intervalLength) {\n\t\t\t//stakes for itself, delegates to the owner\n\t\t\t_stake(msg.sender, uint96(stakedPerInterval), i, stakeFor, delegatee, true);\n\t\t}\n\t}\n\n\t/**\n\t * @notice withdraws the given amount of tokens if they are unlocked\n\t * @param amount the number of tokens to withdraw\n\t * @param until the date until which the tokens were staked\n\t * @param receiver the receiver of the tokens. If not specified, send to the msg.sender\n\t * */\n\tfunction withdraw(\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress receiver\n\t) public {\n\t\t_withdraw(amount, until, receiver, false);\n\t}\n\n\t/**\n\t * @notice withdraws the given amount of tokens\n\t * @param amount the number of tokens to withdraw\n\t * @param until the date until which the tokens were staked\n\t * @param receiver the receiver of the tokens. If not specified, send to the msg.sender\n\t * @dev can be invoked only by whitelisted contract passed to governanceWithdrawVesting\n\t * */\n\tfunction governanceWithdraw(\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress receiver\n\t) public {\n\t\trequire(vestingWhitelist[msg.sender], \"unauthorized\");\n\n\t\t_withdraw(amount, until, receiver, true);\n\t}\n\n\t/**\n\t * @notice withdraws tokens for vesting contact\n\t * @param vesting the address of Vesting contract\n\t * @param receiver the receiver of the tokens. If not specified, send to the msg.sender\n\t * @dev can be invoked only by whitelisted contract passed to governanceWithdrawVesting\n\t * */\n\tfunction governanceWithdrawVesting(address vesting, address receiver) public onlyOwner {\n\t\tvestingWhitelist[vesting] = true;\n\t\tITeamVesting(vesting).governanceWithdrawTokens(receiver);\n\t\tvestingWhitelist[vesting] = false;\n\n\t\temit VestingTokensWithdrawn(vesting, receiver);\n\t}\n\n\tfunction _withdraw(\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress receiver,\n\t\tbool isGovernance\n\t) internal {\n\t\t_validateWithdrawParams(amount, until);\n\n\t\t//determine the receiver\n\t\tif (receiver == address(0)) receiver = msg.sender;\n\n\t\t//update the checkpoints\n\t\t_decreaseDailyStake(until, amount);\n\t\t_decreaseUserStake(msg.sender, until, amount);\n\t\t_decreaseDelegateStake(delegates[msg.sender][until], until, amount);\n\n\t\t//early unstaking should be punished\n\t\tif (block.timestamp < until && !allUnlocked && !isGovernance) {\n\t\t\tuint96 punishedAmount = _getPunishedAmount(amount, until);\n\t\t\tamount -= punishedAmount;\n\n\t\t\t//punishedAmount can be 0 if block.timestamp are very close to 'until'\n\t\t\tif (punishedAmount > 0) {\n\t\t\t\trequire(address(feeSharing) != address(0), \"Staking::withdraw: FeeSharing address wasn't set\");\n\t\t\t\t//move punished amount to fee sharing\n\t\t\t\t//approve transfer here and let feeSharing do transfer and write checkpoint\n\t\t\t\tSOVToken.approve(address(feeSharing), punishedAmount);\n\t\t\t\tfeeSharing.transferTokens(address(SOVToken), punishedAmount);\n\t\t\t}\n\t\t}\n\n\t\t//transferFrom\n\t\tbool success = SOVToken.transfer(receiver, amount);\n\t\trequire(success, \"Staking::withdraw: Token transfer failed\");\n\n\t\temit TokensWithdrawn(msg.sender, receiver, amount);\n\t}\n\n\t/**\n\t * @notice returns available and punished amount for withdrawing\n\t * @param amount the number of tokens to withdraw\n\t * @param until the date until which the tokens were staked\n\t * */\n\tfunction getWithdrawAmounts(uint96 amount, uint256 until) public view returns (uint96, uint96) {\n\t\t_validateWithdrawParams(amount, until);\n\t\tuint96 punishedAmount = _getPunishedAmount(amount, until);\n\t\treturn (amount - punishedAmount, punishedAmount);\n\t}\n\n\t/**\n\t * @notice returns punished amount for withdrawing\n\t * @param amount the number of tokens to withdraw\n\t * @param until the date until which the tokens were staked\n\t * */\n\tfunction _getPunishedAmount(uint96 amount, uint256 until) internal view returns (uint96) {\n\t\tuint256 date = timestampToLockDate(block.timestamp);\n\t\tuint96 weight = computeWeightByDate(until, date); // (10 - 1) * WEIGHT_FACTOR\n\t\tweight = weight * weightScaling;\n\t\treturn (amount * weight) / WEIGHT_FACTOR / 100;\n\t}\n\n\t/**\n\t * @notice validates withdraw parameters\n\t * @param amount the number of tokens to withdraw\n\t * @param until the date until which the tokens were staked\n\t * */\n\tfunction _validateWithdrawParams(uint96 amount, uint256 until) internal view {\n\t\trequire(amount > 0, \"Staking::withdraw: amount of tokens to be withdrawn needs to be bigger than 0\");\n\t\tuint96 balance = getPriorUserStakeByDate(msg.sender, until, block.number - 1);\n\t\trequire(amount <= balance, \"Staking::withdraw: not enough balance\");\n\t}\n\n\t/**\n\t * @notice returns the current balance of for an account locked until a certain date\n\t * @param account the user address\n\t * @param lockDate the lock date\n\t * @return the lock date of the last checkpoint\n\t * */\n\tfunction currentBalance(address account, uint256 lockDate) internal view returns (uint96) {\n\t\treturn userStakingCheckpoints[account][lockDate][numUserStakingCheckpoints[account][lockDate] - 1].stake;\n\t}\n\n\t/**\n\t * @notice Get the number of staked tokens held by the `account`\n\t * @param account The address of the account to get the balance of\n\t * @return The number of tokens held\n\t */\n\tfunction balanceOf(address account) public view returns (uint96 balance) {\n\t\tfor (uint256 i = kickoffTS; i <= block.timestamp + MAX_DURATION; i += TWO_WEEKS) {\n\t\t\tbalance = add96(balance, currentBalance(account, i), \"Staking::balanceOf: overflow\");\n\t\t}\n\t}\n\n\t/**\n\t * @notice Delegate votes from `msg.sender` which are locked until lockDate to `delegatee`\n\t * @param delegatee The address to delegate votes to\n\t * @param lockDate the date if the position to delegate\n\t */\n\tfunction delegate(address delegatee, uint256 lockDate) public {\n\t\treturn _delegate(msg.sender, delegatee, lockDate);\n\t}\n\n\t/**\n\t * @notice Delegates votes from signatory to `delegatee`\n\t * @param delegatee The address to delegate votes to\n\t * @param lockDate the date until which the position is locked\n\t * @param nonce The contract state required to match the signature\n\t * @param expiry The time at which to expire the signature\n\t * @param v The recovery byte of the signature\n\t * @param r Half of the ECDSA signature pair\n\t * @param s Half of the ECDSA signature pair\n\t */\n\tfunction delegateBySig(\n\t\taddress delegatee,\n\t\tuint256 lockDate,\n\t\tuint256 nonce,\n\t\tuint256 expiry,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public {\n\t\tbytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n\t\tbytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, lockDate, nonce, expiry));\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n\t\taddress signatory = ecrecover(digest, v, r, s);\n\t\trequire(RSKAddrValidator.checkPKNotZero(signatory), \"Staking::delegateBySig: invalid signature\");\n\t\trequire(nonce == nonces[signatory]++, \"Staking::delegateBySig: invalid nonce\");\n\t\trequire(now <= expiry, \"Staking::delegateBySig: signature expired\");\n\t\treturn _delegate(signatory, delegatee, lockDate);\n\t}\n\n\t/**\n\t * @notice Gets the current votes balance for `account`\n\t * @param account The address to get votes balance\n\t * @return The number of current votes for `account`\n\t */\n\tfunction getCurrentVotes(address account) external view returns (uint96) {\n\t\treturn getPriorVotes(account, block.number - 1, block.timestamp);\n\t}\n\n\t/**\n\t * @notice gets the current number of tokens staked for a day\n\t * @param lockedTS the timestamp to get the staked tokens for\n\t */\n\tfunction getCurrentStakedUntil(uint256 lockedTS) external view returns (uint96) {\n\t\tuint32 nCheckpoints = numTotalStakingCheckpoints[lockedTS];\n\t\treturn nCheckpoints > 0 ? totalStakingCheckpoints[lockedTS][nCheckpoints - 1].stake : 0;\n\t}\n\n\tfunction _delegate(\n\t\taddress delegator,\n\t\taddress delegatee,\n\t\tuint256 lockedTS\n\t) internal {\n\t\taddress currentDelegate = delegates[delegator][lockedTS];\n\t\tuint96 delegatorBalance = currentBalance(delegator, lockedTS);\n\t\tdelegates[delegator][lockedTS] = delegatee;\n\n\t\temit DelegateChanged(delegator, lockedTS, currentDelegate, delegatee);\n\n\t\t_moveDelegates(currentDelegate, delegatee, delegatorBalance, lockedTS);\n\t}\n\n\tfunction _moveDelegates(\n\t\taddress srcRep,\n\t\taddress dstRep,\n\t\tuint96 amount,\n\t\tuint256 lockedTS\n\t) internal {\n\t\tif (srcRep != dstRep && amount > 0) {\n\t\t\tif (srcRep != address(0)) _decreaseDelegateStake(srcRep, lockedTS, amount);\n\n\t\t\tif (dstRep != address(0)) _increaseDelegateStake(dstRep, lockedTS, amount);\n\t\t}\n\t}\n\n\tfunction getChainId() internal pure returns (uint256) {\n\t\tuint256 chainId;\n\t\tassembly {\n\t\t\tchainId := chainid()\n\t\t}\n\t\treturn chainId;\n\t}\n\n\t/**\n\t * @notice allows the owner to set a new staking contract. as a consequence it allows the stakers to migrate their positions\n\t * to the new contract.\n\t * @dev doesn't have any influence as long as migrateToNewStakingContract is not implemented.\n\t * @param _newStakingContract the address of the new staking contract\n\t */\n\tfunction setNewStakingContract(address _newStakingContract) public onlyOwner {\n\t\trequire(_newStakingContract != address(0), \"can't reset the new staking contract to 0\");\n\t\tnewStakingContract = _newStakingContract;\n\t}\n\n\t/**\n\t * @notice allows the owner to set a fee sharing proxy contract, we need it for unstaking with slashing.\n\t * @param _feeSharing the address of FeeSharingProxy contract\n\t */\n\tfunction setFeeSharing(address _feeSharing) public onlyOwner {\n\t\trequire(_feeSharing != address(0), \"FeeSharing address shouldn't be 0\");\n\t\tfeeSharing = IFeeSharingProxy(_feeSharing);\n\t}\n\n\t/**\n\t * @notice allows the owner to set weight scaling, we need it for unstaking with slashing.\n\t * @param _weightScaling the weight scaling\n\t */\n\tfunction setWeightScaling(uint96 _weightScaling) public onlyOwner {\n\t\trequire(\n\t\t\tMIN_WEIGHT_SCALING <= _weightScaling && _weightScaling <= MAX_WEIGHT_SCALING,\n\t\t\t\"weight scaling doesn't belong to range [1, 9]\"\n\t\t);\n\t\tweightScaling = _weightScaling;\n\t}\n\n\t/**\n\t * @notice allows a staker to migrate his positions to the new staking contract.\n\t * @dev staking contract needs to be set before by the owner. currently not implemented, just needed for the interface.\n\t *      in case it's needed at some point in the future, the implementation needs to be changed first.\n\t */\n\tfunction migrateToNewStakingContract() public {\n\t\trequire(newStakingContract != address(0), \"there is no new staking contract set\");\n\t\t//implementation:\n\t\t//iterate over all possible lock dates from now until now + MAX_DURATION\n\t\t//read the stake & delegate of the msg.sender\n\t\t//if stake > 0, stake it at the new contract until the lock date with the current delegate\n\t}\n\n\t/**\n\t * @notice allow the owner to unlock all tokens in case the staking contract is going to be replaced\n\t * note: not reversible on purpose. once unlocked, everything is unlocked. the owner should not be able to just quickly\n\t * unlock to withdraw his own tokens and lock again.\n\t * @dev last resort.\n\t */\n\tfunction unlockAllTokens() public onlyOwner {\n\t\tallUnlocked = true;\n\t\temit TokensUnlocked(SOVToken.balanceOf(address(this)));\n\t}\n\n\t/**\n\t * @notice Gets list of stakes for `account`\n\t * @param account The address to get stakes\n\t * @return The arrays of dates and stakes\n\t */\n\tfunction getStakes(address account) external view returns (uint256[] memory dates, uint96[] memory stakes) {\n\t\tuint256 latest = timestampToLockDate(block.timestamp + MAX_DURATION);\n\n\t\t//calculate stakes\n\t\tuint256 count = 0;\n\t\t//we need to iterate from first possible stake date after deployment to the latest from current time\n\t\tfor (uint256 i = kickoffTS + TWO_WEEKS; i <= latest; i += TWO_WEEKS) {\n\t\t\tif (currentBalance(account, i) > 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tdates = new uint256[](count);\n\t\tstakes = new uint96[](count);\n\n\t\t//we need to iterate from first possible stake date after deployment to the latest from current time\n\t\tuint256 j = 0;\n\t\tfor (uint256 i = kickoffTS + TWO_WEEKS; i <= latest; i += TWO_WEEKS) {\n\t\t\tuint96 balance = currentBalance(account, i);\n\t\t\tif (balance > 0) {\n\t\t\t\tdates[j] = i;\n\t\t\t\tstakes[j] = balance;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction _getToken() internal view returns (address) {\n\t\treturn address(SOVToken);\n\t}\n\n\tfunction _getSelectors() internal view returns (bytes4[] memory) {\n\t\tbytes4[] memory selectors = new bytes4[](1);\n\t\tselectors[0] = this.stakeWithApproval.selector;\n\t\treturn selectors;\n\t}\n}\n"
        },
        {
            "name": "Checkpoints.sol",
            "contents": "pragma solidity ^0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"./StakingStorage.sol\";\nimport \"./SafeMath96.sol\";\n\ncontract Checkpoints is StakingStorage, SafeMath96 {\n\t/// @notice An event thats emitted when an account changes its delegate\n\tevent DelegateChanged(address indexed delegator, uint256 lockedUntil, address indexed fromDelegate, address indexed toDelegate);\n\n\t/// @notice An event thats emitted when a delegate account's stake balance changes\n\tevent DelegateStakeChanged(address indexed delegate, uint256 lockedUntil, uint256 previousBalance, uint256 newBalance);\n\n\t/// @notice An event thats emitted when tokens get staked\n\tevent TokensStaked(address indexed staker, uint256 amount, uint256 lockedUntil, uint256 totalStaked);\n\n\t/// @notice An event thats emitted when tokens get withdrawn\n\tevent TokensWithdrawn(address indexed staker, address receiver, uint256 amount);\n\n\t/// @notice An event thats emitted when vesting tokens get withdrawn\n\tevent VestingTokensWithdrawn(address vesting, address receiver);\n\n\t/// @notice An event thats emitted when the owner unlocks all tokens\n\tevent TokensUnlocked(uint256 amount);\n\n\t/// @notice An event thats emitted when a staking period gets extended\n\tevent ExtendedStakingDuration(address indexed staker, uint256 previousDate, uint256 newDate);\n\n\t/**\n\t * @notice increases the user's stake for a giving lock date and writes a checkpoint\n\t * @param account the user address\n\t * @param lockedTS the lock date\n\t * @param value the value to add to the staked balance\n\t * */\n\tfunction _increaseUserStake(\n\t\taddress account,\n\t\tuint256 lockedTS,\n\t\tuint96 value\n\t) internal {\n\t\tuint32 nCheckpoints = numUserStakingCheckpoints[account][lockedTS];\n\t\tuint96 staked = userStakingCheckpoints[account][lockedTS][nCheckpoints - 1].stake;\n\t\tuint96 newStake = add96(staked, value, \"Staking::_increaseUserStake: staked amount overflow\");\n\t\t_writeUserCheckpoint(account, lockedTS, nCheckpoints, newStake);\n\t}\n\n\t/**\n\t * @notice decreases the user's stake for a giving lock date and writes a checkpoint\n\t * @param account the user address\n\t * @param lockedTS the lock date\n\t * @param value the value to add to the staked balance\n\t * */\n\tfunction _decreaseUserStake(\n\t\taddress account,\n\t\tuint256 lockedTS,\n\t\tuint96 value\n\t) internal {\n\t\tuint32 nCheckpoints = numUserStakingCheckpoints[account][lockedTS];\n\t\tuint96 staked = userStakingCheckpoints[account][lockedTS][nCheckpoints - 1].stake;\n\t\tuint96 newStake = sub96(staked, value, \"Staking::_decreaseUserStake: staked amount underflow\");\n\t\t_writeUserCheckpoint(account, lockedTS, nCheckpoints, newStake);\n\t}\n\n\tfunction _writeUserCheckpoint(\n\t\taddress account,\n\t\tuint256 lockedTS,\n\t\tuint32 nCheckpoints,\n\t\tuint96 newStake\n\t) internal {\n\t\tuint32 blockNumber = safe32(block.number, \"Staking::_writeStakingCheckpoint: block number exceeds 32 bits\");\n\t\tif (nCheckpoints > 0 && userStakingCheckpoints[account][lockedTS][nCheckpoints - 1].fromBlock == blockNumber) {\n\t\t\tuserStakingCheckpoints[account][lockedTS][nCheckpoints - 1].stake = newStake;\n\t\t} else {\n\t\t\tuserStakingCheckpoints[account][lockedTS][nCheckpoints] = Checkpoint(blockNumber, newStake);\n\t\t\tnumUserStakingCheckpoints[account][lockedTS] = nCheckpoints + 1;\n\t\t}\n\t}\n\n\t/**\n\t * @notice increases the delegatee's stake for a giving lock date and writes a checkpoint\n\t * @param delegatee the delegatee\n\t * @param lockedTS the lock date\n\t * @param value the value to add to the staked balance\n\t * */\n\tfunction _increaseDelegateStake(\n\t\taddress delegatee,\n\t\tuint256 lockedTS,\n\t\tuint96 value\n\t) internal {\n\t\tuint32 nCheckpoints = numDelegateStakingCheckpoints[delegatee][lockedTS];\n\t\tuint96 staked = delegateStakingCheckpoints[delegatee][lockedTS][nCheckpoints - 1].stake;\n\t\tuint96 newStake = add96(staked, value, \"Staking::_increaseDelegateeStake: staked amount overflow\");\n\t\t_writeDelegateCheckpoint(delegatee, lockedTS, nCheckpoints, newStake);\n\t}\n\n\t/**\n\t * @notice decreases the delegatee's stake for a giving lock date and writes a checkpoint\n\t * @param delegatee the delegatee\n\t * @param lockedTS the lock date\n\t * @param value the value to add to the staked balance\n\t * */\n\tfunction _decreaseDelegateStake(\n\t\taddress delegatee,\n\t\tuint256 lockedTS,\n\t\tuint96 value\n\t) internal {\n\t\tuint32 nCheckpoints = numDelegateStakingCheckpoints[delegatee][lockedTS];\n\t\tuint96 staked = delegateStakingCheckpoints[delegatee][lockedTS][nCheckpoints - 1].stake;\n\t\tuint96 newStake = sub96(staked, value, \"Staking::_decreaseDailyStake: staked amount underflow\");\n\t\t_writeDelegateCheckpoint(delegatee, lockedTS, nCheckpoints, newStake);\n\t}\n\n\tfunction _writeDelegateCheckpoint(\n\t\taddress delegatee,\n\t\tuint256 lockedTS,\n\t\tuint32 nCheckpoints,\n\t\tuint96 newStake\n\t) internal {\n\t\tuint32 blockNumber = safe32(block.number, \"Staking::_writeStakingCheckpoint: block number exceeds 32 bits\");\n\t\tuint96 oldStake = delegateStakingCheckpoints[delegatee][lockedTS][nCheckpoints - 1].stake;\n\n\t\tif (nCheckpoints > 0 && delegateStakingCheckpoints[delegatee][lockedTS][nCheckpoints - 1].fromBlock == blockNumber) {\n\t\t\tdelegateStakingCheckpoints[delegatee][lockedTS][nCheckpoints - 1].stake = newStake;\n\t\t} else {\n\t\t\tdelegateStakingCheckpoints[delegatee][lockedTS][nCheckpoints] = Checkpoint(blockNumber, newStake);\n\t\t\tnumDelegateStakingCheckpoints[delegatee][lockedTS] = nCheckpoints + 1;\n\t\t}\n\t\temit DelegateStakeChanged(delegatee, lockedTS, oldStake, newStake);\n\t}\n\n\tfunction _increaseDailyStake(uint256 lockedTS, uint96 value) internal {\n\t\tuint32 nCheckpoints = numTotalStakingCheckpoints[lockedTS];\n\t\tuint96 staked = totalStakingCheckpoints[lockedTS][nCheckpoints - 1].stake;\n\t\tuint96 newStake = add96(staked, value, \"Staking::_increaseDailyStake: staked amount overflow\");\n\t\t_writeStakingCheckpoint(lockedTS, nCheckpoints, newStake);\n\t}\n\n\tfunction _decreaseDailyStake(uint256 lockedTS, uint96 value) internal {\n\t\tuint32 nCheckpoints = numTotalStakingCheckpoints[lockedTS];\n\t\tuint96 staked = totalStakingCheckpoints[lockedTS][nCheckpoints - 1].stake;\n\t\tuint96 newStake = sub96(staked, value, \"Staking::_decreaseDailyStake: staked amount underflow\");\n\t\t_writeStakingCheckpoint(lockedTS, nCheckpoints, newStake);\n\t}\n\n\tfunction _writeStakingCheckpoint(\n\t\tuint256 lockedTS,\n\t\tuint32 nCheckpoints,\n\t\tuint96 newStake\n\t) internal {\n\t\tuint32 blockNumber = safe32(block.number, \"Staking::_writeStakingCheckpoint: block number exceeds 32 bits\");\n\n\t\tif (nCheckpoints > 0 && totalStakingCheckpoints[lockedTS][nCheckpoints - 1].fromBlock == blockNumber) {\n\t\t\ttotalStakingCheckpoints[lockedTS][nCheckpoints - 1].stake = newStake;\n\t\t} else {\n\t\t\ttotalStakingCheckpoints[lockedTS][nCheckpoints] = Checkpoint(blockNumber, newStake);\n\t\t\tnumTotalStakingCheckpoints[lockedTS] = nCheckpoints + 1;\n\t\t}\n\t}\n}\n"
        },
        {
            "name": "IStaking.sol",
            "contents": "pragma solidity ^0.5.17;\n\ninterface IStaking {\n\tfunction stakesBySchedule(\n\t\tuint256 amount,\n\t\tuint256 cliff,\n\t\tuint256 duration,\n\t\tuint256 intervalLength,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) external;\n\n\tfunction stake(\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) external;\n\n\tfunction getPriorVotes(\n\t\taddress account,\n\t\tuint256 blockNumber,\n\t\tuint256 date\n\t) external view returns (uint96);\n\n\tfunction getPriorTotalVotingPower(uint32 blockNumber, uint256 time) external view returns (uint96);\n\n\tfunction getPriorWeightedStake(\n\t\taddress account,\n\t\tuint256 blockNumber,\n\t\tuint256 date\n\t) external view returns (uint96);\n\n\tfunction timestampToLockDate(uint256 timestamp) external view returns (uint256 lockDate);\n}\n"
        },
        {
            "name": "SafeMath96.sol",
            "contents": "pragma solidity ^0.5.17;\npragma experimental ABIEncoderV2;\n\ncontract SafeMath96 {\n\tfunction safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n\t\trequire(n < 2**32, errorMessage);\n\t\treturn uint32(n);\n\t}\n\n\tfunction safe64(uint256 n, string memory errorMessage) internal pure returns (uint64) {\n\t\trequire(n < 2**64, errorMessage);\n\t\treturn uint64(n);\n\t}\n\n\tfunction safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\n\t\trequire(n < 2**96, errorMessage);\n\t\treturn uint96(n);\n\t}\n\n\tfunction add96(\n\t\tuint96 a,\n\t\tuint96 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint96) {\n\t\tuint96 c = a + b;\n\t\trequire(c >= a, errorMessage);\n\t\treturn c;\n\t}\n\n\tfunction sub96(\n\t\tuint96 a,\n\t\tuint96 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint96) {\n\t\trequire(b <= a, errorMessage);\n\t\treturn a - b;\n\t}\n\n\tfunction mul96(\n\t\tuint96 a,\n\t\tuint96 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint96) {\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint96 c = a * b;\n\t\trequire(c / a == b, errorMessage);\n\n\t\treturn c;\n\t}\n\n\tfunction div96(\n\t\tuint96 a,\n\t\tuint96 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint96) {\n\t\t// Solidity only automatically asserts when dividing by 0\n\t\trequire(b > 0, errorMessage);\n\t\tuint96 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\t\treturn c;\n\t}\n}\n"
        },
        {
            "name": "StakingStorage.sol",
            "contents": "pragma solidity ^0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"../../openzeppelin/Ownable.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../IFeeSharingProxy.sol\";\n\ncontract StakingStorage is Ownable {\n\t///@notice 2 weeks in seconds\n\tuint256 constant TWO_WEEKS = 1209600;\n\n\t///@notice the maximum possible voting weight before adding +1 (actually 10, but need 9 for computation)\n\tuint96 public constant MAX_VOTING_WEIGHT = 9;\n\n\t///@notice weight is multiplied with this factor (for allowing decimals, like 1.2x)\n\t///@dev MAX_VOTING_WEIGHT * WEIGHT_FACTOR needs to be < 792, because there are 100,000,000 SOV with 18 decimals\n\tuint96 public constant WEIGHT_FACTOR = 10;\n\n\t/// @notice the maximum duration to stake tokens for\n\tuint256 public constant MAX_DURATION = 1092 days;\n\n\t///@notice the maximum duration ^2\n\tuint96 constant MAX_DURATION_POW_2 = 1092 * 1092;\n\n\t///@notice default weight scaling\n\tuint96 constant DEFAULT_WEIGHT_SCALING = 3;\n\n\t///@notice range for weight scaling\n\tuint96 constant MIN_WEIGHT_SCALING = 1;\n\tuint96 constant MAX_WEIGHT_SCALING = 9;\n\n\t///@notice the timestamp of contract creation. base for the staking period calculation\n\tuint256 public kickoffTS;\n\n\tstring name = \"SOVStaking\";\n\n\t/// @notice the token to be staked\n\tIERC20 public SOVToken;\n\n\t/// @notice A record of each accounts delegate\n\tmapping(address => mapping(uint256 => address)) public delegates;\n\n\t/// @notice if this flag is set to true, all tokens are unlocked immediately\n\tbool public allUnlocked = false;\n\n\t/// @notice The EIP-712 typehash for the contract's domain\n\tbytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n\t/// @notice The EIP-712 typehash for the delegation struct used by the contract\n\tbytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 lockDate,uint256 nonce,uint256 expiry)\");\n\n\t/// @notice used for stake migrations to a new staking contract with a different storage structure\n\taddress public newStakingContract;\n\n\t/*************************** Checkpoints *******************************/\n\n\t/// @notice A checkpoint for marking the stakes from a given block\n\tstruct Checkpoint {\n\t\tuint32 fromBlock;\n\t\tuint96 stake;\n\t}\n\n\t/// @notice A record of tokens to be unstaked at a given time in total\n\t/// for total voting power computation. voting weights get adjusted bi-weekly\n\n\tmapping(uint256 => mapping(uint32 => Checkpoint)) public totalStakingCheckpoints;\n\n\t///@notice The number of total staking checkpoints for each date\n\tmapping(uint256 => uint32) public numTotalStakingCheckpoints;\n\n\t/// @notice A record of tokens to be unstaked at a given time which were delegated to a certain address\n\t/// for delegatee voting power computation. voting weights get adjusted bi-weekly\n\tmapping(address => mapping(uint256 => mapping(uint32 => Checkpoint))) public delegateStakingCheckpoints;\n\n\t///@notice The number of total staking checkpoints for each date per delegate\n\tmapping(address => mapping(uint256 => uint32)) public numDelegateStakingCheckpoints;\n\n\t/// @notice A record of tokens to be unstaked at a given time which per user address (address -> lockDate -> stake checkpoint)\n\tmapping(address => mapping(uint256 => mapping(uint32 => Checkpoint))) public userStakingCheckpoints;\n\n\t///@notice The number of total staking checkpoints for each date per user\n\tmapping(address => mapping(uint256 => uint32)) public numUserStakingCheckpoints;\n\n\t/// @notice A record of states for signing / validating signatures\n\tmapping(address => uint256) public nonces;\n\n\t/*************************** Slashing *******************************/\n\n\t/// @notice the address of FeeSharingProxy contract, we need it for unstaking with slashing\n\tIFeeSharingProxy public feeSharing;\n\n\t// @notice used for weight scaling when unstaking with slashing\n\tuint96 public weightScaling = DEFAULT_WEIGHT_SCALING;\n\n\t// @notice list of Vesting contracts, tokens for these contracts won't be slashed if unstaked by governance\n\tmapping(address => bool) public vestingWhitelist;\n}\n"
        },
        {
            "name": "WeightedStaking.sol",
            "contents": "pragma solidity ^0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"./Checkpoints.sol\";\n\ncontract WeightedStaking is Checkpoints {\n\t/************* TOTAL VOTING POWER COMPUTATION ************************/\n\n\t/**\n\t * @notice computes the total voting power at a given time\n\t * @param time the timestamp for which to calculate the total voting power\n\t * @return the total voting power at the given time\n\t * */\n\tfunction getPriorTotalVotingPower(uint32 blockNumber, uint256 time) public view returns (uint96 totalVotingPower) {\n\t\t//start the computation with the exact or previous unlocking date (voting weight remians the same until the next break point)\n\t\tuint256 start = timestampToLockDate(time);\n\t\tuint256 end = start + MAX_DURATION;\n\n\t\t//max 78 iterations\n\t\tfor (uint256 i = start; i <= end; i += TWO_WEEKS) {\n\t\t\ttotalVotingPower = add96(\n\t\t\t\ttotalVotingPower,\n\t\t\t\t_totalPowerByDate(i, start, blockNumber),\n\t\t\t\t\"WeightedStaking::getPriorTotalVotingPower: overflow on total voting power computation\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @notice computes the voting power for a secific date\n\t * @param date the staking date to compute the power for\n\t * @param startDate the date for which we need to know the power of the stake\n\t * @param blockNumber the block number. needed for checkpointing.\n\t * */\n\tfunction _totalPowerByDate(\n\t\tuint256 date,\n\t\tuint256 startDate,\n\t\tuint256 blockNumber\n\t) internal view returns (uint96 power) {\n\t\tuint96 weight = computeWeightByDate(date, startDate);\n\t\tuint96 staked = getPriorTotalStakesForDate(date, blockNumber);\n\t\t//weight is multiplied by some factor to allow decimals.\n\t\tpower = mul96(staked, weight, \"WeightedStaking::_totalPowerByDate: multiplication overflow\") / WEIGHT_FACTOR;\n\t}\n\n\t/**\n\t * @notice Determine the prior number of stake for an unlocking date as of a block number\n\t * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n\t * @param date The date to check the stakes for\n\t * @param blockNumber The block number to get the vote balance at\n\t * @return The number of votes the account had as of the given block\n\t */\n\tfunction getPriorTotalStakesForDate(uint256 date, uint256 blockNumber) public view returns (uint96) {\n\t\trequire(blockNumber < block.number, \"WeightedStaking::getPriorTotalStakesForDate: not yet determined\");\n\n\t\tuint32 nCheckpoints = numTotalStakingCheckpoints[date];\n\t\tif (nCheckpoints == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// First check most recent balance\n\t\tif (totalStakingCheckpoints[date][nCheckpoints - 1].fromBlock <= blockNumber) {\n\t\t\treturn totalStakingCheckpoints[date][nCheckpoints - 1].stake;\n\t\t}\n\n\t\t// Next check implicit zero balance\n\t\tif (totalStakingCheckpoints[date][0].fromBlock > blockNumber) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint32 lower = 0;\n\t\tuint32 upper = nCheckpoints - 1;\n\t\twhile (upper > lower) {\n\t\t\tuint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n\t\t\tCheckpoint memory cp = totalStakingCheckpoints[date][center];\n\t\t\tif (cp.fromBlock == blockNumber) {\n\t\t\t\treturn cp.stake;\n\t\t\t} else if (cp.fromBlock < blockNumber) {\n\t\t\t\tlower = center;\n\t\t\t} else {\n\t\t\t\tupper = center - 1;\n\t\t\t}\n\t\t}\n\t\treturn totalStakingCheckpoints[date][lower].stake;\n\t}\n\n\t/****************************** DELEGATED VOTING POWER COMPUTATION ************************/\n\n\t/**\n\t * @notice Determine the prior number of votes for a delegatee as of a block number.\n\t * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n\t *      Used for Voting, not for fee sharing.\n\t * @param account The address of the account to check\n\t * @param blockNumber The block number to get the vote balance at\n\t * @return The number of votes the delegatee had as of the given block\n\t */\n\tfunction getPriorVotes(\n\t\taddress account,\n\t\tuint256 blockNumber,\n\t\tuint256 date\n\t) public view returns (uint96 votes) {\n\t\t//if date is not an exact break point, start weight computation from the previous break point (alternative would be the next)\n\t\tuint256 start = timestampToLockDate(date);\n\t\tuint256 end = start + MAX_DURATION;\n\n\t\t//max 78 iterations\n\t\tfor (uint256 i = start; i <= end; i += TWO_WEEKS) {\n\t\t\tvotes = add96(\n\t\t\t\tvotes,\n\t\t\t\t_totalPowerByDateForDelegatee(account, i, start, blockNumber),\n\t\t\t\t\"WeightedStaking::getPriorVotes: overflow on total voting power computation\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @notice computes the voting power for a secific date\n\t * @param date the staking date to compute the power for\n\t * @param startDate the date for which we need to know the power of the stake\n\t * @param blockNumber the block number. needed for checkpointing.\n\t * */\n\tfunction _totalPowerByDateForDelegatee(\n\t\taddress account,\n\t\tuint256 date,\n\t\tuint256 startDate,\n\t\tuint256 blockNumber\n\t) internal view returns (uint96 power) {\n\t\tuint96 weight = computeWeightByDate(date, startDate);\n\t\tuint96 staked = getPriorStakeByDateForDelegatee(account, date, blockNumber);\n\t\tpower = mul96(staked, weight, \"WeightedStaking::_totalPowerByDateForDelegatee: multiplication overflow\") / WEIGHT_FACTOR;\n\t}\n\n\t/**\n\t * @notice Determine the prior number of stake for an account as of a block number\n\t * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n\t * @param account The address of the account to check\n\t * @param blockNumber The block number to get the vote balance at\n\t * @return The number of votes the account had as of the given block\n\t */\n\tfunction getPriorStakeByDateForDelegatee(\n\t\taddress account,\n\t\tuint256 date,\n\t\tuint256 blockNumber\n\t) public view returns (uint96) {\n\t\trequire(blockNumber < block.number, \"WeightedStaking::getPriorStakeByDateForDelegatee: not yet determined\");\n\n\t\tuint32 nCheckpoints = numDelegateStakingCheckpoints[account][date];\n\t\tif (nCheckpoints == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// First check most recent balance\n\t\tif (delegateStakingCheckpoints[account][date][nCheckpoints - 1].fromBlock <= blockNumber) {\n\t\t\treturn delegateStakingCheckpoints[account][date][nCheckpoints - 1].stake;\n\t\t}\n\n\t\t// Next check implicit zero balance\n\t\tif (delegateStakingCheckpoints[account][date][0].fromBlock > blockNumber) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint32 lower = 0;\n\t\tuint32 upper = nCheckpoints - 1;\n\t\twhile (upper > lower) {\n\t\t\tuint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n\t\t\tCheckpoint memory cp = delegateStakingCheckpoints[account][date][center];\n\t\t\tif (cp.fromBlock == blockNumber) {\n\t\t\t\treturn cp.stake;\n\t\t\t} else if (cp.fromBlock < blockNumber) {\n\t\t\t\tlower = center;\n\t\t\t} else {\n\t\t\t\tupper = center - 1;\n\t\t\t}\n\t\t}\n\t\treturn delegateStakingCheckpoints[account][date][lower].stake;\n\t}\n\n\t/*************************** User Weighted Stake computation for fee sharing *******************************/\n\n\t/**\n\t * @notice Determine the prior weighted stake for an account as of a block number\n\t * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n\t *      Used for fee sharing, not voting.\n\t * @param account The address of the account to check\n\t * @param blockNumber The block number to get the vote balance at\n\t * @return The weighted stake the account had as of the given block\n\t */\n\tfunction getPriorWeightedStake(\n\t\taddress account,\n\t\tuint256 blockNumber,\n\t\tuint256 date\n\t) public view returns (uint96 votes) {\n\t\t//if date is not an exact break point, start weight computation from the previous break point (alternative would be the next)\n\t\tuint256 start = timestampToLockDate(date);\n\t\tuint256 end = start + MAX_DURATION;\n\n\t\t//max 78 iterations\n\t\tfor (uint256 i = start; i <= end; i += TWO_WEEKS) {\n\t\t\tuint96 weightedStake = weightedStakeByDate(account, i, start, blockNumber);\n\t\t\tif (weightedStake > 0) {\n\t\t\t\tvotes = add96(votes, weightedStake, \"WeightedStaking::getPriorWeightedStake: overflow on total weight computation\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice computes the voting power for a secific date\n\t * @param date the staking date to compute the power for\n\t * @param startDate the date for which we need to know the power of the stake\n\t * @param blockNumber the block number. needed for checkpointing.\n\t * */\n\tfunction weightedStakeByDate(\n\t\taddress account,\n\t\tuint256 date,\n\t\tuint256 startDate,\n\t\tuint256 blockNumber\n\t) public view returns (uint96 power) {\n\t\tuint96 staked = getPriorUserStakeByDate(account, date, blockNumber);\n\t\tif (staked > 0) {\n\t\t\tuint96 weight = computeWeightByDate(date, startDate);\n\t\t\tpower = mul96(staked, weight, \"WeightedStaking::weightedStakeByDate: multiplication overflow\") / WEIGHT_FACTOR;\n\t\t} else {\n\t\t\tpower = 0;\n\t\t}\n\t}\n\n\t/**\n\t * @notice Determine the prior number of stake for an account until a certain lock date as of a block number\n\t * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n\t * @param account The address of the account to check\n\t * @param date the lock date\n\t * @param blockNumber The block number to get the vote balance at\n\t * @return The number of votes the account had as of the given block\n\t */\n\tfunction getPriorUserStakeByDate(\n\t\taddress account,\n\t\tuint256 date,\n\t\tuint256 blockNumber\n\t) public view returns (uint96) {\n\t\trequire(blockNumber < block.number, \"WeightedStaking::getPriorUserStakeAndDate: not yet determined\");\n\n\t\tuint32 nCheckpoints = numUserStakingCheckpoints[account][date];\n\t\tif (nCheckpoints == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// First check most recent balance\n\t\tif (userStakingCheckpoints[account][date][nCheckpoints - 1].fromBlock <= blockNumber) {\n\t\t\treturn userStakingCheckpoints[account][date][nCheckpoints - 1].stake;\n\t\t}\n\n\t\t// Next check implicit zero balance\n\t\tif (userStakingCheckpoints[account][date][0].fromBlock > blockNumber) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint32 lower = 0;\n\t\tuint32 upper = nCheckpoints - 1;\n\t\twhile (upper > lower) {\n\t\t\tuint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n\t\t\tCheckpoint memory cp = userStakingCheckpoints[account][date][center];\n\t\t\tif (cp.fromBlock == blockNumber) {\n\t\t\t\treturn cp.stake;\n\t\t\t} else if (cp.fromBlock < blockNumber) {\n\t\t\t\tlower = center;\n\t\t\t} else {\n\t\t\t\tupper = center - 1;\n\t\t\t}\n\t\t}\n\t\treturn userStakingCheckpoints[account][date][lower].stake;\n\t}\n\n\t/**************** SHARED FUNCTIONS *********************/\n\n\t/**\n\t * @notice compute the weight for a specific date\n\t * @param date the unlocking date\n\t * @param startDate we compute the weight for the tokens staked until 'date' on 'startDate'\n\t * */\n\tfunction computeWeightByDate(uint256 date, uint256 startDate) public pure returns (uint96 weight) {\n\t\trequire(date >= startDate, \"WeightedStaking::computeWeightByDate: date needs to be bigger than startDate\");\n\t\tuint256 remainingTime = (date - startDate);\n\t\trequire(MAX_DURATION >= remainingTime, \"Staking::computeWeightByDate:remaining time can't be bigger than max duration\");\n\t\t// x = max days - remaining days\n\t\tuint96 x = uint96(MAX_DURATION - remainingTime) / (1 days);\n\t\t//w = (m^2 - x^2)/m^2 +1 (multiplied by the weight factor)\n\t\tweight = add96(\n\t\t\tWEIGHT_FACTOR,\n\t\t\tmul96(\n\t\t\t\tMAX_VOTING_WEIGHT * WEIGHT_FACTOR,\n\t\t\t\tsub96(MAX_DURATION_POW_2, x * x, \"underflow on weight calculation\"),\n\t\t\t\t\"multiplication overflow on weight computation\"\n\t\t\t) / MAX_DURATION_POW_2,\n\t\t\t\"overflow on weight computation\"\n\t\t);\n\t}\n\n\t/**\n\t * @notice unstaking is posisble every 2 weeks only. this means, to calculate the key value for the staking\n\t * checkpoints, we need to map the intended timestamp to the closest available date\n\t * @param timestamp the unlocking timestamp\n\t * @return the actual unlocking date (might be up to 2 weeks shorter than intended)\n\t * */\n\tfunction timestampToLockDate(uint256 timestamp) public view returns (uint256 lockDate) {\n\t\trequire(timestamp >= kickoffTS, \"WeightedStaking::timestampToLockDate: timestamp lies before contract creation\");\n\t\t//if staking timestamp does not match any of the unstaking dates, set the lockDate to the closest one before the timestamp\n\t\t//e.g. passed timestamps lies 7 weeks after kickoff -> only stake for 6 weeks\n\t\tuint256 periodFromKickoff = (timestamp - kickoffTS) / TWO_WEEKS;\n\t\tlockDate = periodFromKickoff * TWO_WEEKS + kickoffTS;\n\t}\n}\n"
        },
        {
            "name": "RSKAddrValidator.sol",
            "contents": "// SPDX-License-Identifier:MIT\npragma solidity ^0.5.17;\n\nlibrary RSKAddrValidator {\n\t/*\n\t * @param addr it is an address to check that it does not originates from\n\t * signing with PK = ZERO. RSK has a small difference in which @ZERO_PK_ADDR is\n\t * also an address from PK = ZERO. So we check for both of them.\n\t */\n\tfunction checkPKNotZero(address addr) internal pure returns (bool) {\n\t\treturn (addr != 0xdcc703c0E500B653Ca82273B7BFAd8045D85a470 && addr != address(0));\n\t}\n\n\t/*\n\t * Safely compares two addresses, checking they do not originate from\n\t * a zero private key\n\t */\n\tfunction safeEquals(address addr1, address addr2) internal pure returns (bool) {\n\t\treturn (addr1 == addr2 && addr1 != 0xdcc703c0E500B653Ca82273B7BFAd8045D85a470 && addr1 != address(0));\n\t}\n}\n"
        },
        {
            "name": "ITeamVesting.sol",
            "contents": "pragma solidity ^0.5.17;\n\ninterface ITeamVesting {\n\tfunction governanceWithdrawTokens(address receiver) external;\n}\n"
        },
        {
            "name": "ErrorDecoder.sol",
            "contents": "pragma solidity ^0.5.17;\n\ncontract ErrorDecoder {\n\t//4 bytes - 0x08c379a0 - method id\n\t//32 bytes - 2 parameters\n\t//32 bytes - bool, result\n\t//32 ... bytes - string, error message\n\tuint256 constant ERROR_MESSAGE_SHIFT = 68;\n\n\tfunction _addErrorMessage(string memory str1, string memory str2) internal pure returns (string memory) {\n\t\tbytes memory bytesStr1 = bytes(str1);\n\t\tbytes memory bytesStr2 = bytes(str2);\n\t\tstring memory str12 = new string(bytesStr1.length + bytesStr2.length - ERROR_MESSAGE_SHIFT);\n\t\tbytes memory bytesStr12 = bytes(str12);\n\t\tuint256 j = 0;\n\t\tfor (uint256 i = 0; i < bytesStr1.length; i++) {\n\t\t\tbytesStr12[j++] = bytesStr1[i];\n\t\t}\n\t\tfor (uint256 i = ERROR_MESSAGE_SHIFT; i < bytesStr2.length; i++) {\n\t\t\tbytesStr12[j++] = bytesStr2[i];\n\t\t}\n\t\treturn string(bytesStr12);\n\t}\n}\n"
        },
        {
            "name": "IApproveAndCall.sol",
            "contents": "pragma solidity ^0.5.17;\n\ninterface IApproveAndCall {\n\t/**\n\t * @notice receives approval from SOV token\n\t * @param _sender the sender of SOV.approveAndCall function\n\t * @param _amount the amount was approved\n\t * @param _token the address of token\n\t * @param _data the data will be used for low level call\n\t */\n\tfunction receiveApproval(\n\t\taddress _sender,\n\t\tuint256 _amount,\n\t\taddress _token,\n\t\tbytes calldata _data\n\t) external;\n}\n"
        }
    ],
    "libraries": {},
    "creationData": {
        "blockHash": "0x4991024aa8c07dfe643f41a8f77f13cdfada8bd7cf18a4b97f69f9105e3d1412",
        "blockNumber": 3100285,
        "transactionHash": "0x8f229439245c46c4c9101a13b15e5df2e05f5dd383bfa0b763c2016fab1ab092",
        "timestamp": 1613126354
    }
}