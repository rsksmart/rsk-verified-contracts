{
  "address": "0x0d00ebb7b7403bc87a113a6d44aa55882ce31438",
  "net": {
    "id": "30",
    "name": "RSK Mainnet"
  },
  "name": "AddressLinker",
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    }
  },
  "version": "0.4.25+commit.59dbf8f1",
  "source": "pragma solidity ^0.4.24;\n\nimport \"../util/AddressHelper.sol\";\nimport \"../third-party/openzeppelin/math/SafeMath.sol\";\n\nlibrary AddressLinker   {\n    using SafeMath for uint256;\n    using SafeMath for uint;\n\n    uint constant BITCOIN  = 0;\n    uint constant ETHEREUM = 1;\n\n    function acceptLinkedRskAddress(\n        address buyerAddress, uint chainId,\n        string redeemAddressAsString, uint8 sig_v,\n        bytes32 sig_r, bytes32 sig_s) public pure returns (bool) {\n\n        // Verify signatures\n        bytes32 hash;\n\n        if (chainId == BITCOIN) {\n            hash = sha256(abi.encodePacked(sha256(abi.encodePacked(\"\\x18Bitcoin Signed Message:\\n\\x2a\", redeemAddressAsString))));\n        } else {\n            hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n42\", redeemAddressAsString));\n        }\n\n        address recoveredAddress = AddressHelper.recoverAddress(hash, sig_v, sig_r, sig_s);\n\n        return recoveredAddress == address(buyerAddress);\n    }\n\n    function acceptDelegate(\n        address buyerAddress, uint chainId,\n        uint8 sig_v,\n        bytes32 sig_r, bytes32 sig_s) public pure returns (bool) {\n\n        // Verify signatures\n        bytes32 hash;\n\n        if (chainId==BITCOIN) {\n            hash = sha256(abi.encodePacked(sha256(abi.encodePacked(\"\\x18Bitcoin Signed Message:\\n\\x0a\",\"DELEGATION\"))));\n        } else {\n            hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n10\",\"DELEGATION\"));\n        }\n\n        address recoveredAddress = AddressHelper.recoverAddress(hash,sig_v,sig_r,sig_s);\n\n        return recoveredAddress == address(buyerAddress);\n    }\n}\n",
  "imports": [
    {
      "name": "AddressLinker.sol",
      "contents": "pragma solidity ^0.4.24;\n\nimport \"../util/AddressHelper.sol\";\nimport \"../third-party/openzeppelin/math/SafeMath.sol\";\n\nlibrary AddressLinker   {\n    using SafeMath for uint256;\n    using SafeMath for uint;\n\n    uint constant BITCOIN  = 0;\n    uint constant ETHEREUM = 1;\n\n    function acceptLinkedRskAddress(\n        address buyerAddress, uint chainId,\n        string redeemAddressAsString, uint8 sig_v,\n        bytes32 sig_r, bytes32 sig_s) public pure returns (bool) {\n\n        // Verify signatures\n        bytes32 hash;\n\n        if (chainId == BITCOIN) {\n            hash = sha256(abi.encodePacked(sha256(abi.encodePacked(\"\\x18Bitcoin Signed Message:\\n\\x2a\", redeemAddressAsString))));\n        } else {\n            hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n42\", redeemAddressAsString));\n        }\n\n        address recoveredAddress = AddressHelper.recoverAddress(hash, sig_v, sig_r, sig_s);\n\n        return recoveredAddress == address(buyerAddress);\n    }\n\n    function acceptDelegate(\n        address buyerAddress, uint chainId,\n        uint8 sig_v,\n        bytes32 sig_r, bytes32 sig_s) public pure returns (bool) {\n\n        // Verify signatures\n        bytes32 hash;\n\n        if (chainId==BITCOIN) {\n            hash = sha256(abi.encodePacked(sha256(abi.encodePacked(\"\\x18Bitcoin Signed Message:\\n\\x0a\",\"DELEGATION\"))));\n        } else {\n            hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n10\",\"DELEGATION\"));\n        }\n\n        address recoveredAddress = AddressHelper.recoverAddress(hash,sig_v,sig_r,sig_s);\n\n        return recoveredAddress == address(buyerAddress);\n    }\n}\n",
      "file": "AddressLinker.sol"
    },
    {
      "name": "AddressHelper.sol",
      "contents": "pragma solidity ^0.4.24;\n\nlibrary AddressHelper {\n    function recoverAddress(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public pure\n        returns (address) {\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        uint8 vv = v;\n        if (vv < 27) {\n            vv += 27;\n        }\n\n        // If the version is correct return the signer address\n        if (vv != 27 && vv != 28) {\n            return (address(0));\n        } else {\n            return ecrecover(hash, vv, r, s);\n        }\n\n    }\n\n    function char(byte b) public pure returns (byte c) {\n        if (b < 10) return byte(uint8(b) + 0x30);\n        else return byte(uint8(b) + 0x57);\n    }\n\n    function getHashedPublicKey(\n        bytes32 _xPoint,\n        bytes32 _yPoint)\n        pure public\n        returns(\n            bytes20 hashedPubKey)\n    {\n        byte startingByte = 0x04;\n        return ripemd160(abi.encodePacked(sha256(abi.encodePacked(startingByte, _xPoint, _yPoint))));\n    }\n\n    function fromHexChar(uint c) public pure returns (uint) {\n        if (c >= uint(byte('0')) && c <= uint(byte('9'))) {\n            return c - uint(byte('0'));\n        }\n\n        if (c >= uint(byte('a')) && c <= uint(byte('f'))) {\n            return 10 + c - uint(byte('a'));\n        }\n\n        if (c >= uint(byte('A')) && c <= uint(byte('F'))) {\n            return 10 + c - uint(byte('A'));\n        }\n\n        // Reaching this point means the ordinal is not for a hex char.\n        revert();\n    }\n\n    function fromAsciiString(string s) public pure returns(address) {\n        bytes memory ss = bytes(s);\n\n        // it should have 40 or 42 characters\n        if (ss.length != 40 && ss.length != 42) revert();\n\n        uint r = 0;\n        uint offset = 0;\n\n        if (ss.length == 42) {\n            offset = 2;\n\n            if (ss[0] != byte('0')) revert();\n            if (ss[1] != byte('x') && ss[1] != byte('X')) revert();\n        }\n\n        uint i;\n        uint x;\n        uint v;\n\n        // loads first 32 bytes from array,\n        // skipping array length (32 bytes to skip)\n        // offset == 0x20\n        assembly { v := mload(add(0x20, ss)) }\n\n        // converts the first 32 bytes, adding to result\n        for (i = offset; i < 32; ++i) {\n            assembly { x := byte(i, v) }\n            r = r * 16 + fromHexChar(x);\n        }\n\n        // loads second 32 bytes from array,\n        // skipping array length (32 bytes to skip)\n        // and first 32 bytes\n        // offset == 0x40\n        assembly { v := mload(add(0x40, ss)) }\n\n        // converts the last 8 bytes, adding to result\n        for (i = 0; i < 8 + offset; ++i) {\n            assembly { x := byte(i, v) }\n            r = r * 16 + fromHexChar(x);\n        }\n\n        return address(r);\n    }\n}\n"
    },
    {
      "name": "SafeMath.sol",
      "contents": "pragma solidity ^0.4.24;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    assert(c / _a == _b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n    return _a / _b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    assert(_b <= _a);\n    return _a - _b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    assert(c >= _a);\n    return c;\n  }\n}\n"
    }
  ],
  "libraries": {
    "AddressHelper": "0xca29fd2e878fc7845e7248ff8f27077c932918f0"
  },
  "creationData": {
    "blockHash": "0x5738ed29c87874df00a657303f00c8ee3ae6163e80bd6cbd6d5b6eea0c86977a",
    "blockNumber": 892211,
    "transactionHash": "0xc22e102b4fc2a419a5b4916a5fc1e4cd5ba53e9f58991c2ac0d07b878b5a1a5a",
    "timestamp": 1541794157
  }
}