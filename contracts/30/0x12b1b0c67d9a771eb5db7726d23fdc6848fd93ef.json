{
    "address": "0x12b1b0c67d9a771eb5db7726d23fdc6848fd93ef",
    "net": {
        "id": "30",
        "name": "RSK Mainnet"
    },
    "name": "FeeSharingProxy",
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        }
    },
    "version": "0.5.17+commit.d19bba13",
    "source": "pragma solidity ^0.5.17;\n\nimport \"./Staking/SafeMath96.sol\";\nimport \"../openzeppelin/SafeMath.sol\";\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"./IFeeSharingProxy.sol\";\nimport \"./Staking/IStaking.sol\";\n\ncontract FeeSharingProxy is SafeMath96, IFeeSharingProxy {\n\tusing SafeMath for uint256;\n\tusing SafeERC20 for IERC20;\n\n\t//TODO FEE_WITHDRAWAL_INTERVAL, MAX_CHECKPOINTS\n\tuint256 constant FEE_WITHDRAWAL_INTERVAL = 86400;\n\n\tuint32 constant MAX_CHECKPOINTS = 100;\n\n\tIProtocol public protocol;\n\tIStaking public staking;\n\n\t/// checkpoints by index per pool token address\n\tmapping(address => mapping(uint256 => Checkpoint)) public tokenCheckpoints;\n\t/// @notice The number of checkpoints for each pool token address\n\tmapping(address => uint32) public numTokenCheckpoints;\n\n\t/// user => token => processed checkpoint\n\tmapping(address => mapping(address => uint32)) public processedCheckpoints;\n\n\t//token => time\n\tmapping(address => uint256) public lastFeeWithdrawalTime;\n\n\t//token => amount\n\t//amount of tokens that were transferred, but were not saved in checkpoints\n\tmapping(address => uint96) public unprocessedAmount;\n\n\tstruct Checkpoint {\n\t\tuint32 blockNumber;\n\t\tuint32 timestamp;\n\t\tuint96 totalWeightedStake;\n\t\tuint96 numTokens;\n\t}\n\n\t/// @notice An event that emitted when fee get withdrawn\n\tevent FeeWithdrawn(address indexed sender, address indexed token, uint256 amount);\n\n\t/// @notice An event that emitted when tokens transferred\n\tevent TokensTransferred(address indexed sender, address indexed token, uint256 amount);\n\n\t/// @notice An event that emitted when checkpoint added\n\tevent CheckpointAdded(address indexed sender, address indexed token, uint256 amount);\n\n\t/// @notice An event that emitted when user fee get withdrawn\n\tevent UserFeeWithdrawn(address indexed sender, address indexed receiver, address indexed token, uint256 amount);\n\n\tconstructor(IProtocol _protocol, IStaking _staking) public {\n\t\tprotocol = _protocol;\n\t\tstaking = _staking;\n\t}\n\n\t/**\n\t * @notice withdraw fees for the given token: lendingFee + tradingFee + borrowingFee\n\t * @param _token address of the token\n\t * */\n\tfunction withdrawFees(address _token) public {\n\t\trequire(_token != address(0), \"FeeSharingProxy::withdrawFees: invalid address\");\n\n\t\taddress loanPoolToken = protocol.underlyingToLoanPool(_token);\n\t\trequire(loanPoolToken != address(0), \"FeeSharingProxy::withdrawFees: loan token not found\");\n\n\t\tuint256 amount = protocol.withdrawFees(_token, address(this));\n\t\trequire(amount > 0, \"FeeSharingProxy::withdrawFees: no tokens to withdraw\");\n\n\t\t//TODO can be also used - function addLiquidity(IERC20Token _reserveToken, uint256 _amount, uint256 _minReturn)\n\t\tIERC20(_token).approve(loanPoolToken, amount);\n\t\tuint256 poolTokenAmount = ILoanToken(loanPoolToken).mint(address(this), amount);\n\n\t\t//update unprocessed amount of tokens\n\t\tuint96 amount96 = safe96(poolTokenAmount, \"FeeSharingProxy::withdrawFees: pool token amount exceeds 96 bits\");\n\t\tunprocessedAmount[loanPoolToken] = add96(\n\t\t\tunprocessedAmount[loanPoolToken],\n\t\t\tamount96,\n\t\t\t\"FeeSharingProxy::withdrawFees: unprocessedAmount exceeds 96 bits\"\n\t\t);\n\n\t\t_addCheckpoint(loanPoolToken);\n\n\t\temit FeeWithdrawn(msg.sender, loanPoolToken, poolTokenAmount);\n\t}\n\n\t/**\n\t * @notice transfer tokens to this contract\n\t * @dev we just update amount of tokens here and write checkpoint in a separate methods\n\t * in order to prevent adding checkpoints too often\n\t * @param _token address of the token\n\t * @param _amount amount to be transferred\n\t * */\n\tfunction transferTokens(address _token, uint96 _amount) public {\n\t\trequire(_token != address(0), \"FeeSharingProxy::transferTokens: invalid address\");\n\t\trequire(_amount > 0, \"FeeSharingProxy::transferTokens: invalid amount\");\n\n\t\t//transfer tokens from msg.sender\n\t\tbool success = IERC20(_token).transferFrom(address(msg.sender), address(this), _amount);\n\t\trequire(success, \"Staking::transferTokens: token transfer failed\");\n\n\t\t//update unprocessed amount of tokens\n\t\tunprocessedAmount[_token] = add96(unprocessedAmount[_token], _amount, \"FeeSharingProxy::transferTokens: amount exceeds 96 bits\");\n\n\t\t_addCheckpoint(_token);\n\n\t\temit TokensTransferred(msg.sender, _token, _amount);\n\t}\n\n\t/**\n\t * @notice adds checkpoint with accumulated amount by function invocation\n\t * @param _token address of the token\n\t * */\n\tfunction _addCheckpoint(address _token) internal {\n\t\tif (block.timestamp - lastFeeWithdrawalTime[_token] >= FEE_WITHDRAWAL_INTERVAL) {\n\t\t\tlastFeeWithdrawalTime[_token] = block.timestamp;\n\t\t\tuint96 amount = unprocessedAmount[_token];\n\t\t\tunprocessedAmount[_token] = 0;\n\t\t\t//write a regular checkpoint\n\t\t\t_writeTokenCheckpoint(_token, amount);\n\t\t}\n\t}\n\n\t/**\n\t * @notice withdraw accumulated fee the message sender\n\t * @param _loanPoolToken address of the pool token\n\t * @param _maxCheckpoints maximum number of checkpoints to be processed\n\t * @param _receiver the receiver of tokens or msg.sender\n\t * */\n\tfunction withdraw(\n\t\taddress _loanPoolToken,\n\t\tuint32 _maxCheckpoints,\n\t\taddress _receiver\n\t) public {\n\t\t//prevents processing all checkpoints because of block gas limit\n\t\trequire(_maxCheckpoints > 0, \"FeeSharingProxy::withdraw: _maxCheckpoints should be positive\");\n\n\t\taddress user = msg.sender;\n\t\tif (_receiver == address(0)) {\n\t\t\t_receiver = msg.sender;\n\t\t}\n\n\t\tuint256 amount;\n\t\tuint32 end;\n\t\t(amount, end) = _getAccumulatedFees(user, _loanPoolToken, _maxCheckpoints);\n\n\t\tprocessedCheckpoints[user][_loanPoolToken] = end;\n\n\t\trequire(IERC20(_loanPoolToken).transfer(user, amount), \"FeeSharingProxy::withdraw: withdrawal failed\");\n\n\t\temit UserFeeWithdrawn(msg.sender, _receiver, _loanPoolToken, amount);\n\t}\n\n\t/**\n\t * @notice returns accumulated fee for the message sender\n\t * @param _user the address of the user or contract\n\t * @param _loanPoolToken address of the pool token\n\t * */\n\tfunction getAccumulatedFees(address _user, address _loanPoolToken) public view returns (uint256) {\n\t\tuint256 amount;\n\t\t(amount, ) = _getAccumulatedFees(_user, _loanPoolToken, 0);\n\t\treturn amount;\n\t}\n\n\tfunction _getAccumulatedFees(\n\t\taddress _user,\n\t\taddress _loanPoolToken,\n\t\tuint32 _maxCheckpoints\n\t) internal view returns (uint256, uint32) {\n\t\tuint32 start = processedCheckpoints[_user][_loanPoolToken];\n\t\tuint32 end;\n\t\t//additional bool param can't be used because of stack too deep error\n\t\tif (_maxCheckpoints > 0) {\n\t\t\t//withdraw -> _getAccumulatedFees\n\t\t\trequire(start < numTokenCheckpoints[_loanPoolToken], \"FeeSharingProxy::withdrawFees: no tokens for a withdrawal\");\n\t\t\tend = _getEndOfRange(start, _loanPoolToken, _maxCheckpoints);\n\t\t} else {\n\t\t\t//getAccumulatedFees -> _getAccumulatedFees\n\t\t\t//don't throw error for getter invocation outside of transaction\n\t\t\tif (start >= numTokenCheckpoints[_loanPoolToken]) {\n\t\t\t\treturn (0, numTokenCheckpoints[_loanPoolToken]);\n\t\t\t}\n\t\t\tend = numTokenCheckpoints[_loanPoolToken];\n\t\t}\n\n\t\tuint256 amount = 0;\n\t\tuint256 cachedLockDate = 0;\n\t\tuint96 cachedWeightedStake = 0;\n\t\tfor (uint32 i = start; i < end; i++) {\n\t\t\tCheckpoint storage checkpoint = tokenCheckpoints[_loanPoolToken][i];\n\t\t\tuint256 lockDate = staking.timestampToLockDate(checkpoint.timestamp);\n\t\t\tuint96 weightedStake;\n\t\t\tif (lockDate == cachedLockDate) {\n\t\t\t\tweightedStake = cachedWeightedStake;\n\t\t\t} else {\n\t\t\t\t//We need to use \"checkpoint.blockNumber - 1\" here to calculate weighted stake\n\t\t\t\t//for the same block like we did for total voting power in _writeTokenCheckpoint\n\t\t\t\tweightedStake = staking.getPriorWeightedStake(_user, checkpoint.blockNumber - 1, checkpoint.timestamp);\n\t\t\t\tcachedWeightedStake = weightedStake;\n\t\t\t\tcachedLockDate = lockDate;\n\t\t\t}\n\t\t\tuint256 share = uint256(checkpoint.numTokens).mul(weightedStake).div(uint256(checkpoint.totalWeightedStake));\n\t\t\tamount = amount.add(share);\n\t\t}\n\t\treturn (amount, end);\n\t}\n\n\tfunction _getEndOfRange(\n\t\tuint32 start,\n\t\taddress _loanPoolToken,\n\t\tuint32 _maxCheckpoints\n\t) internal view returns (uint32) {\n\t\tuint32 nCheckpoints = numTokenCheckpoints[_loanPoolToken];\n\t\tuint32 end;\n\t\tif (_maxCheckpoints == 0) {\n\t\t\t//all checkpoints will be processed (only for getter outside of a transaction)\n\t\t\tend = nCheckpoints;\n\t\t} else {\n\t\t\tif (_maxCheckpoints > MAX_CHECKPOINTS) {\n\t\t\t\t_maxCheckpoints = MAX_CHECKPOINTS;\n\t\t\t}\n\t\t\tend = safe32(start + _maxCheckpoints, \"FeeSharingProxy::withdraw: checkpoint index exceeds 32 bits\");\n\t\t\tif (end > nCheckpoints) {\n\t\t\t\tend = nCheckpoints;\n\t\t\t}\n\t\t}\n\t\t//Withdrawal should only be possible for blocks which were already mined.\n\t\tuint32 lastBlockNumber = tokenCheckpoints[_loanPoolToken][end - 1].blockNumber;\n\t\tif (block.number == lastBlockNumber) {\n\t\t\tend--;\n\t\t}\n\t\treturn end;\n\t}\n\n\tfunction _writeTokenCheckpoint(address _token, uint96 _numTokens) internal {\n\t\tuint32 blockNumber = safe32(block.number, \"FeeSharingProxy::_writeCheckpoint: block number exceeds 32 bits\");\n\t\tuint32 blockTimestamp = safe32(block.timestamp, \"FeeSharingProxy::_writeCheckpoint: block timestamp exceeds 32 bits\");\n\t\tuint32 nCheckpoints = numTokenCheckpoints[_token];\n\n\t\tuint96 totalWeightedStake = staking.getPriorTotalVotingPower(blockNumber - 1, block.timestamp);\n\t\tif (nCheckpoints > 0 && tokenCheckpoints[_token][nCheckpoints - 1].blockNumber == blockNumber) {\n\t\t\ttokenCheckpoints[_token][nCheckpoints - 1].totalWeightedStake = totalWeightedStake;\n\t\t\ttokenCheckpoints[_token][nCheckpoints - 1].numTokens = _numTokens;\n\t\t} else {\n\t\t\ttokenCheckpoints[_token][nCheckpoints] = Checkpoint(blockNumber, blockTimestamp, totalWeightedStake, _numTokens);\n\t\t\tnumTokenCheckpoints[_token] = nCheckpoints + 1;\n\t\t}\n\t\temit CheckpointAdded(msg.sender, _token, _numTokens);\n\t}\n}\n\ninterface IProtocol {\n\tfunction withdrawFees(address token, address receiver) external returns (uint256);\n\n\tfunction underlyingToLoanPool(address token) external returns (address);\n}\n\ninterface ILoanToken {\n\tfunction mint(address receiver, uint256 depositAmount) external returns (uint256 mintAmount);\n}\n",
    "imports": [
        {
            "name": "FeeSharingProxy.sol",
            "contents": "pragma solidity ^0.5.17;\n\nimport \"./Staking/SafeMath96.sol\";\nimport \"../openzeppelin/SafeMath.sol\";\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"./IFeeSharingProxy.sol\";\nimport \"./Staking/IStaking.sol\";\n\ncontract FeeSharingProxy is SafeMath96, IFeeSharingProxy {\n\tusing SafeMath for uint256;\n\tusing SafeERC20 for IERC20;\n\n\t//TODO FEE_WITHDRAWAL_INTERVAL, MAX_CHECKPOINTS\n\tuint256 constant FEE_WITHDRAWAL_INTERVAL = 86400;\n\n\tuint32 constant MAX_CHECKPOINTS = 100;\n\n\tIProtocol public protocol;\n\tIStaking public staking;\n\n\t/// checkpoints by index per pool token address\n\tmapping(address => mapping(uint256 => Checkpoint)) public tokenCheckpoints;\n\t/// @notice The number of checkpoints for each pool token address\n\tmapping(address => uint32) public numTokenCheckpoints;\n\n\t/// user => token => processed checkpoint\n\tmapping(address => mapping(address => uint32)) public processedCheckpoints;\n\n\t//token => time\n\tmapping(address => uint256) public lastFeeWithdrawalTime;\n\n\t//token => amount\n\t//amount of tokens that were transferred, but were not saved in checkpoints\n\tmapping(address => uint96) public unprocessedAmount;\n\n\tstruct Checkpoint {\n\t\tuint32 blockNumber;\n\t\tuint32 timestamp;\n\t\tuint96 totalWeightedStake;\n\t\tuint96 numTokens;\n\t}\n\n\t/// @notice An event that emitted when fee get withdrawn\n\tevent FeeWithdrawn(address indexed sender, address indexed token, uint256 amount);\n\n\t/// @notice An event that emitted when tokens transferred\n\tevent TokensTransferred(address indexed sender, address indexed token, uint256 amount);\n\n\t/// @notice An event that emitted when checkpoint added\n\tevent CheckpointAdded(address indexed sender, address indexed token, uint256 amount);\n\n\t/// @notice An event that emitted when user fee get withdrawn\n\tevent UserFeeWithdrawn(address indexed sender, address indexed receiver, address indexed token, uint256 amount);\n\n\tconstructor(IProtocol _protocol, IStaking _staking) public {\n\t\tprotocol = _protocol;\n\t\tstaking = _staking;\n\t}\n\n\t/**\n\t * @notice withdraw fees for the given token: lendingFee + tradingFee + borrowingFee\n\t * @param _token address of the token\n\t * */\n\tfunction withdrawFees(address _token) public {\n\t\trequire(_token != address(0), \"FeeSharingProxy::withdrawFees: invalid address\");\n\n\t\taddress loanPoolToken = protocol.underlyingToLoanPool(_token);\n\t\trequire(loanPoolToken != address(0), \"FeeSharingProxy::withdrawFees: loan token not found\");\n\n\t\tuint256 amount = protocol.withdrawFees(_token, address(this));\n\t\trequire(amount > 0, \"FeeSharingProxy::withdrawFees: no tokens to withdraw\");\n\n\t\t//TODO can be also used - function addLiquidity(IERC20Token _reserveToken, uint256 _amount, uint256 _minReturn)\n\t\tIERC20(_token).approve(loanPoolToken, amount);\n\t\tuint256 poolTokenAmount = ILoanToken(loanPoolToken).mint(address(this), amount);\n\n\t\t//update unprocessed amount of tokens\n\t\tuint96 amount96 = safe96(poolTokenAmount, \"FeeSharingProxy::withdrawFees: pool token amount exceeds 96 bits\");\n\t\tunprocessedAmount[loanPoolToken] = add96(\n\t\t\tunprocessedAmount[loanPoolToken],\n\t\t\tamount96,\n\t\t\t\"FeeSharingProxy::withdrawFees: unprocessedAmount exceeds 96 bits\"\n\t\t);\n\n\t\t_addCheckpoint(loanPoolToken);\n\n\t\temit FeeWithdrawn(msg.sender, loanPoolToken, poolTokenAmount);\n\t}\n\n\t/**\n\t * @notice transfer tokens to this contract\n\t * @dev we just update amount of tokens here and write checkpoint in a separate methods\n\t * in order to prevent adding checkpoints too often\n\t * @param _token address of the token\n\t * @param _amount amount to be transferred\n\t * */\n\tfunction transferTokens(address _token, uint96 _amount) public {\n\t\trequire(_token != address(0), \"FeeSharingProxy::transferTokens: invalid address\");\n\t\trequire(_amount > 0, \"FeeSharingProxy::transferTokens: invalid amount\");\n\n\t\t//transfer tokens from msg.sender\n\t\tbool success = IERC20(_token).transferFrom(address(msg.sender), address(this), _amount);\n\t\trequire(success, \"Staking::transferTokens: token transfer failed\");\n\n\t\t//update unprocessed amount of tokens\n\t\tunprocessedAmount[_token] = add96(unprocessedAmount[_token], _amount, \"FeeSharingProxy::transferTokens: amount exceeds 96 bits\");\n\n\t\t_addCheckpoint(_token);\n\n\t\temit TokensTransferred(msg.sender, _token, _amount);\n\t}\n\n\t/**\n\t * @notice adds checkpoint with accumulated amount by function invocation\n\t * @param _token address of the token\n\t * */\n\tfunction _addCheckpoint(address _token) internal {\n\t\tif (block.timestamp - lastFeeWithdrawalTime[_token] >= FEE_WITHDRAWAL_INTERVAL) {\n\t\t\tlastFeeWithdrawalTime[_token] = block.timestamp;\n\t\t\tuint96 amount = unprocessedAmount[_token];\n\t\t\tunprocessedAmount[_token] = 0;\n\t\t\t//write a regular checkpoint\n\t\t\t_writeTokenCheckpoint(_token, amount);\n\t\t}\n\t}\n\n\t/**\n\t * @notice withdraw accumulated fee the message sender\n\t * @param _loanPoolToken address of the pool token\n\t * @param _maxCheckpoints maximum number of checkpoints to be processed\n\t * @param _receiver the receiver of tokens or msg.sender\n\t * */\n\tfunction withdraw(\n\t\taddress _loanPoolToken,\n\t\tuint32 _maxCheckpoints,\n\t\taddress _receiver\n\t) public {\n\t\t//prevents processing all checkpoints because of block gas limit\n\t\trequire(_maxCheckpoints > 0, \"FeeSharingProxy::withdraw: _maxCheckpoints should be positive\");\n\n\t\taddress user = msg.sender;\n\t\tif (_receiver == address(0)) {\n\t\t\t_receiver = msg.sender;\n\t\t}\n\n\t\tuint256 amount;\n\t\tuint32 end;\n\t\t(amount, end) = _getAccumulatedFees(user, _loanPoolToken, _maxCheckpoints);\n\n\t\tprocessedCheckpoints[user][_loanPoolToken] = end;\n\n\t\trequire(IERC20(_loanPoolToken).transfer(user, amount), \"FeeSharingProxy::withdraw: withdrawal failed\");\n\n\t\temit UserFeeWithdrawn(msg.sender, _receiver, _loanPoolToken, amount);\n\t}\n\n\t/**\n\t * @notice returns accumulated fee for the message sender\n\t * @param _user the address of the user or contract\n\t * @param _loanPoolToken address of the pool token\n\t * */\n\tfunction getAccumulatedFees(address _user, address _loanPoolToken) public view returns (uint256) {\n\t\tuint256 amount;\n\t\t(amount, ) = _getAccumulatedFees(_user, _loanPoolToken, 0);\n\t\treturn amount;\n\t}\n\n\tfunction _getAccumulatedFees(\n\t\taddress _user,\n\t\taddress _loanPoolToken,\n\t\tuint32 _maxCheckpoints\n\t) internal view returns (uint256, uint32) {\n\t\tuint32 start = processedCheckpoints[_user][_loanPoolToken];\n\t\tuint32 end;\n\t\t//additional bool param can't be used because of stack too deep error\n\t\tif (_maxCheckpoints > 0) {\n\t\t\t//withdraw -> _getAccumulatedFees\n\t\t\trequire(start < numTokenCheckpoints[_loanPoolToken], \"FeeSharingProxy::withdrawFees: no tokens for a withdrawal\");\n\t\t\tend = _getEndOfRange(start, _loanPoolToken, _maxCheckpoints);\n\t\t} else {\n\t\t\t//getAccumulatedFees -> _getAccumulatedFees\n\t\t\t//don't throw error for getter invocation outside of transaction\n\t\t\tif (start >= numTokenCheckpoints[_loanPoolToken]) {\n\t\t\t\treturn (0, numTokenCheckpoints[_loanPoolToken]);\n\t\t\t}\n\t\t\tend = numTokenCheckpoints[_loanPoolToken];\n\t\t}\n\n\t\tuint256 amount = 0;\n\t\tuint256 cachedLockDate = 0;\n\t\tuint96 cachedWeightedStake = 0;\n\t\tfor (uint32 i = start; i < end; i++) {\n\t\t\tCheckpoint storage checkpoint = tokenCheckpoints[_loanPoolToken][i];\n\t\t\tuint256 lockDate = staking.timestampToLockDate(checkpoint.timestamp);\n\t\t\tuint96 weightedStake;\n\t\t\tif (lockDate == cachedLockDate) {\n\t\t\t\tweightedStake = cachedWeightedStake;\n\t\t\t} else {\n\t\t\t\t//We need to use \"checkpoint.blockNumber - 1\" here to calculate weighted stake\n\t\t\t\t//for the same block like we did for total voting power in _writeTokenCheckpoint\n\t\t\t\tweightedStake = staking.getPriorWeightedStake(_user, checkpoint.blockNumber - 1, checkpoint.timestamp);\n\t\t\t\tcachedWeightedStake = weightedStake;\n\t\t\t\tcachedLockDate = lockDate;\n\t\t\t}\n\t\t\tuint256 share = uint256(checkpoint.numTokens).mul(weightedStake).div(uint256(checkpoint.totalWeightedStake));\n\t\t\tamount = amount.add(share);\n\t\t}\n\t\treturn (amount, end);\n\t}\n\n\tfunction _getEndOfRange(\n\t\tuint32 start,\n\t\taddress _loanPoolToken,\n\t\tuint32 _maxCheckpoints\n\t) internal view returns (uint32) {\n\t\tuint32 nCheckpoints = numTokenCheckpoints[_loanPoolToken];\n\t\tuint32 end;\n\t\tif (_maxCheckpoints == 0) {\n\t\t\t//all checkpoints will be processed (only for getter outside of a transaction)\n\t\t\tend = nCheckpoints;\n\t\t} else {\n\t\t\tif (_maxCheckpoints > MAX_CHECKPOINTS) {\n\t\t\t\t_maxCheckpoints = MAX_CHECKPOINTS;\n\t\t\t}\n\t\t\tend = safe32(start + _maxCheckpoints, \"FeeSharingProxy::withdraw: checkpoint index exceeds 32 bits\");\n\t\t\tif (end > nCheckpoints) {\n\t\t\t\tend = nCheckpoints;\n\t\t\t}\n\t\t}\n\t\t//Withdrawal should only be possible for blocks which were already mined.\n\t\tuint32 lastBlockNumber = tokenCheckpoints[_loanPoolToken][end - 1].blockNumber;\n\t\tif (block.number == lastBlockNumber) {\n\t\t\tend--;\n\t\t}\n\t\treturn end;\n\t}\n\n\tfunction _writeTokenCheckpoint(address _token, uint96 _numTokens) internal {\n\t\tuint32 blockNumber = safe32(block.number, \"FeeSharingProxy::_writeCheckpoint: block number exceeds 32 bits\");\n\t\tuint32 blockTimestamp = safe32(block.timestamp, \"FeeSharingProxy::_writeCheckpoint: block timestamp exceeds 32 bits\");\n\t\tuint32 nCheckpoints = numTokenCheckpoints[_token];\n\n\t\tuint96 totalWeightedStake = staking.getPriorTotalVotingPower(blockNumber - 1, block.timestamp);\n\t\tif (nCheckpoints > 0 && tokenCheckpoints[_token][nCheckpoints - 1].blockNumber == blockNumber) {\n\t\t\ttokenCheckpoints[_token][nCheckpoints - 1].totalWeightedStake = totalWeightedStake;\n\t\t\ttokenCheckpoints[_token][nCheckpoints - 1].numTokens = _numTokens;\n\t\t} else {\n\t\t\ttokenCheckpoints[_token][nCheckpoints] = Checkpoint(blockNumber, blockTimestamp, totalWeightedStake, _numTokens);\n\t\t\tnumTokenCheckpoints[_token] = nCheckpoints + 1;\n\t\t}\n\t\temit CheckpointAdded(msg.sender, _token, _numTokens);\n\t}\n}\n\ninterface IProtocol {\n\tfunction withdrawFees(address token, address receiver) external returns (uint256);\n\n\tfunction underlyingToLoanPool(address token) external returns (address);\n}\n\ninterface ILoanToken {\n\tfunction mint(address receiver, uint256 depositAmount) external returns (uint256 mintAmount);\n}\n",
            "file": "FeeSharingProxy.sol"
        },
        {
            "name": "IFeeSharingProxy.sol",
            "contents": "pragma solidity ^0.5.17;\n\ninterface IFeeSharingProxy {\n\tfunction withdrawFees(address _token) external;\n\n\tfunction transferTokens(address _token, uint96 _amount) external;\n\n\tfunction withdraw(\n\t\taddress _loanPoolToken,\n\t\tuint32 _maxCheckpoints,\n\t\taddress _receiver\n\t) external;\n}\n"
        },
        {
            "name": "IStaking.sol",
            "contents": "pragma solidity ^0.5.17;\n\ninterface IStaking {\n\tfunction stakesBySchedule(\n\t\tuint256 amount,\n\t\tuint256 cliff,\n\t\tuint256 duration,\n\t\tuint256 intervalLength,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) external;\n\n\tfunction stake(\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) external;\n\n\tfunction getPriorVotes(\n\t\taddress account,\n\t\tuint256 blockNumber,\n\t\tuint256 date\n\t) external view returns (uint96);\n\n\tfunction getPriorTotalVotingPower(uint32 blockNumber, uint256 time) external view returns (uint96);\n\n\tfunction getPriorWeightedStake(\n\t\taddress account,\n\t\tuint256 blockNumber,\n\t\tuint256 date\n\t) external view returns (uint96);\n\n\tfunction timestampToLockDate(uint256 timestamp) external view returns (uint256 lockDate);\n}\n"
        },
        {
            "name": "SafeMath96.sol",
            "contents": "pragma solidity ^0.5.17;\npragma experimental ABIEncoderV2;\n\ncontract SafeMath96 {\n\tfunction safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n\t\trequire(n < 2**32, errorMessage);\n\t\treturn uint32(n);\n\t}\n\n\tfunction safe64(uint256 n, string memory errorMessage) internal pure returns (uint64) {\n\t\trequire(n < 2**64, errorMessage);\n\t\treturn uint64(n);\n\t}\n\n\tfunction safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\n\t\trequire(n < 2**96, errorMessage);\n\t\treturn uint96(n);\n\t}\n\n\tfunction add96(\n\t\tuint96 a,\n\t\tuint96 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint96) {\n\t\tuint96 c = a + b;\n\t\trequire(c >= a, errorMessage);\n\t\treturn c;\n\t}\n\n\tfunction sub96(\n\t\tuint96 a,\n\t\tuint96 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint96) {\n\t\trequire(b <= a, errorMessage);\n\t\treturn a - b;\n\t}\n\n\tfunction mul96(\n\t\tuint96 a,\n\t\tuint96 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint96) {\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint96 c = a * b;\n\t\trequire(c / a == b, errorMessage);\n\n\t\treturn c;\n\t}\n\n\tfunction div96(\n\t\tuint96 a,\n\t\tuint96 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint96) {\n\t\t// Solidity only automatically asserts when dividing by 0\n\t\trequire(b > 0, errorMessage);\n\t\tuint96 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\t\treturn c;\n\t}\n}\n"
        },
        {
            "name": "SafeERC20.sol",
            "contents": "pragma solidity >=0.5.0 <0.6.0;\n\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\nimport \"../interfaces/IERC20.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n\tusing SafeMath for uint256;\n\tusing Address for address;\n\n\tfunction safeTransfer(\n\t\tIERC20 token,\n\t\taddress to,\n\t\tuint256 value\n\t) internal {\n\t\tcallOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n\t}\n\n\tfunction safeTransferFrom(\n\t\tIERC20 token,\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value\n\t) internal {\n\t\tcallOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n\t}\n\n\tfunction safeApprove(\n\t\tIERC20 token,\n\t\taddress spender,\n\t\tuint256 value\n\t) internal {\n\t\t// safeApprove should only be called when setting an initial allowance,\n\t\t// or when resetting it to zero. To increase and decrease it, use\n\t\t// 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n\t\t// solhint-disable-next-line max-line-length\n\t\trequire((value == 0) || (token.allowance(address(this), spender) == 0), \"SafeERC20: approve from non-zero to non-zero allowance\");\n\t\tcallOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n\t}\n\n\tfunction safeIncreaseAllowance(\n\t\tIERC20 token,\n\t\taddress spender,\n\t\tuint256 value\n\t) internal {\n\t\tuint256 newAllowance = token.allowance(address(this), spender).add(value);\n\t\tcallOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n\t}\n\n\tfunction safeDecreaseAllowance(\n\t\tIERC20 token,\n\t\taddress spender,\n\t\tuint256 value\n\t) internal {\n\t\tuint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n\t\tcallOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n\t}\n\n\t/**\n\t * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n\t * on the return value: the return value is optional (but if data is returned, it must not be false).\n\t * @param token The token targeted by the call.\n\t * @param data The call data (encoded using abi.encode or one of its variants).\n\t */\n\tfunction callOptionalReturn(IERC20 token, bytes memory data) private {\n\t\t// We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n\t\t// we're implementing it ourselves.\n\n\t\t// A Solidity high level call has three parts:\n\t\t//  1. The target address is checked to verify it contains contract code\n\t\t//  2. The call itself is made, and success asserted\n\t\t//  3. The return value is decoded, which in turn checks the size of the returned data.\n\t\t// solhint-disable-next-line max-line-length\n\t\trequire(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n\t\t// solhint-disable-next-line avoid-low-level-calls\n\t\t(bool success, bytes memory returndata) = address(token).call(data);\n\t\trequire(success, \"SafeERC20: low-level call failed\");\n\n\t\tif (returndata.length > 0) {\n\t\t\t// Return data is optional\n\t\t\t// solhint-disable-next-line max-line-length\n\t\t\trequire(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n\t\t}\n\t}\n}\n"
        },
        {
            "name": "SafeMath.sol",
            "contents": "pragma solidity >=0.5.0 <0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n\t/**\n\t * @dev Returns the addition of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `+` operator.\n\t *\n\t * Requirements:\n\t * - Addition cannot overflow.\n\t */\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\trequire(c >= a, \"SafeMath: addition overflow\");\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t * - Subtraction cannot overflow.\n\t */\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn sub(a, b, \"SafeMath: subtraction overflow\");\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t * - Subtraction cannot overflow.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction sub(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\trequire(b <= a, errorMessage);\n\t\tuint256 c = a - b;\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the multiplication of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `*` operator.\n\t *\n\t * Requirements:\n\t * - Multiplication cannot overflow.\n\t */\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\t\t// benefit is lost if 'b' is also tested.\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 c = a * b;\n\t\trequire(c / a == b, \"SafeMath: multiplication overflow\");\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers. Reverts on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn div(a, b, \"SafeMath: division by zero\");\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction div(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\t// Solidity only automatically asserts when dividing by 0\n\t\trequire(b > 0, errorMessage);\n\t\tuint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn mod(a, b, \"SafeMath: modulo by zero\");\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts with custom message when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction mod(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\trequire(b != 0, errorMessage);\n\t\treturn a % b;\n\t}\n\n\tfunction min256(uint256 _a, uint256 _b) internal pure returns (uint256) {\n\t\treturn _a < _b ? _a : _b;\n\t}\n}\n"
        },
        {
            "name": "IERC20.sol",
            "contents": "/**\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0.\n */\n\npragma solidity >=0.5.0 <0.6.0;\n\ncontract IERC20 {\n\tstring public name;\n\tuint8 public decimals;\n\tstring public symbol;\n\n\tfunction totalSupply() public view returns (uint256);\n\n\tfunction balanceOf(address _who) public view returns (uint256);\n\n\tfunction transfer(address _to, uint256 _value) public returns (bool);\n\n\tfunction allowance(address _owner, address _spender) public view returns (uint256);\n\n\tfunction transferFrom(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _value\n\t) public returns (bool);\n\n\tfunction approve(address _spender, uint256 _value) public returns (bool);\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
        },
        {
            "name": "Address.sol",
            "contents": "pragma solidity >=0.5.0 <0.6.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n\t/**\n\t * @dev Returns true if `account` is a contract.\n\t *\n\t * [IMPORTANT]\n\t * ====\n\t * It is unsafe to assume that an address for which this function returns\n\t * false is an externally-owned account (EOA) and not a contract.\n\t *\n\t * Among others, `isContract` will return false for the following\n\t * types of addresses:\n\t *\n\t *  - an externally-owned account\n\t *  - a contract in construction\n\t *  - an address where a contract will be created\n\t *  - an address where a contract lived, but was destroyed\n\t * ====\n\t */\n\tfunction isContract(address account) internal view returns (bool) {\n\t\t// According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\t\t// and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\t\t// for accounts without code, i.e. `keccak256('')`\n\t\tbytes32 codehash;\n\t\tbytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tcodehash := extcodehash(account)\n\t\t}\n\t\treturn (codehash != accountHash && codehash != 0x0);\n\t}\n\n\t/**\n\t * @dev Converts an `address` into `address payable`. Note that this is\n\t * simply a type cast: the actual underlying value is not changed.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction toPayable(address account) internal pure returns (address payable) {\n\t\treturn address(uint160(account));\n\t}\n\n\t/**\n\t * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n\t * `recipient`, forwarding all available gas and reverting on errors.\n\t *\n\t * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n\t * of certain opcodes, possibly making contracts go over the 2300 gas limit\n\t * imposed by `transfer`, making them unable to receive funds via\n\t * `transfer`. {sendValue} removes this limitation.\n\t *\n\t * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n\t *\n\t * IMPORTANT: because control is transferred to `recipient`, care must be\n\t * taken to not create reentrancy vulnerabilities. Consider using\n\t * {ReentrancyGuard} or the\n\t * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction sendValue(address recipient, uint256 amount) internal {\n\t\trequire(address(this).balance >= amount, \"Address: insufficient balance\");\n\n\t\t// solhint-disable-next-line avoid-call-value\n\t\t(bool success, ) = recipient.call.value(amount)(\"\");\n\t\trequire(success, \"Address: unable to send value, recipient may have reverted\");\n\t}\n}\n"
        }
    ],
    "libraries": {},
    "constructorArguments": [
        "0x5A0D867e0D70Fcc6Ade25C3F1B89d618b5B4Eaa7",
        "0x5684a06CaB22Db16d901fEe2A5C081b4C91eA40e"
    ],
    "creationData": {
        "blockHash": "0x0c870b51a045b70e5bcf085fc7595ff4012b5c562efce5cbd781e0dfbeff7b7d",
        "blockNumber": 3100266,
        "transactionHash": "0xad8baf097f7fd8424e9df3ca5c2840936f781568850d0dae9c0ac07a499e752a",
        "timestamp": 1613125795
    }
}