{
  "address": "0x5204e8baa485f9511be3943ebea3e4af07bdafef",
  "net": {
    "id": "30",
    "name": "RSK Mainnet"
  },
  "name": "LiquidityPoolV2ConverterCustomFactory",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    }
  },
  "version": "0.4.26+commit.4563c3fc",
  "source": "pragma solidity 0.4.26;\r\n\r\n/*\r\n    Typed Converter Custom Factory interface\r\n*/\r\ncontract ITypedConverterCustomFactory {\r\n    function converterType() public pure returns (uint16);\r\n}\r\n\r\n/**\r\n * @dev Utilities & Common Modifiers\r\n */\r\ncontract Utils {\r\n    // verifies that a value is greater than zero\r\n    modifier greaterThanZero(uint256 _value) {\r\n        _greaterThanZero(_value);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _greaterThanZero(uint256 _value) internal pure {\r\n        require(_value > 0, \"ERR_ZERO_VALUE\");\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        _validAddress(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validAddress(address _address) internal pure {\r\n        require(_address != address(0), \"ERR_INVALID_ADDRESS\");\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        _notThis(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _notThis(address _address) internal view {\r\n        require(_address != address(this), \"ERR_ADDRESS_IS_SELF\");\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Library for basic math operations with overflow/underflow protection\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev returns the sum of _x and _y, reverts if the calculation overflows\r\n     *\r\n     * @param _x   value 1\r\n     * @param _y   value 2\r\n     *\r\n     * @return sum\r\n     */\r\n    function add(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        require(z >= _x, \"ERR_OVERFLOW\");\r\n        return z;\r\n    }\r\n\r\n    /**\r\n     * @dev returns the difference of _x minus _y, reverts if the calculation underflows\r\n     *\r\n     * @param _x   minuend\r\n     * @param _y   subtrahend\r\n     *\r\n     * @return difference\r\n     */\r\n    function sub(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_x >= _y, \"ERR_UNDERFLOW\");\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n     * @dev returns the product of multiplying _x by _y, reverts if the calculation overflows\r\n     *\r\n     * @param _x   factor 1\r\n     * @param _y   factor 2\r\n     *\r\n     * @return product\r\n     */\r\n    function mul(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        // gas optimization\r\n        if (_x == 0) return 0;\r\n\r\n        uint256 z = _x * _y;\r\n        require(z / _x == _y, \"ERR_OVERFLOW\");\r\n        return z;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n     *\r\n     * @param _x   dividend\r\n     * @param _y   divisor\r\n     *\r\n     * @return quotient\r\n     */\r\n    function div(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_y > 0, \"ERR_DIVIDE_BY_ZERO\");\r\n        uint256 c = _x / _y;\r\n        return c;\r\n    }\r\n}\r\n\r\n/*\r\n    Chainlink Price Oracle interface\r\n*/\r\ninterface IConsumerPriceOracle {\r\n    function latestAnswer() external view returns (int256);\r\n\r\n    function latestTimestamp() external view returns (uint256);\r\n}\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ncontract IERC20Token {\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    function name() public view returns (string) {\r\n        this;\r\n    }\r\n\r\n    function symbol() public view returns (string) {\r\n        this;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        this;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        this;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        _owner;\r\n        this;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        _owner;\r\n        _spender;\r\n        this;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value)\r\n        public\r\n        returns (bool success);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) public returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value)\r\n        public\r\n        returns (bool success);\r\n}\r\n\r\n/*\r\n    Price Oracle interface\r\n*/\r\ncontract IPriceOracle {\r\n    function latestRate(IERC20Token _tokenA, IERC20Token _tokenB)\r\n        public\r\n        view\r\n        returns (uint256, uint256);\r\n\r\n    function lastUpdateTime() public view returns (uint256);\r\n\r\n    function latestRateAndUpdateTime(IERC20Token _tokenA, IERC20Token _tokenB)\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function tokenAOracle() public view returns (IConsumerPriceOracle) {\r\n        this;\r\n    }\r\n\r\n    function tokenBOracle() public view returns (IConsumerPriceOracle) {\r\n        this;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Provides the off-chain rate between two tokens\r\n *\r\n * The price oracle uses chainlink oracles internally to get the rates of the two tokens\r\n * with respect to a common denominator, and then returns the rate between them, which\r\n * is equivalent to the rate of TokenA / TokenB\r\n */\r\ncontract PriceOracle is IPriceOracle, Utils {\r\n    using SafeMath for uint256;\r\n\r\n    address\r\n        private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    uint8 private constant ETH_DECIMALS = 18;\r\n\r\n    IERC20Token public tokenA; // token A the oracle supports\r\n    IERC20Token public tokenB; // token B the oracle supports\r\n    mapping(address => uint8) public tokenDecimals; // token -> token decimals\r\n\r\n    IConsumerPriceOracle public tokenAOracle; // token A chainlink price oracle\r\n    IConsumerPriceOracle public tokenBOracle; // token B chainlink price oracle\r\n    mapping(address => IConsumerPriceOracle) public tokensToOracles; // token -> price oracle for easier access\r\n\r\n    /**\r\n     * @dev initializes a new PriceOracle instance\r\n     * note that the oracles must have the same common denominator (USD, ETH etc.)\r\n     *\r\n     * @param  _tokenA         first token to support\r\n     * @param  _tokenB         second token to support\r\n     * @param  _tokenAOracle   first token price oracle\r\n     * @param  _tokenBOracle   second token price oracle\r\n     */\r\n    constructor(\r\n        IERC20Token _tokenA,\r\n        IERC20Token _tokenB,\r\n        IConsumerPriceOracle _tokenAOracle,\r\n        IConsumerPriceOracle _tokenBOracle\r\n    )\r\n        public\r\n        validUniqueAddresses(_tokenA, _tokenB)\r\n        validUniqueAddresses(_tokenAOracle, _tokenBOracle)\r\n    {\r\n        tokenA = _tokenA;\r\n        tokenB = _tokenB;\r\n        tokenDecimals[_tokenA] = decimals(_tokenA);\r\n        tokenDecimals[_tokenB] = decimals(_tokenB);\r\n\r\n        tokenAOracle = _tokenAOracle;\r\n        tokenBOracle = _tokenBOracle;\r\n        tokensToOracles[_tokenA] = _tokenAOracle;\r\n        tokensToOracles[_tokenB] = _tokenBOracle;\r\n    }\r\n\r\n    // ensures that the provided addresses are unique valid\r\n    modifier validUniqueAddresses(address _address1, address _address2) {\r\n        _validUniqueAddresses(_address1, _address2);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validUniqueAddresses(address _address1, address _address2)\r\n        internal\r\n        pure\r\n    {\r\n        _validAddress(_address1);\r\n        _validAddress(_address2);\r\n        require(_address1 != _address2, \"ERR_SAME_ADDRESS\");\r\n    }\r\n\r\n    // ensures that the provides tokens are supported by the oracle\r\n    modifier supportedTokens(IERC20Token _tokenA, IERC20Token _tokenB) {\r\n        _supportedTokens(_tokenA, _tokenB);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _supportedTokens(IERC20Token _tokenA, IERC20Token _tokenB)\r\n        internal\r\n        view\r\n    {\r\n        _validUniqueAddresses(_tokenA, _tokenB);\r\n        require(\r\n            tokensToOracles[_tokenA] != address(0) &&\r\n                tokensToOracles[_tokenB] != address(0),\r\n            \"ERR_UNSUPPORTED_TOKEN\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev returns the latest known rate between the two given tokens\r\n     * for a given pair of tokens A and B, returns the rate of A / B\r\n     * (the number of B units equivalent to a single A unit)\r\n     * the rate is returned as a fraction (numerator / denominator) for accuracy\r\n     *\r\n     * @param  _tokenA token to get the rate of 1 unit of\r\n     * @param  _tokenB token to get the rate of 1 `_tokenA` against\r\n     *\r\n     * @return numerator\r\n     * @return denominator\r\n     */\r\n    function latestRate(IERC20Token _tokenA, IERC20Token _tokenB)\r\n        public\r\n        view\r\n        supportedTokens(_tokenA, _tokenB)\r\n        returns (uint256, uint256)\r\n    {\r\n        uint256 rateTokenA = uint256(tokensToOracles[_tokenA].latestAnswer());\r\n        uint256 rateTokenB = uint256(tokensToOracles[_tokenB].latestAnswer());\r\n        uint8 decimalsTokenA = tokenDecimals[_tokenA];\r\n        uint8 decimalsTokenB = tokenDecimals[_tokenB];\r\n\r\n        // the normalization works as follows:\r\n        //   - token A with decimals of dA and price of rateA per one token (e.g., for 10^dA weiA)\r\n        //   - token B with decimals of dB < dA and price of rateB per one token (e.g., for 10^dB weiB)\r\n        // then the normalized rate, representing the rate between 1 weiA and 1 weiB is rateA / (rateB * 10^(dA - dB)).\r\n        //\r\n        // for example:\r\n        //   - token A with decimals of 5 and price of $10 per one token (e.g., for 100,000 weiA)\r\n        //   - token B with decimals of 2 and price of $2 per one token (e.g., for 100 weiB)\r\n        // then the normalized rate would be: 5 / (2 * 10^3) = 0.0025, which is the correct rate since\r\n        // 1 weiA costs $0.00005, 1 weiB costs $0.02, and weiA / weiB is 0.0025.\r\n\r\n        if (decimalsTokenA > decimalsTokenB) {\r\n            rateTokenB = rateTokenB.mul(\r\n                uint256(10)**(decimalsTokenA - decimalsTokenB)\r\n            );\r\n        } else if (decimalsTokenA < decimalsTokenB) {\r\n            rateTokenA = rateTokenA.mul(\r\n                uint256(10)**(decimalsTokenB - decimalsTokenA)\r\n            );\r\n        }\r\n\r\n        return (rateTokenA, rateTokenB);\r\n    }\r\n\r\n    /**\r\n     * @dev returns the timestamp of the last price update the rates are returned as numerator (token1) and denominator\r\n     * (token2) for accuracy\r\n     *\r\n     * @return timestamp\r\n     */\r\n    function lastUpdateTime() public view returns (uint256) {\r\n        // returns the oldest timestamp between the two\r\n        uint256 timestampA = tokenAOracle.latestTimestamp();\r\n        uint256 timestampB = tokenBOracle.latestTimestamp();\r\n\r\n        return timestampA < timestampB ? timestampA : timestampB;\r\n    }\r\n\r\n    /**\r\n     * @dev returns both the rate and the timestamp of the last update in a single call (gas optimization)\r\n     *\r\n     * @param  _tokenA token to get the rate of 1 unit of\r\n     * @param  _tokenB token to get the rate of 1 `_tokenA` against\r\n     *\r\n     * @return numerator\r\n     * @return denominator\r\n     * @return timestamp of the last update\r\n     */\r\n    function latestRateAndUpdateTime(IERC20Token _tokenA, IERC20Token _tokenB)\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        (uint256 numerator, uint256 denominator) = latestRate(_tokenA, _tokenB);\r\n\r\n        return (numerator, denominator, lastUpdateTime());\r\n    }\r\n\r\n    /** @dev returns the decimals of a given token */\r\n    function decimals(IERC20Token _token) private view returns (uint8) {\r\n        if (_token == ETH_ADDRESS) {\r\n            return ETH_DECIMALS;\r\n        }\r\n\r\n        return _token.decimals();\r\n    }\r\n}\r\n\r\n/*\r\n    LiquidityPoolV2ConverterCustomFactory Factory\r\n*/\r\ncontract LiquidityPoolV2ConverterCustomFactory is ITypedConverterCustomFactory {\r\n    /**\r\n     * @dev returns the converter type the factory is associated with\r\n     *\r\n     * @return converter type\r\n     */\r\n    function converterType() public pure returns (uint16) {\r\n        return 2;\r\n    }\r\n\r\n    /**\r\n     * @dev creates a new price oracle\r\n     * note that the oracles must have the same common denominator (USD, ETH etc.)\r\n     *\r\n     * @param  _primaryReserveToken    primary reserve token address\r\n     * @param  _secondaryReserveToken  secondary reserve token address\r\n     * @param  _primaryReserveOracle   primary reserve oracle address\r\n     * @param  _secondaryReserveOracle secondary reserve oracle address\r\n     */\r\n    function createPriceOracle(\r\n        IERC20Token _primaryReserveToken,\r\n        IERC20Token _secondaryReserveToken,\r\n        IConsumerPriceOracle _primaryReserveOracle,\r\n        IConsumerPriceOracle _secondaryReserveOracle\r\n    ) public returns (IPriceOracle) {\r\n        return\r\n            new PriceOracle(\r\n                _primaryReserveToken,\r\n                _secondaryReserveToken,\r\n                _primaryReserveOracle,\r\n                _secondaryReserveOracle\r\n            );\r\n    }\r\n}\r\n",
  "imports": [
    {
      "name": "13_LiquidityPoolV2ConverterCustomFactory_fix.sol",
      "contents": "pragma solidity 0.4.26;\r\n\r\n/*\r\n    Typed Converter Custom Factory interface\r\n*/\r\ncontract ITypedConverterCustomFactory {\r\n    function converterType() public pure returns (uint16);\r\n}\r\n\r\n/**\r\n * @dev Utilities & Common Modifiers\r\n */\r\ncontract Utils {\r\n    // verifies that a value is greater than zero\r\n    modifier greaterThanZero(uint256 _value) {\r\n        _greaterThanZero(_value);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _greaterThanZero(uint256 _value) internal pure {\r\n        require(_value > 0, \"ERR_ZERO_VALUE\");\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        _validAddress(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validAddress(address _address) internal pure {\r\n        require(_address != address(0), \"ERR_INVALID_ADDRESS\");\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        _notThis(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _notThis(address _address) internal view {\r\n        require(_address != address(this), \"ERR_ADDRESS_IS_SELF\");\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Library for basic math operations with overflow/underflow protection\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev returns the sum of _x and _y, reverts if the calculation overflows\r\n     *\r\n     * @param _x   value 1\r\n     * @param _y   value 2\r\n     *\r\n     * @return sum\r\n     */\r\n    function add(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        require(z >= _x, \"ERR_OVERFLOW\");\r\n        return z;\r\n    }\r\n\r\n    /**\r\n     * @dev returns the difference of _x minus _y, reverts if the calculation underflows\r\n     *\r\n     * @param _x   minuend\r\n     * @param _y   subtrahend\r\n     *\r\n     * @return difference\r\n     */\r\n    function sub(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_x >= _y, \"ERR_UNDERFLOW\");\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n     * @dev returns the product of multiplying _x by _y, reverts if the calculation overflows\r\n     *\r\n     * @param _x   factor 1\r\n     * @param _y   factor 2\r\n     *\r\n     * @return product\r\n     */\r\n    function mul(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        // gas optimization\r\n        if (_x == 0) return 0;\r\n\r\n        uint256 z = _x * _y;\r\n        require(z / _x == _y, \"ERR_OVERFLOW\");\r\n        return z;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n     *\r\n     * @param _x   dividend\r\n     * @param _y   divisor\r\n     *\r\n     * @return quotient\r\n     */\r\n    function div(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_y > 0, \"ERR_DIVIDE_BY_ZERO\");\r\n        uint256 c = _x / _y;\r\n        return c;\r\n    }\r\n}\r\n\r\n/*\r\n    Chainlink Price Oracle interface\r\n*/\r\ninterface IConsumerPriceOracle {\r\n    function latestAnswer() external view returns (int256);\r\n\r\n    function latestTimestamp() external view returns (uint256);\r\n}\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ncontract IERC20Token {\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    function name() public view returns (string) {\r\n        this;\r\n    }\r\n\r\n    function symbol() public view returns (string) {\r\n        this;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        this;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        this;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        _owner;\r\n        this;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        _owner;\r\n        _spender;\r\n        this;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value)\r\n        public\r\n        returns (bool success);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) public returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value)\r\n        public\r\n        returns (bool success);\r\n}\r\n\r\n/*\r\n    Price Oracle interface\r\n*/\r\ncontract IPriceOracle {\r\n    function latestRate(IERC20Token _tokenA, IERC20Token _tokenB)\r\n        public\r\n        view\r\n        returns (uint256, uint256);\r\n\r\n    function lastUpdateTime() public view returns (uint256);\r\n\r\n    function latestRateAndUpdateTime(IERC20Token _tokenA, IERC20Token _tokenB)\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function tokenAOracle() public view returns (IConsumerPriceOracle) {\r\n        this;\r\n    }\r\n\r\n    function tokenBOracle() public view returns (IConsumerPriceOracle) {\r\n        this;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Provides the off-chain rate between two tokens\r\n *\r\n * The price oracle uses chainlink oracles internally to get the rates of the two tokens\r\n * with respect to a common denominator, and then returns the rate between them, which\r\n * is equivalent to the rate of TokenA / TokenB\r\n */\r\ncontract PriceOracle is IPriceOracle, Utils {\r\n    using SafeMath for uint256;\r\n\r\n    address\r\n        private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    uint8 private constant ETH_DECIMALS = 18;\r\n\r\n    IERC20Token public tokenA; // token A the oracle supports\r\n    IERC20Token public tokenB; // token B the oracle supports\r\n    mapping(address => uint8) public tokenDecimals; // token -> token decimals\r\n\r\n    IConsumerPriceOracle public tokenAOracle; // token A chainlink price oracle\r\n    IConsumerPriceOracle public tokenBOracle; // token B chainlink price oracle\r\n    mapping(address => IConsumerPriceOracle) public tokensToOracles; // token -> price oracle for easier access\r\n\r\n    /**\r\n     * @dev initializes a new PriceOracle instance\r\n     * note that the oracles must have the same common denominator (USD, ETH etc.)\r\n     *\r\n     * @param  _tokenA         first token to support\r\n     * @param  _tokenB         second token to support\r\n     * @param  _tokenAOracle   first token price oracle\r\n     * @param  _tokenBOracle   second token price oracle\r\n     */\r\n    constructor(\r\n        IERC20Token _tokenA,\r\n        IERC20Token _tokenB,\r\n        IConsumerPriceOracle _tokenAOracle,\r\n        IConsumerPriceOracle _tokenBOracle\r\n    )\r\n        public\r\n        validUniqueAddresses(_tokenA, _tokenB)\r\n        validUniqueAddresses(_tokenAOracle, _tokenBOracle)\r\n    {\r\n        tokenA = _tokenA;\r\n        tokenB = _tokenB;\r\n        tokenDecimals[_tokenA] = decimals(_tokenA);\r\n        tokenDecimals[_tokenB] = decimals(_tokenB);\r\n\r\n        tokenAOracle = _tokenAOracle;\r\n        tokenBOracle = _tokenBOracle;\r\n        tokensToOracles[_tokenA] = _tokenAOracle;\r\n        tokensToOracles[_tokenB] = _tokenBOracle;\r\n    }\r\n\r\n    // ensures that the provided addresses are unique valid\r\n    modifier validUniqueAddresses(address _address1, address _address2) {\r\n        _validUniqueAddresses(_address1, _address2);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validUniqueAddresses(address _address1, address _address2)\r\n        internal\r\n        pure\r\n    {\r\n        _validAddress(_address1);\r\n        _validAddress(_address2);\r\n        require(_address1 != _address2, \"ERR_SAME_ADDRESS\");\r\n    }\r\n\r\n    // ensures that the provides tokens are supported by the oracle\r\n    modifier supportedTokens(IERC20Token _tokenA, IERC20Token _tokenB) {\r\n        _supportedTokens(_tokenA, _tokenB);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _supportedTokens(IERC20Token _tokenA, IERC20Token _tokenB)\r\n        internal\r\n        view\r\n    {\r\n        _validUniqueAddresses(_tokenA, _tokenB);\r\n        require(\r\n            tokensToOracles[_tokenA] != address(0) &&\r\n                tokensToOracles[_tokenB] != address(0),\r\n            \"ERR_UNSUPPORTED_TOKEN\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev returns the latest known rate between the two given tokens\r\n     * for a given pair of tokens A and B, returns the rate of A / B\r\n     * (the number of B units equivalent to a single A unit)\r\n     * the rate is returned as a fraction (numerator / denominator) for accuracy\r\n     *\r\n     * @param  _tokenA token to get the rate of 1 unit of\r\n     * @param  _tokenB token to get the rate of 1 `_tokenA` against\r\n     *\r\n     * @return numerator\r\n     * @return denominator\r\n     */\r\n    function latestRate(IERC20Token _tokenA, IERC20Token _tokenB)\r\n        public\r\n        view\r\n        supportedTokens(_tokenA, _tokenB)\r\n        returns (uint256, uint256)\r\n    {\r\n        uint256 rateTokenA = uint256(tokensToOracles[_tokenA].latestAnswer());\r\n        uint256 rateTokenB = uint256(tokensToOracles[_tokenB].latestAnswer());\r\n        uint8 decimalsTokenA = tokenDecimals[_tokenA];\r\n        uint8 decimalsTokenB = tokenDecimals[_tokenB];\r\n\r\n        // the normalization works as follows:\r\n        //   - token A with decimals of dA and price of rateA per one token (e.g., for 10^dA weiA)\r\n        //   - token B with decimals of dB < dA and price of rateB per one token (e.g., for 10^dB weiB)\r\n        // then the normalized rate, representing the rate between 1 weiA and 1 weiB is rateA / (rateB * 10^(dA - dB)).\r\n        //\r\n        // for example:\r\n        //   - token A with decimals of 5 and price of $10 per one token (e.g., for 100,000 weiA)\r\n        //   - token B with decimals of 2 and price of $2 per one token (e.g., for 100 weiB)\r\n        // then the normalized rate would be: 5 / (2 * 10^3) = 0.0025, which is the correct rate since\r\n        // 1 weiA costs $0.00005, 1 weiB costs $0.02, and weiA / weiB is 0.0025.\r\n\r\n        if (decimalsTokenA > decimalsTokenB) {\r\n            rateTokenB = rateTokenB.mul(\r\n                uint256(10)**(decimalsTokenA - decimalsTokenB)\r\n            );\r\n        } else if (decimalsTokenA < decimalsTokenB) {\r\n            rateTokenA = rateTokenA.mul(\r\n                uint256(10)**(decimalsTokenB - decimalsTokenA)\r\n            );\r\n        }\r\n\r\n        return (rateTokenA, rateTokenB);\r\n    }\r\n\r\n    /**\r\n     * @dev returns the timestamp of the last price update the rates are returned as numerator (token1) and denominator\r\n     * (token2) for accuracy\r\n     *\r\n     * @return timestamp\r\n     */\r\n    function lastUpdateTime() public view returns (uint256) {\r\n        // returns the oldest timestamp between the two\r\n        uint256 timestampA = tokenAOracle.latestTimestamp();\r\n        uint256 timestampB = tokenBOracle.latestTimestamp();\r\n\r\n        return timestampA < timestampB ? timestampA : timestampB;\r\n    }\r\n\r\n    /**\r\n     * @dev returns both the rate and the timestamp of the last update in a single call (gas optimization)\r\n     *\r\n     * @param  _tokenA token to get the rate of 1 unit of\r\n     * @param  _tokenB token to get the rate of 1 `_tokenA` against\r\n     *\r\n     * @return numerator\r\n     * @return denominator\r\n     * @return timestamp of the last update\r\n     */\r\n    function latestRateAndUpdateTime(IERC20Token _tokenA, IERC20Token _tokenB)\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        (uint256 numerator, uint256 denominator) = latestRate(_tokenA, _tokenB);\r\n\r\n        return (numerator, denominator, lastUpdateTime());\r\n    }\r\n\r\n    /** @dev returns the decimals of a given token */\r\n    function decimals(IERC20Token _token) private view returns (uint8) {\r\n        if (_token == ETH_ADDRESS) {\r\n            return ETH_DECIMALS;\r\n        }\r\n\r\n        return _token.decimals();\r\n    }\r\n}\r\n\r\n/*\r\n    LiquidityPoolV2ConverterCustomFactory Factory\r\n*/\r\ncontract LiquidityPoolV2ConverterCustomFactory is ITypedConverterCustomFactory {\r\n    /**\r\n     * @dev returns the converter type the factory is associated with\r\n     *\r\n     * @return converter type\r\n     */\r\n    function converterType() public pure returns (uint16) {\r\n        return 2;\r\n    }\r\n\r\n    /**\r\n     * @dev creates a new price oracle\r\n     * note that the oracles must have the same common denominator (USD, ETH etc.)\r\n     *\r\n     * @param  _primaryReserveToken    primary reserve token address\r\n     * @param  _secondaryReserveToken  secondary reserve token address\r\n     * @param  _primaryReserveOracle   primary reserve oracle address\r\n     * @param  _secondaryReserveOracle secondary reserve oracle address\r\n     */\r\n    function createPriceOracle(\r\n        IERC20Token _primaryReserveToken,\r\n        IERC20Token _secondaryReserveToken,\r\n        IConsumerPriceOracle _primaryReserveOracle,\r\n        IConsumerPriceOracle _secondaryReserveOracle\r\n    ) public returns (IPriceOracle) {\r\n        return\r\n            new PriceOracle(\r\n                _primaryReserveToken,\r\n                _secondaryReserveToken,\r\n                _primaryReserveOracle,\r\n                _secondaryReserveOracle\r\n            );\r\n    }\r\n}\r\n",
      "file": "13_LiquidityPoolV2ConverterCustomFactory_fix.sol"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x1543eb54eac71cd7a3316aa73ba87070253d566c9572dbd37711a720384dc70a",
    "blockNumber": 2742589,
    "transactionHash": "0x8afec8744b1a0e3f00e2312188ec618dd9ef68cb55fa4e80723501ca9933d7ca",
    "timestamp": 1601482417
  }
}