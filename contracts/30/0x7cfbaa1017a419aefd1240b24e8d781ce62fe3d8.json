{
  "address": "0x7cfbaa1017a419aefd1240b24e8d781ce62fe3d8",
  "net": {
    "id": "30",
    "name": "RSK Mainnet"
  },
  "name": "LoanMaintenance",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    }
  },
  "version": "0.5.17+commit.d19bba13",
  "source": "/**\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0.\n */\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\ncontract LoanStruct {\n    struct Loan {\n        bytes32 id; // id of the loan\n        bytes32 loanParamsId; // the linked loan params id\n        bytes32 pendingTradesId; // the linked pending trades id\n        bool active; // if false, the loan has been fully closed\n        uint256 principal; // total borrowed amount outstanding\n        uint256 collateral; // total collateral escrowed for the loan\n        uint256 startTimestamp; // loan start time\n        uint256 endTimestamp; // for active loans, this is the expected loan end time, for in-active loans, is the actual (past) end time\n        uint256 startMargin; // initial margin when the loan opened\n        uint256 startRate; // reference rate when the loan opened for converting collateralToken to loanToken\n        address borrower; // borrower of this loan\n        address lender; // lender of this loan\n    }\n}\n\ncontract LoanParamsStruct {\n    struct LoanParams {\n        bytes32 id; // id of loan params object\n        bool active; // if false, this object has been disabled by the owner and can't be used for future loans\n        address owner; // owner of this object\n        address loanToken; // the token being loaned\n        address collateralToken; // the required collateral token\n        uint256 minInitialMargin; // the minimum allowed initial margin\n        uint256 maintenanceMargin; // an unhealthy loan when current margin is at or below this value\n        uint256 maxLoanTerm; // the maximum term for new loans (0 means there's no max term)\n    }\n}\n\ncontract OrderStruct {\n    struct Order {\n        uint256 lockedAmount; // escrowed amount waiting for a counterparty\n        uint256 interestRate; // interest rate defined by the creator of this order\n        uint256 minLoanTerm; // minimum loan term allowed\n        uint256 maxLoanTerm; // maximum loan term allowed\n        uint256 createdTimestamp; // timestamp when this order was created\n        uint256 expirationTimestamp; // timestamp when this order expires\n    }\n}\n\ncontract LenderInterestStruct {\n    struct LenderInterest {\n        uint256 principalTotal; // total borrowed amount outstanding of asset\n        uint256 owedPerDay; // interest owed per day for all loans of asset\n        uint256 owedTotal; // total interest owed for all loans of asset (assuming they go to full term)\n        uint256 paidTotal; // total interest paid so far for asset\n        uint256 updatedTimestamp; // last update\n    }\n}\n\ncontract LoanInterestStruct {\n    struct LoanInterest {\n        uint256 owedPerDay; // interest owed per day for loan\n        uint256 depositTotal; // total escrowed interest for loan\n        uint256 updatedTimestamp; // last update\n    }\n}\n\ncontract Objects is\n    LoanStruct,\n    LoanParamsStruct,\n    OrderStruct,\n    LenderInterestStruct,\n    LoanInterestStruct\n{}\n\n/**\n * @dev Library for managing loan sets\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * Include with `using EnumerableBytes32Set for EnumerableBytes32Set.Bytes32Set;`.\n *\n */\nlibrary EnumerableBytes32Set {\n    struct Bytes32Set {\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) index;\n        bytes32[] values;\n    }\n\n    /**\n     * @dev Add an address value to a set. O(1).\n     * Returns false if the value was already in the set.\n     */\n    function addAddress(Bytes32Set storage set, address addrvalue)\n        internal\n        returns (bool)\n    {\n        bytes32 value;\n        assembly {\n            value := addrvalue\n        }\n        return addBytes32(set, value);\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     * Returns false if the value was already in the set.\n     */\n    function addBytes32(Bytes32Set storage set, bytes32 value)\n        internal\n        returns (bool)\n    {\n        if (!contains(set, value)) {\n            set.index[value] = set.values.push(value);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes an address value from a set. O(1).\n     * Returns false if the value was not present in the set.\n     */\n    function removeAddress(Bytes32Set storage set, address addrvalue)\n        internal\n        returns (bool)\n    {\n        bytes32 value;\n        assembly {\n            value := addrvalue\n        }\n        return removeBytes32(set, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     * Returns false if the value was not present in the set.\n     */\n    function removeBytes32(Bytes32Set storage set, bytes32 value)\n        internal\n        returns (bool)\n    {\n        if (contains(set, value)) {\n            uint256 toDeleteIndex = set.index[value] - 1;\n            uint256 lastIndex = set.values.length - 1;\n\n            // If the element we're deleting is the last one, we can just remove it without doing a swap\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set.values[lastIndex];\n\n                // Move the last value to the index where the deleted value is\n                set.values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set.index[lastValue] = toDeleteIndex + 1; // All indexes are 1-based\n            }\n\n            // Delete the index entry for the deleted value\n            delete set.index[value];\n\n            // Delete the old entry for the moved value\n            set.values.pop();\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value)\n        internal\n        view\n        returns (bool)\n    {\n        return set.index[value] != 0;\n    }\n\n    /**\n     * @dev Returns an array with all values in the set. O(N).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n\n     * WARNING: This function may run out of gas on large sets: use {length} and\n     * {get} instead in these cases.\n     */\n    function enumerate(\n        Bytes32Set storage set,\n        uint256 start,\n        uint256 count\n    ) internal view returns (bytes32[] memory output) {\n        uint256 end = start + count;\n        require(end >= start, \"addition overflow\");\n        end = set.values.length < end ? set.values.length : end;\n        if (end == 0 || start >= end) {\n            return output;\n        }\n\n        output = new bytes32[](end - start);\n        for (uint256 i; i < end - start; i++) {\n            output[i] = set.values[i + start];\n        }\n        return output;\n    }\n\n    /**\n     * @dev Returns the number of elements on the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return set.values.length;\n    }\n\n    /** @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function get(Bytes32Set storage set, uint256 index)\n        internal\n        view\n        returns (bytes32)\n    {\n        return set.values[index];\n    }\n}\n\n/**\n * @title Helps contracts guard against reentrancy attacks.\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\n * @dev If you mark a function `nonReentrant`, you should also\n * mark it `external`.\n */\ncontract ReentrancyGuard {\n    /// @dev Constant for unlocked guard state - non-zero to prevent extra gas costs.\n    /// See: https://github.com/OpenZeppelin/openzeppelin-solidity/issues/1056\n    uint256 internal constant REENTRANCY_GUARD_FREE = 1;\n\n    /// @dev Constant for locked guard state\n    uint256 internal constant REENTRANCY_GUARD_LOCKED = 2;\n\n    /**\n     * @dev We use a single lock for the whole contract.\n     */\n    uint256 internal reentrancyLock = REENTRANCY_GUARD_FREE;\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * If you mark a function `nonReentrant`, you should also\n     * mark it `external`. Calling one `nonReentrant` function from\n     * another is not supported. Instead, you can implement a\n     * `private` function doing the actual work, and an `external`\n     * wrapper marked as `nonReentrant`.\n     */\n    modifier nonReentrant() {\n        require(reentrancyLock == REENTRANCY_GUARD_FREE, \"nonReentrant\");\n        reentrancyLock = REENTRANCY_GUARD_LOCKED;\n        _;\n        reentrancyLock = REENTRANCY_GUARD_FREE;\n    }\n}\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract ContextSovryn {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor() internal {}\n\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is ContextSovryn {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"unauthorized\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IWrbtc {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\ncontract IERC20Sovryn {\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n\n    function totalSupply() public view returns (uint256);\n\n    function balanceOf(address _who) public view returns (uint256);\n\n    function transfer(address _to, uint256 _value) public returns (bool);\n\n    function allowance(address _owner, address _spender)\n        public\n        view\n        returns (uint256);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public returns (bool);\n\n    function approve(address _spender, uint256 _value) public returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\ncontract IWrbtcERC20 is IWrbtc, IERC20Sovryn {}\n\ncontract State is Objects, ReentrancyGuard, Ownable {\n    using SafeMathSovryn for uint256;\n    using EnumerableBytes32Set for EnumerableBytes32Set.Bytes32Set;\n\n    address public priceFeeds; // handles asset reference price lookups\n    address public swapsImpl; // handles asset swaps using dex liquidity\n    address public sovrynSwapContractRegistryAddress; // contract registry address of the sovryn swap network\n\n    mapping(bytes4 => address) public logicTargets; // implementations of protocol functions\n\n    mapping(bytes32 => Loan) public loans; // loanId => Loan\n    mapping(bytes32 => LoanParams) public loanParams; // loanParamsId => LoanParams\n\n    mapping(address => mapping(bytes32 => Order)) public lenderOrders; // lender => orderParamsId => Order\n    mapping(address => mapping(bytes32 => Order)) public borrowerOrders; // borrower => orderParamsId => Order\n\n    mapping(bytes32 => mapping(address => bool)) public delegatedManagers; // loanId => delegated => approved\n\n    // Interest\n    mapping(address => mapping(address => LenderInterest))\n        public lenderInterest; // lender => loanToken => LenderInterest object\n    mapping(bytes32 => LoanInterest) public loanInterest; // loanId => LoanInterest object\n\n    // Internals\n    EnumerableBytes32Set.Bytes32Set internal logicTargetsSet; // implementations set\n    EnumerableBytes32Set.Bytes32Set internal activeLoansSet; // active loans set\n\n    mapping(address => EnumerableBytes32Set.Bytes32Set) internal lenderLoanSets; // lender loans set\n    mapping(address => EnumerableBytes32Set.Bytes32Set)\n        internal borrowerLoanSets; // borrow loans set\n    mapping(address => EnumerableBytes32Set.Bytes32Set)\n        internal userLoanParamSets; // user loan params set\n\n    address public feesController; // address controlling fee withdrawals\n\n    uint256 public lendingFeePercent = 10**19; // 10% fee                               // fee taken from lender interest payments\n    mapping(address => uint256) public lendingFeeTokensHeld; // total interest fees received and not withdrawn per asset\n    mapping(address => uint256) public lendingFeeTokensPaid; // total interest fees withdraw per asset (lifetime fees = lendingFeeTokensHeld + lendingFeeTokensPaid)\n\n    uint256 public tradingFeePercent = 15 * 10**16; // 0.15% fee                        // fee paid for each trade\n    mapping(address => uint256) public tradingFeeTokensHeld; // total trading fees received and not withdrawn per asset\n    mapping(address => uint256) public tradingFeeTokensPaid; // total trading fees withdraw per asset (lifetime fees = tradingFeeTokensHeld + tradingFeeTokensPaid)\n\n    uint256 public borrowingFeePercent = 9 * 10**16; // 0.09% fee                       // origination fee paid for each loan\n    mapping(address => uint256) public borrowingFeeTokensHeld; // total borrowing fees received and not withdrawn per asset\n    mapping(address => uint256) public borrowingFeeTokensPaid; // total borrowing fees withdraw per asset (lifetime fees = borrowingFeeTokensHeld + borrowingFeeTokensPaid)\n\n    uint256 public protocolTokenHeld; // current protocol token deposit balance\n    uint256 public protocolTokenPaid; // lifetime total payout of protocol token\n\n    uint256 public affiliateFeePercent = 30 * 10**18; // 30% fee share                  // fee share for affiliate program\n\n    uint256 public liquidationIncentivePercent = 5 * 10**18; // 5% collateral discount  // discount on collateral for liquidators\n\n    mapping(address => address) public loanPoolToUnderlying; // loanPool => underlying\n    mapping(address => address) public underlyingToLoanPool; // underlying => loanPool\n    EnumerableBytes32Set.Bytes32Set internal loanPoolsSet; // loan pools set\n\n    mapping(address => bool) public supportedTokens; // supported tokens for swaps\n\n    uint256 public maxDisagreement = 5 * 10**18; // % disagreement between swap rate and reference rate\n\n    uint256 public sourceBuffer = 10000; // used as buffer for swap source amount estimations\n\n    uint256 public maxSwapSize = 50 ether; // maximum support swap size in BTC\n\n    mapping(address => uint256) public borrowerNonce; // nonce per borrower. used for loan id creation.\n\n    uint256 public rolloverBaseReward = 16800000000000; // Rollover transaction costs around 0.0000168 rBTC, it is denominated in wRBTC\n    uint256 public rolloverFlexFeePercent = 0.1 ether; // 0.1%\n\n    IWrbtcERC20 public wrbtcToken;\n    address public protocolTokenAddress;\n\n    function _setTarget(bytes4 sig, address target) internal {\n        logicTargets[sig] = target;\n\n        if (target != address(0)) {\n            logicTargetsSet.addBytes32(bytes32(sig));\n        } else {\n            logicTargetsSet.removeBytes32(bytes32(sig));\n        }\n    }\n}\n\ncontract LoanOpeningsEvents {\n    // topic0: 0x7bd8cbb7ba34b33004f3deda0fd36c92fc0360acbd97843360037b467a538f90\n    event Borrow(\n        address indexed user,\n        address indexed lender,\n        bytes32 indexed loanId,\n        address loanToken,\n        address collateralToken,\n        uint256 newPrincipal,\n        uint256 newCollateral,\n        uint256 interestRate,\n        uint256 interestDuration,\n        uint256 collateralToLoanRate,\n        uint256 currentMargin\n    );\n\n    // topic0: 0xf640c1cfe1a912a0b0152b5a542e5c2403142eed75b06cde526cee54b1580e5c\n    event Trade(\n        address indexed user,\n        address indexed lender,\n        bytes32 indexed loanId,\n        address collateralToken,\n        address loanToken,\n        uint256 positionSize,\n        uint256 borrowedAmount,\n        uint256 interestRate,\n        uint256 settlementDate,\n        uint256 entryPrice, // one unit of collateralToken, denominated in loanToken\n        uint256 entryLeverage,\n        uint256 currentLeverage\n    );\n\n    // topic0: 0x0eef4f90457a741c97d76fcf13fa231fefdcc7649bdb3cb49157c37111c98433\n    event DelegatedManagerSet(\n        bytes32 indexed loanId,\n        address indexed delegator,\n        address indexed delegated,\n        bool isActive\n    );\n}\n\ncontract LoanMaintenanceEvents {\n    event DepositCollateral(bytes32 loanId, uint256 depositAmount);\n}\n\ncontract VaultController is State {\n    using SafeERC20 for IERC20Sovryn;\n\n    event VaultDeposit(\n        address indexed asset,\n        address indexed from,\n        uint256 amount\n    );\n    event VaultWithdraw(\n        address indexed asset,\n        address indexed to,\n        uint256 amount\n    );\n\n    function vaultEtherDeposit(address from, uint256 value) internal {\n        IWrbtcERC20 _wrbtcToken = wrbtcToken;\n        _wrbtcToken.deposit.value(value)();\n\n        emit VaultDeposit(address(_wrbtcToken), from, value);\n    }\n\n    function vaultEtherWithdraw(address to, uint256 value) internal {\n        if (value != 0) {\n            IWrbtcERC20 _wrbtcToken = wrbtcToken;\n            uint256 balance = address(this).balance;\n            if (value > balance) {\n                _wrbtcToken.withdraw(value - balance);\n            }\n            Address.sendValue(address(uint160(to)), value);\n\n            emit VaultWithdraw(address(_wrbtcToken), to, value);\n        }\n    }\n\n    function vaultDeposit(\n        address token,\n        address from,\n        uint256 value\n    ) internal {\n        if (value != 0) {\n            IERC20Sovryn(token).safeTransferFrom(from, address(this), value);\n\n            emit VaultDeposit(token, from, value);\n        }\n    }\n\n    function vaultWithdraw(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        if (value != 0) {\n            IERC20Sovryn(token).safeTransfer(to, value);\n\n            emit VaultWithdraw(token, to, value);\n        }\n    }\n\n    function vaultTransfer(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        if (value != 0) {\n            if (from == address(this)) {\n                IERC20Sovryn(token).safeTransfer(to, value);\n            } else {\n                IERC20Sovryn(token).safeTransferFrom(from, to, value);\n            }\n        }\n    }\n\n    function vaultApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        if (\n            value != 0 && IERC20Sovryn(token).allowance(address(this), to) != 0\n        ) {\n            IERC20Sovryn(token).safeApprove(to, 0);\n        }\n        IERC20Sovryn(token).safeApprove(to, value);\n    }\n}\n\ncontract LiquidationHelper is State {\n    /**\n     * computes how much needs to be liquidated in order to restore the desired margin (maintenance + 5%)\n     * @param principal total borrowed amount (in loan tokens)\n     * @param collateral the collateral (in collateral tokens)\n     * @param currentMargin the current margin\n     * @param maintenanceMargin the maintenance (minimum) margin\n     * @param collateralToLoanRate the exchange rate from collateral to loan tokens\n     * */\n    function _getLiquidationAmounts(\n        uint256 principal,\n        uint256 collateral,\n        uint256 currentMargin,\n        uint256 maintenanceMargin,\n        uint256 collateralToLoanRate\n    )\n        internal\n        view\n        returns (\n            uint256 maxLiquidatable,\n            uint256 maxSeizable,\n            uint256 incentivePercent\n        )\n    {\n        incentivePercent = liquidationIncentivePercent;\n        if (currentMargin > maintenanceMargin || collateralToLoanRate == 0) {\n            return (maxLiquidatable, maxSeizable, incentivePercent);\n        } else if (currentMargin <= incentivePercent) {\n            return (principal, collateral, currentMargin);\n        }\n\n        uint256 desiredMargin = maintenanceMargin.add(5 ether); // 5 percentage points above maintenance\n\n        // maxLiquidatable = ((1 + desiredMargin)*principal - collateralToLoanRate*collateral) / (desiredMargin - 0.05)\n        maxLiquidatable = desiredMargin.add(10**20).mul(principal).div(10**20);\n        maxLiquidatable = maxLiquidatable.sub(\n            collateral.mul(collateralToLoanRate).div(10**18)\n        );\n        maxLiquidatable = maxLiquidatable.mul(10**20).div(\n            desiredMargin.sub(incentivePercent)\n        );\n        if (maxLiquidatable > principal) {\n            maxLiquidatable = principal;\n        }\n\n        // maxSeizable = maxLiquidatable * (1 + incentivePercent) / collateralToLoanRate\n        maxSeizable = maxLiquidatable.mul(incentivePercent.add(10**20));\n        maxSeizable = maxSeizable.div(collateralToLoanRate).div(100);\n        if (maxSeizable > collateral) {\n            maxSeizable = collateral;\n        }\n\n        return (maxLiquidatable, maxSeizable, incentivePercent);\n    }\n}\n\ninterface IPriceFeeds {\n    function queryRate(address sourceToken, address destToken)\n        external\n        view\n        returns (uint256 rate, uint256 precision);\n\n    function queryPrecision(address sourceToken, address destToken)\n        external\n        view\n        returns (uint256 precision);\n\n    function queryReturn(\n        address sourceToken,\n        address destToken,\n        uint256 sourceAmount\n    ) external view returns (uint256 destAmount);\n\n    function checkPriceDisagreement(\n        address sourceToken,\n        address destToken,\n        uint256 sourceAmount,\n        uint256 destAmount,\n        uint256 maxSlippage\n    ) external view returns (uint256 sourceToDestSwapRate);\n\n    function amountInEth(address Token, uint256 amount)\n        external\n        view\n        returns (uint256 ethAmount);\n\n    function getMaxDrawdown(\n        address loanToken,\n        address collateralToken,\n        uint256 loanAmount,\n        uint256 collateralAmount,\n        uint256 maintenanceMargin\n    ) external view returns (uint256);\n\n    function getCurrentMarginAndCollateralSize(\n        address loanToken,\n        address collateralToken,\n        uint256 loanAmount,\n        uint256 collateralAmount\n    )\n        external\n        view\n        returns (uint256 currentMargin, uint256 collateralInEthAmount);\n\n    function getCurrentMargin(\n        address loanToken,\n        address collateralToken,\n        uint256 loanAmount,\n        uint256 collateralAmount\n    )\n        external\n        view\n        returns (uint256 currentMargin, uint256 collateralToLoanRate);\n\n    function shouldLiquidate(\n        address loanToken,\n        address collateralToken,\n        uint256 loanAmount,\n        uint256 collateralAmount,\n        uint256 maintenanceMargin\n    ) external view returns (bool);\n\n    function getFastGasPrice(address payToken) external view returns (uint256);\n}\n\ncontract SwapsEvents {\n    event LoanSwap(\n        bytes32 indexed loanId,\n        address indexed sourceToken,\n        address indexed destToken,\n        address borrower,\n        uint256 sourceAmount,\n        uint256 destAmount\n    );\n\n    event ExternalSwap(\n        address indexed user,\n        address indexed sourceToken,\n        address indexed destToken,\n        uint256 sourceAmount,\n        uint256 destAmount\n    );\n}\n\ncontract FeesEvents {\n    event PayLendingFee(\n        address indexed payer,\n        address indexed token,\n        uint256 amount\n    );\n\n    event PayTradingFee(\n        address indexed payer,\n        address indexed token,\n        bytes32 indexed loanId,\n        uint256 amount\n    );\n\n    event PayBorrowingFee(\n        address indexed payer,\n        address indexed token,\n        bytes32 indexed loanId,\n        uint256 amount\n    );\n\n    event EarnReward(\n        address indexed receiver,\n        address indexed token,\n        bytes32 indexed loanId,\n        uint256 amount\n    );\n}\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathSovryn {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n\n    function min256(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return _a < _b ? _a : _b;\n    }\n}\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract's constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * IMPORTANT: It is unsafe to assume that an address for which this\n     * function returns false is an externally-owned account (EOA) and not a\n     * contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n\n\n            bytes32 accountHash\n         = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            codehash := extcodehash(account)\n        }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account)\n        internal\n        pure\n        returns (address payable)\n    {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance >= amount,\n            \"Address: insufficient balance\"\n        );\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMathSovryn for uint256;\n    using Address for address;\n\n    function safeTransfer(\n        IERC20Sovryn token,\n        address to,\n        uint256 value\n    ) internal {\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20Sovryn token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    function safeApprove(\n        IERC20Sovryn token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Sovryn token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(\n            value\n        );\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Sovryn token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\n            value,\n            \"SafeERC20: decreased allowance below zero\"\n        );\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20Sovryn token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) {\n            // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\n\ncontract ProtocolTokenUser is State {\n    using SafeERC20 for IERC20Sovryn;\n\n    function _withdrawProtocolToken(address receiver, uint256 amount)\n        internal\n        returns (address, bool)\n    {\n        uint256 withdrawAmount = amount;\n\n        uint256 tokenBalance = protocolTokenHeld;\n        if (withdrawAmount > tokenBalance) {\n            withdrawAmount = tokenBalance;\n        }\n        if (withdrawAmount == 0) {\n            return (protocolTokenAddress, false);\n        }\n\n        protocolTokenHeld = tokenBalance.sub(withdrawAmount);\n\n        IERC20Sovryn(protocolTokenAddress).safeTransfer(\n            receiver,\n            withdrawAmount\n        );\n\n        return (protocolTokenAddress, true);\n    }\n}\n\ncontract FeesHelper is State, ProtocolTokenUser, FeesEvents {\n    using SafeERC20 for IERC20Sovryn;\n\n    // calculate trading fee\n    function _getTradingFee(uint256 feeTokenAmount)\n        internal\n        view\n        returns (uint256)\n    {\n        return feeTokenAmount.mul(tradingFeePercent).div(10**20);\n    }\n\n    // calculate loan origination fee\n    function _getBorrowingFee(uint256 feeTokenAmount)\n        internal\n        view\n        returns (uint256)\n    {\n        return feeTokenAmount.mul(borrowingFeePercent).div(10**20);\n    }\n\n    // settle trading fee\n    function _payTradingFee(\n        address user,\n        bytes32 loanId,\n        address feeToken,\n        uint256 tradingFee\n    ) internal {\n        if (tradingFee != 0) {\n            tradingFeeTokensHeld[feeToken] = tradingFeeTokensHeld[feeToken].add(\n                tradingFee\n            );\n\n            emit PayTradingFee(user, feeToken, loanId, tradingFee);\n\n            _payFeeReward(user, loanId, feeToken, tradingFee);\n        }\n    }\n\n    // settle loan origination fee\n    function _payBorrowingFee(\n        address user,\n        bytes32 loanId,\n        address feeToken,\n        uint256 borrowingFee\n    ) internal {\n        if (borrowingFee != 0) {\n            borrowingFeeTokensHeld[feeToken] = borrowingFeeTokensHeld[feeToken]\n                .add(borrowingFee);\n\n            emit PayBorrowingFee(user, feeToken, loanId, borrowingFee);\n\n            _payFeeReward(user, loanId, feeToken, borrowingFee);\n        }\n    }\n\n    // settle lender (interest) fee\n    function _payLendingFee(\n        address user,\n        address feeToken,\n        uint256 lendingFee\n    ) internal {\n        if (lendingFee != 0) {\n            lendingFeeTokensHeld[feeToken] = lendingFeeTokensHeld[feeToken].add(\n                lendingFee\n            );\n\n            emit PayLendingFee(user, feeToken, lendingFee);\n\n            //// NOTE: Lenders do not receive a fee reward ////\n        }\n    }\n\n    // settles and pays borrowers based on the fees generated by their interest payments\n    function _settleFeeRewardForInterestExpense(\n        LoanInterest storage loanInterestLocal,\n        bytes32 loanId,\n        address feeToken,\n        address user,\n        uint256 interestTime\n    ) internal {\n        // this represents the fee generated by a borrower's interest payment\n        uint256 interestExpenseFee = interestTime\n            .sub(loanInterestLocal.updatedTimestamp)\n            .mul(loanInterestLocal.owedPerDay)\n            .div(86400)\n            .mul(lendingFeePercent)\n            .div(10**20);\n\n        loanInterestLocal.updatedTimestamp = interestTime;\n\n        if (interestExpenseFee != 0) {\n            _payFeeReward(user, loanId, feeToken, interestExpenseFee);\n        }\n    }\n\n    // pay potocolToken reward to user\n    function _payFeeReward(\n        address user,\n        bytes32 loanId,\n        address feeToken,\n        uint256 feeAmount\n    ) internal {\n        uint256 rewardAmount;\n        address _priceFeeds = priceFeeds;\n        (bool success, bytes memory data) = _priceFeeds.staticcall(\n            abi.encodeWithSelector(\n                IPriceFeeds(_priceFeeds).queryReturn.selector,\n                feeToken,\n                protocolTokenAddress, // price rewards using BZRX price rather than vesting token price\n                feeAmount / 2 // 50% of fee value\n            )\n        );\n        assembly {\n            if eq(success, 1) {\n                rewardAmount := mload(add(data, 32))\n            }\n        }\n\n        if (rewardAmount != 0) {\n            address rewardToken;\n            (rewardToken, success) = _withdrawProtocolToken(user, rewardAmount);\n            if (success) {\n                protocolTokenPaid = protocolTokenPaid.add(rewardAmount);\n\n                emit EarnReward(user, rewardToken, loanId, rewardAmount);\n            }\n        }\n    }\n}\n\ncontract InterestUser is VaultController, FeesHelper {\n    using SafeERC20 for IERC20Sovryn;\n\n    function _payInterest(address lender, address interestToken) internal {\n\n            LenderInterest storage lenderInterestLocal\n         = lenderInterest[lender][interestToken];\n\n        uint256 interestOwedNow = 0;\n        if (\n            lenderInterestLocal.owedPerDay != 0 &&\n            lenderInterestLocal.updatedTimestamp != 0\n        ) {\n            interestOwedNow = block\n                .timestamp\n                .sub(lenderInterestLocal.updatedTimestamp)\n                .mul(lenderInterestLocal.owedPerDay)\n                .div(86400);\n\n            if (interestOwedNow > lenderInterestLocal.owedTotal)\n                interestOwedNow = lenderInterestLocal.owedTotal;\n\n            if (interestOwedNow != 0) {\n                lenderInterestLocal.paidTotal = lenderInterestLocal\n                    .paidTotal\n                    .add(interestOwedNow);\n                lenderInterestLocal.owedTotal = lenderInterestLocal\n                    .owedTotal\n                    .sub(interestOwedNow);\n\n                _payInterestTransfer(lender, interestToken, interestOwedNow);\n            }\n        }\n\n        lenderInterestLocal.updatedTimestamp = block.timestamp;\n    }\n\n    function _payInterestTransfer(\n        address lender,\n        address interestToken,\n        uint256 interestOwedNow\n    ) internal {\n        uint256 lendingFee = interestOwedNow.mul(lendingFeePercent).div(10**20);\n\n        _payLendingFee(lender, interestToken, lendingFee);\n\n        // transfers the interest to the lender, less the interest fee\n        vaultWithdraw(interestToken, lender, interestOwedNow.sub(lendingFee));\n    }\n}\n\ninterface ISwapsImpl {\n    function internalSwap(\n        address sourceTokenAddress,\n        address destTokenAddress,\n        address receiverAddress,\n        address returnToSenderAddress,\n        uint256 minSourceTokenAmount,\n        uint256 maxSourceTokenAmount,\n        uint256 requiredDestTokenAmount\n    )\n        external\n        returns (\n            uint256 destTokenAmountReceived,\n            uint256 sourceTokenAmountUsed\n        );\n\n    function internalExpectedRate(\n        address sourceTokenAddress,\n        address destTokenAddress,\n        uint256 sourceTokenAmount\n    ) external view returns (uint256);\n}\n\ncontract SwapsUser is State, SwapsEvents, FeesHelper {\n    function _loanSwap(\n        bytes32 loanId,\n        address sourceToken,\n        address destToken,\n        address user,\n        uint256 minSourceTokenAmount,\n        uint256 maxSourceTokenAmount,\n        uint256 requiredDestTokenAmount,\n        bool bypassFee,\n        bytes memory loanDataBytes\n    )\n        internal\n        returns (\n            uint256 destTokenAmountReceived,\n            uint256 sourceTokenAmountUsed,\n            uint256 sourceToDestSwapRate\n        )\n    {\n        (destTokenAmountReceived, sourceTokenAmountUsed) = _swapsCall(\n            [\n                sourceToken,\n                destToken,\n                address(this), // receiver\n                address(this), // returnToSender\n                user\n            ],\n            [\n                minSourceTokenAmount,\n                maxSourceTokenAmount,\n                requiredDestTokenAmount\n            ],\n            loanId,\n            bypassFee,\n            loanDataBytes\n        );\n\n        // will revert if swap size too large\n        _checkSwapSize(sourceToken, sourceTokenAmountUsed);\n\n        // will revert if disagreement found\n        sourceToDestSwapRate = IPriceFeeds(priceFeeds).checkPriceDisagreement(\n            sourceToken,\n            destToken,\n            sourceTokenAmountUsed,\n            destTokenAmountReceived,\n            maxDisagreement\n        );\n\n        emit LoanSwap(\n            loanId,\n            sourceToken,\n            destToken,\n            user,\n            sourceTokenAmountUsed,\n            destTokenAmountReceived\n        );\n    }\n\n    function _swapsCall(\n        address[5] memory addrs,\n        uint256[3] memory vals,\n        bytes32 loanId,\n        bool miscBool, // bypassFee\n        bytes memory loanDataBytes\n    ) internal returns (uint256, uint256) {\n        //addrs[0]: sourceToken\n        //addrs[1]: destToken\n        //addrs[2]: receiver\n        //addrs[3]: returnToSender\n        //addrs[4]: user\n        //vals[0]:  minSourceTokenAmount\n        //vals[1]:  maxSourceTokenAmount\n        //vals[2]:  requiredDestTokenAmount\n\n        require(\n            vals[0] != 0 || vals[1] != 0,\n            \"min or max source token amount needs to be set\"\n        );\n\n        if (vals[1] == 0) {\n            vals[1] = vals[0];\n        }\n        require(vals[0] <= vals[1], \"sourceAmount larger than max\");\n\n        uint256 destTokenAmountReceived;\n        uint256 sourceTokenAmountUsed;\n\n        uint256 tradingFee;\n        if (!miscBool) {\n            // bypassFee\n            if (vals[2] == 0) {\n                // condition: vals[0] will always be used as sourceAmount\n\n                tradingFee = _getTradingFee(vals[0]);\n                if (tradingFee != 0) {\n                    _payTradingFee(\n                        addrs[4], // user\n                        loanId,\n                        addrs[0], // sourceToken\n                        tradingFee\n                    );\n\n                    vals[0] = vals[0].sub(tradingFee);\n                }\n            } else {\n                // condition: unknown sourceAmount will be used\n\n                tradingFee = _getTradingFee(vals[2]);\n\n                if (tradingFee != 0) {\n                    vals[2] = vals[2].add(tradingFee);\n                }\n            }\n        }\n\n        if (loanDataBytes.length == 0) {\n            (\n                destTokenAmountReceived,\n                sourceTokenAmountUsed\n            ) = _swapsCall_internal(addrs, vals);\n        } else {\n            revert(\"invalid state\");\n            /*\n            //keccak256(\"Swaps_SwapsImplZeroX\")\n            address swapsImplZeroX;\n            assembly {\n                swapsImplZeroX := sload(0x129a6cb350d136ca8d0881f83a9141afd5dc8b3c99057f06df01ab75943df952)\n            }\n            */\n            //revert(string(loanDataBytes));\n            /*\n            vaultWithdraw(\n                addrs[0], // sourceToken\n                address(zeroXConnector),\n                sourceTokenAmount\n            );\n            (destTokenAmountReceived, sourceTokenAmountUsed) = zeroXConnector.swap.value(msg.value)(\n                addrs[0], // sourceToken\n                addrs[1], // destToken\n                addrs[2], // receiver\n                sourceTokenAmount,\n                0,\n                loanDataBytes\n            );\n            */\n        }\n\n        if (vals[2] == 0) {\n            // there's no minimum destTokenAmount, but all of vals[0] (minSourceTokenAmount) must be spent\n            require(sourceTokenAmountUsed == vals[0], \"swap too large to fill\");\n\n            if (tradingFee != 0) {\n                sourceTokenAmountUsed = sourceTokenAmountUsed.add(tradingFee);\n            }\n        } else {\n            // there's a minimum destTokenAmount required, but sourceTokenAmountUsed won't be greater than vals[1] (maxSourceTokenAmount)\n            require(sourceTokenAmountUsed <= vals[1], \"swap fill too large\");\n            require(\n                destTokenAmountReceived >= vals[2],\n                \"insufficient swap liquidity\"\n            );\n\n            if (tradingFee != 0) {\n                _payTradingFee(\n                    addrs[4], // user\n                    loanId, // loanId,\n                    addrs[1], // destToken\n                    tradingFee\n                );\n\n                destTokenAmountReceived = destTokenAmountReceived.sub(\n                    tradingFee\n                );\n            }\n        }\n\n        return (destTokenAmountReceived, sourceTokenAmountUsed);\n    }\n\n    function _swapsCall_internal(\n        address[5] memory addrs,\n        uint256[3] memory vals\n    )\n        internal\n        returns (uint256 destTokenAmountReceived, uint256 sourceTokenAmountUsed)\n    {\n        bytes memory data = abi.encodeWithSelector(\n            ISwapsImpl(swapsImpl).internalSwap.selector,\n            addrs[0], // sourceToken\n            addrs[1], // destToken\n            addrs[2], // receiverAddress\n            addrs[3], // returnToSenderAddress\n            vals[0], // minSourceTokenAmount\n            vals[1], // maxSourceTokenAmount\n            vals[2] // requiredDestTokenAmount\n        );\n\n        bool success;\n        (success, data) = swapsImpl.delegatecall(data);\n        require(success, \"swap failed\");\n\n        assembly {\n            destTokenAmountReceived := mload(add(data, 32))\n            sourceTokenAmountUsed := mload(add(data, 64))\n        }\n    }\n\n    function _swapsExpectedReturn(\n        address sourceToken,\n        address destToken,\n        uint256 sourceTokenAmount\n    ) internal view returns (uint256) {\n        uint256 tradingFee = _getTradingFee(sourceTokenAmount);\n        if (tradingFee != 0) {\n            sourceTokenAmount = sourceTokenAmount.sub(tradingFee);\n        }\n\n        uint256 sourceToDestRate = ISwapsImpl(swapsImpl).internalExpectedRate(\n            sourceToken,\n            destToken,\n            sourceTokenAmount\n        );\n        uint256 sourceToDestPrecision = IPriceFeeds(priceFeeds).queryPrecision(\n            sourceToken,\n            destToken\n        );\n\n        return\n            sourceTokenAmount.mul(sourceToDestRate).div(sourceToDestPrecision);\n    }\n\n    function _checkSwapSize(address tokenAddress, uint256 amount)\n        internal\n        view\n    {\n        uint256 _maxSwapSize = maxSwapSize;\n        if (_maxSwapSize != 0) {\n            uint256 amountInEth;\n            if (tokenAddress == address(wrbtcToken)) {\n                amountInEth = amount;\n            } else {\n                amountInEth = IPriceFeeds(priceFeeds).amountInEth(\n                    tokenAddress,\n                    amount\n                );\n            }\n            require(amountInEth <= _maxSwapSize, \"swap too large\");\n        }\n    }\n}\n\ncontract LoanMaintenance is\n    LoanOpeningsEvents,\n    LoanMaintenanceEvents,\n    VaultController,\n    InterestUser,\n    SwapsUser,\n    LiquidationHelper\n{\n    struct LoanReturnData {\n        bytes32 loanId;\n        address loanToken;\n        address collateralToken;\n        uint256 principal;\n        uint256 collateral;\n        uint256 interestOwedPerDay;\n        uint256 interestDepositRemaining;\n        uint256 startRate; // collateralToLoanRate\n        uint256 startMargin;\n        uint256 maintenanceMargin;\n        uint256 currentMargin;\n        uint256 maxLoanTerm;\n        uint256 endTimestamp;\n        uint256 maxLiquidatable;\n        uint256 maxSeizable;\n    }\n\n    constructor() public {}\n\n    function() external {\n        revert(\"fallback not allowed\");\n    }\n\n    function initialize(address target) external onlyOwner {\n        _setTarget(this.depositCollateral.selector, target);\n        _setTarget(this.withdrawCollateral.selector, target);\n        _setTarget(this.withdrawAccruedInterest.selector, target);\n        _setTarget(this.extendLoanDuration.selector, target);\n        _setTarget(this.reduceLoanDuration.selector, target);\n        _setTarget(this.getLenderInterestData.selector, target);\n        _setTarget(this.getLoanInterestData.selector, target);\n        _setTarget(this.getUserLoans.selector, target);\n        _setTarget(this.getLoan.selector, target);\n        _setTarget(this.getActiveLoans.selector, target);\n    }\n\n    function depositCollateral(\n        bytes32 loanId,\n        uint256 depositAmount // must match msg.value if ether is sent\n    ) external payable nonReentrant {\n        require(depositAmount != 0, \"depositAmount is 0\");\n        Loan storage loanLocal = loans[loanId];\n        LoanParams storage loanParamsLocal = loanParams[loanLocal.loanParamsId];\n\n        require(loanLocal.active, \"loan is closed\");\n        require(\n            msg.value == 0 ||\n                loanParamsLocal.collateralToken == address(wrbtcToken),\n            \"wrong asset sent\"\n        );\n\n        loanLocal.collateral = loanLocal.collateral.add(depositAmount);\n\n        if (msg.value == 0) {\n            vaultDeposit(\n                loanParamsLocal.collateralToken,\n                msg.sender,\n                depositAmount\n            );\n        } else {\n            require(msg.value == depositAmount, \"ether deposit mismatch\");\n            vaultEtherDeposit(msg.sender, msg.value);\n        }\n\n        emit DepositCollateral(loanId, depositAmount);\n    }\n\n    function withdrawCollateral(\n        bytes32 loanId,\n        address receiver,\n        uint256 withdrawAmount\n    ) external nonReentrant returns (uint256 actualWithdrawAmount) {\n        require(withdrawAmount != 0, \"withdrawAmount is 0\");\n        Loan storage loanLocal = loans[loanId];\n        LoanParams storage loanParamsLocal = loanParams[loanLocal.loanParamsId];\n\n        require(loanLocal.active, \"loan is closed\");\n        require(\n            msg.sender == loanLocal.borrower ||\n                delegatedManagers[loanLocal.id][msg.sender],\n            \"unauthorized\"\n        );\n\n        uint256 maxDrawdown = IPriceFeeds(priceFeeds).getMaxDrawdown(\n            loanParamsLocal.loanToken,\n            loanParamsLocal.collateralToken,\n            loanLocal.principal,\n            loanLocal.collateral,\n            loanParamsLocal.maintenanceMargin\n        );\n\n        if (withdrawAmount > maxDrawdown) {\n            actualWithdrawAmount = maxDrawdown;\n        } else {\n            actualWithdrawAmount = withdrawAmount;\n        }\n\n        loanLocal.collateral = loanLocal.collateral.sub(actualWithdrawAmount);\n\n        if (loanParamsLocal.collateralToken == address(wrbtcToken)) {\n            vaultEtherWithdraw(receiver, actualWithdrawAmount);\n        } else {\n            vaultWithdraw(\n                loanParamsLocal.collateralToken,\n                receiver,\n                actualWithdrawAmount\n            );\n        }\n    }\n\n    function withdrawAccruedInterest(address loanToken) external {\n        // pay outstanding interest to lender\n        _payInterest(\n            msg.sender, // lender\n            loanToken\n        );\n    }\n\n    function extendLoanDuration(\n        bytes32 loanId,\n        uint256 depositAmount,\n        bool useCollateral,\n        bytes calldata // for future use /*loanDataBytes*/\n    ) external payable nonReentrant returns (uint256 secondsExtended) {\n        require(depositAmount != 0, \"depositAmount is 0\");\n        Loan storage loanLocal = loans[loanId];\n        LoanParams storage loanParamsLocal = loanParams[loanLocal.loanParamsId];\n\n        require(loanLocal.active, \"loan is closed\");\n        require(\n            !useCollateral ||\n                msg.sender == loanLocal.borrower ||\n                delegatedManagers[loanLocal.id][msg.sender],\n            \"unauthorized\"\n        );\n        require(loanParamsLocal.maxLoanTerm == 0, \"indefinite-term only\");\n        require(\n            msg.value == 0 ||\n                (!useCollateral &&\n                    loanParamsLocal.loanToken == address(wrbtcToken)),\n            \"wrong asset sent\"\n        );\n\n        // pay outstanding interest to lender\n        _payInterest(loanLocal.lender, loanParamsLocal.loanToken);\n\n        LoanInterest storage loanInterestLocal = loanInterest[loanLocal.id];\n\n        _settleFeeRewardForInterestExpense(\n            loanInterestLocal,\n            loanLocal.id,\n            loanParamsLocal.loanToken,\n            loanLocal.borrower,\n            block.timestamp\n        );\n\n        // Handle back interest: calculates interest owned since the loan endtime passed but the loan remained open\n        uint256 backInterestOwed;\n        if (block.timestamp > loanLocal.endTimestamp) {\n            backInterestOwed = block.timestamp.sub(loanLocal.endTimestamp);\n            backInterestOwed = backInterestOwed.mul(\n                loanInterestLocal.owedPerDay\n            );\n            backInterestOwed = backInterestOwed.div(86400);\n\n            require(\n                depositAmount > backInterestOwed,\n                \"deposit cannot cover back interest\"\n            );\n        }\n\n        // deposit interest\n        if (useCollateral) {\n            _doCollateralSwap(loanLocal, loanParamsLocal, depositAmount);\n        } else {\n            if (msg.value == 0) {\n                vaultDeposit(\n                    loanParamsLocal.loanToken,\n                    msg.sender,\n                    depositAmount\n                );\n            } else {\n                require(msg.value == depositAmount, \"ether deposit mismatch\");\n                vaultEtherDeposit(msg.sender, msg.value);\n            }\n        }\n\n        if (backInterestOwed != 0) {\n            depositAmount = depositAmount.sub(backInterestOwed);\n\n            // pay out backInterestOwed\n            _payInterestTransfer(\n                loanLocal.lender,\n                loanParamsLocal.loanToken,\n                backInterestOwed\n            );\n        }\n\n        secondsExtended = depositAmount.mul(86400).div(\n            loanInterestLocal.owedPerDay\n        );\n\n        loanLocal.endTimestamp = loanLocal.endTimestamp.add(secondsExtended);\n\n        require(loanLocal.endTimestamp > block.timestamp, \"loan too short\");\n\n        uint256 maxDuration = loanLocal.endTimestamp.sub(block.timestamp);\n\n        // loan term has to at least be greater than one hour\n        require(maxDuration > 3600, \"loan too short\");\n\n        loanInterestLocal.depositTotal = loanInterestLocal.depositTotal.add(\n            depositAmount\n        );\n\n        lenderInterest[loanLocal.lender][loanParamsLocal.loanToken]\n            .owedTotal = lenderInterest[loanLocal.lender][loanParamsLocal\n            .loanToken]\n            .owedTotal\n            .add(depositAmount);\n    }\n\n    function reduceLoanDuration(\n        bytes32 loanId,\n        address receiver,\n        uint256 withdrawAmount\n    ) external nonReentrant returns (uint256 secondsReduced) {\n        require(withdrawAmount != 0, \"withdrawAmount is 0\");\n        Loan storage loanLocal = loans[loanId];\n        LoanParams storage loanParamsLocal = loanParams[loanLocal.loanParamsId];\n\n        require(loanLocal.active, \"loan is closed\");\n        require(\n            msg.sender == loanLocal.borrower ||\n                delegatedManagers[loanLocal.id][msg.sender],\n            \"unauthorized\"\n        );\n        require(loanParamsLocal.maxLoanTerm == 0, \"indefinite-term only\");\n        require(\n            loanLocal.endTimestamp > block.timestamp,\n            \"loan term has ended\"\n        );\n\n        // pay outstanding interest to lender\n        _payInterest(loanLocal.lender, loanParamsLocal.loanToken);\n\n        LoanInterest storage loanInterestLocal = loanInterest[loanLocal.id];\n\n        _settleFeeRewardForInterestExpense(\n            loanInterestLocal,\n            loanLocal.id,\n            loanParamsLocal.loanToken,\n            loanLocal.borrower,\n            block.timestamp\n        );\n\n        uint256 interestDepositRemaining = loanLocal\n            .endTimestamp\n            .sub(block.timestamp)\n            .mul(loanInterestLocal.owedPerDay)\n            .div(86400);\n        require(\n            withdrawAmount < interestDepositRemaining,\n            \"withdraw amount too high\"\n        );\n\n        // withdraw interest\n        if (loanParamsLocal.loanToken == address(wrbtcToken)) {\n            vaultEtherWithdraw(receiver, withdrawAmount);\n        } else {\n            vaultWithdraw(loanParamsLocal.loanToken, receiver, withdrawAmount);\n        }\n\n        secondsReduced = withdrawAmount.mul(86400).div(\n            loanInterestLocal.owedPerDay\n        );\n\n        require(loanLocal.endTimestamp > secondsReduced, \"loan too short\");\n\n        loanLocal.endTimestamp = loanLocal.endTimestamp.sub(secondsReduced);\n\n        require(loanLocal.endTimestamp > block.timestamp, \"loan too short\");\n\n        uint256 maxDuration = loanLocal.endTimestamp.sub(block.timestamp);\n\n        // loan term has to at least be greater than one hour\n        require(maxDuration > 3600, \"loan too short\");\n\n        loanInterestLocal.depositTotal = loanInterestLocal.depositTotal.sub(\n            withdrawAmount\n        );\n\n        lenderInterest[loanLocal.lender][loanParamsLocal.loanToken]\n            .owedTotal = lenderInterest[loanLocal.lender][loanParamsLocal\n            .loanToken]\n            .owedTotal\n            .sub(withdrawAmount);\n    }\n\n    /// @dev Gets current lender interest data totals for all loans with a specific oracle and interest token\n    /// @param lender The lender address\n    /// @param loanToken The loan token address\n    /// @return interestPaid The total amount of interest that has been paid to a lender so far\n    /// @return interestPaidDate The date of the last interest pay out, or 0 if no interest has been withdrawn yet\n    /// @return interestOwedPerDay The amount of interest the lender is earning per day\n    /// @return interestUnPaid The total amount of interest the lender is owned and not yet withdrawn\n    /// @return interestFeePercent The fee retained by the protocol before interest is paid to the lender\n    /// @return principalTotal The total amount of outstading principal the lender has loaned\n    function getLenderInterestData(address lender, address loanToken)\n        external\n        view\n        returns (\n            uint256 interestPaid,\n            uint256 interestPaidDate,\n            uint256 interestOwedPerDay,\n            uint256 interestUnPaid,\n            uint256 interestFeePercent,\n            uint256 principalTotal\n        )\n    {\n\n            LenderInterest memory lenderInterestLocal\n         = lenderInterest[lender][loanToken];\n\n        interestUnPaid = block\n            .timestamp\n            .sub(lenderInterestLocal.updatedTimestamp)\n            .mul(lenderInterestLocal.owedPerDay)\n            .div(86400);\n        if (interestUnPaid > lenderInterestLocal.owedTotal)\n            interestUnPaid = lenderInterestLocal.owedTotal;\n\n        return (\n            lenderInterestLocal.paidTotal,\n            lenderInterestLocal.paidTotal != 0\n                ? lenderInterestLocal.updatedTimestamp\n                : 0,\n            lenderInterestLocal.owedPerDay,\n            lenderInterestLocal.updatedTimestamp != 0 ? interestUnPaid : 0,\n            lendingFeePercent,\n            lenderInterestLocal.principalTotal\n        );\n    }\n\n    /// @dev Gets current interest data for a loan\n    /// @param loanId A unique id representing the loan\n    /// @return loanToken The loan token that interest is paid in\n    /// @return interestOwedPerDay The amount of interest the borrower is paying per day\n    /// @return interestDepositTotal The total amount of interest the borrower has deposited\n    /// @return interestDepositRemaining The amount of deposited interest that is not yet owed to a lender\n    function getLoanInterestData(bytes32 loanId)\n        external\n        view\n        returns (\n            address loanToken,\n            uint256 interestOwedPerDay,\n            uint256 interestDepositTotal,\n            uint256 interestDepositRemaining\n        )\n    {\n        loanToken = loanParams[loans[loanId].loanParamsId].loanToken;\n        interestOwedPerDay = loanInterest[loanId].owedPerDay;\n        interestDepositTotal = loanInterest[loanId].depositTotal;\n\n        uint256 endTimestamp = loans[loanId].endTimestamp;\n        uint256 interestTime = block.timestamp > endTimestamp\n            ? endTimestamp\n            : block.timestamp;\n        interestDepositRemaining = endTimestamp > interestTime\n            ? endTimestamp.sub(interestTime).mul(interestOwedPerDay).div(86400)\n            : 0;\n    }\n\n    // Only returns data for loans that are active\n    // loanType 0: all loans\n    // loanType 1: margin trade loans\n    // loanType 2: non-margin trade loans\n    // only active loans are returned\n    function getUserLoans(\n        address user,\n        uint256 start,\n        uint256 count,\n        uint256 loanType,\n        bool isLender,\n        bool unsafeOnly\n    ) external view returns (LoanReturnData[] memory loansData) {\n        EnumerableBytes32Set.Bytes32Set storage set = isLender\n            ? lenderLoanSets[user]\n            : borrowerLoanSets[user];\n\n        uint256 end = count.min256(set.values.length);\n        if (end == 0 || start >= end) {\n            return loansData;\n        }\n\n        loansData = new LoanReturnData[](count);\n        uint256 itemCount;\n        for (uint256 i = end - start; i > 0; i--) {\n            if (itemCount == count) {\n                break;\n            }\n            LoanReturnData memory loanData = _getLoan(\n                set.get(i + start - 1), // loanId\n                loanType,\n                unsafeOnly\n            );\n            if (loanData.loanId == 0) continue;\n\n            loansData[itemCount] = loanData;\n            itemCount++;\n        }\n\n        if (itemCount < count) {\n            assembly {\n                mstore(loansData, itemCount)\n            }\n        }\n    }\n\n    function getLoan(bytes32 loanId)\n        external\n        view\n        returns (LoanReturnData memory loanData)\n    {\n        return\n            _getLoan(\n                loanId,\n                0, // loanType\n                false // unsafeOnly\n            );\n    }\n\n    function getActiveLoans(\n        uint256 start,\n        uint256 count,\n        bool unsafeOnly\n    ) external view returns (LoanReturnData[] memory loansData) {\n        uint256 end = count.min256(activeLoansSet.values.length);\n        if (end == 0 || start >= end) {\n            return loansData;\n        }\n\n        loansData = new LoanReturnData[](count);\n        uint256 itemCount;\n        for (uint256 i = end - start; i > 0; i--) {\n            if (itemCount == count) {\n                break;\n            }\n            LoanReturnData memory loanData = _getLoan(\n                activeLoansSet.get(i + start - 1), // loanId\n                0, // loanType\n                unsafeOnly\n            );\n            if (loanData.loanId == 0) continue;\n\n            loansData[itemCount] = loanData;\n            itemCount++;\n        }\n\n        if (itemCount < count) {\n            assembly {\n                mstore(loansData, itemCount)\n            }\n        }\n    }\n\n    function _getLoan(\n        bytes32 loanId,\n        uint256 loanType,\n        bool unsafeOnly\n    ) internal view returns (LoanReturnData memory loanData) {\n        Loan memory loanLocal = loans[loanId];\n        LoanParams memory loanParamsLocal = loanParams[loanLocal.loanParamsId];\n\n        if (loanType != 0) {\n            if (\n                !((loanType == 1 && loanParamsLocal.maxLoanTerm != 0) ||\n                    (loanType == 2 && loanParamsLocal.maxLoanTerm == 0))\n            ) {\n                return loanData;\n            }\n        }\n\n        LoanInterest memory loanInterestLocal = loanInterest[loanId];\n\n        (uint256 currentMargin, uint256 collateralToLoanRate) = IPriceFeeds(\n            priceFeeds\n        )\n            .getCurrentMargin(\n            loanParamsLocal.loanToken,\n            loanParamsLocal.collateralToken,\n            loanLocal.principal,\n            loanLocal.collateral\n        );\n\n        uint256 maxLiquidatable;\n        uint256 maxSeizable;\n        if (currentMargin <= loanParamsLocal.maintenanceMargin) {\n            (maxLiquidatable, maxSeizable, ) = _getLiquidationAmounts(\n                loanLocal.principal,\n                loanLocal.collateral,\n                currentMargin,\n                loanParamsLocal.maintenanceMargin,\n                collateralToLoanRate\n            );\n        } else if (unsafeOnly) {\n            return loanData;\n        }\n\n        return\n            LoanReturnData({\n                loanId: loanId,\n                loanToken: loanParamsLocal.loanToken,\n                collateralToken: loanParamsLocal.collateralToken,\n                principal: loanLocal.principal,\n                collateral: loanLocal.collateral,\n                interestOwedPerDay: loanInterestLocal.owedPerDay,\n                interestDepositRemaining: loanLocal.endTimestamp >=\n                    block.timestamp\n                    ? loanLocal\n                        .endTimestamp\n                        .sub(block.timestamp)\n                        .mul(loanInterestLocal.owedPerDay)\n                        .div(86400)\n                    : 0,\n                startRate: loanLocal.startRate,\n                startMargin: loanLocal.startMargin,\n                maintenanceMargin: loanParamsLocal.maintenanceMargin,\n                currentMargin: currentMargin,\n                maxLoanTerm: loanParamsLocal.maxLoanTerm,\n                endTimestamp: loanLocal.endTimestamp,\n                maxLiquidatable: maxLiquidatable,\n                maxSeizable: maxSeizable\n            });\n    }\n\n    function _doCollateralSwap(\n        Loan storage loanLocal,\n        LoanParams memory loanParamsLocal,\n        uint256 depositAmount\n    ) internal {\n        // reverts in _loanSwap if amountNeeded can't be bought\n        (, uint256 sourceTokenAmountUsed, ) = _loanSwap(\n            loanLocal.id,\n            loanParamsLocal.collateralToken,\n            loanParamsLocal.loanToken,\n            loanLocal.borrower,\n            loanLocal.collateral, // minSourceTokenAmount\n            0, // maxSourceTokenAmount (0 means minSourceTokenAmount)\n            depositAmount, // requiredDestTokenAmount (partial spend of loanLocal.collateral to fill this amount)\n            true, // bypassFee\n            \"\" // loanDataBytes\n        );\n        loanLocal.collateral = loanLocal.collateral.sub(sourceTokenAmountUsed);\n\n        // ensure the loan is still healthy\n        (uint256 currentMargin, ) = IPriceFeeds(priceFeeds).getCurrentMargin(\n            loanParamsLocal.loanToken,\n            loanParamsLocal.collateralToken,\n            loanLocal.principal,\n            loanLocal.collateral\n        );\n        require(\n            currentMargin > loanParamsLocal.maintenanceMargin,\n            \"unhealthy position\"\n        );\n    }\n}\n",
  "imports": [
    {
      "name": "LoanMaintenance_Deployable.sol",
      "contents": "/**\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0.\n */\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\ncontract LoanStruct {\n    struct Loan {\n        bytes32 id; // id of the loan\n        bytes32 loanParamsId; // the linked loan params id\n        bytes32 pendingTradesId; // the linked pending trades id\n        bool active; // if false, the loan has been fully closed\n        uint256 principal; // total borrowed amount outstanding\n        uint256 collateral; // total collateral escrowed for the loan\n        uint256 startTimestamp; // loan start time\n        uint256 endTimestamp; // for active loans, this is the expected loan end time, for in-active loans, is the actual (past) end time\n        uint256 startMargin; // initial margin when the loan opened\n        uint256 startRate; // reference rate when the loan opened for converting collateralToken to loanToken\n        address borrower; // borrower of this loan\n        address lender; // lender of this loan\n    }\n}\n\ncontract LoanParamsStruct {\n    struct LoanParams {\n        bytes32 id; // id of loan params object\n        bool active; // if false, this object has been disabled by the owner and can't be used for future loans\n        address owner; // owner of this object\n        address loanToken; // the token being loaned\n        address collateralToken; // the required collateral token\n        uint256 minInitialMargin; // the minimum allowed initial margin\n        uint256 maintenanceMargin; // an unhealthy loan when current margin is at or below this value\n        uint256 maxLoanTerm; // the maximum term for new loans (0 means there's no max term)\n    }\n}\n\ncontract OrderStruct {\n    struct Order {\n        uint256 lockedAmount; // escrowed amount waiting for a counterparty\n        uint256 interestRate; // interest rate defined by the creator of this order\n        uint256 minLoanTerm; // minimum loan term allowed\n        uint256 maxLoanTerm; // maximum loan term allowed\n        uint256 createdTimestamp; // timestamp when this order was created\n        uint256 expirationTimestamp; // timestamp when this order expires\n    }\n}\n\ncontract LenderInterestStruct {\n    struct LenderInterest {\n        uint256 principalTotal; // total borrowed amount outstanding of asset\n        uint256 owedPerDay; // interest owed per day for all loans of asset\n        uint256 owedTotal; // total interest owed for all loans of asset (assuming they go to full term)\n        uint256 paidTotal; // total interest paid so far for asset\n        uint256 updatedTimestamp; // last update\n    }\n}\n\ncontract LoanInterestStruct {\n    struct LoanInterest {\n        uint256 owedPerDay; // interest owed per day for loan\n        uint256 depositTotal; // total escrowed interest for loan\n        uint256 updatedTimestamp; // last update\n    }\n}\n\ncontract Objects is\n    LoanStruct,\n    LoanParamsStruct,\n    OrderStruct,\n    LenderInterestStruct,\n    LoanInterestStruct\n{}\n\n/**\n * @dev Library for managing loan sets\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * Include with `using EnumerableBytes32Set for EnumerableBytes32Set.Bytes32Set;`.\n *\n */\nlibrary EnumerableBytes32Set {\n    struct Bytes32Set {\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) index;\n        bytes32[] values;\n    }\n\n    /**\n     * @dev Add an address value to a set. O(1).\n     * Returns false if the value was already in the set.\n     */\n    function addAddress(Bytes32Set storage set, address addrvalue)\n        internal\n        returns (bool)\n    {\n        bytes32 value;\n        assembly {\n            value := addrvalue\n        }\n        return addBytes32(set, value);\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     * Returns false if the value was already in the set.\n     */\n    function addBytes32(Bytes32Set storage set, bytes32 value)\n        internal\n        returns (bool)\n    {\n        if (!contains(set, value)) {\n            set.index[value] = set.values.push(value);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes an address value from a set. O(1).\n     * Returns false if the value was not present in the set.\n     */\n    function removeAddress(Bytes32Set storage set, address addrvalue)\n        internal\n        returns (bool)\n    {\n        bytes32 value;\n        assembly {\n            value := addrvalue\n        }\n        return removeBytes32(set, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     * Returns false if the value was not present in the set.\n     */\n    function removeBytes32(Bytes32Set storage set, bytes32 value)\n        internal\n        returns (bool)\n    {\n        if (contains(set, value)) {\n            uint256 toDeleteIndex = set.index[value] - 1;\n            uint256 lastIndex = set.values.length - 1;\n\n            // If the element we're deleting is the last one, we can just remove it without doing a swap\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set.values[lastIndex];\n\n                // Move the last value to the index where the deleted value is\n                set.values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set.index[lastValue] = toDeleteIndex + 1; // All indexes are 1-based\n            }\n\n            // Delete the index entry for the deleted value\n            delete set.index[value];\n\n            // Delete the old entry for the moved value\n            set.values.pop();\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value)\n        internal\n        view\n        returns (bool)\n    {\n        return set.index[value] != 0;\n    }\n\n    /**\n     * @dev Returns an array with all values in the set. O(N).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n\n     * WARNING: This function may run out of gas on large sets: use {length} and\n     * {get} instead in these cases.\n     */\n    function enumerate(\n        Bytes32Set storage set,\n        uint256 start,\n        uint256 count\n    ) internal view returns (bytes32[] memory output) {\n        uint256 end = start + count;\n        require(end >= start, \"addition overflow\");\n        end = set.values.length < end ? set.values.length : end;\n        if (end == 0 || start >= end) {\n            return output;\n        }\n\n        output = new bytes32[](end - start);\n        for (uint256 i; i < end - start; i++) {\n            output[i] = set.values[i + start];\n        }\n        return output;\n    }\n\n    /**\n     * @dev Returns the number of elements on the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return set.values.length;\n    }\n\n    /** @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function get(Bytes32Set storage set, uint256 index)\n        internal\n        view\n        returns (bytes32)\n    {\n        return set.values[index];\n    }\n}\n\n/**\n * @title Helps contracts guard against reentrancy attacks.\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\n * @dev If you mark a function `nonReentrant`, you should also\n * mark it `external`.\n */\ncontract ReentrancyGuard {\n    /// @dev Constant for unlocked guard state - non-zero to prevent extra gas costs.\n    /// See: https://github.com/OpenZeppelin/openzeppelin-solidity/issues/1056\n    uint256 internal constant REENTRANCY_GUARD_FREE = 1;\n\n    /// @dev Constant for locked guard state\n    uint256 internal constant REENTRANCY_GUARD_LOCKED = 2;\n\n    /**\n     * @dev We use a single lock for the whole contract.\n     */\n    uint256 internal reentrancyLock = REENTRANCY_GUARD_FREE;\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * If you mark a function `nonReentrant`, you should also\n     * mark it `external`. Calling one `nonReentrant` function from\n     * another is not supported. Instead, you can implement a\n     * `private` function doing the actual work, and an `external`\n     * wrapper marked as `nonReentrant`.\n     */\n    modifier nonReentrant() {\n        require(reentrancyLock == REENTRANCY_GUARD_FREE, \"nonReentrant\");\n        reentrancyLock = REENTRANCY_GUARD_LOCKED;\n        _;\n        reentrancyLock = REENTRANCY_GUARD_FREE;\n    }\n}\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract ContextSovryn {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor() internal {}\n\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is ContextSovryn {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"unauthorized\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IWrbtc {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\ncontract IERC20Sovryn {\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n\n    function totalSupply() public view returns (uint256);\n\n    function balanceOf(address _who) public view returns (uint256);\n\n    function transfer(address _to, uint256 _value) public returns (bool);\n\n    function allowance(address _owner, address _spender)\n        public\n        view\n        returns (uint256);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public returns (bool);\n\n    function approve(address _spender, uint256 _value) public returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\ncontract IWrbtcERC20 is IWrbtc, IERC20Sovryn {}\n\ncontract State is Objects, ReentrancyGuard, Ownable {\n    using SafeMathSovryn for uint256;\n    using EnumerableBytes32Set for EnumerableBytes32Set.Bytes32Set;\n\n    address public priceFeeds; // handles asset reference price lookups\n    address public swapsImpl; // handles asset swaps using dex liquidity\n    address public sovrynSwapContractRegistryAddress; // contract registry address of the sovryn swap network\n\n    mapping(bytes4 => address) public logicTargets; // implementations of protocol functions\n\n    mapping(bytes32 => Loan) public loans; // loanId => Loan\n    mapping(bytes32 => LoanParams) public loanParams; // loanParamsId => LoanParams\n\n    mapping(address => mapping(bytes32 => Order)) public lenderOrders; // lender => orderParamsId => Order\n    mapping(address => mapping(bytes32 => Order)) public borrowerOrders; // borrower => orderParamsId => Order\n\n    mapping(bytes32 => mapping(address => bool)) public delegatedManagers; // loanId => delegated => approved\n\n    // Interest\n    mapping(address => mapping(address => LenderInterest))\n        public lenderInterest; // lender => loanToken => LenderInterest object\n    mapping(bytes32 => LoanInterest) public loanInterest; // loanId => LoanInterest object\n\n    // Internals\n    EnumerableBytes32Set.Bytes32Set internal logicTargetsSet; // implementations set\n    EnumerableBytes32Set.Bytes32Set internal activeLoansSet; // active loans set\n\n    mapping(address => EnumerableBytes32Set.Bytes32Set) internal lenderLoanSets; // lender loans set\n    mapping(address => EnumerableBytes32Set.Bytes32Set)\n        internal borrowerLoanSets; // borrow loans set\n    mapping(address => EnumerableBytes32Set.Bytes32Set)\n        internal userLoanParamSets; // user loan params set\n\n    address public feesController; // address controlling fee withdrawals\n\n    uint256 public lendingFeePercent = 10**19; // 10% fee                               // fee taken from lender interest payments\n    mapping(address => uint256) public lendingFeeTokensHeld; // total interest fees received and not withdrawn per asset\n    mapping(address => uint256) public lendingFeeTokensPaid; // total interest fees withdraw per asset (lifetime fees = lendingFeeTokensHeld + lendingFeeTokensPaid)\n\n    uint256 public tradingFeePercent = 15 * 10**16; // 0.15% fee                        // fee paid for each trade\n    mapping(address => uint256) public tradingFeeTokensHeld; // total trading fees received and not withdrawn per asset\n    mapping(address => uint256) public tradingFeeTokensPaid; // total trading fees withdraw per asset (lifetime fees = tradingFeeTokensHeld + tradingFeeTokensPaid)\n\n    uint256 public borrowingFeePercent = 9 * 10**16; // 0.09% fee                       // origination fee paid for each loan\n    mapping(address => uint256) public borrowingFeeTokensHeld; // total borrowing fees received and not withdrawn per asset\n    mapping(address => uint256) public borrowingFeeTokensPaid; // total borrowing fees withdraw per asset (lifetime fees = borrowingFeeTokensHeld + borrowingFeeTokensPaid)\n\n    uint256 public protocolTokenHeld; // current protocol token deposit balance\n    uint256 public protocolTokenPaid; // lifetime total payout of protocol token\n\n    uint256 public affiliateFeePercent = 30 * 10**18; // 30% fee share                  // fee share for affiliate program\n\n    uint256 public liquidationIncentivePercent = 5 * 10**18; // 5% collateral discount  // discount on collateral for liquidators\n\n    mapping(address => address) public loanPoolToUnderlying; // loanPool => underlying\n    mapping(address => address) public underlyingToLoanPool; // underlying => loanPool\n    EnumerableBytes32Set.Bytes32Set internal loanPoolsSet; // loan pools set\n\n    mapping(address => bool) public supportedTokens; // supported tokens for swaps\n\n    uint256 public maxDisagreement = 5 * 10**18; // % disagreement between swap rate and reference rate\n\n    uint256 public sourceBuffer = 10000; // used as buffer for swap source amount estimations\n\n    uint256 public maxSwapSize = 50 ether; // maximum support swap size in BTC\n\n    mapping(address => uint256) public borrowerNonce; // nonce per borrower. used for loan id creation.\n\n    uint256 public rolloverBaseReward = 16800000000000; // Rollover transaction costs around 0.0000168 rBTC, it is denominated in wRBTC\n    uint256 public rolloverFlexFeePercent = 0.1 ether; // 0.1%\n\n    IWrbtcERC20 public wrbtcToken;\n    address public protocolTokenAddress;\n\n    function _setTarget(bytes4 sig, address target) internal {\n        logicTargets[sig] = target;\n\n        if (target != address(0)) {\n            logicTargetsSet.addBytes32(bytes32(sig));\n        } else {\n            logicTargetsSet.removeBytes32(bytes32(sig));\n        }\n    }\n}\n\ncontract LoanOpeningsEvents {\n    // topic0: 0x7bd8cbb7ba34b33004f3deda0fd36c92fc0360acbd97843360037b467a538f90\n    event Borrow(\n        address indexed user,\n        address indexed lender,\n        bytes32 indexed loanId,\n        address loanToken,\n        address collateralToken,\n        uint256 newPrincipal,\n        uint256 newCollateral,\n        uint256 interestRate,\n        uint256 interestDuration,\n        uint256 collateralToLoanRate,\n        uint256 currentMargin\n    );\n\n    // topic0: 0xf640c1cfe1a912a0b0152b5a542e5c2403142eed75b06cde526cee54b1580e5c\n    event Trade(\n        address indexed user,\n        address indexed lender,\n        bytes32 indexed loanId,\n        address collateralToken,\n        address loanToken,\n        uint256 positionSize,\n        uint256 borrowedAmount,\n        uint256 interestRate,\n        uint256 settlementDate,\n        uint256 entryPrice, // one unit of collateralToken, denominated in loanToken\n        uint256 entryLeverage,\n        uint256 currentLeverage\n    );\n\n    // topic0: 0x0eef4f90457a741c97d76fcf13fa231fefdcc7649bdb3cb49157c37111c98433\n    event DelegatedManagerSet(\n        bytes32 indexed loanId,\n        address indexed delegator,\n        address indexed delegated,\n        bool isActive\n    );\n}\n\ncontract LoanMaintenanceEvents {\n    event DepositCollateral(bytes32 loanId, uint256 depositAmount);\n}\n\ncontract VaultController is State {\n    using SafeERC20 for IERC20Sovryn;\n\n    event VaultDeposit(\n        address indexed asset,\n        address indexed from,\n        uint256 amount\n    );\n    event VaultWithdraw(\n        address indexed asset,\n        address indexed to,\n        uint256 amount\n    );\n\n    function vaultEtherDeposit(address from, uint256 value) internal {\n        IWrbtcERC20 _wrbtcToken = wrbtcToken;\n        _wrbtcToken.deposit.value(value)();\n\n        emit VaultDeposit(address(_wrbtcToken), from, value);\n    }\n\n    function vaultEtherWithdraw(address to, uint256 value) internal {\n        if (value != 0) {\n            IWrbtcERC20 _wrbtcToken = wrbtcToken;\n            uint256 balance = address(this).balance;\n            if (value > balance) {\n                _wrbtcToken.withdraw(value - balance);\n            }\n            Address.sendValue(address(uint160(to)), value);\n\n            emit VaultWithdraw(address(_wrbtcToken), to, value);\n        }\n    }\n\n    function vaultDeposit(\n        address token,\n        address from,\n        uint256 value\n    ) internal {\n        if (value != 0) {\n            IERC20Sovryn(token).safeTransferFrom(from, address(this), value);\n\n            emit VaultDeposit(token, from, value);\n        }\n    }\n\n    function vaultWithdraw(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        if (value != 0) {\n            IERC20Sovryn(token).safeTransfer(to, value);\n\n            emit VaultWithdraw(token, to, value);\n        }\n    }\n\n    function vaultTransfer(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        if (value != 0) {\n            if (from == address(this)) {\n                IERC20Sovryn(token).safeTransfer(to, value);\n            } else {\n                IERC20Sovryn(token).safeTransferFrom(from, to, value);\n            }\n        }\n    }\n\n    function vaultApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        if (\n            value != 0 && IERC20Sovryn(token).allowance(address(this), to) != 0\n        ) {\n            IERC20Sovryn(token).safeApprove(to, 0);\n        }\n        IERC20Sovryn(token).safeApprove(to, value);\n    }\n}\n\ncontract LiquidationHelper is State {\n    /**\n     * computes how much needs to be liquidated in order to restore the desired margin (maintenance + 5%)\n     * @param principal total borrowed amount (in loan tokens)\n     * @param collateral the collateral (in collateral tokens)\n     * @param currentMargin the current margin\n     * @param maintenanceMargin the maintenance (minimum) margin\n     * @param collateralToLoanRate the exchange rate from collateral to loan tokens\n     * */\n    function _getLiquidationAmounts(\n        uint256 principal,\n        uint256 collateral,\n        uint256 currentMargin,\n        uint256 maintenanceMargin,\n        uint256 collateralToLoanRate\n    )\n        internal\n        view\n        returns (\n            uint256 maxLiquidatable,\n            uint256 maxSeizable,\n            uint256 incentivePercent\n        )\n    {\n        incentivePercent = liquidationIncentivePercent;\n        if (currentMargin > maintenanceMargin || collateralToLoanRate == 0) {\n            return (maxLiquidatable, maxSeizable, incentivePercent);\n        } else if (currentMargin <= incentivePercent) {\n            return (principal, collateral, currentMargin);\n        }\n\n        uint256 desiredMargin = maintenanceMargin.add(5 ether); // 5 percentage points above maintenance\n\n        // maxLiquidatable = ((1 + desiredMargin)*principal - collateralToLoanRate*collateral) / (desiredMargin - 0.05)\n        maxLiquidatable = desiredMargin.add(10**20).mul(principal).div(10**20);\n        maxLiquidatable = maxLiquidatable.sub(\n            collateral.mul(collateralToLoanRate).div(10**18)\n        );\n        maxLiquidatable = maxLiquidatable.mul(10**20).div(\n            desiredMargin.sub(incentivePercent)\n        );\n        if (maxLiquidatable > principal) {\n            maxLiquidatable = principal;\n        }\n\n        // maxSeizable = maxLiquidatable * (1 + incentivePercent) / collateralToLoanRate\n        maxSeizable = maxLiquidatable.mul(incentivePercent.add(10**20));\n        maxSeizable = maxSeizable.div(collateralToLoanRate).div(100);\n        if (maxSeizable > collateral) {\n            maxSeizable = collateral;\n        }\n\n        return (maxLiquidatable, maxSeizable, incentivePercent);\n    }\n}\n\ninterface IPriceFeeds {\n    function queryRate(address sourceToken, address destToken)\n        external\n        view\n        returns (uint256 rate, uint256 precision);\n\n    function queryPrecision(address sourceToken, address destToken)\n        external\n        view\n        returns (uint256 precision);\n\n    function queryReturn(\n        address sourceToken,\n        address destToken,\n        uint256 sourceAmount\n    ) external view returns (uint256 destAmount);\n\n    function checkPriceDisagreement(\n        address sourceToken,\n        address destToken,\n        uint256 sourceAmount,\n        uint256 destAmount,\n        uint256 maxSlippage\n    ) external view returns (uint256 sourceToDestSwapRate);\n\n    function amountInEth(address Token, uint256 amount)\n        external\n        view\n        returns (uint256 ethAmount);\n\n    function getMaxDrawdown(\n        address loanToken,\n        address collateralToken,\n        uint256 loanAmount,\n        uint256 collateralAmount,\n        uint256 maintenanceMargin\n    ) external view returns (uint256);\n\n    function getCurrentMarginAndCollateralSize(\n        address loanToken,\n        address collateralToken,\n        uint256 loanAmount,\n        uint256 collateralAmount\n    )\n        external\n        view\n        returns (uint256 currentMargin, uint256 collateralInEthAmount);\n\n    function getCurrentMargin(\n        address loanToken,\n        address collateralToken,\n        uint256 loanAmount,\n        uint256 collateralAmount\n    )\n        external\n        view\n        returns (uint256 currentMargin, uint256 collateralToLoanRate);\n\n    function shouldLiquidate(\n        address loanToken,\n        address collateralToken,\n        uint256 loanAmount,\n        uint256 collateralAmount,\n        uint256 maintenanceMargin\n    ) external view returns (bool);\n\n    function getFastGasPrice(address payToken) external view returns (uint256);\n}\n\ncontract SwapsEvents {\n    event LoanSwap(\n        bytes32 indexed loanId,\n        address indexed sourceToken,\n        address indexed destToken,\n        address borrower,\n        uint256 sourceAmount,\n        uint256 destAmount\n    );\n\n    event ExternalSwap(\n        address indexed user,\n        address indexed sourceToken,\n        address indexed destToken,\n        uint256 sourceAmount,\n        uint256 destAmount\n    );\n}\n\ncontract FeesEvents {\n    event PayLendingFee(\n        address indexed payer,\n        address indexed token,\n        uint256 amount\n    );\n\n    event PayTradingFee(\n        address indexed payer,\n        address indexed token,\n        bytes32 indexed loanId,\n        uint256 amount\n    );\n\n    event PayBorrowingFee(\n        address indexed payer,\n        address indexed token,\n        bytes32 indexed loanId,\n        uint256 amount\n    );\n\n    event EarnReward(\n        address indexed receiver,\n        address indexed token,\n        bytes32 indexed loanId,\n        uint256 amount\n    );\n}\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathSovryn {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n\n    function min256(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return _a < _b ? _a : _b;\n    }\n}\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract's constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * IMPORTANT: It is unsafe to assume that an address for which this\n     * function returns false is an externally-owned account (EOA) and not a\n     * contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n\n\n            bytes32 accountHash\n         = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            codehash := extcodehash(account)\n        }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account)\n        internal\n        pure\n        returns (address payable)\n    {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance >= amount,\n            \"Address: insufficient balance\"\n        );\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMathSovryn for uint256;\n    using Address for address;\n\n    function safeTransfer(\n        IERC20Sovryn token,\n        address to,\n        uint256 value\n    ) internal {\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20Sovryn token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    function safeApprove(\n        IERC20Sovryn token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Sovryn token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(\n            value\n        );\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Sovryn token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\n            value,\n            \"SafeERC20: decreased allowance below zero\"\n        );\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20Sovryn token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) {\n            // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\n\ncontract ProtocolTokenUser is State {\n    using SafeERC20 for IERC20Sovryn;\n\n    function _withdrawProtocolToken(address receiver, uint256 amount)\n        internal\n        returns (address, bool)\n    {\n        uint256 withdrawAmount = amount;\n\n        uint256 tokenBalance = protocolTokenHeld;\n        if (withdrawAmount > tokenBalance) {\n            withdrawAmount = tokenBalance;\n        }\n        if (withdrawAmount == 0) {\n            return (protocolTokenAddress, false);\n        }\n\n        protocolTokenHeld = tokenBalance.sub(withdrawAmount);\n\n        IERC20Sovryn(protocolTokenAddress).safeTransfer(\n            receiver,\n            withdrawAmount\n        );\n\n        return (protocolTokenAddress, true);\n    }\n}\n\ncontract FeesHelper is State, ProtocolTokenUser, FeesEvents {\n    using SafeERC20 for IERC20Sovryn;\n\n    // calculate trading fee\n    function _getTradingFee(uint256 feeTokenAmount)\n        internal\n        view\n        returns (uint256)\n    {\n        return feeTokenAmount.mul(tradingFeePercent).div(10**20);\n    }\n\n    // calculate loan origination fee\n    function _getBorrowingFee(uint256 feeTokenAmount)\n        internal\n        view\n        returns (uint256)\n    {\n        return feeTokenAmount.mul(borrowingFeePercent).div(10**20);\n    }\n\n    // settle trading fee\n    function _payTradingFee(\n        address user,\n        bytes32 loanId,\n        address feeToken,\n        uint256 tradingFee\n    ) internal {\n        if (tradingFee != 0) {\n            tradingFeeTokensHeld[feeToken] = tradingFeeTokensHeld[feeToken].add(\n                tradingFee\n            );\n\n            emit PayTradingFee(user, feeToken, loanId, tradingFee);\n\n            _payFeeReward(user, loanId, feeToken, tradingFee);\n        }\n    }\n\n    // settle loan origination fee\n    function _payBorrowingFee(\n        address user,\n        bytes32 loanId,\n        address feeToken,\n        uint256 borrowingFee\n    ) internal {\n        if (borrowingFee != 0) {\n            borrowingFeeTokensHeld[feeToken] = borrowingFeeTokensHeld[feeToken]\n                .add(borrowingFee);\n\n            emit PayBorrowingFee(user, feeToken, loanId, borrowingFee);\n\n            _payFeeReward(user, loanId, feeToken, borrowingFee);\n        }\n    }\n\n    // settle lender (interest) fee\n    function _payLendingFee(\n        address user,\n        address feeToken,\n        uint256 lendingFee\n    ) internal {\n        if (lendingFee != 0) {\n            lendingFeeTokensHeld[feeToken] = lendingFeeTokensHeld[feeToken].add(\n                lendingFee\n            );\n\n            emit PayLendingFee(user, feeToken, lendingFee);\n\n            //// NOTE: Lenders do not receive a fee reward ////\n        }\n    }\n\n    // settles and pays borrowers based on the fees generated by their interest payments\n    function _settleFeeRewardForInterestExpense(\n        LoanInterest storage loanInterestLocal,\n        bytes32 loanId,\n        address feeToken,\n        address user,\n        uint256 interestTime\n    ) internal {\n        // this represents the fee generated by a borrower's interest payment\n        uint256 interestExpenseFee = interestTime\n            .sub(loanInterestLocal.updatedTimestamp)\n            .mul(loanInterestLocal.owedPerDay)\n            .div(86400)\n            .mul(lendingFeePercent)\n            .div(10**20);\n\n        loanInterestLocal.updatedTimestamp = interestTime;\n\n        if (interestExpenseFee != 0) {\n            _payFeeReward(user, loanId, feeToken, interestExpenseFee);\n        }\n    }\n\n    // pay potocolToken reward to user\n    function _payFeeReward(\n        address user,\n        bytes32 loanId,\n        address feeToken,\n        uint256 feeAmount\n    ) internal {\n        uint256 rewardAmount;\n        address _priceFeeds = priceFeeds;\n        (bool success, bytes memory data) = _priceFeeds.staticcall(\n            abi.encodeWithSelector(\n                IPriceFeeds(_priceFeeds).queryReturn.selector,\n                feeToken,\n                protocolTokenAddress, // price rewards using BZRX price rather than vesting token price\n                feeAmount / 2 // 50% of fee value\n            )\n        );\n        assembly {\n            if eq(success, 1) {\n                rewardAmount := mload(add(data, 32))\n            }\n        }\n\n        if (rewardAmount != 0) {\n            address rewardToken;\n            (rewardToken, success) = _withdrawProtocolToken(user, rewardAmount);\n            if (success) {\n                protocolTokenPaid = protocolTokenPaid.add(rewardAmount);\n\n                emit EarnReward(user, rewardToken, loanId, rewardAmount);\n            }\n        }\n    }\n}\n\ncontract InterestUser is VaultController, FeesHelper {\n    using SafeERC20 for IERC20Sovryn;\n\n    function _payInterest(address lender, address interestToken) internal {\n\n            LenderInterest storage lenderInterestLocal\n         = lenderInterest[lender][interestToken];\n\n        uint256 interestOwedNow = 0;\n        if (\n            lenderInterestLocal.owedPerDay != 0 &&\n            lenderInterestLocal.updatedTimestamp != 0\n        ) {\n            interestOwedNow = block\n                .timestamp\n                .sub(lenderInterestLocal.updatedTimestamp)\n                .mul(lenderInterestLocal.owedPerDay)\n                .div(86400);\n\n            if (interestOwedNow > lenderInterestLocal.owedTotal)\n                interestOwedNow = lenderInterestLocal.owedTotal;\n\n            if (interestOwedNow != 0) {\n                lenderInterestLocal.paidTotal = lenderInterestLocal\n                    .paidTotal\n                    .add(interestOwedNow);\n                lenderInterestLocal.owedTotal = lenderInterestLocal\n                    .owedTotal\n                    .sub(interestOwedNow);\n\n                _payInterestTransfer(lender, interestToken, interestOwedNow);\n            }\n        }\n\n        lenderInterestLocal.updatedTimestamp = block.timestamp;\n    }\n\n    function _payInterestTransfer(\n        address lender,\n        address interestToken,\n        uint256 interestOwedNow\n    ) internal {\n        uint256 lendingFee = interestOwedNow.mul(lendingFeePercent).div(10**20);\n\n        _payLendingFee(lender, interestToken, lendingFee);\n\n        // transfers the interest to the lender, less the interest fee\n        vaultWithdraw(interestToken, lender, interestOwedNow.sub(lendingFee));\n    }\n}\n\ninterface ISwapsImpl {\n    function internalSwap(\n        address sourceTokenAddress,\n        address destTokenAddress,\n        address receiverAddress,\n        address returnToSenderAddress,\n        uint256 minSourceTokenAmount,\n        uint256 maxSourceTokenAmount,\n        uint256 requiredDestTokenAmount\n    )\n        external\n        returns (\n            uint256 destTokenAmountReceived,\n            uint256 sourceTokenAmountUsed\n        );\n\n    function internalExpectedRate(\n        address sourceTokenAddress,\n        address destTokenAddress,\n        uint256 sourceTokenAmount\n    ) external view returns (uint256);\n}\n\ncontract SwapsUser is State, SwapsEvents, FeesHelper {\n    function _loanSwap(\n        bytes32 loanId,\n        address sourceToken,\n        address destToken,\n        address user,\n        uint256 minSourceTokenAmount,\n        uint256 maxSourceTokenAmount,\n        uint256 requiredDestTokenAmount,\n        bool bypassFee,\n        bytes memory loanDataBytes\n    )\n        internal\n        returns (\n            uint256 destTokenAmountReceived,\n            uint256 sourceTokenAmountUsed,\n            uint256 sourceToDestSwapRate\n        )\n    {\n        (destTokenAmountReceived, sourceTokenAmountUsed) = _swapsCall(\n            [\n                sourceToken,\n                destToken,\n                address(this), // receiver\n                address(this), // returnToSender\n                user\n            ],\n            [\n                minSourceTokenAmount,\n                maxSourceTokenAmount,\n                requiredDestTokenAmount\n            ],\n            loanId,\n            bypassFee,\n            loanDataBytes\n        );\n\n        // will revert if swap size too large\n        _checkSwapSize(sourceToken, sourceTokenAmountUsed);\n\n        // will revert if disagreement found\n        sourceToDestSwapRate = IPriceFeeds(priceFeeds).checkPriceDisagreement(\n            sourceToken,\n            destToken,\n            sourceTokenAmountUsed,\n            destTokenAmountReceived,\n            maxDisagreement\n        );\n\n        emit LoanSwap(\n            loanId,\n            sourceToken,\n            destToken,\n            user,\n            sourceTokenAmountUsed,\n            destTokenAmountReceived\n        );\n    }\n\n    function _swapsCall(\n        address[5] memory addrs,\n        uint256[3] memory vals,\n        bytes32 loanId,\n        bool miscBool, // bypassFee\n        bytes memory loanDataBytes\n    ) internal returns (uint256, uint256) {\n        //addrs[0]: sourceToken\n        //addrs[1]: destToken\n        //addrs[2]: receiver\n        //addrs[3]: returnToSender\n        //addrs[4]: user\n        //vals[0]:  minSourceTokenAmount\n        //vals[1]:  maxSourceTokenAmount\n        //vals[2]:  requiredDestTokenAmount\n\n        require(\n            vals[0] != 0 || vals[1] != 0,\n            \"min or max source token amount needs to be set\"\n        );\n\n        if (vals[1] == 0) {\n            vals[1] = vals[0];\n        }\n        require(vals[0] <= vals[1], \"sourceAmount larger than max\");\n\n        uint256 destTokenAmountReceived;\n        uint256 sourceTokenAmountUsed;\n\n        uint256 tradingFee;\n        if (!miscBool) {\n            // bypassFee\n            if (vals[2] == 0) {\n                // condition: vals[0] will always be used as sourceAmount\n\n                tradingFee = _getTradingFee(vals[0]);\n                if (tradingFee != 0) {\n                    _payTradingFee(\n                        addrs[4], // user\n                        loanId,\n                        addrs[0], // sourceToken\n                        tradingFee\n                    );\n\n                    vals[0] = vals[0].sub(tradingFee);\n                }\n            } else {\n                // condition: unknown sourceAmount will be used\n\n                tradingFee = _getTradingFee(vals[2]);\n\n                if (tradingFee != 0) {\n                    vals[2] = vals[2].add(tradingFee);\n                }\n            }\n        }\n\n        if (loanDataBytes.length == 0) {\n            (\n                destTokenAmountReceived,\n                sourceTokenAmountUsed\n            ) = _swapsCall_internal(addrs, vals);\n        } else {\n            revert(\"invalid state\");\n            /*\n            //keccak256(\"Swaps_SwapsImplZeroX\")\n            address swapsImplZeroX;\n            assembly {\n                swapsImplZeroX := sload(0x129a6cb350d136ca8d0881f83a9141afd5dc8b3c99057f06df01ab75943df952)\n            }\n            */\n            //revert(string(loanDataBytes));\n            /*\n            vaultWithdraw(\n                addrs[0], // sourceToken\n                address(zeroXConnector),\n                sourceTokenAmount\n            );\n            (destTokenAmountReceived, sourceTokenAmountUsed) = zeroXConnector.swap.value(msg.value)(\n                addrs[0], // sourceToken\n                addrs[1], // destToken\n                addrs[2], // receiver\n                sourceTokenAmount,\n                0,\n                loanDataBytes\n            );\n            */\n        }\n\n        if (vals[2] == 0) {\n            // there's no minimum destTokenAmount, but all of vals[0] (minSourceTokenAmount) must be spent\n            require(sourceTokenAmountUsed == vals[0], \"swap too large to fill\");\n\n            if (tradingFee != 0) {\n                sourceTokenAmountUsed = sourceTokenAmountUsed.add(tradingFee);\n            }\n        } else {\n            // there's a minimum destTokenAmount required, but sourceTokenAmountUsed won't be greater than vals[1] (maxSourceTokenAmount)\n            require(sourceTokenAmountUsed <= vals[1], \"swap fill too large\");\n            require(\n                destTokenAmountReceived >= vals[2],\n                \"insufficient swap liquidity\"\n            );\n\n            if (tradingFee != 0) {\n                _payTradingFee(\n                    addrs[4], // user\n                    loanId, // loanId,\n                    addrs[1], // destToken\n                    tradingFee\n                );\n\n                destTokenAmountReceived = destTokenAmountReceived.sub(\n                    tradingFee\n                );\n            }\n        }\n\n        return (destTokenAmountReceived, sourceTokenAmountUsed);\n    }\n\n    function _swapsCall_internal(\n        address[5] memory addrs,\n        uint256[3] memory vals\n    )\n        internal\n        returns (uint256 destTokenAmountReceived, uint256 sourceTokenAmountUsed)\n    {\n        bytes memory data = abi.encodeWithSelector(\n            ISwapsImpl(swapsImpl).internalSwap.selector,\n            addrs[0], // sourceToken\n            addrs[1], // destToken\n            addrs[2], // receiverAddress\n            addrs[3], // returnToSenderAddress\n            vals[0], // minSourceTokenAmount\n            vals[1], // maxSourceTokenAmount\n            vals[2] // requiredDestTokenAmount\n        );\n\n        bool success;\n        (success, data) = swapsImpl.delegatecall(data);\n        require(success, \"swap failed\");\n\n        assembly {\n            destTokenAmountReceived := mload(add(data, 32))\n            sourceTokenAmountUsed := mload(add(data, 64))\n        }\n    }\n\n    function _swapsExpectedReturn(\n        address sourceToken,\n        address destToken,\n        uint256 sourceTokenAmount\n    ) internal view returns (uint256) {\n        uint256 tradingFee = _getTradingFee(sourceTokenAmount);\n        if (tradingFee != 0) {\n            sourceTokenAmount = sourceTokenAmount.sub(tradingFee);\n        }\n\n        uint256 sourceToDestRate = ISwapsImpl(swapsImpl).internalExpectedRate(\n            sourceToken,\n            destToken,\n            sourceTokenAmount\n        );\n        uint256 sourceToDestPrecision = IPriceFeeds(priceFeeds).queryPrecision(\n            sourceToken,\n            destToken\n        );\n\n        return\n            sourceTokenAmount.mul(sourceToDestRate).div(sourceToDestPrecision);\n    }\n\n    function _checkSwapSize(address tokenAddress, uint256 amount)\n        internal\n        view\n    {\n        uint256 _maxSwapSize = maxSwapSize;\n        if (_maxSwapSize != 0) {\n            uint256 amountInEth;\n            if (tokenAddress == address(wrbtcToken)) {\n                amountInEth = amount;\n            } else {\n                amountInEth = IPriceFeeds(priceFeeds).amountInEth(\n                    tokenAddress,\n                    amount\n                );\n            }\n            require(amountInEth <= _maxSwapSize, \"swap too large\");\n        }\n    }\n}\n\ncontract LoanMaintenance is\n    LoanOpeningsEvents,\n    LoanMaintenanceEvents,\n    VaultController,\n    InterestUser,\n    SwapsUser,\n    LiquidationHelper\n{\n    struct LoanReturnData {\n        bytes32 loanId;\n        address loanToken;\n        address collateralToken;\n        uint256 principal;\n        uint256 collateral;\n        uint256 interestOwedPerDay;\n        uint256 interestDepositRemaining;\n        uint256 startRate; // collateralToLoanRate\n        uint256 startMargin;\n        uint256 maintenanceMargin;\n        uint256 currentMargin;\n        uint256 maxLoanTerm;\n        uint256 endTimestamp;\n        uint256 maxLiquidatable;\n        uint256 maxSeizable;\n    }\n\n    constructor() public {}\n\n    function() external {\n        revert(\"fallback not allowed\");\n    }\n\n    function initialize(address target) external onlyOwner {\n        _setTarget(this.depositCollateral.selector, target);\n        _setTarget(this.withdrawCollateral.selector, target);\n        _setTarget(this.withdrawAccruedInterest.selector, target);\n        _setTarget(this.extendLoanDuration.selector, target);\n        _setTarget(this.reduceLoanDuration.selector, target);\n        _setTarget(this.getLenderInterestData.selector, target);\n        _setTarget(this.getLoanInterestData.selector, target);\n        _setTarget(this.getUserLoans.selector, target);\n        _setTarget(this.getLoan.selector, target);\n        _setTarget(this.getActiveLoans.selector, target);\n    }\n\n    function depositCollateral(\n        bytes32 loanId,\n        uint256 depositAmount // must match msg.value if ether is sent\n    ) external payable nonReentrant {\n        require(depositAmount != 0, \"depositAmount is 0\");\n        Loan storage loanLocal = loans[loanId];\n        LoanParams storage loanParamsLocal = loanParams[loanLocal.loanParamsId];\n\n        require(loanLocal.active, \"loan is closed\");\n        require(\n            msg.value == 0 ||\n                loanParamsLocal.collateralToken == address(wrbtcToken),\n            \"wrong asset sent\"\n        );\n\n        loanLocal.collateral = loanLocal.collateral.add(depositAmount);\n\n        if (msg.value == 0) {\n            vaultDeposit(\n                loanParamsLocal.collateralToken,\n                msg.sender,\n                depositAmount\n            );\n        } else {\n            require(msg.value == depositAmount, \"ether deposit mismatch\");\n            vaultEtherDeposit(msg.sender, msg.value);\n        }\n\n        emit DepositCollateral(loanId, depositAmount);\n    }\n\n    function withdrawCollateral(\n        bytes32 loanId,\n        address receiver,\n        uint256 withdrawAmount\n    ) external nonReentrant returns (uint256 actualWithdrawAmount) {\n        require(withdrawAmount != 0, \"withdrawAmount is 0\");\n        Loan storage loanLocal = loans[loanId];\n        LoanParams storage loanParamsLocal = loanParams[loanLocal.loanParamsId];\n\n        require(loanLocal.active, \"loan is closed\");\n        require(\n            msg.sender == loanLocal.borrower ||\n                delegatedManagers[loanLocal.id][msg.sender],\n            \"unauthorized\"\n        );\n\n        uint256 maxDrawdown = IPriceFeeds(priceFeeds).getMaxDrawdown(\n            loanParamsLocal.loanToken,\n            loanParamsLocal.collateralToken,\n            loanLocal.principal,\n            loanLocal.collateral,\n            loanParamsLocal.maintenanceMargin\n        );\n\n        if (withdrawAmount > maxDrawdown) {\n            actualWithdrawAmount = maxDrawdown;\n        } else {\n            actualWithdrawAmount = withdrawAmount;\n        }\n\n        loanLocal.collateral = loanLocal.collateral.sub(actualWithdrawAmount);\n\n        if (loanParamsLocal.collateralToken == address(wrbtcToken)) {\n            vaultEtherWithdraw(receiver, actualWithdrawAmount);\n        } else {\n            vaultWithdraw(\n                loanParamsLocal.collateralToken,\n                receiver,\n                actualWithdrawAmount\n            );\n        }\n    }\n\n    function withdrawAccruedInterest(address loanToken) external {\n        // pay outstanding interest to lender\n        _payInterest(\n            msg.sender, // lender\n            loanToken\n        );\n    }\n\n    function extendLoanDuration(\n        bytes32 loanId,\n        uint256 depositAmount,\n        bool useCollateral,\n        bytes calldata // for future use /*loanDataBytes*/\n    ) external payable nonReentrant returns (uint256 secondsExtended) {\n        require(depositAmount != 0, \"depositAmount is 0\");\n        Loan storage loanLocal = loans[loanId];\n        LoanParams storage loanParamsLocal = loanParams[loanLocal.loanParamsId];\n\n        require(loanLocal.active, \"loan is closed\");\n        require(\n            !useCollateral ||\n                msg.sender == loanLocal.borrower ||\n                delegatedManagers[loanLocal.id][msg.sender],\n            \"unauthorized\"\n        );\n        require(loanParamsLocal.maxLoanTerm == 0, \"indefinite-term only\");\n        require(\n            msg.value == 0 ||\n                (!useCollateral &&\n                    loanParamsLocal.loanToken == address(wrbtcToken)),\n            \"wrong asset sent\"\n        );\n\n        // pay outstanding interest to lender\n        _payInterest(loanLocal.lender, loanParamsLocal.loanToken);\n\n        LoanInterest storage loanInterestLocal = loanInterest[loanLocal.id];\n\n        _settleFeeRewardForInterestExpense(\n            loanInterestLocal,\n            loanLocal.id,\n            loanParamsLocal.loanToken,\n            loanLocal.borrower,\n            block.timestamp\n        );\n\n        // Handle back interest: calculates interest owned since the loan endtime passed but the loan remained open\n        uint256 backInterestOwed;\n        if (block.timestamp > loanLocal.endTimestamp) {\n            backInterestOwed = block.timestamp.sub(loanLocal.endTimestamp);\n            backInterestOwed = backInterestOwed.mul(\n                loanInterestLocal.owedPerDay\n            );\n            backInterestOwed = backInterestOwed.div(86400);\n\n            require(\n                depositAmount > backInterestOwed,\n                \"deposit cannot cover back interest\"\n            );\n        }\n\n        // deposit interest\n        if (useCollateral) {\n            _doCollateralSwap(loanLocal, loanParamsLocal, depositAmount);\n        } else {\n            if (msg.value == 0) {\n                vaultDeposit(\n                    loanParamsLocal.loanToken,\n                    msg.sender,\n                    depositAmount\n                );\n            } else {\n                require(msg.value == depositAmount, \"ether deposit mismatch\");\n                vaultEtherDeposit(msg.sender, msg.value);\n            }\n        }\n\n        if (backInterestOwed != 0) {\n            depositAmount = depositAmount.sub(backInterestOwed);\n\n            // pay out backInterestOwed\n            _payInterestTransfer(\n                loanLocal.lender,\n                loanParamsLocal.loanToken,\n                backInterestOwed\n            );\n        }\n\n        secondsExtended = depositAmount.mul(86400).div(\n            loanInterestLocal.owedPerDay\n        );\n\n        loanLocal.endTimestamp = loanLocal.endTimestamp.add(secondsExtended);\n\n        require(loanLocal.endTimestamp > block.timestamp, \"loan too short\");\n\n        uint256 maxDuration = loanLocal.endTimestamp.sub(block.timestamp);\n\n        // loan term has to at least be greater than one hour\n        require(maxDuration > 3600, \"loan too short\");\n\n        loanInterestLocal.depositTotal = loanInterestLocal.depositTotal.add(\n            depositAmount\n        );\n\n        lenderInterest[loanLocal.lender][loanParamsLocal.loanToken]\n            .owedTotal = lenderInterest[loanLocal.lender][loanParamsLocal\n            .loanToken]\n            .owedTotal\n            .add(depositAmount);\n    }\n\n    function reduceLoanDuration(\n        bytes32 loanId,\n        address receiver,\n        uint256 withdrawAmount\n    ) external nonReentrant returns (uint256 secondsReduced) {\n        require(withdrawAmount != 0, \"withdrawAmount is 0\");\n        Loan storage loanLocal = loans[loanId];\n        LoanParams storage loanParamsLocal = loanParams[loanLocal.loanParamsId];\n\n        require(loanLocal.active, \"loan is closed\");\n        require(\n            msg.sender == loanLocal.borrower ||\n                delegatedManagers[loanLocal.id][msg.sender],\n            \"unauthorized\"\n        );\n        require(loanParamsLocal.maxLoanTerm == 0, \"indefinite-term only\");\n        require(\n            loanLocal.endTimestamp > block.timestamp,\n            \"loan term has ended\"\n        );\n\n        // pay outstanding interest to lender\n        _payInterest(loanLocal.lender, loanParamsLocal.loanToken);\n\n        LoanInterest storage loanInterestLocal = loanInterest[loanLocal.id];\n\n        _settleFeeRewardForInterestExpense(\n            loanInterestLocal,\n            loanLocal.id,\n            loanParamsLocal.loanToken,\n            loanLocal.borrower,\n            block.timestamp\n        );\n\n        uint256 interestDepositRemaining = loanLocal\n            .endTimestamp\n            .sub(block.timestamp)\n            .mul(loanInterestLocal.owedPerDay)\n            .div(86400);\n        require(\n            withdrawAmount < interestDepositRemaining,\n            \"withdraw amount too high\"\n        );\n\n        // withdraw interest\n        if (loanParamsLocal.loanToken == address(wrbtcToken)) {\n            vaultEtherWithdraw(receiver, withdrawAmount);\n        } else {\n            vaultWithdraw(loanParamsLocal.loanToken, receiver, withdrawAmount);\n        }\n\n        secondsReduced = withdrawAmount.mul(86400).div(\n            loanInterestLocal.owedPerDay\n        );\n\n        require(loanLocal.endTimestamp > secondsReduced, \"loan too short\");\n\n        loanLocal.endTimestamp = loanLocal.endTimestamp.sub(secondsReduced);\n\n        require(loanLocal.endTimestamp > block.timestamp, \"loan too short\");\n\n        uint256 maxDuration = loanLocal.endTimestamp.sub(block.timestamp);\n\n        // loan term has to at least be greater than one hour\n        require(maxDuration > 3600, \"loan too short\");\n\n        loanInterestLocal.depositTotal = loanInterestLocal.depositTotal.sub(\n            withdrawAmount\n        );\n\n        lenderInterest[loanLocal.lender][loanParamsLocal.loanToken]\n            .owedTotal = lenderInterest[loanLocal.lender][loanParamsLocal\n            .loanToken]\n            .owedTotal\n            .sub(withdrawAmount);\n    }\n\n    /// @dev Gets current lender interest data totals for all loans with a specific oracle and interest token\n    /// @param lender The lender address\n    /// @param loanToken The loan token address\n    /// @return interestPaid The total amount of interest that has been paid to a lender so far\n    /// @return interestPaidDate The date of the last interest pay out, or 0 if no interest has been withdrawn yet\n    /// @return interestOwedPerDay The amount of interest the lender is earning per day\n    /// @return interestUnPaid The total amount of interest the lender is owned and not yet withdrawn\n    /// @return interestFeePercent The fee retained by the protocol before interest is paid to the lender\n    /// @return principalTotal The total amount of outstading principal the lender has loaned\n    function getLenderInterestData(address lender, address loanToken)\n        external\n        view\n        returns (\n            uint256 interestPaid,\n            uint256 interestPaidDate,\n            uint256 interestOwedPerDay,\n            uint256 interestUnPaid,\n            uint256 interestFeePercent,\n            uint256 principalTotal\n        )\n    {\n\n            LenderInterest memory lenderInterestLocal\n         = lenderInterest[lender][loanToken];\n\n        interestUnPaid = block\n            .timestamp\n            .sub(lenderInterestLocal.updatedTimestamp)\n            .mul(lenderInterestLocal.owedPerDay)\n            .div(86400);\n        if (interestUnPaid > lenderInterestLocal.owedTotal)\n            interestUnPaid = lenderInterestLocal.owedTotal;\n\n        return (\n            lenderInterestLocal.paidTotal,\n            lenderInterestLocal.paidTotal != 0\n                ? lenderInterestLocal.updatedTimestamp\n                : 0,\n            lenderInterestLocal.owedPerDay,\n            lenderInterestLocal.updatedTimestamp != 0 ? interestUnPaid : 0,\n            lendingFeePercent,\n            lenderInterestLocal.principalTotal\n        );\n    }\n\n    /// @dev Gets current interest data for a loan\n    /// @param loanId A unique id representing the loan\n    /// @return loanToken The loan token that interest is paid in\n    /// @return interestOwedPerDay The amount of interest the borrower is paying per day\n    /// @return interestDepositTotal The total amount of interest the borrower has deposited\n    /// @return interestDepositRemaining The amount of deposited interest that is not yet owed to a lender\n    function getLoanInterestData(bytes32 loanId)\n        external\n        view\n        returns (\n            address loanToken,\n            uint256 interestOwedPerDay,\n            uint256 interestDepositTotal,\n            uint256 interestDepositRemaining\n        )\n    {\n        loanToken = loanParams[loans[loanId].loanParamsId].loanToken;\n        interestOwedPerDay = loanInterest[loanId].owedPerDay;\n        interestDepositTotal = loanInterest[loanId].depositTotal;\n\n        uint256 endTimestamp = loans[loanId].endTimestamp;\n        uint256 interestTime = block.timestamp > endTimestamp\n            ? endTimestamp\n            : block.timestamp;\n        interestDepositRemaining = endTimestamp > interestTime\n            ? endTimestamp.sub(interestTime).mul(interestOwedPerDay).div(86400)\n            : 0;\n    }\n\n    // Only returns data for loans that are active\n    // loanType 0: all loans\n    // loanType 1: margin trade loans\n    // loanType 2: non-margin trade loans\n    // only active loans are returned\n    function getUserLoans(\n        address user,\n        uint256 start,\n        uint256 count,\n        uint256 loanType,\n        bool isLender,\n        bool unsafeOnly\n    ) external view returns (LoanReturnData[] memory loansData) {\n        EnumerableBytes32Set.Bytes32Set storage set = isLender\n            ? lenderLoanSets[user]\n            : borrowerLoanSets[user];\n\n        uint256 end = count.min256(set.values.length);\n        if (end == 0 || start >= end) {\n            return loansData;\n        }\n\n        loansData = new LoanReturnData[](count);\n        uint256 itemCount;\n        for (uint256 i = end - start; i > 0; i--) {\n            if (itemCount == count) {\n                break;\n            }\n            LoanReturnData memory loanData = _getLoan(\n                set.get(i + start - 1), // loanId\n                loanType,\n                unsafeOnly\n            );\n            if (loanData.loanId == 0) continue;\n\n            loansData[itemCount] = loanData;\n            itemCount++;\n        }\n\n        if (itemCount < count) {\n            assembly {\n                mstore(loansData, itemCount)\n            }\n        }\n    }\n\n    function getLoan(bytes32 loanId)\n        external\n        view\n        returns (LoanReturnData memory loanData)\n    {\n        return\n            _getLoan(\n                loanId,\n                0, // loanType\n                false // unsafeOnly\n            );\n    }\n\n    function getActiveLoans(\n        uint256 start,\n        uint256 count,\n        bool unsafeOnly\n    ) external view returns (LoanReturnData[] memory loansData) {\n        uint256 end = count.min256(activeLoansSet.values.length);\n        if (end == 0 || start >= end) {\n            return loansData;\n        }\n\n        loansData = new LoanReturnData[](count);\n        uint256 itemCount;\n        for (uint256 i = end - start; i > 0; i--) {\n            if (itemCount == count) {\n                break;\n            }\n            LoanReturnData memory loanData = _getLoan(\n                activeLoansSet.get(i + start - 1), // loanId\n                0, // loanType\n                unsafeOnly\n            );\n            if (loanData.loanId == 0) continue;\n\n            loansData[itemCount] = loanData;\n            itemCount++;\n        }\n\n        if (itemCount < count) {\n            assembly {\n                mstore(loansData, itemCount)\n            }\n        }\n    }\n\n    function _getLoan(\n        bytes32 loanId,\n        uint256 loanType,\n        bool unsafeOnly\n    ) internal view returns (LoanReturnData memory loanData) {\n        Loan memory loanLocal = loans[loanId];\n        LoanParams memory loanParamsLocal = loanParams[loanLocal.loanParamsId];\n\n        if (loanType != 0) {\n            if (\n                !((loanType == 1 && loanParamsLocal.maxLoanTerm != 0) ||\n                    (loanType == 2 && loanParamsLocal.maxLoanTerm == 0))\n            ) {\n                return loanData;\n            }\n        }\n\n        LoanInterest memory loanInterestLocal = loanInterest[loanId];\n\n        (uint256 currentMargin, uint256 collateralToLoanRate) = IPriceFeeds(\n            priceFeeds\n        )\n            .getCurrentMargin(\n            loanParamsLocal.loanToken,\n            loanParamsLocal.collateralToken,\n            loanLocal.principal,\n            loanLocal.collateral\n        );\n\n        uint256 maxLiquidatable;\n        uint256 maxSeizable;\n        if (currentMargin <= loanParamsLocal.maintenanceMargin) {\n            (maxLiquidatable, maxSeizable, ) = _getLiquidationAmounts(\n                loanLocal.principal,\n                loanLocal.collateral,\n                currentMargin,\n                loanParamsLocal.maintenanceMargin,\n                collateralToLoanRate\n            );\n        } else if (unsafeOnly) {\n            return loanData;\n        }\n\n        return\n            LoanReturnData({\n                loanId: loanId,\n                loanToken: loanParamsLocal.loanToken,\n                collateralToken: loanParamsLocal.collateralToken,\n                principal: loanLocal.principal,\n                collateral: loanLocal.collateral,\n                interestOwedPerDay: loanInterestLocal.owedPerDay,\n                interestDepositRemaining: loanLocal.endTimestamp >=\n                    block.timestamp\n                    ? loanLocal\n                        .endTimestamp\n                        .sub(block.timestamp)\n                        .mul(loanInterestLocal.owedPerDay)\n                        .div(86400)\n                    : 0,\n                startRate: loanLocal.startRate,\n                startMargin: loanLocal.startMargin,\n                maintenanceMargin: loanParamsLocal.maintenanceMargin,\n                currentMargin: currentMargin,\n                maxLoanTerm: loanParamsLocal.maxLoanTerm,\n                endTimestamp: loanLocal.endTimestamp,\n                maxLiquidatable: maxLiquidatable,\n                maxSeizable: maxSeizable\n            });\n    }\n\n    function _doCollateralSwap(\n        Loan storage loanLocal,\n        LoanParams memory loanParamsLocal,\n        uint256 depositAmount\n    ) internal {\n        // reverts in _loanSwap if amountNeeded can't be bought\n        (, uint256 sourceTokenAmountUsed, ) = _loanSwap(\n            loanLocal.id,\n            loanParamsLocal.collateralToken,\n            loanParamsLocal.loanToken,\n            loanLocal.borrower,\n            loanLocal.collateral, // minSourceTokenAmount\n            0, // maxSourceTokenAmount (0 means minSourceTokenAmount)\n            depositAmount, // requiredDestTokenAmount (partial spend of loanLocal.collateral to fill this amount)\n            true, // bypassFee\n            \"\" // loanDataBytes\n        );\n        loanLocal.collateral = loanLocal.collateral.sub(sourceTokenAmountUsed);\n\n        // ensure the loan is still healthy\n        (uint256 currentMargin, ) = IPriceFeeds(priceFeeds).getCurrentMargin(\n            loanParamsLocal.loanToken,\n            loanParamsLocal.collateralToken,\n            loanLocal.principal,\n            loanLocal.collateral\n        );\n        require(\n            currentMargin > loanParamsLocal.maintenanceMargin,\n            \"unhealthy position\"\n        );\n    }\n}\n",
      "file": "LoanMaintenance_Deployable.sol"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0xb9858b6167e8a7bf80ee81edda61dee418d74d40303c2942219e809791ca0cff",
    "blockNumber": 2742462,
    "transactionHash": "0x073c085288ef5def5eb98d274259d46bc428d003b1d51e5558084630ae3a88de",
    "timestamp": 1601478270
  }
}