{
  "address": "0x99a12be4c89cbf6cfd11d1f2c029904a7b644368",
  "net": {
    "id": "30",
    "name": "RSK Mainnet"
  },
  "name": "MultiChainResolver",
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "evmVersion": "byzantium",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "metadata",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ]
      }
    }
  },
  "version": "0.5.8+commit.23d335f2",
  "source": "pragma solidity ^0.5.2;\n\nimport \"../registry/AbstractRNS.sol\";\nimport \"./AbstractPublicResolver.sol\";\nimport \"./AbstractMultiChainResolver.sol\";\nimport \"../util/AddressHelper.sol\";\n\ncontract MultiChainResolver is AbstractMultiChainResolver {\n    AbstractRNS rns;\n    AbstractPublicResolver publicResolver;\n\n    AddressHelper addressHelper;\n\n    mapping (bytes32 => bytes32) contents;\n    mapping (bytes32 => mapping (bytes8 => ChainAddress)) chainAddresses;\n\n    bytes4 constant ADDR_SIGN = 0x3b3b57de;\n    bytes4 constant CONTENT_SIGN = 0x2dff6941;\n    bytes4 constant CHAIN_ADDR_SIGN = 0x8be4b5f6;\n\n    bytes4 constant RSK_CHAIN_ID = 0x80000089;\n\n    event ContentChanged (bytes32 node, bytes32 content);\n    event ChainMetadataChanged (bytes32 node, bytes4 chain, bytes32 metadata);\n\n    struct ChainAddress {\n        bytes32 metadata;\n        string addr;\n    }\n\n    modifier onlyOwner (bytes32 node) {\n        require(rns.owner(node) == msg.sender);\n        _;\n    }\n\n    constructor (AbstractRNS _rns, AbstractPublicResolver _publicResolver) public {\n        rns = _rns;\n        publicResolver = _publicResolver;\n        addressHelper = new AddressHelper();\n    }\n\n    function () external {\n        revert();\n    }\n\n    function supportsInterface (bytes4 interfaceId) public pure returns (bool) {\n        return ((interfaceId == ADDR_SIGN) || (interfaceId == CONTENT_SIGN) || interfaceId == (CHAIN_ADDR_SIGN));\n    }\n\n    function addr (bytes32 node) public view returns (address) {\n        string memory _addr = chainAddresses[node][RSK_CHAIN_ID].addr;\n\n        if (bytes(_addr).length > 0) {\n            return addressHelper.stringToAddress(_addr);\n        }\n\n        return publicResolver.addr(node);\n    }\n\n    function setAddr (bytes32 node, address addrValue) public onlyOwner(node) {\n        chainAddresses[node][RSK_CHAIN_ID].addr = addressHelper.addressToString(addrValue);\n        emit AddrChanged(node, addrValue);\n    }\n\n    function content (bytes32 node) public view returns (bytes32) {\n        bytes32 _content = contents[node];\n\n        if (_content != 0) {\n            return _content;\n        }\n\n        return publicResolver.content(node);\n    }\n\n    function setContent (bytes32 node, bytes32 contentValue) public onlyOwner(node) {\n        contents[node] = contentValue;\n        emit ContentChanged(node, contentValue);\n    }\n\n    function chainAddr (bytes32 node, bytes4 chain) public view returns (string memory) {\n        return chainAddresses[node][chain].addr;\n    }\n\n    function setChainAddr (bytes32 node, bytes4 chain, string memory addrValue) public onlyOwner(node) {\n        chainAddresses[node][chain].addr = addrValue;\n        if (chain == RSK_CHAIN_ID) {\n            address _addr = addressHelper.stringToAddress(addrValue);\n            emit AddrChanged(node, _addr);\n        } else {\n            emit ChainAddrChanged(node, chain, addrValue);\n        }\n    }\n\n    function chainMetadata (bytes32 node, bytes4 chain) public view returns (bytes32) {\n        return chainAddresses[node][chain].metadata;\n    }\n\n    function setChainMetadata (bytes32 node, bytes4 chain, bytes32 metadataValue) public onlyOwner(node) {\n        chainAddresses[node][chain].metadata = metadataValue;\n        emit ChainMetadataChanged(node, chain, metadataValue);\n    }\n\n    function chainAddrAndMetadata (bytes32 node, bytes4 chain) public view returns (string memory, bytes32) {\n        ChainAddress storage chainAddress = chainAddresses[node][chain];\n        return (chainAddress.addr, chainAddress.metadata);\n    }\n\n    function setChainAddrWithMetadata (bytes32 node, bytes4 chain, string memory addrValue, bytes32 metadataValue) public onlyOwner(node) {\n        setChainAddr(node, chain, addrValue);\n        setChainMetadata(node, chain, metadataValue);\n    }\n}\n",
  "imports": [
    {
      "name": "MultiChainResolver.sol",
      "contents": "pragma solidity ^0.5.2;\n\nimport \"../registry/AbstractRNS.sol\";\nimport \"./AbstractPublicResolver.sol\";\nimport \"./AbstractMultiChainResolver.sol\";\nimport \"../util/AddressHelper.sol\";\n\ncontract MultiChainResolver is AbstractMultiChainResolver {\n    AbstractRNS rns;\n    AbstractPublicResolver publicResolver;\n\n    AddressHelper addressHelper;\n\n    mapping (bytes32 => bytes32) contents;\n    mapping (bytes32 => mapping (bytes8 => ChainAddress)) chainAddresses;\n\n    bytes4 constant ADDR_SIGN = 0x3b3b57de;\n    bytes4 constant CONTENT_SIGN = 0x2dff6941;\n    bytes4 constant CHAIN_ADDR_SIGN = 0x8be4b5f6;\n\n    bytes4 constant RSK_CHAIN_ID = 0x80000089;\n\n    event ContentChanged (bytes32 node, bytes32 content);\n    event ChainMetadataChanged (bytes32 node, bytes4 chain, bytes32 metadata);\n\n    struct ChainAddress {\n        bytes32 metadata;\n        string addr;\n    }\n\n    modifier onlyOwner (bytes32 node) {\n        require(rns.owner(node) == msg.sender);\n        _;\n    }\n\n    constructor (AbstractRNS _rns, AbstractPublicResolver _publicResolver) public {\n        rns = _rns;\n        publicResolver = _publicResolver;\n        addressHelper = new AddressHelper();\n    }\n\n    function () external {\n        revert();\n    }\n\n    function supportsInterface (bytes4 interfaceId) public pure returns (bool) {\n        return ((interfaceId == ADDR_SIGN) || (interfaceId == CONTENT_SIGN) || interfaceId == (CHAIN_ADDR_SIGN));\n    }\n\n    function addr (bytes32 node) public view returns (address) {\n        string memory _addr = chainAddresses[node][RSK_CHAIN_ID].addr;\n\n        if (bytes(_addr).length > 0) {\n            return addressHelper.stringToAddress(_addr);\n        }\n\n        return publicResolver.addr(node);\n    }\n\n    function setAddr (bytes32 node, address addrValue) public onlyOwner(node) {\n        chainAddresses[node][RSK_CHAIN_ID].addr = addressHelper.addressToString(addrValue);\n        emit AddrChanged(node, addrValue);\n    }\n\n    function content (bytes32 node) public view returns (bytes32) {\n        bytes32 _content = contents[node];\n\n        if (_content != 0) {\n            return _content;\n        }\n\n        return publicResolver.content(node);\n    }\n\n    function setContent (bytes32 node, bytes32 contentValue) public onlyOwner(node) {\n        contents[node] = contentValue;\n        emit ContentChanged(node, contentValue);\n    }\n\n    function chainAddr (bytes32 node, bytes4 chain) public view returns (string memory) {\n        return chainAddresses[node][chain].addr;\n    }\n\n    function setChainAddr (bytes32 node, bytes4 chain, string memory addrValue) public onlyOwner(node) {\n        chainAddresses[node][chain].addr = addrValue;\n        if (chain == RSK_CHAIN_ID) {\n            address _addr = addressHelper.stringToAddress(addrValue);\n            emit AddrChanged(node, _addr);\n        } else {\n            emit ChainAddrChanged(node, chain, addrValue);\n        }\n    }\n\n    function chainMetadata (bytes32 node, bytes4 chain) public view returns (bytes32) {\n        return chainAddresses[node][chain].metadata;\n    }\n\n    function setChainMetadata (bytes32 node, bytes4 chain, bytes32 metadataValue) public onlyOwner(node) {\n        chainAddresses[node][chain].metadata = metadataValue;\n        emit ChainMetadataChanged(node, chain, metadataValue);\n    }\n\n    function chainAddrAndMetadata (bytes32 node, bytes4 chain) public view returns (string memory, bytes32) {\n        ChainAddress storage chainAddress = chainAddresses[node][chain];\n        return (chainAddress.addr, chainAddress.metadata);\n    }\n\n    function setChainAddrWithMetadata (bytes32 node, bytes4 chain, string memory addrValue, bytes32 metadataValue) public onlyOwner(node) {\n        setChainAddr(node, chain, addrValue);\n        setChainMetadata(node, chain, metadataValue);\n    }\n}\n",
      "file": "MultiChainResolver.sol"
    },
    {
      "name": "Whitelist.sol",
      "contents": "pragma solidity ^0.5.2;\n\nimport \"./AbstractWhitelist.sol\";\n\ncontract Whitelist is AbstractWhitelist {\n\taddress public owner;\n\n\tmapping (address => bool) public isManager;\n\tmapping (address => uint) public whitelistedUntil;\n\n\tuint public whitelistedTime;\n\n\tmodifier onlyOwner () {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\n\tmodifier onlyManagers () {\n\t\trequire(isManager[msg.sender]);\n\t\t_;\n\t}\n\n\tconstructor () public {\n\t\towner = msg.sender;\n\t\twhitelistedTime = 1 days;\n\t}\n\n\tfunction addManager (address manager) public onlyOwner() {\n\t\tisManager[manager] = true;\n\t}\n\n\tfunction removeManager (address manager) public onlyOwner() {\n\t\tisManager[manager] = false;\n\t}\n\n\tfunction addWhitelisted (address whitelisted) public onlyManagers() {\n\t\twhitelistedUntil[whitelisted] = now + whitelistedTime;\n\t}\n\n\tfunction removeWhitelisted (address whitelisted) public onlyManagers() {\n\t\twhitelistedUntil[whitelisted] = 0;\n\t}\n\n\tfunction isWhitelisted (address whitelisted) public view returns (bool) {\n\t\treturn whitelistedUntil[whitelisted] > now;\n\t}\n\n\tfunction setExpirationTime (uint time) public onlyOwner() {\n\t\twhitelistedTime = time;\n\t}\n}\n"
    },
    {
      "name": "SubdomainRegistrar.sol",
      "contents": "pragma solidity ^0.5.2;\n\nimport \"../registry/AbstractRNS.sol\";\n\n/**\n * @title SubdomainRegistrar\n * Allows anyone to create subnodes under a given and owned RNS node.\n */\ncontract SubdomainRegistrar {\n  AbstractRNS public rns;\n  bytes32 public rootNode;\n  address owner;\n\n  modifier onlyOwner () {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Constructor\n   * @param _rns AbstractRNS RNS registry address\n   * @param _rootNode An owned node. The contract emits subnodes under this node.\n   */\n  constructor (AbstractRNS _rns, bytes32 _rootNode) public {\n    rns = _rns;\n    rootNode = _rootNode;\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Registers a new subnode under the root node. The new node owner is the sender\n   * @param label bytres32 The label of the new subnode.\n   */\n  function register (bytes32 label) public {\n    bytes32 node = keccak256(abi.encodePacked(rootNode, label));\n    require(rns.owner(node) == address(0));\n\n    rns.setSubnodeOwner(rootNode, label, msg.sender);\n  }\n\n  /**\n   * @dev Transfers back the root node ownership to the contract's owner.\n   */\n  function transferBack () public onlyOwner() {\n    rns.setOwner(rootNode, owner);\n  }\n}\n"
    },
    {
      "name": "SafeMath.sol",
      "contents": "pragma solidity ^0.5.2;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n"
    },
    {
      "name": "RNS.sol",
      "contents": "pragma solidity ^0.5.2;\n\nimport \"./AbstractRNS.sol\";\n\n/**\n * The RNS registry contract.\n */\ncontract RNS is AbstractRNS {\n    struct Record {\n        address owner;\n        address resolver;\n        uint64 ttl;\n    }\n\n    mapping(bytes32=>Record) records;\n\n    // Permits modifications only by the owner of the specified node.\n    modifier only_owner(bytes32 node) {\n        require(records[node].owner == msg.sender);\n        _;\n    }\n\n    /**\n     * Constructs a new RNS registrar.\n     */\n    constructor() public {\n        records[bytes32(0)].owner = msg.sender;\n    }\n\n    /**\n     * Returns the address that owns the specified node.\n     */\n    function owner(bytes32 node) public view returns (address) {\n        return records[node].owner;\n    }\n\n    /**\n     * Returns the address of the resolver for the specified node.\n     */\n    function resolver(bytes32 node) public view returns (address) {\n        return records[node].resolver;\n    }\n\n    /**\n     * Returns the TTL of a node, and any records associated with it.\n     */\n    function ttl(bytes32 node) public view returns (uint64) {\n        return records[node].ttl;\n    }\n\n    /**\n     * Transfers ownership of a node to a new address. May only be called by the current\n     * owner of the node.\n     * @param node The node to transfer ownership of.\n     * @param ownerAddress The address of the new owner.\n     */\n    function setOwner(bytes32 node, address ownerAddress) public only_owner(node) {\n        emit Transfer(node, ownerAddress);\n        records[node].owner = ownerAddress;\n    }\n\n    /**\n     * Transfers ownership of a subnode keccak256(node, label) to a new address. May only be\n     * called by the owner of the parent node.\n     * @param node The parent node.\n     * @param label The hash of the label specifying the subnode.\n     * @param ownerAddress The address of the new owner.\n     */\n    function setSubnodeOwner(bytes32 node, bytes32 label, address ownerAddress) public only_owner(node) {\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\n        emit NewOwner(node, label, ownerAddress);\n        records[subnode].owner = ownerAddress;\n\n        emit NewResolver(subnode, records[node].resolver);\n        records[subnode].resolver = records[node].resolver;\n    }\n\n    /**\n     * Sets the resolver address for the specified node.\n     * @param node The node to update.\n     * @param resolverAddress The address of the resolver.\n     */\n    function setResolver(bytes32 node, address resolverAddress) public only_owner(node) {\n        emit NewResolver(node, resolverAddress);\n        records[node].resolver = resolverAddress;\n    }\n\n    /**\n     * Sets the TTL for the specified node.\n     * @param node The node to update.\n     * @param ttlValue The TTL in seconds.\n     */\n    function setTTL(bytes32 node, uint64 ttlValue) public only_owner(node) {\n        emit NewTTL(node, ttlValue);\n        records[node].ttl = ttlValue;\n    }\n\n    /**\n     * Sets the default resolver for new nodes\n     * @param _resolver The address of the new defaultResolver\n     */\n    function setDefaultResolver(address _resolver) public only_owner(0) {\n        records[bytes32(0)].resolver = _resolver;\n    }\n}\n"
    },
    {
      "name": "PublicSubdomainRegistrar.sol",
      "contents": "pragma solidity ^0.5.2;\n\nimport \"../registry/AbstractRNS.sol\";\n\n/**\n * @title PublicSubdomainRegistrar\n * Allows anyone to create subnodes under any delegated RNS node.\n */\ncontract PublicSubdomainRegistrar {\n    AbstractRNS public rns;\n\n    mapping (bytes32 => address) delegated;\n\n    modifier onlyOwned (bytes32 node) {\n        require(rns.owner(node) == address(this));\n        _;\n    }\n\n    modifier onlyPreviousOwner (bytes32 node) {\n        require(msg.sender == delegated[node]);\n        _;\n    }\n\n    /**\n     * @dev Constructor\n     * @param _rns AbstractRNS RNS registry address\n     */\n    constructor (AbstractRNS _rns) public {\n        rns = _rns;\n    }\n\n    /**\n     * @dev Delegates an owned node to this contract.\n     * @param node bytes32 The delegated RNS node.\n     */\n    function delegate (bytes32 node) public onlyOwned(node) {\n        delegated[node] = msg.sender;\n    }\n\n    /**\n     * @dev Check if a node is delegated to this contract.\n     * @param node bytes32 An RNS node.\n     * @return if the node is delgated\n     */\n    function isDelegated (bytes32 node) public view returns (bool) {\n        return delegated[node] != address(0);\n    }\n\n    /**\n     * @dev Transfers back a delegated node to who delegated it.\n     * @param node bytes32 Node to retrive.\n     */\n    function transferBack (bytes32 node) public onlyPreviousOwner(node) {\n        rns.setOwner(node, delegated[node]);\n        delegated[node] = address(0);\n    }\n\n    /**\n     * @dev Registrers a subnode under a given and delegated node.\n     * @param node bytes32 The parent node.\n     * @param label bytes32 The hash of the label specifying the subnode.\n     */\n    function register (bytes32 node, bytes32 label) public {\n        address subnodeOwner = rns.owner(keccak256(abi.encodePacked(node, label)));\n        require(subnodeOwner == address(0));\n\n        rns.setSubnodeOwner(node, label, msg.sender);\n    }\n}\n"
    },
    {
      "name": "PublicResolver.sol",
      "contents": "pragma solidity ^0.5.2;\n\nimport \"../registry/AbstractRNS.sol\";\n\n/**\n * A simple resolver anyone can use; only allows the owner of a node to set its\n * address.\n */\ncontract PublicResolver {\n    AbstractRNS rns;\n    mapping(bytes32=>address) addresses;\n    mapping(bytes32=>bytes32) hashes;\n\n    modifier only_owner(bytes32 node) {\n        require(rns.owner(node) == msg.sender);\n        _;\n    }\n\n    /**\n     * Constructor.\n     * @param rnsAddr The RNS registrar contract.\n     */\n    constructor(AbstractRNS rnsAddr) public {\n        rns = rnsAddr;\n    }\n\n    /**\n     * Fallback function.\n     */\n    function() payable external {\n        revert();\n    }\n\n    /**\n     * Returns true if the specified node has the specified record type.\n     * @param node The RNS node to query.\n     * @param kind The record type name, as specified in EIP137.\n     * @return True if this resolver has a record of the provided type on the\n     *         provided node.\n     */\n    function has(bytes32 node, bytes32 kind) public view returns (bool) {\n        return  (kind == \"addr\" && addresses[node] != address(0)) || \n        (kind == \"hash\" && hashes[node] != 0);\n    }\n\n    /**\n     * Returns true if the resolver implements the interface specified by the provided hash.\n     * @param interfaceID The ID of the interface to check for.\n     * @return True if the contract implements the requested interface.\n     */\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\n        return interfaceID == 0x3b3b57de || interfaceID == 0xd8389dc5;\n    }\n\n    /**\n     * Returns the address associated with an RNS node.\n     * @param node The RNS node to query.\n     * @return The associated address.\n     */\n    function addr(bytes32 node) public view returns (address) {\n        return addresses[node];\n    }\n\n    /**\n     * Sets the address associated with an RNS node.\n     * May only be called by the owner of that node in the RNS registry.\n     * @param node The node to update.\n     * @param addrValue The address to set.\n     */\n    function setAddr(bytes32 node, address addrValue) public only_owner(node) {\n        addresses[node] = addrValue;\n    }\n\n    /**\n     * Returns the content hash associated with an RNS node.\n     * Note that this resource type is not standardized, and will likely change\n     * in future to a resource type based on multihash.\n     * @param node The RNS node to query.\n     * @return The associated content hash.\n     */\n    function content(bytes32 node) public view returns (bytes32) {\n        return hashes[node];\n    }\n\n    /**\n     * Sets the content hash associated with an RNS node.\n     * May only be called by the owner of that node in the RNS registry.\n     * Note that this resource type is not standardized, and will likely change\n     * in future to a resource type based on multihash.\n     * @param node The node to update.\n     * @param hash The content hash to set\n     */\n    function setContent(bytes32 node, bytes32 hash) public only_owner(node) {\n        hashes[node] = hash;\n    }\n}\n"
    },
    {
      "name": "PriceSubdomainRegistrar.sol",
      "contents": "pragma solidity ^0.5.2;\n\nimport \"../registry/AbstractRNS.sol\";\nimport \"../util/PaymentAdmin.sol\";\nimport \"../util/AbstractWhitelist.sol\";\nimport \"../token/ERC20Basic.sol\";\nimport \"../resolver/AbstractAddrResolver.sol\";\n\n/**\n * @title PriceSubdomainRegistrar\n * Allows anyone who is whitelisted to create subnodes under a given\n * RNS node and receive a price for doing this.\n */\ncontract PriceSubdomainRegistrar {\n    address owner = msg.sender;\n\n    PaymentAdmin public admin = new PaymentAdmin();\n    AbstractRNS public rns;\n    AbstractWhitelist public whitelist;\n    ERC20Basic public token;\n    bytes32 public rootNode;\n\n    uint256 public price = 1 * (10 ** 18);\n\n    bytes4 constant ADDR_SIGN = 0x3b3b57de;\n\n    modifier onlyOwner () {\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier onlyWhitelisted () {\n        require(whitelist.isWhitelisted(msg.sender));\n        _;\n    }\n\n    /**\n     * @dev Constructor\n     * @param _rns AbstractRNS RNS registry address.\n     * @param _whitelist AbstractWhitelist Whitelist to manage who can register domains.\n     * @param _token ERC20Basic ERC-20 token address.\n     * @param _rootNode bytes32 An owned node. The contract emits subnodes under this node.\n     */\n    constructor (AbstractRNS _rns, AbstractWhitelist _whitelist, ERC20Basic _token, bytes32 _rootNode) public {\n        rns = _rns;\n        whitelist = _whitelist;\n        rootNode = _rootNode;\n        token = _token;\n    }\n\n    /**\n     * @dev Registrers a subnode under a given and delegated node. Who registers a domain\n     * receives a token price.\n     * @param label bytres32 The label of the new subnode.\n     */\n    function register (bytes32 label, address addr) public onlyWhitelisted() {\n        bytes32 subnode = keccak256(abi.encodePacked(rootNode, label));\n        require(rns.owner(subnode) == address(0));\n\n        AbstractAddrResolver resolver = AbstractAddrResolver(rns.resolver(rootNode));\n        require(resolver.supportsInterface(ADDR_SIGN));\n\n        rns.setSubnodeOwner(rootNode, label, address(this));\n        resolver.setAddr(subnode, addr);\n\n        rns.setOwner(subnode, addr);\n        whitelist.removeWhitelisted(msg.sender);\n        admin.transfer(addr, token, price);\n    }\n\n    /**\n     * @dev Sets the price given for regstring a subnode.\n     * @param _price uint256 The new price.\n     */\n    function setPrice (uint256 _price) public onlyOwner() {\n        price = _price;\n    }\n\n    /**\n     * @dev Transfer the tokens stored in the token admin contract.\n     * @param receiver address The address of the token receiver.\n     * @param _token ERC20Basic The token to retrieve the founds of.\n     */\n    function retrieveTokens (address receiver, ERC20Basic _token) public onlyOwner() {\n        admin.retrieveTokens(receiver, _token);\n    }\n\n  /**\n   * @dev Transfers back the root node ownership to the contract's owner.\n   */\n  function transferBack () public onlyOwner() {\n    rns.setOwner(rootNode, owner);\n  }\n}\n"
    },
    {
      "name": "PaymentAdmin.sol",
      "contents": "pragma solidity ^0.5.2;\n\nimport \"../token/ERC20Basic.sol\";\n\ncontract PaymentAdmin {\n    address payable public owner = msg.sender;\n\n    modifier onlyOwner () {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function () external payable {\n        owner.transfer(msg.value);\n    }\n\n    function retrieveTokens (address receiver, ERC20Basic token) public onlyOwner() {\n        uint256 balance = token.balanceOf(address(this));\n        token.transfer(receiver, balance);\n    }\n\n    function transfer (address receiver, ERC20Basic token, uint256 value) public onlyOwner() {\n        token.transfer(receiver, value);\n    }\n}\n"
    },
    {
      "name": "ERC20Basic.sol",
      "contents": "pragma solidity ^0.5.2;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n"
    },
    {
      "name": "BasicToken.sol",
      "contents": "pragma solidity ^0.5.2;\n\n\nimport \"./ERC20Basic.sol\";\nimport \"../util/SafeMath.sol\";\n\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  constructor (uint256 _totalSupply) public {\n    totalSupply_ = _totalSupply;\n    balances[msg.sender] = _totalSupply;\n  }\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}"
    },
    {
      "name": "AddressHelper.sol",
      "contents": "pragma solidity ^0.5.2;\n\ncontract AddressHelper {\n    function addressToString (address data) public pure returns (string memory) {\n        bytes memory s = new bytes(42);\n        s[0] = \"0\";\n        s[1] = \"x\";\n        for (uint i = 0; i < 20; i++) {\n            byte b = byte(uint8(uint(data) / (2**(8*(19 - i)))));\n            byte hi = byte(uint8(b) / 16);\n            byte lo = byte(uint8(b) - 16 * uint8(hi));\n            s[2*i + 2] = char(hi);\n            s[2*i + 3] = char(lo);\n        }\n        return string(s);\n    }\n\n    function char (byte b) internal pure returns (byte c) {\n        if (b < 0x0A) return byte(uint8(b) + 0x30);\n        else return byte(uint8(b) + 0x57);\n    }\n\n    // source: https://github.com/riflabs/RIF-Token/blob/master/contracts/util/AddressHelper.sol\n    function stringToAddress(string memory s) public pure returns(address) {\n        bytes memory ss = bytes(s);\n\n        // it should have 40 or 42 characters\n        if (ss.length != 40 && ss.length != 42) revert();\n\n        uint r = 0;\n        uint offset = 0;\n\n        if (ss.length == 42) {\n            offset = 2;\n\n            if (ss[0] != byte('0')) revert();\n            if (ss[1] != byte('x') && ss[1] != byte('X')) revert();\n        }\n\n        uint i;\n        uint x;\n        uint v;\n\n        // loads first 32 bytes from array,\n        // skipping array length (32 bytes to skip)\n        // offset == 0x20\n        assembly { v := mload(add(0x20, ss)) }\n\n        // converts the first 32 bytes, adding to result\n        for (i = offset; i < 32; ++i) {\n            assembly { x := byte(i, v) }\n            r = r * 16 + fromHexChar(x);\n        }\n\n        // loads second 32 bytes from array,\n        // skipping array length (32 bytes to skip)\n        // and first 32 bytes\n        // offset == 0x40\n        assembly { v := mload(add(0x40, ss)) }\n\n        // converts the last 8 bytes, adding to result\n        for (i = 0; i < 8 + offset; ++i) {\n            assembly { x := byte(i, v) }\n            r = r * 16 + fromHexChar(x);\n        }\n\n        return address(r);\n    }\n\n    function fromHexChar(uint c) public pure returns (uint) {\n        if (c >= 0x30 && c <= 0x39) {\n            return c - 0x30;\n        }\n\n        if (c >= 0x61 && c <= 0x66) {\n            return 10 + c - 0x61;\n        }\n\n        if (c >= 0x41 && c <= 0x46) {\n            return 10 + c - 0x41;\n        }\n\n        // Reaching this point means the ordinal is not for a hex char.\n        revert();\n    }\n}"
    },
    {
      "name": "AbstractWhitelist.sol",
      "contents": "pragma solidity ^0.5.2;\n\ncontract AbstractWhitelist {\n\tfunction isWhitelisted (address whitelisted) public view returns (bool);\n\tfunction removeWhitelisted (address whitelisted) public;\n}\n"
    },
    {
      "name": "AbstractRNS.sol",
      "contents": "pragma solidity ^0.5.2;\n\ncontract AbstractRNS {\n    function owner(bytes32 node) public view returns(address);\n    function resolver(bytes32 node) public view returns(address);\n    function ttl(bytes32 node) public view returns(uint64);\n    function setOwner(bytes32 node, address ownerAddress) public;\n    function setSubnodeOwner(bytes32 node, bytes32 label, address ownerAddress) public;\n    function setResolver(bytes32 node, address resolverAddress) public;\n    function setTTL(bytes32 node, uint64 ttlValue) public;\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address ownerAddress);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address ownerAddress);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolverAddress);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttlValue);\n}\n"
    },
    {
      "name": "AbstractResolver.sol",
      "contents": "pragma solidity ^0.5.2;\n\ncontract AbstractResolver {\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool);\n}\n"
    },
    {
      "name": "AbstractPublicResolver.sol",
      "contents": "pragma solidity ^0.5.2;\n\nimport \"./AbstractAddrResolver.sol\";\n\ncontract AbstractPublicResolver is AbstractAddrResolver {\n    function content(bytes32 node) public view returns (bytes32 ret);\n    function setContent(bytes32 node, bytes32 hashValue) public;\n    function has(bytes32 node, bytes32 kind) public view returns (bool);\n}\n"
    },
    {
      "name": "AbstractMultiChainResolver.sol",
      "contents": "pragma solidity ^0.5.2;\n\nimport \"./AbstractAddrResolver.sol\";\n\ncontract AbstractMultiChainResolver is AbstractAddrResolver {\n    function chainAddr(bytes32 node, bytes4 chain) public view returns (string memory);\n    function setChainAddr(bytes32 node, bytes4 chain, string memory addrValue) public;\n\n    event ChainAddrChanged(bytes32 indexed node, bytes4 chain, string addr);\n}\n"
    },
    {
      "name": "AbstractAddrResolver.sol",
      "contents": "pragma solidity ^0.5.2;\n\nimport \"./AbstractResolver.sol\";\n\ncontract AbstractAddrResolver is AbstractResolver {\n    function addr(bytes32 node) public view returns (address ret);\n    function setAddr(bytes32 node, address addrValue) public;\n\n    event AddrChanged(bytes32 indexed node, address addr);\n}\n"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0xae7a6b93261c7628e8ed9e99225ecb101e20c1ef9d3cf4d006b97b6d69b88cca",
    "blockNumber": 1352337,
    "transactionHash": "0x55de5e10b3077a766b8228ec68c41f8639f483225b4647f11664f1efad435386",
    "timestamp": 1557160626
  },
  "constructorArguments": [
    "0xcb868aeabd31e2b66f74e9a55cf064abb31a4ad5",
    "0x4efd25e3d348f8f25a14fb7655fba6f72edfe93a"
  ]
}