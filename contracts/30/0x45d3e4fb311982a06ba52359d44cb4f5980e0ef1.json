{
  "address": "0x45d3e4fb311982a06ba52359d44cb4f5980e0ef1",
  "net": {
    "id": "30",
    "name": "RSK Mainnet"
  },
  "name": "RSKOwner",
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "metadata",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ]
      }
    }
  },
  "version": "0.5.12+commit.7709ece9",
  "source": "pragma solidity ^0.5.3;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/access/Roles.sol\";\nimport \"./testing/TokenDeed.sol\";\nimport \"./testing/AbstractRNS.sol\";\nimport \"./testing/TokenRegistrar.sol\";\n\ncontract RSKOwner is ERC721, Ownable {\n    using Roles for Roles.Role;\n\n    TokenRegistrar private previousRegistrar;\n    AbstractRNS private rns;\n    bytes32 private rootNode;\n\n    mapping (uint256 => uint) public expirationTime;\n\n    event ExpirationChanged(uint256 tokenId, uint expirationTime);\n\n    modifier onlyPreviousRegistrar {\n        require(msg.sender == address(previousRegistrar), \"Only previous registrar.\");\n        _;\n    }\n\n    modifier onlyRegistrar {\n        require(registrars.has(msg.sender), \"Only registrar.\");\n        _;\n    }\n\n    modifier onlyRenewer {\n        require(renewers.has(msg.sender), \"Only renewer.\");\n        _;\n    }\n\n    constructor (\n        TokenRegistrar _previousRegistrar,\n        AbstractRNS _rns,\n        bytes32 _rootNode\n    ) public {\n        previousRegistrar = _previousRegistrar;\n        rns = _rns;\n        rootNode = _rootNode;\n    }\n\n    /// @notice Gets the owner of the specified domain.\n    /// @param tokenId keccak256 of the domain label.\n    /// @return domain owner.\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        require(expirationTime[tokenId] > now, \"ERC721: owner query for nonexistent token\");\n        return super.ownerOf(tokenId);\n    }\n\n    /// @notice Check if a domain is available to be registered.\n    /// @dev The name must be registered via account with registrar role.\n    /// @param tokenId keccak256 of the domain label.\n    /// @return true if the specified domain can be registered.\n    function available(uint256 tokenId) public view returns(bool) {\n        return (\n            expirationTime[tokenId] < now &&\n            previousRegistrar.state(bytes32(tokenId)) != TokenRegistrar.Mode.Owned\n        );\n    }\n\n    ///////////////////\n    // RSK TLD ADMIN //\n    ///////////////////\n\n    /*\n        This contract owns a node in RNS, so it is capable to\n        change it's resolution and ttl.\n    */\n\n    /// @notice set root node resolver in RNS.\n    /// @param resolver to be set.\n    function setRootResolver (address resolver) external onlyOwner {\n        rns.setResolver(rootNode, resolver);\n    }\n\n    /// @notice set root node ttl in RNS.\n    /// @param ttl to be set.\n    function setRootTTL (uint64 ttl) external onlyOwner {\n        rns.setTTL(rootNode, ttl);\n    }\n\n    ///////////////////////\n    // AUCTION MIGRATION //\n    ///////////////////////\n\n    /*\n        A domain registered with previous registrar (auction)\n        should be transfered before it can be renewed. If the\n        domain is not transfered and it expires, it might be\n        registered by someone else.\n    */\n\n    /// @notice Accept domain transfer from previous registrar.\n    /// @dev Use it via tokenRegistrar.trnasferRegistrars(label).\n    /// All locked tokens in Deed are returned.\n    /// @param label Accepted domain label.\n    /// @param deed Deed contract address holding tokens.\n    function acceptRegistrarTransfer(bytes32 label, TokenDeed deed, uint) external onlyPreviousRegistrar {\n        uint256 tokenId = uint256(label);\n        expirationTime[tokenId] = deed.expirationDate();\n        _mint(deed.owner(), tokenId);\n        deed.closeDeed(1000);\n    }\n\n    //////////////////\n    // REGISTRATION //\n    //////////////////\n\n    /*\n        Only available domains can be registered. Once a domain is\n        registered, it cannot be revoked until expiration.\n    */\n\n    // An account with registrar role can register domains.\n    Roles.Role registrars;\n\n    /// @notice Give an account access to registrar role.\n    /// @dev Only owner.\n    /// @param registrar new registrar.\n    function addRegistrar(address registrar) external onlyOwner {\n        registrars.add(registrar);\n    }\n\n    /// @notice Check if an account has registrar role.\n    /// @param registrar to query if has registrar role.\n    /// @return true if it has registrar role.\n    function isRegistrar(address registrar) external view returns (bool) {\n        return registrars.has(registrar);\n    }\n\n    /// @notice Remove an account's access to registrar role.\n    /// @dev Only owner\n    /// @param registrar registrar to remove from registrar role.\n    function removeRegistrar(address registrar) external onlyOwner {\n        registrars.remove(registrar);\n    }\n\n    /// @notice Registers a domain in RNS for a given duration.\n    /// @dev Only accounts with registrar role.\n    /// @param label keccak256 of the domain label to register.\n    /// @param tokenOwner account that will own the registered domain.\n    /// @param duration time to register the domain for.\n    function register(bytes32 label, address tokenOwner, uint duration) external onlyRegistrar {\n        uint256 tokenId = uint256(label);\n\n        require(available(tokenId), \"Not available\");\n\n        uint newExpirationTime = now.add(duration);\n        expirationTime[tokenId] = newExpirationTime;\n        emit ExpirationChanged(tokenId, newExpirationTime);\n\n        if (_exists(tokenId))\n            _burn(tokenId);\n\n        _mint(tokenOwner, tokenId);\n\n        rns.setSubnodeOwner(rootNode, label, tokenOwner);\n    }\n\n    ////////////////\n    // RECLAIMING //\n    ////////////////\n\n    /*\n        Names might be lost by transferring to contracts, or by\n        error. This allows any owner (or approved) to reclaim the\n        domain ownership in RNS.\n    */\n\n    /// @notice Reclaim ownership of a domain in RNS.\n    /// @dev Only owner or approved for the domain.\n    /// @param tokenId keccak256 of the domain\n    /// @param newOwner the owner to set in RNS.\n    function reclaim(uint256 tokenId, address newOwner) external {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"Not approved or owner\");\n        rns.setSubnodeOwner(rootNode, bytes32(tokenId), newOwner);\n    }\n\n    ////////////////\n    // RENOVATION //\n    ////////////////\n\n    /*\n        Only owned domains can be renewed. A renovation extends\n        domain ownership.\n    */\n\n    // An account with renewer role can extend domain expirations.\n    Roles.Role renewers;\n\n    /// @notice Give an account access to renewer role.\n    /// @dev Only owner\n    /// @param renewer new renewer.\n    function addRenewer(address renewer) external onlyOwner {\n        renewers.add(renewer);\n    }\n\n    /// @notice Check if an account has renewer role.\n    /// @param renewer to query if has renewer role.\n    /// @return true if it has renewer role.\n    function isRenewer(address renewer) external view returns (bool) {\n        return renewers.has(renewer);\n    }\n\n    /// @notice Remove an account's access to renewer role.\n    /// @dev Only owner\n    /// @param renewer renewer to remove from renewer role.\n    function removeRenewer(address renewer) external onlyOwner {\n        renewers.remove(renewer);\n    }\n\n    /// @notice Renew a domain for a given duraiton.\n    /// @dev Only accounts with renewer role.\n    /// @param label keccak256 of the domain label to renew.\n    /// @param time to extend the duration for.\n    function renew (bytes32 label, uint time) external onlyRenewer {\n        uint256 tokenId = uint256(label);\n        require(expirationTime[tokenId] > now, \"Name already expired\");\n        uint newExpirationTime = expirationTime[tokenId].add(time);\n        expirationTime[tokenId] = newExpirationTime;\n        emit ExpirationChanged(tokenId, newExpirationTime);\n    }\n\n    //////////////////////\n    // AFTER EXPIRATION //\n    //////////////////////\n\n    /// @notice This method removes expired domains.\n    /// @dev Use this to set 0 address in RNS ownership\n    /// and burn the domains to keep balance up to date.\n    /// @param tokenIds keccak256s of the domain labels to remove.\n    function removeExpired(uint256[] calldata tokenIds) external {\n        uint256 tokenId;\n        bytes32 label;\n\n        for (uint i = 0; i < tokenIds.length; i++) {\n            tokenId = tokenIds[i];\n\n            if (_exists(tokenId) && available(tokenId)) {\n                expirationTime[tokenId] = ~uint(0);\n                _burn(tokenId);\n                expirationTime[tokenId] = 0;\n\n                label = bytes32(tokenId);\n                rns.setSubnodeOwner(rootNode, label, address(0));\n            }\n        }\n    }\n}\n",
  "imports": [
    {
      "name": "RSKOwner.sol",
      "contents": "pragma solidity ^0.5.3;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/access/Roles.sol\";\nimport \"./testing/TokenDeed.sol\";\nimport \"./testing/AbstractRNS.sol\";\nimport \"./testing/TokenRegistrar.sol\";\n\ncontract RSKOwner is ERC721, Ownable {\n    using Roles for Roles.Role;\n\n    TokenRegistrar private previousRegistrar;\n    AbstractRNS private rns;\n    bytes32 private rootNode;\n\n    mapping (uint256 => uint) public expirationTime;\n\n    event ExpirationChanged(uint256 tokenId, uint expirationTime);\n\n    modifier onlyPreviousRegistrar {\n        require(msg.sender == address(previousRegistrar), \"Only previous registrar.\");\n        _;\n    }\n\n    modifier onlyRegistrar {\n        require(registrars.has(msg.sender), \"Only registrar.\");\n        _;\n    }\n\n    modifier onlyRenewer {\n        require(renewers.has(msg.sender), \"Only renewer.\");\n        _;\n    }\n\n    constructor (\n        TokenRegistrar _previousRegistrar,\n        AbstractRNS _rns,\n        bytes32 _rootNode\n    ) public {\n        previousRegistrar = _previousRegistrar;\n        rns = _rns;\n        rootNode = _rootNode;\n    }\n\n    /// @notice Gets the owner of the specified domain.\n    /// @param tokenId keccak256 of the domain label.\n    /// @return domain owner.\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        require(expirationTime[tokenId] > now, \"ERC721: owner query for nonexistent token\");\n        return super.ownerOf(tokenId);\n    }\n\n    /// @notice Check if a domain is available to be registered.\n    /// @dev The name must be registered via account with registrar role.\n    /// @param tokenId keccak256 of the domain label.\n    /// @return true if the specified domain can be registered.\n    function available(uint256 tokenId) public view returns(bool) {\n        return (\n            expirationTime[tokenId] < now &&\n            previousRegistrar.state(bytes32(tokenId)) != TokenRegistrar.Mode.Owned\n        );\n    }\n\n    ///////////////////\n    // RSK TLD ADMIN //\n    ///////////////////\n\n    /*\n        This contract owns a node in RNS, so it is capable to\n        change it's resolution and ttl.\n    */\n\n    /// @notice set root node resolver in RNS.\n    /// @param resolver to be set.\n    function setRootResolver (address resolver) external onlyOwner {\n        rns.setResolver(rootNode, resolver);\n    }\n\n    /// @notice set root node ttl in RNS.\n    /// @param ttl to be set.\n    function setRootTTL (uint64 ttl) external onlyOwner {\n        rns.setTTL(rootNode, ttl);\n    }\n\n    ///////////////////////\n    // AUCTION MIGRATION //\n    ///////////////////////\n\n    /*\n        A domain registered with previous registrar (auction)\n        should be transfered before it can be renewed. If the\n        domain is not transfered and it expires, it might be\n        registered by someone else.\n    */\n\n    /// @notice Accept domain transfer from previous registrar.\n    /// @dev Use it via tokenRegistrar.trnasferRegistrars(label).\n    /// All locked tokens in Deed are returned.\n    /// @param label Accepted domain label.\n    /// @param deed Deed contract address holding tokens.\n    function acceptRegistrarTransfer(bytes32 label, TokenDeed deed, uint) external onlyPreviousRegistrar {\n        uint256 tokenId = uint256(label);\n        expirationTime[tokenId] = deed.expirationDate();\n        _mint(deed.owner(), tokenId);\n        deed.closeDeed(1000);\n    }\n\n    //////////////////\n    // REGISTRATION //\n    //////////////////\n\n    /*\n        Only available domains can be registered. Once a domain is\n        registered, it cannot be revoked until expiration.\n    */\n\n    // An account with registrar role can register domains.\n    Roles.Role registrars;\n\n    /// @notice Give an account access to registrar role.\n    /// @dev Only owner.\n    /// @param registrar new registrar.\n    function addRegistrar(address registrar) external onlyOwner {\n        registrars.add(registrar);\n    }\n\n    /// @notice Check if an account has registrar role.\n    /// @param registrar to query if has registrar role.\n    /// @return true if it has registrar role.\n    function isRegistrar(address registrar) external view returns (bool) {\n        return registrars.has(registrar);\n    }\n\n    /// @notice Remove an account's access to registrar role.\n    /// @dev Only owner\n    /// @param registrar registrar to remove from registrar role.\n    function removeRegistrar(address registrar) external onlyOwner {\n        registrars.remove(registrar);\n    }\n\n    /// @notice Registers a domain in RNS for a given duration.\n    /// @dev Only accounts with registrar role.\n    /// @param label keccak256 of the domain label to register.\n    /// @param tokenOwner account that will own the registered domain.\n    /// @param duration time to register the domain for.\n    function register(bytes32 label, address tokenOwner, uint duration) external onlyRegistrar {\n        uint256 tokenId = uint256(label);\n\n        require(available(tokenId), \"Not available\");\n\n        uint newExpirationTime = now.add(duration);\n        expirationTime[tokenId] = newExpirationTime;\n        emit ExpirationChanged(tokenId, newExpirationTime);\n\n        if (_exists(tokenId))\n            _burn(tokenId);\n\n        _mint(tokenOwner, tokenId);\n\n        rns.setSubnodeOwner(rootNode, label, tokenOwner);\n    }\n\n    ////////////////\n    // RECLAIMING //\n    ////////////////\n\n    /*\n        Names might be lost by transferring to contracts, or by\n        error. This allows any owner (or approved) to reclaim the\n        domain ownership in RNS.\n    */\n\n    /// @notice Reclaim ownership of a domain in RNS.\n    /// @dev Only owner or approved for the domain.\n    /// @param tokenId keccak256 of the domain\n    /// @param newOwner the owner to set in RNS.\n    function reclaim(uint256 tokenId, address newOwner) external {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"Not approved or owner\");\n        rns.setSubnodeOwner(rootNode, bytes32(tokenId), newOwner);\n    }\n\n    ////////////////\n    // RENOVATION //\n    ////////////////\n\n    /*\n        Only owned domains can be renewed. A renovation extends\n        domain ownership.\n    */\n\n    // An account with renewer role can extend domain expirations.\n    Roles.Role renewers;\n\n    /// @notice Give an account access to renewer role.\n    /// @dev Only owner\n    /// @param renewer new renewer.\n    function addRenewer(address renewer) external onlyOwner {\n        renewers.add(renewer);\n    }\n\n    /// @notice Check if an account has renewer role.\n    /// @param renewer to query if has renewer role.\n    /// @return true if it has renewer role.\n    function isRenewer(address renewer) external view returns (bool) {\n        return renewers.has(renewer);\n    }\n\n    /// @notice Remove an account's access to renewer role.\n    /// @dev Only owner\n    /// @param renewer renewer to remove from renewer role.\n    function removeRenewer(address renewer) external onlyOwner {\n        renewers.remove(renewer);\n    }\n\n    /// @notice Renew a domain for a given duraiton.\n    /// @dev Only accounts with renewer role.\n    /// @param label keccak256 of the domain label to renew.\n    /// @param time to extend the duration for.\n    function renew (bytes32 label, uint time) external onlyRenewer {\n        uint256 tokenId = uint256(label);\n        require(expirationTime[tokenId] > now, \"Name already expired\");\n        uint newExpirationTime = expirationTime[tokenId].add(time);\n        expirationTime[tokenId] = newExpirationTime;\n        emit ExpirationChanged(tokenId, newExpirationTime);\n    }\n\n    //////////////////////\n    // AFTER EXPIRATION //\n    //////////////////////\n\n    /// @notice This method removes expired domains.\n    /// @dev Use this to set 0 address in RNS ownership\n    /// and burn the domains to keep balance up to date.\n    /// @param tokenIds keccak256s of the domain labels to remove.\n    function removeExpired(uint256[] calldata tokenIds) external {\n        uint256 tokenId;\n        bytes32 label;\n\n        for (uint i = 0; i < tokenIds.length; i++) {\n            tokenId = tokenIds[i];\n\n            if (_exists(tokenId) && available(tokenId)) {\n                expirationTime[tokenId] = ~uint(0);\n                _burn(tokenId);\n                expirationTime[tokenId] = 0;\n\n                label = bytes32(tokenId);\n                rns.setSubnodeOwner(rootNode, label, address(0));\n            }\n        }\n    }\n}\n",
      "file": "RSKOwner.sol"
    },
    {
      "name": "AbstractRNS.sol",
      "contents": "pragma solidity ^0.5.3;\n\n// Used only for testing reasons\n\ncontract AbstractRNS {\n    function owner(bytes32 node) public view returns(address);\n    function resolver(bytes32 node) public view returns(address);\n    function ttl(bytes32 node) public view returns(uint64);\n    function setOwner(bytes32 node, address ownerAddress) public;\n    function setSubnodeOwner(bytes32 node, bytes32 label, address ownerAddress) public;\n    function setResolver(bytes32 node, address resolverAddress) public;\n    function setTTL(bytes32 node, uint64 ttlValue) public;\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address ownerAddress);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address ownerAddress);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolverAddress);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttlValue);\n}\n"
    },
    {
      "name": "TokenDeed.sol",
      "contents": "pragma solidity ^0.5.3;\n\nimport './ERC677TokenContract.sol';\n\n// Used only for testing reasons\n\n// See https://github.com/ethereum/EIPs/issues/677\n\n/**\n * @title Deed to hold RIF tokens in exchange for ownership of a node\n *\n * @dev The deed can be controlled only by the registrar and can only send tokens back to the owner.\n */\ncontract TokenDeed {\n\n    address payable constant RESOURCE_POOL_ADDRESS = 0xE594DF49AA7a13ccdD2dB3A7917312E02374f744;\n    uint constant RENT_PAYMENT_TIME = 3 * 30 days; // 3 months\n    uint constant VALIDITY = 365 days; // 1 year\n\n    address public registrar;\n    address public owner;\n    address public previousOwner;\n\n    uint public creationDate;\n    uint public expirationDate;\n\tuint public tokenQuantity;\n\n\tERC677TokenContract public tokenContract;\n\n    bool active;\n\n    event OwnerChanged(address newOwner);\n    event DeedClosed();\n\n    modifier onlyRegistrar {\n        require(msg.sender == registrar);\n        _;\n    }\n\n    modifier onlyActive {\n        require(active);\n        _;\n    }\n\n    /** \n     * @dev Constructor for a TokenDeed\n     *\n     * @param _owner The deed's owner\n     * @param _tokenQuantity Amount of tokens locked in the Deed\n     * @param _tokenContract Address of the contract which handles tokens\n    **/\n    constructor(address _owner, uint _tokenQuantity, ERC677TokenContract _tokenContract) public {\n        owner = _owner;\n        registrar = msg.sender;\n        creationDate = now;\n        expirationDate = 0;\n        active = true;\n        tokenQuantity = _tokenQuantity;\n        tokenContract = _tokenContract;\n    }\n\n    function setOwner(address newOwner) public onlyRegistrar {\n        require(newOwner != address(0));\n        previousOwner = owner;  // This allows contracts to check who sent them the ownership\n        owner = newOwner;\n        emit OwnerChanged(newOwner);\n    }\n\n    function setRegistrar(address newRegistrar) public onlyRegistrar {\n        registrar = newRegistrar;\n    }\n\n    /** \n     * @dev Sets the Deed's new balance, returning the difference to the owner\n     *\n     * The new balance MUST be lower or equal than the current one\n     *\n     * @param newTokenQuantity The new balance in tokens\n     * @param throwOnFailure Flag to indicate if the token transference should throw or not\n    **/\n    function setBalance(uint newTokenQuantity, bool throwOnFailure) public onlyRegistrar onlyActive {\n        // Check if it has enough balance to set the value\n        require(tokenQuantity >= newTokenQuantity);\n        uint diffTokenQuantity = tokenQuantity - newTokenQuantity;\n        tokenQuantity = newTokenQuantity;\n        // Send the difference to the owner\n        require(tokenContract.transfer(owner, diffTokenQuantity) || !throwOnFailure);\n    }\n\n    /** \n     * @dev Computes and sets the expirationDate from a given date, starting the vigency period\n     *\n     * @param startDate Date to calculate the expirationDate from\n     * @param rentValue The value of the initial rent fee to pay in tokens\n    **/\n    function startExpiration(uint startDate, uint rentValue) public onlyRegistrar onlyActive {\n        require(expirationDate == 0 && startDate <= now); // require expiration hasn't started\n        require(rentValue <= tokenQuantity);\n\n        expirationDate = startDate + VALIDITY;\n\n        // transfer the fee to the resource pool address\n        tokenQuantity = tokenQuantity - rentValue;\n        require(tokenContract.transfer(RESOURCE_POOL_ADDRESS, rentValue));\n    }\n\n    /** \n     * @dev Pay the Deed's rent, thus extending the expirationDate and the vigency period\n     *\n     * Can only be called when the current date falls within the payment period (3 months)\n     *\n     * @param rentValue The value to pay in tokens\n    **/\n    function payRent(uint rentValue) public onlyRegistrar onlyActive returns(bool) {\n        require(canPayRent());\n        \n        require(tokenContract.transfer(RESOURCE_POOL_ADDRESS, rentValue));\n\n        expirationDate = expirationDate + VALIDITY;\n\n        return true;\n    }\n\n    /** \n     * @dev Returns wheter the current date falls within the Deed's rent payment period\n    **/\n    function canPayRent() public view returns(bool) {\n        return expirationDate - RENT_PAYMENT_TIME <= now && now <= expirationDate;\n    }\n\n\n    /** \n     * @dev Returns wether the Deed is expired or not\n    **/\n    function expired() public view returns(bool) {\n        return 0 < expirationDate && expirationDate < now;\n    }\n\n    /**\n     * @dev Close a deed and refund a specified fraction of the bid value\n     *\n     * @param refundRatio The amount*1/1000 to refund in tokens\n     */\n    function closeDeed(uint refundRatio) public onlyRegistrar onlyActive {\n        refundAndDestroy(refundRatio);\n    }\n\n    /** \n     * @dev Close an expired deed. No funds are returned\n    **/\n    function closeExpiredDeed() public onlyActive {\n        require(expired(), \"Deed should be expired\");\n        refundAndDestroy(0);\n    }\n\n    /** \n     * @dev Internal method which handles fund returns/burning and the Deed's destruction\n     *\n     * @param refundRatio The amount*1/1000 to refund in tokens\n    **/\n    function refundAndDestroy(uint refundRatio) private onlyActive {\n        require(refundRatio <= 1000);\n\n        active = false;\n        uint torefund = (1000 - refundRatio) * tokenQuantity / 1000;\n        require(tokenContract.transfer(RESOURCE_POOL_ADDRESS, torefund));\n        tokenQuantity -= torefund;\n        emit DeedClosed();\n        destroyDeed();\n    }\n\n    /**\n     * @dev Close a deed and refund a specified fraction of the bid value\n     */\n    function destroyDeed() private {\n        require(!active);\n\n        if (tokenContract.transfer(owner, tokenQuantity)) {\n            selfdestruct(RESOURCE_POOL_ADDRESS);\n        }\n    }\n\n    function tokenFallback(address from, uint256 amount, bytes memory data) public returns (bool) {\n        return true;\n    }\n}\n"
    },
    {
      "name": "TokenRegistrar.sol",
      "contents": "pragma solidity ^0.5.3;\n\n\n/*\n\nTemporary Hash Registrar\n========================\n\nThis is a simplified version of a hash registrar. It is purporsefully limited:\nnames cannot be six letters or shorter, new auctions will stop after 4 years.\n\nThe plan is to test the basic features and then move to a new contract in at most\n2 years, when some sort of renewal mechanism will be enabled.\n\nRefund schedule\n===============\n\nCase A: Reveal Period\n------------------------------------------------------------------------------------\n| (I) Auction winner | Funds are locked in Deed. 80% are returned on Deed release  |\n------------------------------------------------------------------------------------\n| (II) Auction losser | 100% refund over the losing bid                            |\n------------------------------------------------------------------------------------\n\nCase B: Late-Reveal Period (2 weeks after auction finish)\n---------------------------------------------------------------------------------------------------\n| (I) Bid that would have won                 | 20% taken as fee                                  |\n---------------------------------------------------------------------------------------------------\n| (II) Bid that would have affected 2nd place | Difference with the actual 2nd place taken as fee |\n---------------------------------------------------------------------------------------------------\n| (III) Otherwise                             | 0.5% taken as fee                                 |\n---------------------------------------------------------------------------------------------------\n\nCase C: Any bid unsealed beyond the Late-Reveal period won't be refunded\n*/\n\n\nimport './TokenDeed.sol';\nimport './RNS.sol';\nimport './ERC677TokenContract.sol';\n\n// Used only for testing reasons\n\n/**\n * @title TokenRegistrar\n * @dev The registrar handles the auction process for each subnode of the node it owns.\n */\ncontract TokenRegistrar {\n    using SafeMath for uint256;\n\n    RNS public rns;\n    bytes32 public rootNode;\n\tERC677TokenContract public tokenContract;\n\n    mapping (bytes32 => Entry) _entries;\n    mapping (address => mapping (bytes32 => TokenDeed)) public sealedBids;\n\n    enum Mode { Open, Auction, Owned, Forbidden, Reveal }\n\n    bytes4 constant SIGN_NEW_BID = 0x1413151f;  // sha3('newBidWithToken(address,uint256,bytes32)')\n    bytes4 constant SIGN_PAY_RENT = 0xe1ac9915; // sha3('payRentWithToken(address,uint256,bytes32)')\n    uint32 constant TOTAL_AUCTION_LENGTH = 5 days;\n    uint32 constant REVEAL_PERIOD = 48 hours;\n    uint32 constant LATE_UNSEAL_PERIOD = 15 days;\n    uint constant RELEASE_FEE_PER_MIL = 200;    // 200 of 1000 = 20%\n    uint constant MIN_TOKEN_QUANTITY = 1 * 10**18;  // 1 token\n    uint constant RENT_VALUE = 1 * 10**18;  // 1 token\n\n    event AuctionStarted(bytes32 indexed hash, uint registrationDate);\n    event NewBid(bytes32 indexed hash, address indexed bidder, uint deposit);\n    event BidRevealed(bytes32 indexed hash, address indexed owner, uint value, uint8 status);\n    event HashRegistered(bytes32 indexed hash, address indexed owner, uint value, uint registrationDate);\n    event HashReleased(bytes32 indexed hash, uint value);\n\n    struct Entry {\n        TokenDeed deed;\n        uint registrationDate;\n        uint value;\n        uint highestBid;\n    }\n\n    modifier inState(bytes32 _hash, Mode _state) {\n        require(state(_hash) == _state);\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _hash) {\n        require(state(_hash) == Mode.Owned && msg.sender == _entries[_hash].deed.owner());\n        _;\n    }\n\n    modifier registryOpen() {\n        require(rns.owner(rootNode) == address(this));\n        _;\n    }\n\n    /**\n     * @dev Constructs a new Registrar, with the provided address as the owner of the root node.\n     *\n     * @param _rns The address of the RNS\n     * @param _rootNode The hash of the rootnode.\n     * @param _tokenAddr The ERC677 contract address to handle tokens\n     */\n    constructor(RNS _rns, bytes32 _rootNode, ERC677TokenContract _tokenAddr) public {\n        rns = _rns;\n        rootNode = _rootNode;\n        tokenContract = _tokenAddr;\n    }\n\n    /**\n     * @dev Start an auction for an available hash\n     *\n     * @param _hash The hash to start an auction on\n     */\n    function startAuction(bytes32 _hash) public registryOpen() {\n        Mode mode = state(_hash);\n        if (mode == Mode.Auction) return;\n        require(mode == Mode.Open);\n\n        Entry storage newAuction = _entries[_hash];\n        newAuction.registrationDate = now + TOTAL_AUCTION_LENGTH;\n        newAuction.value = 0;\n        newAuction.highestBid = 0;\n        newAuction.deed = TokenDeed(0);\n\n        emit AuctionStarted(_hash, newAuction.registrationDate);\n    }\n\n    /**\n     * @dev Start multiple auctions for better anonymity\n     *\n     * Anyone can start an auction by sending an array of hashes that they want to bid for.\n     * Arrays are sent so that someone can open up an auction for X dummy hashes when they\n     * are only really interested in bidding for one. This will increase the cost for an\n     * attacker to simply bid blindly on all new auctions. Dummy auctions that are\n     * open but not bid on are closed after a week.\n     *\n     * @param _hashes An array of hashes, at least one of which you presumably want to bid on\n     */\n    function startAuctions(bytes32[] memory _hashes) public {\n        for (uint i = 0; i < _hashes.length; i ++) {\n            startAuction(_hashes[i]);\n        }\n    }\n\n    /**\n     * @dev Submit a new sealed bid on a desired hash in a blind auction\n     *\n     * Bids are sent by sending a message to the main contract with a hash and an amount. The hash\n     * contains information about the bid, including the bidded hash, the bid amount, and a random\n     * salt. Bids are not tied to any one auction until they are revealed. The value of the bid\n     * itself can be masqueraded by sending more than the value of your actual bid. This is\n     * followed by a 48h reveal period. For bids revealed after this period, a percentage (defined in the late unsealing \n     * Refund schedule) will be sent to a special resource pool address.\n     * Since this is an auction, it is expected that most public hashes, like known domains and common dictionary\n     * words, will have multiple bidders pushing the price up.\n     *\n     * This method requires the sender to approve the Registrar to use the specified tokenQuantity in the ERC677 contract.\n     * Otherwise it can be done through the tokenFallback after a transfer with the corresponding parameters\n     *\n     * @param _sealedBid A sealedBid, created by the shaBid function\n     * @param _tokenQuantity token quantity to bid\n     */\n    function newBid(bytes32 _sealedBid, uint _tokenQuantity) public {\n        require(tokenContract.transferFrom(msg.sender, address(this), _tokenQuantity));\n\n        newBidAfterTransfer(msg.sender, _tokenQuantity, _sealedBid);\n    }\n\n    /**\n     * @dev Method to be called through a dynamic invocation from an ERC677 token contract\n     *\n     * @param _from Address sending the tokens as well as submitting the bid\n     * @param _tokenQuantity Amount in tokens received throuh the transference\n     * @param _sealedBid Sealed bid, created through the shaBid function\n    **/\n    function newBidWithToken(address _from, uint _tokenQuantity, bytes32 _sealedBid) public {\n        require(msg.sender == address(tokenContract));\n        newBidAfterTransfer(_from, _tokenQuantity, _sealedBid);\n    }\n\n    /**\n     * @dev Internal method which handles the new bidding logic\n     *\n     * @param _from Address sending the tokens as well as submitting the bid\n     * @param _tokenQuantity Amount in tokens received through the transference. To be used to mask the actual bidded value\n     * @param _sealedBid Sealed bid, created through the shaBid function\n    **/\n    function newBidAfterTransfer(address _from, uint _tokenQuantity, bytes32 _sealedBid) private {\n        require(address(sealedBids[_from][_sealedBid]) == address(0));\n\n        // Creates a new hash contract with the owner\n        TokenDeed createdBid = new TokenDeed(_from, _tokenQuantity, tokenContract);\n        require(tokenContract.transfer(address(createdBid), _tokenQuantity));\n        sealedBids[_from][_sealedBid] = createdBid;\n\n        emit NewBid(_sealedBid, _from, _tokenQuantity);\n    }\n\n    /**\n     * @dev Start a set of auctions and bid on one of them\n     *\n     * This method functions identically to calling `startAuctions` followed by `newBid`,\n     * but all in one transaction.\n     *\n     * @param _hashes A list of hashes to start auctions on.\n     * @param _sealedBid A sealed bid for one of the auctions.\n     * @param _tokenQuantity Amount of tokens to mask the bid with.\n     */\n    function startAuctionsAndBid(bytes32[] memory _hashes, bytes32 _sealedBid, uint _tokenQuantity) public payable {\n        startAuctions(_hashes);\n        newBid(_sealedBid, _tokenQuantity);\n    }\n\n    /**\n     * @dev Submit the properties of a bid to reveal them\n     *\n     * @param _hash The node in the sealedBid\n     * @param _value The bid amount in the sealedBid\n     * @param _salt The sale in the sealedBid\n     */\n    function unsealBid(bytes32 _hash, uint _value, bytes32 _salt) public {\n        bytes32 seal = shaBid(_hash, msg.sender, _value, _salt);\n        TokenDeed bid = sealedBids[msg.sender][seal];\n        require(address(bid) != address(0));\n\n        sealedBids[msg.sender][seal] = TokenDeed(0);\n        Entry storage h = _entries[_hash];\n        uint value = min(_value, bid.tokenQuantity());\n        bid.setBalance(value, true);\n\n        Mode auctionState = state(_hash);\n\n        if (auctionState == Mode.Owned) {\n            // By this point the auction has ended. The refund values are defined in the above Refund Schedule\n\n            uint256 refundRatio = 995; // See: Case B)III\n\n            if (h.registrationDate + LATE_UNSEAL_PERIOD < now) {\n                refundRatio = 0; // See: Case C\n            } else {\n                if (value > h.highestBid) {\n                    refundRatio = 800; // See: Case B)I\n                } else if (value > h.value) {\n                    // See: Case B)II\n                    // Compute percentage corresponding to the difference between the actual 2nd place (h.value)\n                    // and the late unsealed bid (value)\n                    refundRatio = h.value.mul(1000).div(value);\n                }\n            }\n\n            bid.closeDeed(refundRatio);\n            emit BidRevealed(_hash, msg.sender, value, 1);\n        } else if (auctionState != Mode.Reveal) {\n            // invalid phase for unsealing\n            revert();\n        } else if (value < MIN_TOKEN_QUANTITY || bid.creationDate() > h.registrationDate - REVEAL_PERIOD) {\n            // Bid below the minimum or too late (created in the reveal period)\n            bid.closeDeed(1000);\n            emit BidRevealed(_hash, msg.sender, value, 0);\n        } else if (value > h.highestBid) {\n            // New winner\n            // Cancel the other bid\n            if (address(h.deed) != address(0)) {\n                TokenDeed previousWinner = h.deed;\n                previousWinner.closeDeed(1000);\n            }\n\n            // Set new winner\n            // Per the rules of a vickery auction, the value becomes the previous highestBid\n            h.value = h.highestBid;  // will be zero if there's only 1 bidder\n            h.highestBid = value;\n            h.deed = bid;\n            emit BidRevealed(_hash, msg.sender, value, 2);\n        } else if (value > h.value) {\n            // Not winner, but affects second place\n            h.value = value;\n            bid.closeDeed(1000);\n            emit BidRevealed(_hash, msg.sender, value, 3);\n        } else {\n            // Bid doesn't affect auction\n            bid.closeDeed(1000);\n            emit BidRevealed(_hash, msg.sender, value, 4);\n        }\n    }\n\n    /**\n     * @dev Finalize an auction after the registration date has passed\n     *\n     * Updates the Registry to reflect the new node owner. Starts the winning Deed's expiration period.\n     *\n     * @param _hash The hash of the name the auction is for\n     */\n    function finalizeAuction(bytes32 _hash) public onlyOwner(_hash) {\n        Entry storage h = _entries[_hash];\n\n        // Handles the case when there's only a single bidder (h.value is zero)\n        h.value = max(h.value, MIN_TOKEN_QUANTITY);\n        h.deed.setBalance(h.value, true);\n        h.deed.startExpiration(h.registrationDate, RENT_VALUE);\n\n        trySetSubnodeOwner(_hash, h.deed.owner());\n        emit HashRegistered(_hash, h.deed.owner(), h.value, h.registrationDate);\n    }\n\n    /**\n     * @dev The owner of a domain may transfer it to someone else at any time.\n     *\n     * @param _hash The node to transfer\n     * @param _newOwner The address to transfer ownership to\n     */\n    function transfer(bytes32 _hash, address _newOwner) public onlyOwner(_hash) {\n        require(_newOwner != address(0));\n\n        Entry storage h = _entries[_hash];\n        h.deed.setOwner(_newOwner);\n        trySetSubnodeOwner(_hash, _newOwner);\n    }\n\n    /**\n     * @dev After some time, or if we're no longer the registrar, the owner can release\n     *      the name and get a part of their tokens back.\n     *\n     * The allowed release period is within the rent payment period, which starts 3 months before the expiration date\n     *\n     * @param _hash The node to release\n     */\n    function releaseDeed(bytes32 _hash) public onlyOwner(_hash) {\n        Entry storage h = _entries[_hash];\n        TokenDeed deedContract = h.deed;\n\n        require(now < deedContract.expirationDate() || rns.owner(rootNode) != address(this));\n\n        h.value = 0;\n        h.highestBid = 0;\n        h.deed = TokenDeed(0);\n\n        _tryEraseSingleNode(_hash);\n\n        // return funds after deducting a fee and close the deed\n        deedContract.closeDeed(1000 - RELEASE_FEE_PER_MIL);\n\n        emit HashReleased(_hash, h.value);\n    }\n\n    /**\n     * @dev Allows anyone to delete the owner and resolver records for a (subdomain of) a\n     *      name that is not currently owned in the registrar. If passing, eg, 'foo.bar.rsk',\n     *      the owner and resolver fields on 'foo.bar.rsk' and 'bar.rsk' will all be cleared.\n     *\n     * @param _labels A series of label hashes identifying the name to zero out, rooted at the\n     *        registrar's root. Must contain at least one element. For instance, to zero\n     *        'foo.bar.rsk' on a registrar that owns '.rsk', pass an array containing\n     *        [keccak256('foo'), keccak256('bar')].\n     */\n    function eraseNode(bytes32[] memory _labels) public {\n        require(_labels.length != 0);\n        require(state(_labels[_labels.length - 1]) != Mode.Owned);\n\n        _eraseNodeHierarchy(_labels.length - 1, _labels, rootNode);\n    }\n\n    /**\n     * @dev Transfers the deed to the current registrar, if different from this one.\n     *\n     * Used during the upgrade process to a permanent registrar.\n     *\n     * @param _hash The name hash to transfer.\n     */\n    function transferRegistrars(bytes32 _hash) public onlyOwner(_hash) {\n        address registrar = rns.owner(rootNode);\n        require(registrar != address(this));\n\n        // Migrate the deed\n        Entry storage h = _entries[_hash];\n        h.deed.setRegistrar(registrar);\n\n        // Call the new registrar to accept the transfer\n        TokenRegistrar(registrar).acceptRegistrarTransfer(_hash, h.deed, h.registrationDate);\n\n        // Zero out the Entry\n        h.deed = TokenDeed(0);\n        h.registrationDate = 0;\n        h.value = 0;\n        h.highestBid = 0;\n    }\n\n    /**\n     * @dev Pay the yearly rent for a name\n     *\n     * Names have a vigency of 1 year after the registration date. Said expiry date is reflected through the associated Deed \n     * contract. Owners have a period of 3 months before the expiryDate to pay the rent and extend their ownership for 1 year\n     *\n     * @param _hash The hash of the name to pay the rent for\n     */\n    function payRent(bytes32 _hash) public {\n        require(tokenContract.transferFrom(msg.sender, address(this), RENT_VALUE));\n        payRentAfterTransfer(_hash);\n    }\n\n    /**\n     * @dev Method to be called through a dynamic invocation from an ERC677 token contract\n     *\n     * @param _from Address sending the tokens as well as submitting the bid\n     * @param _tokenQuantity Amount in tokens received throuh the transference\n     * @param _hash Hash of the name to pay the rent for\n    **/\n    function payRentWithToken(address _from, uint _tokenQuantity, bytes32 _hash) public {\n        require(_tokenQuantity == RENT_VALUE);\n        require(msg.sender == address(tokenContract));\n        payRentAfterTransfer(_hash);\n    }\n\n    /**\n     * @dev Internal method which handles the rent payment logic\n     *\n     * @param _hash Hash of the name to pay the rent for\n    **/\n    function payRentAfterTransfer(bytes32 _hash) private {\n        require(state(_hash) == Mode.Owned);\n\n        Entry storage h = _entries[_hash];\n\n        require(address(h.deed) != address(0));\n\n        require(tokenContract.transfer(address(h.deed), RENT_VALUE));\n        require(h.deed.payRent(RENT_VALUE));\n    }\n\n    /**\n     * @dev Accepts a transfer from a previous registrar; stubbed out here since there\n     *      is no previous registrar implementing this interface.\n     *\n     * @param _hash The sha3 hash of the label to transfer.\n     * @param _deed The TokenDeed object for the name being transferred in.\n     * @param _registrationDate The date at which the name was originally registered.\n     */\n    function acceptRegistrarTransfer(bytes32 _hash, TokenDeed _deed, uint _registrationDate) public {\n        _hash; _deed; _registrationDate; // Don't warn about unused variables\n    }\n\n    // State transitions for names:\n    //   Open -> Auction (startAuction)\n    //   Auction -> Reveal\n    //   Reveal -> Owned\n    //   Reveal -> Open (if nobody bid)\n    //   Owned -> Open (releaseDeed or the deed has expired)\n    function state(bytes32 _hash) public view returns (Mode) {\n        Entry storage entry = _entries[_hash];\n\n        if (now < entry.registrationDate) {\n            if (now < entry.registrationDate - REVEAL_PERIOD) {\n                return Mode.Auction;\n            } else {\n                return Mode.Reveal;\n            }\n        } else {\n            // there may not be any bid (not yet auctioned) or there is and it may have already expired (Expired)\n            if (entry.highestBid == 0 || entry.deed.expired()) {\n                return Mode.Open;\n            } else {\n                return Mode.Owned;\n            }\n        }\n    }\n\n    /**\n     * @dev Returns information related to a certain name\n     *\n     * @param _hash Hash of the name to query about\n    **/\n    function entries(bytes32 _hash) public view returns (Mode, address, uint, uint, uint) {\n        Entry storage h = _entries[_hash];\n        return (state(_hash), address(h.deed), h.registrationDate, h.value, h.highestBid);\n    }\n\n    /**\n     * @dev Hash the values required for a secret bid\n     *\n     * @param _hash The node corresponding to the desired namehash\n     * @param _value The bid amount in tokens\n     * @param _salt A random value to ensure secrecy of the bid\n     * @return The hash of the bid values\n     */\n    function shaBid(bytes32 _hash, address _owner, uint _value, bytes32 _salt) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_hash, _owner, _value, _salt));\n    }\n\n    function _tryEraseSingleNode(bytes32 _label) internal {\n        if (rns.owner(rootNode) == address(this)) {\n            rns.setSubnodeOwner(rootNode, _label, address(this));\n            bytes32 node = keccak256(abi.encodePacked(rootNode, _label));\n            rns.setResolver(node, address(0));\n            rns.setOwner(node, address(0));\n        }\n    }\n\n    function _eraseNodeHierarchy(uint _idx, bytes32[] memory _labels, bytes32 _node) internal {\n        // Take ownership of the node\n        rns.setSubnodeOwner(_node, _labels[_idx], address(this));\n        _node = keccak256(abi.encodePacked(_node, _labels[_idx]));\n\n        // Recurse if there are more labels\n        if (_idx > 0) {\n            _eraseNodeHierarchy(_idx - 1, _labels, _node);\n        }\n\n        // Erase the resolver and owner records\n        rns.setResolver(_node, address(0));\n        rns.setOwner(_node, address(0));\n    }\n\n    /**\n     * @dev Assign the owner in RNS, if we're still the registrar\n     *\n     * @param _hash hash to change owner\n     * @param _newOwner new owner to transfer to\n     */\n    function trySetSubnodeOwner(bytes32 _hash, address _newOwner) internal {\n        if (rns.owner(rootNode) == address(this))\n            rns.setSubnodeOwner(rootNode, _hash, _newOwner);\n    }\n\n    /**\n     * @dev Returns the maximum of two unsigned integers\n     *\n     * @param a A number to compare\n     * @param b A number to compare\n     * @return The maximum of two unsigned integers\n     */\n    function max(uint a, uint b) internal pure returns (uint) {\n        if (a > b)\n            return a;\n        else\n            return b;\n    }\n\n    /**\n     * @dev Returns the minimum of two unsigned integers\n     *\n     * @param a A number to compare\n     * @param b A number to compare\n     * @return The minimum of two unsigned integers\n     */\n    function min(uint a, uint b) internal pure returns (uint) {\n        if (a < b)\n            return a;\n        else\n            return b;\n    }\n\n    /**\n     * @dev Fallback function to be called when the contract receives a transference through an ERC677 contract\n     *\n     * Functions supported:\n     * - newBidWithToken (signature 0x1413151f) with a 32 byte parameter (sealedBid to submit)\n     * - payRentWithToken (signature 0xe1ac9915) with a 32 byte parameter (hash of the name to pay the rent for)\n     *\n     * @param _from Address which sent the tokens\n     * @param _value Amount of tokens sent\n     * @param _data Byte array with information of which function to call and the parameters used for the invocation\n    **/\n    function tokenFallback(address _from, uint256 _value, bytes memory _data) public returns (bool) {\n        if (_data.length < 4) return true;\n\n        require(msg.sender == address(tokenContract));\n\n        bytes4 signature =  bytesToBytes4(_data, 0);\n\n        if (signature == SIGN_NEW_BID) {\n            bytes32 sealedBid = bytesToBytes32(_data, 4);\n\n            newBidWithToken(_from, _value, sealedBid);\n        } else if (signature == SIGN_PAY_RENT) {\n            bytes32 name = bytesToBytes32(_data, 4);\n\n            payRentWithToken(_from, _value, name);\n        } else {\n            revert();\n        }\n\n        return true;\n    }\n\n    function bytesToBytes4(bytes memory _b, uint _offset) private pure returns (bytes4) {\n        bytes4 out;\n\n        for (uint i = 0; i < 4; i++) {\n            out |= bytes4(_b[_offset + i] & 0xFF) >> (i * 8);\n        }\n\n        return out;\n    }\n\n    /**\n     * @dev Given a byte array and a given offset, extract the following 32 bytes into an array\n     *\n     * from https://ethereum.stackexchange.com/questions/7702/how-to-convert-byte-array-to-bytes32-in-solidity\n    **/\n    function bytesToBytes32(bytes memory _b, uint _offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        for (uint i = 0; i < 32; i++) {\n            out |= bytes32(_b[_offset + i] & 0xFF) >> (i * 8);\n        }\n\n        return out;\n    }\n}\n"
    },
    {
      "name": "Roles.sol",
      "contents": "pragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n"
    },
    {
      "name": "Context.sol",
      "contents": "pragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    {
      "name": "SafeMath.sol",
      "contents": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    {
      "name": "Ownable.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    {
      "name": "ERC721.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../drafts/Counters.sol\";\nimport \"../../introspection/ERC165.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is Context, ERC165, IERC721 {\n    using SafeMath for uint256;\n    using Address for address;\n    using Counters for Counters.Counter;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from token ID to owner\n    mapping (uint256 => address) private _tokenOwner;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping (address => Counters.Counter) private _ownedTokensCount;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    constructor () public {\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner address to query the balance of\n     * @return uint256 representing the amount owned by the passed address\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n\n        return _ownedTokensCount[owner].current();\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _tokenOwner[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n\n        return owner;\n    }\n\n    /**\n     * @dev Approves another address to transfer the given token ID\n     * The zero address indicates there is no approved address.\n     * There can only be one approved address per token at a given time.\n     * Can only be called by the token owner or an approved operator.\n     * @param to address to be approved for the given token ID\n     * @param tokenId uint256 ID of the token to be approved\n     */\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Gets the approved address for a token ID, or zero if no address set\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to query the approval of\n     * @return address currently approved for the given token ID\n     */\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Sets or unsets the approval of a given operator\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\n     * @param to operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     */\n    function setApprovalForAll(address to, bool approved) public {\n        require(to != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][to] = approved;\n        emit ApprovalForAll(_msgSender(), to, approved);\n    }\n\n    /**\n     * @dev Tells whether an operator is approved by a given owner.\n     * @param owner owner address which you want to query the approval of\n     * @param operator operator address which you want to query the approval of\n     * @return bool whether the given operator is approved by the given owner\n     */\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Transfers the ownership of a given token ID to another address.\n     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     * Requires the msg.sender to be the owner, approved, or operator.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the _msgSender() to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransferFrom(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function _safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) internal {\n        _transferFrom(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether the specified token exists.\n     * @param tokenId uint256 ID of the token to query the existence of\n     * @return bool whether the token exists\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner = _tokenOwner[tokenId];\n        return owner != address(0);\n    }\n\n    /**\n     * @dev Returns whether the given spender can transfer a given token ID.\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     * is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Internal function to safely mint a new token.\n     * Reverts if the given token ID already exists.\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Internal function to safely mint a new token.\n     * Reverts if the given token ID already exists.\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Internal function to mint a new token.\n     * Reverts if the given token ID already exists.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _tokenOwner[tokenId] = to;\n        _ownedTokensCount[to].increment();\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use {_burn} instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == owner, \"ERC721: burn of token that is not own\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[owner].decrement();\n        _tokenOwner[tokenId] = address(0);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(uint256 tokenId) internal {\n        _burn(ownerOf(tokenId), tokenId);\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[from].decrement();\n        _ownedTokensCount[to].increment();\n\n        _tokenOwner[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * This function is deprecated.\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        internal returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n\n        bytes4 retval = IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data);\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /**\n     * @dev Private function to clear current approval of a given token ID.\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _clearApproval(uint256 tokenId) private {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n        }\n    }\n}\n"
    },
    {
      "name": "ERC721Burnable.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./ERC721.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\n */\ncontract ERC721Burnable is Context, ERC721 {\n    /**\n     * @dev Burns a specific ERC721 token.\n     * @param tokenId uint256 id of the ERC721 token to be burned.\n     */\n    function burn(uint256 tokenId) public {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n        _burn(tokenId);\n    }\n}\n"
    },
    {
      "name": "ERC721Enumerable.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC721Enumerable.sol\";\nimport \"./ERC721.sol\";\nimport \"../../introspection/ERC165.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721Enumerable is Context, ERC165, ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => uint256[]) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * @dev Constructor function.\n     */\n    constructor () public {\n        // register the supported interface to conform to ERC721Enumerable via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner.\n     * @param owner address owning the tokens list to be accessed\n     * @param index uint256 representing the index to be accessed of the requested tokens list\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n        require(index < balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev Gets the total amount of tokens stored by the contract.\n     * @return uint256 representing the total amount of tokens\n     */\n    function totalSupply() public view returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev Gets the token ID at a given index of all the tokens in this contract\n     * Reverts if the index is greater or equal to the total number of tokens.\n     * @param index uint256 representing the index to be accessed of the tokens list\n     * @return uint256 token ID at the given index of the tokens list\n     */\n    function tokenByIndex(uint256 index) public view returns (uint256) {\n        require(index < totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        super._transferFrom(from, to, tokenId);\n\n        _removeTokenFromOwnerEnumeration(from, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to mint a new token.\n     * Reverts if the given token ID already exists.\n     * @param to address the beneficiary that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        super._mint(to, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n\n        _addTokenToAllTokensEnumeration(tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use {ERC721-_burn} instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        super._burn(owner, tokenId);\n\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\n        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\n        _ownedTokensIndex[tokenId] = 0;\n\n        _removeTokenFromAllTokensEnumeration(tokenId);\n    }\n\n    /**\n     * @dev Gets the list of token IDs of the requested owner.\n     * @param owner address owning the tokens\n     * @return uint256[] List of token IDs owned by the requested address\n     */\n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\n        return _ownedTokens[owner];\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n        _ownedTokens[to].push(tokenId);\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        _ownedTokens[from].length--;\n\n        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\n        // lastTokenId, or just over the end of the array if the token was the last one).\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        _allTokens.length--;\n        _allTokensIndex[tokenId] = 0;\n    }\n}\n"
    },
    {
      "name": "ERC721Full.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"./ERC721.sol\";\nimport \"./ERC721Enumerable.sol\";\nimport \"./ERC721Metadata.sol\";\n\n/**\n * @title Full ERC721 Token\n * @dev This implementation includes all the required and some optional functionality of the ERC721 standard\n * Moreover, it includes approve all functionality using operator terminology.\n *\n * See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {\n    constructor (string memory name, string memory symbol) public ERC721Metadata(name, symbol) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n}\n"
    },
    {
      "name": "ERC721Holder.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"./IERC721Receiver.sol\";\n\ncontract ERC721Holder is IERC721Receiver {\n    function onERC721Received(address, address, uint256, bytes memory) public returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    {
      "name": "ERC721Metadata.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./ERC721.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"../../introspection/ERC165.sol\";\n\ncontract ERC721Metadata is Context, ERC165, ERC721, IERC721Metadata {\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /**\n     * @dev Constructor function\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n    }\n\n    /**\n     * @dev Gets the token name.\n     * @return string representing the token name\n     */\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Gets the token symbol.\n     * @return string representing the token symbol\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns an URI for a given token ID.\n     * Throws if the token ID does not exist. May return an empty string.\n     * @param tokenId uint256 ID of the token to query\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n        return _tokenURIs[tokenId];\n    }\n\n    /**\n     * @dev Internal function to set the token URI for a given token.\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to set its URI\n     * @param uri string URI to assign\n     */\n    function _setTokenURI(uint256 tokenId, string memory uri) internal {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = uri;\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use _burn(uint256) instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned by the msg.sender\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        super._burn(owner, tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n"
    },
    {
      "name": "ERC721MetadataMintable.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"./ERC721Metadata.sol\";\nimport \"../../access/roles/MinterRole.sol\";\n\n\n/**\n * @title ERC721MetadataMintable\n * @dev ERC721 minting logic with metadata.\n */\ncontract ERC721MetadataMintable is ERC721, ERC721Metadata, MinterRole {\n    /**\n     * @dev Function to mint tokens.\n     * @param to The address that will receive the minted tokens.\n     * @param tokenId The token id to mint.\n     * @param tokenURI The token URI of the minted token.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mintWithTokenURI(address to, uint256 tokenId, string memory tokenURI) public onlyMinter returns (bool) {\n        _mint(to, tokenId);\n        _setTokenURI(tokenId, tokenURI);\n        return true;\n    }\n}\n"
    },
    {
      "name": "ERC721Mintable.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"./ERC721.sol\";\nimport \"../../access/roles/MinterRole.sol\";\n\n/**\n * @title ERC721Mintable\n * @dev ERC721 minting logic.\n */\ncontract ERC721Mintable is ERC721, MinterRole {\n    /**\n     * @dev Function to mint tokens.\n     * @param to The address that will receive the minted token.\n     * @param tokenId The token id to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(address to, uint256 tokenId) public onlyMinter returns (bool) {\n        _mint(to, tokenId);\n        return true;\n    }\n\n    /**\n     * @dev Function to safely mint tokens.\n     * @param to The address that will receive the minted token.\n     * @param tokenId The token id to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function safeMint(address to, uint256 tokenId) public onlyMinter returns (bool) {\n        _safeMint(to, tokenId);\n        return true;\n    }\n\n    /**\n     * @dev Function to safely mint tokens.\n     * @param to The address that will receive the minted token.\n     * @param tokenId The token id to mint.\n     * @param _data bytes data to send along with a safe transfer check.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function safeMint(address to, uint256 tokenId, bytes memory _data) public onlyMinter returns (bool) {\n        _safeMint(to, tokenId, _data);\n        return true;\n    }\n}\n"
    },
    {
      "name": "ERC721Pausable.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"./ERC721.sol\";\nimport \"../../lifecycle/Pausable.sol\";\n\n/**\n * @title ERC721 Non-Fungible Pausable token\n * @dev ERC721 modified with pausable transfers.\n */\ncontract ERC721Pausable is ERC721, Pausable {\n    function approve(address to, uint256 tokenId) public whenNotPaused {\n        super.approve(to, tokenId);\n    }\n\n    function setApprovalForAll(address to, bool approved) public whenNotPaused {\n        super.setApprovalForAll(to, approved);\n    }\n\n    function _transferFrom(address from, address to, uint256 tokenId) internal whenNotPaused {\n        super._transferFrom(from, to, tokenId);\n    }\n}\n"
    },
    {
      "name": "IERC721.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address owner) public view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     *\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n"
    },
    {
      "name": "IERC721Enumerable.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract IERC721Enumerable is IERC721 {\n    function totalSupply() public view returns (uint256);\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\n\n    function tokenByIndex(uint256 index) public view returns (uint256);\n}\n"
    },
    {
      "name": "IERC721Full.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\nimport \"./IERC721Metadata.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract IERC721Full is IERC721, IERC721Enumerable, IERC721Metadata {\n    // solhint-disable-previous-line no-empty-blocks\n}\n"
    },
    {
      "name": "IERC721Metadata.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    {
      "name": "IERC721Receiver.sol",
      "contents": "pragma solidity ^0.5.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract IERC721Receiver {\n    /**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\n     * otherwise the caller will revert the transaction. The selector to be\n     * returned can be obtained as `this.onERC721Received.selector`. This\n     * function MAY throw to revert and reject the transfer.\n     * Note: the ERC721 contract address is always the message sender.\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n    public returns (bytes4);\n}\n"
    },
    {
      "name": "ERC20.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}\n"
    },
    {
      "name": "ERC20Burnable.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./ERC20.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\ncontract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev See {ERC20-_burnFrom}.\n     */\n    function burnFrom(address account, uint256 amount) public {\n        _burnFrom(account, amount);\n    }\n}\n"
    },
    {
      "name": "ERC20Capped.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"./ERC20Mintable.sol\";\n\n/**\n * @dev Extension of {ERC20Mintable} that adds a cap to the supply of tokens.\n */\ncontract ERC20Capped is ERC20Mintable {\n    uint256 private _cap;\n\n    /**\n     * @dev Sets the value of the `cap`. This value is immutable, it can only be\n     * set once during construction.\n     */\n    constructor (uint256 cap) public {\n        require(cap > 0, \"ERC20Capped: cap is 0\");\n        _cap = cap;\n    }\n\n    /**\n     * @dev Returns the cap on the token's total supply.\n     */\n    function cap() public view returns (uint256) {\n        return _cap;\n    }\n\n    /**\n     * @dev See {ERC20Mintable-mint}.\n     *\n     * Requirements:\n     *\n     * - `value` must not cause the total supply to go over the cap.\n     */\n    function _mint(address account, uint256 value) internal {\n        require(totalSupply().add(value) <= _cap, \"ERC20Capped: cap exceeded\");\n        super._mint(account, value);\n    }\n}\n"
    },
    {
      "name": "ERC20Detailed.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    {
      "name": "ERC20Mintable.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"./ERC20.sol\";\nimport \"../../access/roles/MinterRole.sol\";\n\n/**\n * @dev Extension of {ERC20} that adds a set of accounts with the {MinterRole},\n * which have permission to mint (create) new tokens as they see fit.\n *\n * At construction, the deployer of the contract is the only minter.\n */\ncontract ERC20Mintable is ERC20, MinterRole {\n    /**\n     * @dev See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the {MinterRole}.\n     */\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n}\n"
    },
    {
      "name": "ERC20Pausable.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"./ERC20.sol\";\nimport \"../../lifecycle/Pausable.sol\";\n\n/**\n * @title Pausable token\n * @dev ERC20 with pausable transfers and allowances.\n *\n * Useful if you want to stop trades until the end of a crowdsale, or have\n * an emergency switch for freezing all token transfers in the event of a large\n * bug.\n */\ncontract ERC20Pausable is ERC20, Pausable {\n    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {\n        return super.transfer(to, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {\n        return super.transferFrom(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {\n        return super.approve(spender, value);\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {\n        return super.increaseAllowance(spender, addedValue);\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {\n        return super.decreaseAllowance(spender, subtractedValue);\n    }\n}\n"
    },
    {
      "name": "IERC20.sol",
      "contents": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    {
      "name": "SafeERC20.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    {
      "name": "TokenTimelock.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"./SafeERC20.sol\";\n\n/**\n * @dev A token holder contract that will allow a beneficiary to extract the\n * tokens after a given release time.\n *\n * Useful for simple vesting schedules like \"advisors get all of their tokens\n * after 1 year\".\n *\n * For a more complete vesting schedule, see {TokenVesting}.\n */\ncontract TokenTimelock {\n    using SafeERC20 for IERC20;\n\n    // ERC20 basic token contract being held\n    IERC20 private _token;\n\n    // beneficiary of tokens after they are released\n    address private _beneficiary;\n\n    // timestamp when token release is enabled\n    uint256 private _releaseTime;\n\n    constructor (IERC20 token, address beneficiary, uint256 releaseTime) public {\n        // solhint-disable-next-line not-rely-on-time\n        require(releaseTime > block.timestamp, \"TokenTimelock: release time is before current time\");\n        _token = token;\n        _beneficiary = beneficiary;\n        _releaseTime = releaseTime;\n    }\n\n    /**\n     * @return the token being held.\n     */\n    function token() public view returns (IERC20) {\n        return _token;\n    }\n\n    /**\n     * @return the beneficiary of the tokens.\n     */\n    function beneficiary() public view returns (address) {\n        return _beneficiary;\n    }\n\n    /**\n     * @return the time when the tokens are released.\n     */\n    function releaseTime() public view returns (uint256) {\n        return _releaseTime;\n    }\n\n    /**\n     * @notice Transfers tokens held by timelock to beneficiary.\n     */\n    function release() public {\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp >= _releaseTime, \"TokenTimelock: current time is before release time\");\n\n        uint256 amount = _token.balanceOf(address(this));\n        require(amount > 0, \"TokenTimelock: no tokens to release\");\n\n        _token.safeTransfer(_beneficiary, amount);\n    }\n}\n"
    },
    {
      "name": "Counters.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"../math/SafeMath.sol\";\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n"
    },
    {
      "name": "Address.sol",
      "contents": "pragma solidity ^0.5.5;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract's constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * IMPORTANT: It is unsafe to assume that an address for which this\n     * function returns false is an externally-owned account (EOA) and not a\n     * contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n"
    },
    {
      "name": "ERC165.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\ncontract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    {
      "name": "ERC165Checker.sol",
      "contents": "pragma solidity ^0.5.0;\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface,\n     */\n    function _supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return _supportsERC165Interface(account, _INTERFACE_ID_ERC165) &&\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function _supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return _supportsERC165(account) &&\n            _supportsERC165Interface(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function _supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!_supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in _interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with the `supportsERC165` method in this library.\n     * Interface identification is specified in ERC-165.\n     */\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\n        // success determines whether the staticcall succeeded and result determines\n        // whether the contract at account indicates support of _interfaceId\n        (bool success, bool result) = _callERC165SupportsInterface(account, interfaceId);\n\n        return (success && result);\n    }\n\n    /**\n     * @notice Calls the function with selector 0x01ffc9a7 (ERC165) and suppresses throw\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return success true if the STATICCALL succeeded, false otherwise\n     * @return result true if the STATICCALL succeeded and the contract at account\n     * indicates support of the interface with identifier interfaceId, false otherwise\n     */\n    function _callERC165SupportsInterface(address account, bytes4 interfaceId)\n        private\n        view\n        returns (bool success, bool result)\n    {\n        bytes memory encodedParams = abi.encodeWithSelector(_INTERFACE_ID_ERC165, interfaceId);\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encodedParams_data := add(0x20, encodedParams)\n            let encodedParams_size := mload(encodedParams)\n\n            let output := mload(0x40)    // Find empty storage location using \"free memory pointer\"\n            mstore(output, 0x0)\n\n            success := staticcall(\n                30000,                   // 30k gas\n                account,                 // To addr\n                encodedParams_data,\n                encodedParams_size,\n                output,\n                0x20                     // Outputs are 32 bytes long\n            )\n\n            result := mload(output)      // Load the result\n        }\n    }\n}\n"
    },
    {
      "name": "ERC1820Implementer.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"./IERC1820Implementer.sol\";\n\n/**\n * @dev Implementation of the {IERC1820Implementer} interface.\n *\n * Contracts may inherit from this and call {_registerInterfaceForAddress} to\n * declare their willingness to be implementers.\n * {IERC1820Registry-setInterfaceImplementer} should then be called for the\n * registration to be complete.\n */\ncontract ERC1820Implementer is IERC1820Implementer {\n    bytes32 constant private ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\"));\n\n    mapping(bytes32 => mapping(address => bool)) private _supportedInterfaces;\n\n    /**\n     * See {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) external view returns (bytes32) {\n        return _supportedInterfaces[interfaceHash][account] ? ERC1820_ACCEPT_MAGIC : bytes32(0x00);\n    }\n\n    /**\n     * @dev Declares the contract as willing to be an implementer of\n     * `interfaceHash` for `account`.\n     *\n     * See {IERC1820Registry-setInterfaceImplementer} and\n     * {IERC1820Registry-interfaceHash}.\n     */\n    function _registerInterfaceForAddress(bytes32 interfaceHash, address account) internal {\n        _supportedInterfaces[interfaceHash][account] = true;\n    }\n}\n"
    },
    {
      "name": "IERC165.sol",
      "contents": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    {
      "name": "IERC1820Implementer.sol",
      "contents": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface for an ERC1820 implementer, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820#interface-implementation-erc1820implementerinterface[EIP].\n * Used by contracts that will be registered as implementers in the\n * {IERC1820Registry}.\n */\ninterface IERC1820Implementer {\n    /**\n     * @dev Returns a special value (`ERC1820_ACCEPT_MAGIC`) if this contract\n     * implements `interfaceHash` for `account`.\n     *\n     * See {IERC1820Registry-setInterfaceImplementer}.\n     */\n    function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) external view returns (bytes32);\n}\n"
    },
    {
      "name": "IERC1820Registry.sol",
      "contents": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as `account`'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\n\n    /**\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     *  @param account Address of the contract for which to update the cache.\n     *  @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\n     *  If the result is not cached a direct lookup on the contract address is performed.\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     *  {updateERC165Cache} with the contract address.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n}\n"
    },
    {
      "name": "ContractReceiver.sol",
      "contents": "pragma solidity ^0.5.3;\n\n// Used only for testing reasons\n\n /*\n * Contract interface that is working with ERC677 tokens\n */\ncontract ContractReceiver {\n    function tokenFallback(address _from, uint _value, bytes memory _data) public returns(bool);\n}\n\n"
    },
    {
      "name": "ERC677.sol",
      "contents": "pragma solidity ^0.5.3;\n\n// Used only for testing reasons\n// See https://github.com/ethereum/EIPs/issues/677\n\n/* ERC677 contract interface */\ncontract ERC677 {\n    function transferAndCall(address to, uint256 value, bytes memory data) public returns (bool ok);\n\n    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);\n}\n"
    },
    {
      "name": "ERC677Receiver.sol",
      "contents": "pragma solidity ^0.5.3;\n\ncontract ERC677Receiver {\n    function tokenFallback(address from, uint value, bytes calldata data) external returns (bool);\n}\n"
    },
    {
      "name": "ERC677TokenContract.sol",
      "contents": "pragma solidity ^0.5.3;\n\n// Used only for testing reasons\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\";\nimport \"./ContractReceiver.sol\";\nimport \"./ERC677.sol\";\n\ncontract ERC677TokenContract is ERC677, ERC20, ERC20Detailed {\n\n    constructor(address initialAccount, uint256 initialBalance) ERC20Detailed(\"RIF Token\", \"RIF\", 18) public {\n        _mint(initialAccount, initialBalance);\n    }\n\n    function transferAndCall(address to, uint256 value, bytes memory data) public returns (bool) {\n        super.transfer(to, value);\n\n        ContractReceiver(to).tokenFallback(msg.sender, value, data);\n\n        emit Transfer(msg.sender, to, value, data);\n\n        return true;\n    }\n}\n"
    },
    {
      "name": "RNS.sol",
      "contents": "pragma solidity ^0.5.3;\n\nimport './AbstractRNS.sol';\n\n// Used only for testing reasons\n\n/**\n * The RNS registry contract.\n */\ncontract RNS is AbstractRNS {\n    struct Record {\n        address owner;\n        address resolver;\n        uint64 ttl;\n    }\n\n    mapping(bytes32=>Record) records;\n\n    // Permits modifications only by the owner of the specified node.\n    modifier only_owner(bytes32 node) {\n        require(records[node].owner == msg.sender);\n        _;\n    }\n\n    /**\n     * Constructs a new RNS registrar.\n     */\n    constructor() public {\n        records[bytes32(0)].owner = msg.sender;\n    }\n\n    /**\n     * Returns the address that owns the specified node.\n     */\n    function owner(bytes32 node) public view returns (address) {\n        return records[node].owner;\n    }\n\n    /**\n     * Returns the address of the resolver for the specified node.\n     */\n    function resolver(bytes32 node) public view returns (address) {\n        return records[node].resolver;\n    }\n\n    /**\n     * Returns the TTL of a node, and any records associated with it.\n     */\n    function ttl(bytes32 node) public view returns (uint64) {\n        return records[node].ttl;\n    }\n\n    /**\n     * Transfers ownership of a node to a new address. May only be called by the current\n     * owner of the node.\n     * @param node The node to transfer ownership of.\n     * @param ownerAddress The address of the new owner.\n     */\n    function setOwner(bytes32 node, address ownerAddress) public only_owner(node) {\n        emit Transfer(node, ownerAddress);\n        records[node].owner = ownerAddress;\n    }\n\n    /**\n     * Transfers ownership of a subnode keccak256(node, label) to a new address. May only be\n     * called by the owner of the parent node.\n     * @param node The parent node.\n     * @param label The hash of the label specifying the subnode.\n     * @param ownerAddress The address of the new owner.\n     */\n    function setSubnodeOwner(bytes32 node, bytes32 label, address ownerAddress) public only_owner(node) {\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\n        emit NewOwner(node, label, ownerAddress);\n        records[subnode].owner = ownerAddress;\n\n        emit NewResolver(subnode, records[node].resolver);\n        records[subnode].resolver = records[node].resolver;\n    }\n\n    /**\n     * Sets the resolver address for the specified node.\n     * @param node The node to update.\n     * @param resolverAddress The address of the resolver.\n     */\n    function setResolver(bytes32 node, address resolverAddress) public only_owner(node) {\n        emit NewResolver(node, resolverAddress);\n        records[node].resolver = resolverAddress;\n    }\n\n    /**\n     * Sets the TTL for the specified node.\n     * @param node The node to update.\n     * @param ttlValue The TTL in seconds.\n     */\n    function setTTL(bytes32 node, uint64 ttlValue) public only_owner(node) {\n        emit NewTTL(node, ttlValue);\n        records[node].ttl = ttlValue;\n    }\n\n    /**\n     * Sets the default resolver for new nodes\n     * @param _resolver The address of the new defaultResolver\n     */\n    function setDefaultResolver(address _resolver) public only_owner(0) {\n        records[bytes32(0)].resolver = _resolver;\n    }\n}\n"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0xbc5ade62cf4745748d5d1d44364caf8ac40f48cb9ae2dd8e2bb797ab0db0b6a5",
    "blockNumber": 1891388,
    "transactionHash": "0x17b549b4567617c3edbf623b56542084eb514649affe48e74161f31d050be7b1",
    "timestamp": 1574370400
  },
  "constructorArguments": [
    "0x5269f5bc51cdd8aa62755c97229b7eeddd8e69a6",
    "0xcb868aeabd31e2b66f74e9a55cf064abb31a4ad5",
    "0x0cd5c10192478cd220936e91293afc15e3f6de4d419de5de7506b679cbdd8ec4"
  ]
}