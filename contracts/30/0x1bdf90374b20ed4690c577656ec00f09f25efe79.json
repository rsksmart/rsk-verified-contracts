{
  "address": "0x1bdf90374b20ed4690c577656ec00f09f25efe79",
  "net": {
    "id": "30",
    "name": "RSK Mainnet"
  },
  "name": "LoanTokenLogicWrbtc",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "istanbul"
  },
  "version": "0.5.17+commit.d19bba13",
  "source": "/**\r\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0.\r\n */\r\n\r\npragma solidity 0.5.17;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @title SignedSafeMath\r\n * @dev Signed math operations with safety checks that revert on error.\r\n */\r\nlibrary SignedSafeMath {\r\n    int256 private constant _INT256_MIN = -2**255;\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(\r\n            !(a == -1 && b == _INT256_MIN),\r\n            \"SignedSafeMath: multiplication overflow\"\r\n        );\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two signed integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0, \"SignedSafeMath: division by zero\");\r\n        require(\r\n            !(b == -1 && a == _INT256_MIN),\r\n            \"SignedSafeMath: division overflow\"\r\n        );\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require(\r\n            (b >= 0 && c <= a) || (b < 0 && c > a),\r\n            \"SignedSafeMath: subtraction overflow\"\r\n        );\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require(\r\n            (b >= 0 && c >= a) || (b < 0 && c < a),\r\n            \"SignedSafeMath: addition overflow\"\r\n        );\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMathSovryn {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function min256(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        return _a < _b ? _a : _b;\r\n    }\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract ContextSovryn {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor() internal {}\r\n\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev Constant for unlocked guard state - non-zero to prevent extra gas costs.\r\n    /// See: https://github.com/OpenZeppelin/openzeppelin-solidity/issues/1056\r\n    uint256 internal constant REENTRANCY_GUARD_FREE = 1;\r\n\r\n    /// @dev Constant for locked guard state\r\n    uint256 internal constant REENTRANCY_GUARD_LOCKED = 2;\r\n\r\n    /**\r\n     * @dev We use a single lock for the whole contract.\r\n     */\r\n    uint256 internal reentrancyLock = REENTRANCY_GUARD_FREE;\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * If you mark a function `nonReentrant`, you should also\r\n     * mark it `external`. Calling one `nonReentrant` function from\r\n     * another is not supported. Instead, you can implement a\r\n     * `private` function doing the actual work, and an `external`\r\n     * wrapper marked as `nonReentrant`.\r\n     */\r\n    modifier nonReentrant() {\r\n        require(reentrancyLock == REENTRANCY_GUARD_FREE, \"nonReentrant\");\r\n        reentrancyLock = REENTRANCY_GUARD_LOCKED;\r\n        _;\r\n        reentrancyLock = REENTRANCY_GUARD_FREE;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is ContextSovryn {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"unauthorized\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n\r\n\r\n            bytes32 accountHash\r\n         = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account)\r\n        internal\r\n        pure\r\n        returns (address payable)\r\n    {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n}\r\n\r\ninterface IWrbtc {\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256 wad) external;\r\n}\r\n\r\ncontract IERC20Sovryn {\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function balanceOf(address _who) public view returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n\r\n    function allowance(address _owner, address _spender)\r\n        public\r\n        view\r\n        returns (uint256);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) public returns (bool);\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ncontract IWrbtcERC20 is IWrbtc, IERC20Sovryn {}\r\n\r\ncontract Pausable {\r\n    // keccak256(\"Pausable_FunctionPause\")\r\n    bytes32\r\n        internal constant Pausable_FunctionPause = 0xa7143c84d793a15503da6f19bf9119a2dac94448ca45d77c8bf08f57b2e91047;\r\n\r\n    modifier pausable(bytes4 sig) {\r\n        require(!_isPaused(sig), \"unauthorized\");\r\n        _;\r\n    }\r\n\r\n    function _isPaused(bytes4 sig) internal view returns (bool isPaused) {\r\n        bytes32 slot = keccak256(abi.encodePacked(sig, Pausable_FunctionPause));\r\n        assembly {\r\n            isPaused := sload(slot)\r\n        }\r\n    }\r\n}\r\n\r\ncontract LoanTokenBase is ReentrancyGuard, Ownable {\r\n    uint256 internal constant WEI_PRECISION = 10**18;\r\n    uint256 internal constant WEI_PERCENT_PRECISION = 10**20;\r\n\r\n    int256 internal constant sWEI_PRECISION = 10**18;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    address public loanTokenAddress;\r\n\r\n    uint256 public baseRate;\r\n    uint256 public rateMultiplier;\r\n    uint256 public lowUtilBaseRate;\r\n    uint256 public lowUtilRateMultiplier;\r\n\r\n    uint256 public targetLevel;\r\n    uint256 public kinkLevel;\r\n    uint256 public maxScaleRate;\r\n\r\n    uint256 internal _flTotalAssetSupply;\r\n    uint256 public checkpointSupply;\r\n    uint256 public initialPrice;\r\n\r\n    // uint88 for tight packing -> 8 + 88 + 160 = 256\r\n    uint88 internal lastSettleTime_;\r\n\r\n    mapping(uint256 => bytes32) public loanParamsIds; // mapping of keccak256(collateralToken, isTorqueLoan) to loanParamsId\r\n    mapping(address => uint256) internal checkpointPrices_; // price of token at last user checkpoint\r\n\r\n    mapping(address => uint256) public transactionLimit; // the maximum trading/borrowing/lending limit per token address\r\n    // 0 -> no limit\r\n}\r\n\r\ncontract AdvancedTokenStorage is LoanTokenBase {\r\n    using SafeMathSovryn for uint256;\r\n\r\n    // topic: 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // topic: 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    // topic: 0xb4c03061fb5b7fed76389d5af8f2e0ddb09f8c70d1333abbb62582835e10accb\r\n    event Mint(\r\n        address indexed minter,\r\n        uint256 tokenAmount,\r\n        uint256 assetAmount,\r\n        uint256 price\r\n    );\r\n\r\n    // topic: 0x743033787f4738ff4d6a7225ce2bd0977ee5f86b91a902a58f5e4d0b297b4644\r\n    event Burn(\r\n        address indexed burner,\r\n        uint256 tokenAmount,\r\n        uint256 assetAmount,\r\n        uint256 price\r\n    );\r\n\r\n    mapping(address => uint256) internal balances;\r\n    mapping(address => mapping(address => uint256)) internal allowed;\r\n    uint256 internal totalSupply_;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function allowance(address _owner, address _spender)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\ncontract AdvancedToken is AdvancedTokenStorage {\r\n    using SafeMathSovryn for uint256;\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function _mint(\r\n        address _to,\r\n        uint256 _tokenAmount,\r\n        uint256 _assetAmount,\r\n        uint256 _price\r\n    ) internal returns (uint256) {\r\n        require(_to != address(0), \"15\");\r\n\r\n        uint256 _balance = balances[_to].add(_tokenAmount);\r\n        balances[_to] = _balance;\r\n\r\n        totalSupply_ = totalSupply_.add(_tokenAmount);\r\n\r\n        emit Mint(_to, _tokenAmount, _assetAmount, _price);\r\n        emit Transfer(address(0), _to, _tokenAmount);\r\n\r\n        return _balance;\r\n    }\r\n\r\n    function _burn(\r\n        address _who,\r\n        uint256 _tokenAmount,\r\n        uint256 _assetAmount,\r\n        uint256 _price\r\n    ) internal returns (uint256) {\r\n        require(_tokenAmount <= balances[_who], \"16\");\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n        uint256 _balance = balances[_who].sub(_tokenAmount);\r\n        if (_balance <= 10) {\r\n            // we can't leave such small balance quantities\r\n            _tokenAmount = _tokenAmount.add(_balance);\r\n            _balance = 0;\r\n        }\r\n        balances[_who] = _balance;\r\n\r\n        totalSupply_ = totalSupply_.sub(_tokenAmount);\r\n\r\n        emit Burn(_who, _tokenAmount, _assetAmount, _price);\r\n        emit Transfer(_who, address(0), _tokenAmount);\r\n\r\n        return _balance;\r\n    }\r\n}\r\n\r\ninterface ProtocolLike {\r\n    function borrowOrTradeFromPool(\r\n        bytes32 loanParamsId,\r\n        bytes32 loanId, // if 0, start a new loan\r\n        bool isTorqueLoan,\r\n        uint256 initialMargin,\r\n        address[4] calldata sentAddresses,\r\n        // lender: must match loan if loanId provided\r\n        // borrower: must match loan if loanId provided\r\n        // receiver: receiver of funds (address(0) assumes borrower address)\r\n        // manager: delegated manager of loan unless address(0)\r\n        uint256[5] calldata sentValues,\r\n        // newRate: new loan interest rate\r\n        // newPrincipal: new loan size (borrowAmount + any borrowed interest)\r\n        // torqueInterest: new amount of interest to escrow for Torque loan (determines initial loan length)\r\n        // loanTokenReceived: total loanToken deposit (amount not sent to borrower in the case of Torque loans)\r\n        // collateralTokenReceived: total collateralToken deposit\r\n        bytes calldata loanDataBytes\r\n    ) external payable returns (uint256 newPrincipal, uint256 newCollateral);\r\n\r\n    function getTotalPrincipal(address lender, address loanToken)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function withdrawAccruedInterest(address loanToken) external;\r\n\r\n    function getLenderInterestData(address lender, address loanToken)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 interestPaid,\r\n            uint256 interestPaidDate,\r\n            uint256 interestOwedPerDay,\r\n            uint256 interestUnPaid,\r\n            uint256 interestFeePercent,\r\n            uint256 principalTotal\r\n        );\r\n\r\n    function priceFeeds() external view returns (address);\r\n\r\n    function getEstimatedMarginExposure(\r\n        address loanToken,\r\n        address collateralToken,\r\n        uint256 loanTokenSent,\r\n        uint256 collateralTokenSent,\r\n        uint256 interestRate,\r\n        uint256 newPrincipal\r\n    ) external view returns (uint256);\r\n\r\n    function getRequiredCollateral(\r\n        address loanToken,\r\n        address collateralToken,\r\n        uint256 newPrincipal,\r\n        uint256 marginAmount,\r\n        bool isTorqueLoan\r\n    ) external view returns (uint256 collateralAmountRequired);\r\n\r\n    function getBorrowAmount(\r\n        address loanToken,\r\n        address collateralToken,\r\n        uint256 collateralTokenAmount,\r\n        uint256 marginAmount,\r\n        bool isTorqueLoan\r\n    ) external view returns (uint256 borrowAmount);\r\n\r\n    function isLoanPool(address loanPool) external view returns (bool);\r\n\r\n    function lendingFeePercent() external view returns (uint256);\r\n}\r\n\r\ninterface FeedsLike {\r\n    function queryRate(address sourceTokenAddress, address destTokenAddress)\r\n        external\r\n        view\r\n        returns (uint256 rate, uint256 precision);\r\n}\r\n\r\ncontract LoanTokenLogicStandard is AdvancedToken {\r\n    using SafeMathSovryn for uint256;\r\n    using SignedSafeMath for int256;\r\n\r\n    // It is important to maintain the variables order so the delegate calls can access sovrynContractAddress and wrbtcTokenAddress\r\n    address public sovrynContractAddress;\r\n    address public wrbtcTokenAddress;\r\n    address internal target_;\r\n\r\n    uint256 public constant VERSION = 5;\r\n    address\r\n        internal constant arbitraryCaller = 0x000F400e6818158D541C3EBE45FE3AA0d47372FF;\r\n    address public earlyAccessToken;\r\n\r\n    modifier hasEarlyAccessToken() {\r\n        require(\r\n            IERC20Sovryn(earlyAccessToken).balanceOf(msg.sender) > 0,\r\n            \"No early access tokens\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function() external {\r\n        revert(\"loan token logic - fallback not allowed\");\r\n    }\r\n\r\n    event SetEarlyAccessToken(\r\n        address indexed sender,\r\n        address indexed oldValue,\r\n        address indexed newValue\r\n    );\r\n\r\n    /* Public functions */\r\n\r\n    function mint(address receiver, uint256 depositAmount)\r\n        external\r\n        nonReentrant\r\n        hasEarlyAccessToken\r\n        returns (uint256 mintAmount)\r\n    {\r\n        //temporary: limit transaction size\r\n        if (transactionLimit[loanTokenAddress] > 0)\r\n            require(depositAmount <= transactionLimit[loanTokenAddress]);\r\n\r\n        return _mintToken(receiver, depositAmount);\r\n    }\r\n\r\n    function burn(address receiver, uint256 burnAmount)\r\n        external\r\n        nonReentrant\r\n        returns (uint256 loanAmountPaid)\r\n    {\r\n        loanAmountPaid = _burnToken(burnAmount);\r\n\r\n        if (loanAmountPaid != 0) {\r\n            _safeTransfer(loanTokenAddress, receiver, loanAmountPaid, \"5\");\r\n        }\r\n    }\r\n\r\n    /*\r\n    flashBorrow is disabled for the MVP, but is going to be added later.\r\n    therefore, it needs to be revised\r\n    \r\n    function flashBorrow(\r\n        uint256 borrowAmount,\r\n        address borrower,\r\n        address target,\r\n        string calldata signature,\r\n        bytes calldata data)\r\n        external\r\n        payable\r\n        nonReentrant\r\n        returns (bytes memory)\r\n    {\r\n        require(borrowAmount != 0, \"38\");\r\n\r\n        _checkPause();\r\n\r\n        _settleInterest();\r\n\r\n        // save before balances\r\n        uint256 beforeEtherBalance = address(this).balance.sub(msg.value);\r\n        uint256 beforeAssetsBalance = _underlyingBalance()\r\n            .add(totalAssetBorrow());\r\n\r\n        // lock totalAssetSupply for duration of flash loan\r\n        _flTotalAssetSupply = beforeAssetsBalance;\r\n\r\n        // transfer assets to calling contract\r\n        _safeTransfer(loanTokenAddress, borrower, borrowAmount, \"39\");\r\n\r\n        bytes memory callData;\r\n        if (bytes(signature).length == 0) {\r\n            callData = data;\r\n        } else {\r\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\r\n        }\r\n\r\n        // arbitrary call\r\n        (bool success, bytes memory returnData) = arbitraryCaller.call.value(msg.value)(\r\n            abi.encodeWithSelector(\r\n                0xde064e0d, // sendCall(address,bytes)\r\n                target,\r\n                callData\r\n            )\r\n        );\r\n        require(success, \"call failed\");\r\n\r\n        // unlock totalAssetSupply\r\n        _flTotalAssetSupply = 0;\r\n\r\n        // verifies return of flash loan\r\n        require(\r\n            address(this).balance >= beforeEtherBalance &&\r\n            _underlyingBalance()\r\n                .add(totalAssetBorrow()) >= beforeAssetsBalance,\r\n            \"40\"\r\n        );\r\n\r\n        return returnData;\r\n    }\r\n    */\r\n\r\n    /**\r\n     * borrows funds from the pool. The underlying loan token may not be used as collateral.\r\n     * @param loanId the ID of the loan, 0 for a new loan\r\n     * @param withdrawAmount the amount to be withdrawn (actually borrowed)\r\n     * @param initialLoanDuration the duration of the loan in seconds. if the loan is not paid back until then, it'll need to be rolled over\r\n     * @param collateralTokenSent the amount of collateral token sent (150% of the withdrawn amount worth in collateral tokenns)\r\n     * @param collateralTokenAddress the address of the tokenn to be used as collateral. cannot be the loan token address\r\n     * @param borrower the one paying for the collateral\r\n     * @param receiver the one receiving the withdrawn amount\r\n     * */\r\n    function borrow(\r\n        bytes32 loanId, // 0 if new loan\r\n        uint256 withdrawAmount,\r\n        uint256 initialLoanDuration, // duration in seconds\r\n        uint256 collateralTokenSent, // if 0, loanId must be provided; any ETH sent must equal this value\r\n        address collateralTokenAddress, // if address(0), this means ETH and ETH must be sent with the call or loanId must be provided\r\n        address borrower,\r\n        address receiver,\r\n        bytes memory // arbitrary order data (for future use) /*loanDataBytes*/\r\n    )\r\n        public\r\n        payable\r\n        nonReentrant //note: needs to be removed to allow flashloan use cases\r\n        hasEarlyAccessToken\r\n        returns (\r\n            uint256,\r\n            uint256 // returns new principal and new collateral added to loan\r\n        )\r\n    {\r\n        require(withdrawAmount != 0, \"6\");\r\n\r\n        _checkPause();\r\n\r\n        //temporary: limit transaction size\r\n        if (transactionLimit[collateralTokenAddress] > 0)\r\n            require(\r\n                collateralTokenSent <= transactionLimit[collateralTokenAddress]\r\n            );\r\n\r\n        require(msg.value == 0 || msg.value == collateralTokenSent, \"7\");\r\n        require(collateralTokenSent != 0 || loanId != 0, \"8\");\r\n        require(\r\n            collateralTokenAddress != address(0) ||\r\n                msg.value != 0 ||\r\n                loanId != 0,\r\n            \"9\"\r\n        );\r\n\r\n        if (collateralTokenAddress == address(0)) {\r\n            collateralTokenAddress = wrbtcTokenAddress;\r\n        }\r\n        require(collateralTokenAddress != loanTokenAddress, \"10\");\r\n\r\n        _settleInterest();\r\n\r\n        address[4] memory sentAddresses;\r\n        uint256[5] memory sentAmounts;\r\n\r\n        sentAddresses[0] = address(this); // lender\r\n        sentAddresses[1] = borrower;\r\n        sentAddresses[2] = receiver;\r\n        //sentAddresses[3] = address(0); // manager\r\n\r\n        sentAmounts[1] = withdrawAmount;\r\n\r\n        // interestRate, interestInitialAmount, borrowAmount (newBorrowAmount)\r\n        (\r\n            sentAmounts[0],\r\n            sentAmounts[2],\r\n            sentAmounts[1]\r\n        ) = _getInterestRateAndBorrowAmount(\r\n            sentAmounts[1],\r\n            _totalAssetSupply(0), // interest is settled above\r\n            initialLoanDuration\r\n        );\r\n\r\n        //sentAmounts[3] = 0; // loanTokenSent\r\n        sentAmounts[4] = collateralTokenSent;\r\n\r\n        return\r\n            _borrowOrTrade(\r\n                loanId,\r\n                withdrawAmount,\r\n                2 * 10**18, // leverageAmount (translates to 150% margin for a Torque loan)\r\n                collateralTokenAddress,\r\n                sentAddresses,\r\n                sentAmounts,\r\n                \"\" // loanDataBytes\r\n            );\r\n    }\r\n\r\n    // Called to borrow and immediately get into a positions\r\n    function marginTrade(\r\n        bytes32 loanId, // 0 if new loan\r\n        uint256 leverageAmount, // expected in x * 10**18 where x is the actual leverage (2, 3, 4, or 5)\r\n        uint256 loanTokenSent,\r\n        uint256 collateralTokenSent,\r\n        address collateralTokenAddress,\r\n        address trader,\r\n        bytes memory loanDataBytes // arbitrary order data\r\n    )\r\n        public\r\n        payable\r\n        nonReentrant //note: needs to be removed to allow flashloan use cases\r\n        hasEarlyAccessToken\r\n        returns (\r\n            uint256,\r\n            uint256 // returns new principal and new collateral added to trade\r\n        )\r\n    {\r\n        _checkPause();\r\n\r\n        if (collateralTokenAddress == address(0)) {\r\n            collateralTokenAddress = wrbtcTokenAddress;\r\n        }\r\n\r\n        require(collateralTokenAddress != loanTokenAddress, \"11\");\r\n\r\n        //temporary: limit transaction size\r\n        if (transactionLimit[collateralTokenAddress] > 0)\r\n            require(\r\n                collateralTokenSent <= transactionLimit[collateralTokenAddress]\r\n            );\r\n        if (transactionLimit[loanTokenAddress] > 0)\r\n            require(loanTokenSent <= transactionLimit[loanTokenAddress]);\r\n\r\n        //computes the worth of the total deposit in loan tokens.\r\n        //(loanTokenSent + convert(collateralTokenSent))\r\n        //no actual swap happening here.\r\n        uint256 totalDeposit = _totalDeposit(\r\n            collateralTokenAddress,\r\n            collateralTokenSent,\r\n            loanTokenSent\r\n        );\r\n        require(totalDeposit != 0, \"12\");\r\n\r\n        address[4] memory sentAddresses;\r\n        uint256[5] memory sentAmounts;\r\n\r\n        sentAddresses[0] = address(this); // lender\r\n        sentAddresses[1] = trader;\r\n        sentAddresses[2] = trader;\r\n        //sentAddresses[3] = address(0); // manager\r\n\r\n        //sentAmounts[0] = 0; // interestRate (found later)\r\n        sentAmounts[1] = totalDeposit; // total amount of deposit\r\n        //sentAmounts[2] = 0; // interestInitialAmount (interest is calculated based on fixed-term loan)\r\n        sentAmounts[3] = loanTokenSent;\r\n        sentAmounts[4] = collateralTokenSent;\r\n\r\n        _settleInterest();\r\n\r\n        (sentAmounts[1], sentAmounts[0]) = _getMarginBorrowAmountAndRate( // borrowAmount, interestRate\r\n            leverageAmount,\r\n            sentAmounts[1] // depositAmount\r\n        );\r\n\r\n        return\r\n            _borrowOrTrade(\r\n                loanId,\r\n                0, // withdrawAmount\r\n                leverageAmount,\r\n                collateralTokenAddress,\r\n                sentAddresses,\r\n                sentAmounts,\r\n                loanDataBytes\r\n            );\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool) {\r\n        return _internalTransferFrom(msg.sender, _to, _value, uint256(-1));\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool) {\r\n        return\r\n            _internalTransferFrom(\r\n                _from,\r\n                _to,\r\n                _value,\r\n                ProtocolLike(sovrynContractAddress).isLoanPool(msg.sender)\r\n                    ? uint256(-1)\r\n                    : allowed[_from][msg.sender]\r\n            );\r\n    }\r\n\r\n    function _internalTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _allowanceAmount\r\n    ) internal returns (bool) {\r\n        if (_allowanceAmount != uint256(-1)) {\r\n            require(_value <= _allowanceAmount, \"14\");\r\n            allowed[_from][msg.sender] = _allowanceAmount.sub(_value);\r\n        }\r\n\r\n        uint256 _balancesFrom = balances[_from];\r\n        require(_value <= _balancesFrom && _to != address(0), \"14\");\r\n\r\n        uint256 _balancesFromNew = _balancesFrom.sub(_value);\r\n        balances[_from] = _balancesFromNew;\r\n\r\n        uint256 _balancesTo = balances[_to];\r\n        uint256 _balancesToNew = _balancesTo.add(_value);\r\n        balances[_to] = _balancesToNew;\r\n\r\n        // handle checkpoint update\r\n        uint256 _currentPrice = tokenPrice();\r\n\r\n        _updateCheckpoints(\r\n            _from,\r\n            _balancesFrom,\r\n            _balancesFromNew,\r\n            _currentPrice\r\n        );\r\n        _updateCheckpoints(_to, _balancesTo, _balancesToNew, _currentPrice);\r\n\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    event Debug(bytes32 slot, uint256 one, uint256 two);\r\n\r\n    function _updateCheckpoints(\r\n        address _user,\r\n        uint256 _oldBalance,\r\n        uint256 _newBalance,\r\n        uint256 _currentPrice\r\n    ) internal {\r\n        // keccak256(\"iToken_ProfitSoFar\")\r\n        bytes32 slot = keccak256(\r\n            abi.encodePacked(\r\n                _user,\r\n                uint256(\r\n                    0x37aa2b7d583612f016e4a4de4292cb015139b3d7762663d06a53964912ea2fb6\r\n                )\r\n            )\r\n        );\r\n\r\n        uint256 _currentProfit;\r\n        if (_oldBalance != 0 && _newBalance != 0) {\r\n            _currentProfit = _profitOf(\r\n                slot,\r\n                _oldBalance,\r\n                _currentPrice,\r\n                checkpointPrices_[_user]\r\n            );\r\n        } else if (_newBalance == 0) {\r\n            _currentPrice = 0;\r\n        }\r\n\r\n        assembly {\r\n            sstore(slot, _currentProfit)\r\n        }\r\n\r\n        checkpointPrices_[_user] = _currentPrice;\r\n\r\n        emit Debug(slot, _currentProfit, _currentPrice);\r\n    }\r\n\r\n    /* Public View functions */\r\n\r\n    function profitOf(address user) public view returns (uint256) {\r\n        // keccak256(\"iToken_ProfitSoFar\")\r\n        bytes32 slot = keccak256(\r\n            abi.encodePacked(\r\n                user,\r\n                uint256(\r\n                    0x37aa2b7d583612f016e4a4de4292cb015139b3d7762663d06a53964912ea2fb6\r\n                )\r\n            )\r\n        );\r\n\r\n        return\r\n            _profitOf(\r\n                slot,\r\n                balances[user],\r\n                tokenPrice(),\r\n                checkpointPrices_[user]\r\n            );\r\n    }\r\n\r\n    function _profitOf(\r\n        bytes32 slot,\r\n        uint256 _balance,\r\n        uint256 _currentPrice,\r\n        uint256 _checkpointPrice\r\n    ) internal view returns (uint256) {\r\n        if (_checkpointPrice == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 profitSoFar;\r\n        uint256 profitDiff;\r\n\r\n        assembly {\r\n            profitSoFar := sload(slot)\r\n        }\r\n\r\n        if (_currentPrice > _checkpointPrice) {\r\n            profitDiff = _balance.mul(_currentPrice - _checkpointPrice).div(\r\n                10**18\r\n            );\r\n            profitSoFar = profitSoFar.add(profitDiff);\r\n        } else {\r\n            profitDiff = _balance.mul(_checkpointPrice - _currentPrice).div(\r\n                10**18\r\n            );\r\n            if (profitSoFar > profitDiff) {\r\n                profitSoFar = profitSoFar - profitDiff;\r\n            } else {\r\n                profitSoFar = 0;\r\n            }\r\n        }\r\n\r\n        return profitSoFar;\r\n    }\r\n\r\n    function tokenPrice() public view returns (uint256 price) {\r\n        uint256 interestUnPaid;\r\n        if (lastSettleTime_ != uint88(block.timestamp)) {\r\n            (, interestUnPaid) = _getAllInterest();\r\n        }\r\n\r\n        return _tokenPrice(_totalAssetSupply(interestUnPaid));\r\n    }\r\n\r\n    function checkpointPrice(address _user)\r\n        public\r\n        view\r\n        returns (uint256 price)\r\n    {\r\n        return checkpointPrices_[_user];\r\n    }\r\n\r\n    function marketLiquidity() public view returns (uint256) {\r\n        uint256 totalSupply = _totalAssetSupply(0);\r\n        uint256 totalBorrow = totalAssetBorrow();\r\n        if (totalSupply > totalBorrow) {\r\n            return totalSupply.sub(totalBorrow);\r\n        }\r\n    }\r\n\r\n    function avgBorrowInterestRate() public view returns (uint256) {\r\n        return _avgBorrowInterestRate(totalAssetBorrow());\r\n    }\r\n\r\n    // the minimum rate the next base protocol borrower will receive for variable-rate loans\r\n    function borrowInterestRate() public view returns (uint256) {\r\n        return _nextBorrowInterestRate(0);\r\n    }\r\n\r\n    function nextBorrowInterestRate(uint256 borrowAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _nextBorrowInterestRate(borrowAmount);\r\n    }\r\n\r\n    // interest that lenders are currently receiving when supplying to the pool\r\n    function supplyInterestRate() public view returns (uint256) {\r\n        return totalSupplyInterestRate(_totalAssetSupply(0));\r\n    }\r\n\r\n    function nextSupplyInterestRate(uint256 supplyAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalSupplyInterestRate(_totalAssetSupply(0).add(supplyAmount));\r\n    }\r\n\r\n    function totalSupplyInterestRate(uint256 assetSupply)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 assetBorrow = totalAssetBorrow();\r\n        if (assetBorrow != 0) {\r\n            return _supplyInterestRate(assetBorrow, assetSupply);\r\n        }\r\n    }\r\n\r\n    function totalAssetBorrow() public view returns (uint256) {\r\n        return\r\n            ProtocolLike(sovrynContractAddress).getTotalPrincipal(\r\n                address(this),\r\n                loanTokenAddress\r\n            );\r\n    }\r\n\r\n    function totalAssetSupply() public view returns (uint256) {\r\n        uint256 interestUnPaid;\r\n        if (lastSettleTime_ != uint88(block.timestamp)) {\r\n            (, interestUnPaid) = _getAllInterest();\r\n        }\r\n\r\n        return _totalAssetSupply(interestUnPaid);\r\n    }\r\n\r\n    function getMaxEscrowAmount(uint256 leverageAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 initialMargin = SafeMathSovryn.div(10**38, leverageAmount);\r\n        return\r\n            marketLiquidity().mul(initialMargin).div(\r\n                _adjustValue(\r\n                    10**20, // maximum possible interest (100%)\r\n                    2419200, // 28 day duration for margin trades\r\n                    initialMargin\r\n                )\r\n            );\r\n    }\r\n\r\n    // returns the user's balance of underlying token\r\n    function assetBalanceOf(address _owner) public view returns (uint256) {\r\n        return balanceOf(_owner).mul(tokenPrice()).div(10**18);\r\n    }\r\n\r\n    function getEstimatedMarginDetails(\r\n        uint256 leverageAmount,\r\n        uint256 loanTokenSent,\r\n        uint256 collateralTokenSent,\r\n        address collateralTokenAddress // address(0) means ETH\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            uint256 principal,\r\n            uint256 collateral,\r\n            uint256 interestRate\r\n        )\r\n    {\r\n        if (collateralTokenAddress == address(0)) {\r\n            collateralTokenAddress = wrbtcTokenAddress;\r\n        }\r\n\r\n        uint256 totalDeposit = _totalDeposit(\r\n            collateralTokenAddress,\r\n            collateralTokenSent,\r\n            loanTokenSent\r\n        );\r\n\r\n        (principal, interestRate) = _getMarginBorrowAmountAndRate(\r\n            leverageAmount,\r\n            totalDeposit\r\n        );\r\n        if (principal > _underlyingBalance()) {\r\n            return (0, 0, 0);\r\n        }\r\n\r\n        loanTokenSent = loanTokenSent.add(principal);\r\n\r\n        collateral = ProtocolLike(sovrynContractAddress)\r\n            .getEstimatedMarginExposure(\r\n            loanTokenAddress,\r\n            collateralTokenAddress,\r\n            loanTokenSent,\r\n            collateralTokenSent,\r\n            interestRate,\r\n            principal\r\n        );\r\n    }\r\n\r\n    function getDepositAmountForBorrow(\r\n        uint256 borrowAmount,\r\n        uint256 initialLoanDuration, // duration in seconds\r\n        address collateralTokenAddress // address(0) means ETH\r\n    ) public view returns (uint256 depositAmount) {\r\n        if (borrowAmount != 0) {\r\n            (, , uint256 newBorrowAmount) = _getInterestRateAndBorrowAmount(\r\n                borrowAmount,\r\n                totalAssetSupply(),\r\n                initialLoanDuration\r\n            );\r\n\r\n            if (newBorrowAmount <= _underlyingBalance()) {\r\n                return\r\n                    ProtocolLike(sovrynContractAddress)\r\n                        .getRequiredCollateral(\r\n                        loanTokenAddress,\r\n                        collateralTokenAddress != address(0)\r\n                            ? collateralTokenAddress\r\n                            : wrbtcTokenAddress,\r\n                        newBorrowAmount,\r\n                        50 * 10**18, // initialMargin\r\n                        true // isTorqueLoan\r\n                    )\r\n                        .add(10); // some dust to compensate for rounding errors\r\n            }\r\n        }\r\n    }\r\n\r\n    function getBorrowAmountForDeposit(\r\n        uint256 depositAmount,\r\n        uint256 initialLoanDuration, // duration in seconds\r\n        address collateralTokenAddress // address(0) means ETH\r\n    ) public view returns (uint256 borrowAmount) {\r\n        if (depositAmount != 0) {\r\n            borrowAmount = ProtocolLike(sovrynContractAddress).getBorrowAmount(\r\n                loanTokenAddress,\r\n                collateralTokenAddress != address(0)\r\n                    ? collateralTokenAddress\r\n                    : wrbtcTokenAddress,\r\n                depositAmount,\r\n                50 * 10**18, // initialMargin,\r\n                true // isTorqueLoan\r\n            );\r\n\r\n            (, , borrowAmount) = _getInterestRateAndBorrowAmount(\r\n                borrowAmount,\r\n                totalAssetSupply(),\r\n                initialLoanDuration\r\n            );\r\n\r\n            if (borrowAmount > _underlyingBalance()) {\r\n                borrowAmount = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    /* Internal functions */\r\n\r\n    function _mintToken(address receiver, uint256 depositAmount)\r\n        internal\r\n        returns (uint256 mintAmount)\r\n    {\r\n        require(depositAmount != 0, \"17\");\r\n\r\n        _settleInterest();\r\n\r\n        uint256 currentPrice = _tokenPrice(_totalAssetSupply(0));\r\n        mintAmount = depositAmount.mul(10**18).div(currentPrice);\r\n\r\n        if (msg.value == 0) {\r\n            _safeTransferFrom(\r\n                loanTokenAddress,\r\n                msg.sender,\r\n                address(this),\r\n                depositAmount,\r\n                \"18\"\r\n            );\r\n        } else {\r\n            IWrbtc(wrbtcTokenAddress).deposit.value(depositAmount)();\r\n        }\r\n\r\n        uint256 oldBalance = balances[receiver];\r\n        _updateCheckpoints(\r\n            receiver,\r\n            oldBalance,\r\n            _mint(receiver, mintAmount, depositAmount, currentPrice), // newBalance\r\n            currentPrice\r\n        );\r\n    }\r\n\r\n    function _burnToken(uint256 burnAmount)\r\n        internal\r\n        returns (uint256 loanAmountPaid)\r\n    {\r\n        require(burnAmount != 0, \"19\");\r\n\r\n        if (burnAmount > balanceOf(msg.sender)) {\r\n            burnAmount = balanceOf(msg.sender);\r\n        }\r\n\r\n        _settleInterest();\r\n\r\n        uint256 currentPrice = _tokenPrice(_totalAssetSupply(0));\r\n\r\n        uint256 loanAmountOwed = burnAmount.mul(currentPrice).div(10**18);\r\n        uint256 loanAmountAvailableInContract = _underlyingBalance();\r\n\r\n        loanAmountPaid = loanAmountOwed;\r\n        require(loanAmountPaid <= loanAmountAvailableInContract, \"37\");\r\n\r\n        uint256 oldBalance = balances[msg.sender];\r\n        _updateCheckpoints(\r\n            msg.sender,\r\n            oldBalance,\r\n            _burn(msg.sender, burnAmount, loanAmountPaid, currentPrice), // newBalance\r\n            currentPrice\r\n        );\r\n    }\r\n\r\n    function _settleInterest() internal {\r\n        uint88 ts = uint88(block.timestamp);\r\n        if (lastSettleTime_ != ts) {\r\n            ProtocolLike(sovrynContractAddress).withdrawAccruedInterest(\r\n                loanTokenAddress\r\n            );\r\n\r\n            lastSettleTime_ = ts;\r\n        }\r\n    }\r\n\r\n    function _totalDeposit(\r\n        address collateralTokenAddress,\r\n        uint256 collateralTokenSent,\r\n        uint256 loanTokenSent\r\n    ) internal view returns (uint256 totalDeposit) {\r\n        totalDeposit = loanTokenSent;\r\n        if (collateralTokenSent != 0) {\r\n            (\r\n                uint256 sourceToDestRate,\r\n                uint256 sourceToDestPrecision\r\n            ) = FeedsLike(ProtocolLike(sovrynContractAddress).priceFeeds())\r\n                .queryRate(collateralTokenAddress, loanTokenAddress);\r\n            if (sourceToDestPrecision != 0) {\r\n                totalDeposit = collateralTokenSent\r\n                    .mul(sourceToDestRate)\r\n                    .div(sourceToDestPrecision)\r\n                    .add(totalDeposit);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _getInterestRateAndBorrowAmount(\r\n        uint256 borrowAmount,\r\n        uint256 assetSupply,\r\n        uint256 initialLoanDuration // duration in seconds\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 interestRate,\r\n            uint256 interestInitialAmount,\r\n            uint256 newBorrowAmount\r\n        )\r\n    {\r\n        interestRate = _nextBorrowInterestRate2(borrowAmount, assetSupply);\r\n\r\n        // newBorrowAmount = borrowAmount * 10^18 / (10^18 - interestRate * 7884000 * 10^18 / 31536000 / 10^20)\r\n        newBorrowAmount = borrowAmount.mul(10**18).div(\r\n            SafeMathSovryn.sub(\r\n                10**18,\r\n                interestRate.mul(initialLoanDuration).mul(10**18).div(\r\n                    31536000 * 10**20\r\n                ) // 365 * 86400 * 10**20\r\n            )\r\n        );\r\n\r\n        interestInitialAmount = newBorrowAmount.sub(borrowAmount);\r\n    }\r\n\r\n    // returns newPrincipal\r\n    function _borrowOrTrade(\r\n        bytes32 loanId,\r\n        uint256 withdrawAmount,\r\n        uint256 leverageAmount,\r\n        address collateralTokenAddress,\r\n        address[4] memory sentAddresses,\r\n        uint256[5] memory sentAmounts,\r\n        bytes memory loanDataBytes\r\n    ) internal returns (uint256, uint256) {\r\n        _checkPause();\r\n\r\n        require(\r\n            sentAmounts[1] <= _underlyingBalance() && // newPrincipal (borrowed amount + fees)\r\n                sentAddresses[1] != address(0), // borrower\r\n            \"24\"\r\n        );\r\n\r\n        if (sentAddresses[2] == address(0)) {\r\n            sentAddresses[2] = sentAddresses[1]; // receiver = borrower\r\n        }\r\n\r\n        // handle transfers prior to adding newPrincipal to loanTokenSent\r\n        uint256 msgValue = _verifyTransfers(\r\n            collateralTokenAddress,\r\n            sentAddresses,\r\n            sentAmounts,\r\n            withdrawAmount\r\n        );\r\n\r\n        // adding the loan token portion from the lender to loanTokenSent\r\n        // (add the loan to the loan tokens sent from the user)\r\n        sentAmounts[3] = sentAmounts[3].add(sentAmounts[1]); // newPrincipal\r\n\r\n        if (withdrawAmount != 0) {\r\n            // withdrawAmount already sent to the borrower, so we aren't sending it to the protocol\r\n            sentAmounts[3] = sentAmounts[3].sub(withdrawAmount);\r\n        }\r\n\r\n        bytes32 loanParamsId = loanParamsIds[uint256(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    collateralTokenAddress,\r\n                    withdrawAmount != 0 // isTorqueLoan\r\n                        ? true\r\n                        : false\r\n                )\r\n            )\r\n        )];\r\n\r\n        // converting to initialMargin\r\n        leverageAmount = SafeMathSovryn.div(10**38, leverageAmount);\r\n\r\n        (sentAmounts[1], sentAmounts[4]) = ProtocolLike(sovrynContractAddress)\r\n            .borrowOrTradeFromPool\r\n            .value(msgValue)( // newPrincipal, newCollateral\r\n            loanParamsId,\r\n            loanId,\r\n            withdrawAmount != 0 // isTorqueLoan\r\n                ? true\r\n                : false,\r\n            leverageAmount, // initialMargin\r\n            sentAddresses,\r\n            sentAmounts,\r\n            loanDataBytes\r\n        );\r\n        require(sentAmounts[1] != 0, \"25\");\r\n\r\n        return (sentAmounts[1], sentAmounts[4]); // newPrincipal, newCollateral\r\n    }\r\n\r\n    // sentAddresses[0]: lender\r\n    // sentAddresses[1]: borrower\r\n    // sentAddresses[2]: receiver\r\n    // sentAddresses[3]: manager\r\n    // sentAmounts[0]: interestRate\r\n    // sentAmounts[1]: newPrincipal\r\n    // sentAmounts[2]: interestInitialAmount\r\n    // sentAmounts[3]: loanTokenSent\r\n    // sentAmounts[4]: collateralTokenSent\r\n    function _verifyTransfers(\r\n        address collateralTokenAddress,\r\n        address[4] memory sentAddresses,\r\n        uint256[5] memory sentAmounts,\r\n        uint256 withdrawalAmount\r\n    ) internal returns (uint256 msgValue) {\r\n        address _wrbtcToken = wrbtcTokenAddress;\r\n        address _loanTokenAddress = loanTokenAddress;\r\n        address receiver = sentAddresses[2];\r\n        uint256 newPrincipal = sentAmounts[1];\r\n        uint256 loanTokenSent = sentAmounts[3];\r\n        uint256 collateralTokenSent = sentAmounts[4];\r\n\r\n        require(_loanTokenAddress != collateralTokenAddress, \"26\");\r\n\r\n        msgValue = msg.value;\r\n\r\n        if (withdrawalAmount != 0) {\r\n            // withdrawOnOpen == true\r\n            _safeTransfer(_loanTokenAddress, receiver, withdrawalAmount, \"\");\r\n            if (newPrincipal > withdrawalAmount) {\r\n                _safeTransfer(\r\n                    _loanTokenAddress,\r\n                    sovrynContractAddress,\r\n                    newPrincipal - withdrawalAmount,\r\n                    \"\"\r\n                );\r\n            }\r\n        } else {\r\n            _safeTransfer(\r\n                _loanTokenAddress,\r\n                sovrynContractAddress,\r\n                newPrincipal,\r\n                \"27\"\r\n            );\r\n        }\r\n        //this is a critical piece of code!\r\n        //wEth are supposed to be held by the contract itself, while other tokens are being transfered from the sender directly\r\n        if (collateralTokenSent != 0) {\r\n            if (\r\n                collateralTokenAddress == _wrbtcToken &&\r\n                msgValue != 0 &&\r\n                msgValue >= collateralTokenSent\r\n            ) {\r\n                IWrbtc(_wrbtcToken).deposit.value(collateralTokenSent)();\r\n                _safeTransfer(\r\n                    collateralTokenAddress,\r\n                    sovrynContractAddress,\r\n                    collateralTokenSent,\r\n                    \"28-a\"\r\n                );\r\n                msgValue -= collateralTokenSent;\r\n            } else {\r\n                _safeTransferFrom(\r\n                    collateralTokenAddress,\r\n                    msg.sender,\r\n                    sovrynContractAddress,\r\n                    collateralTokenSent,\r\n                    \"28-b\"\r\n                );\r\n            }\r\n        }\r\n\r\n        if (loanTokenSent != 0) {\r\n            _safeTransferFrom(\r\n                _loanTokenAddress,\r\n                msg.sender,\r\n                sovrynContractAddress,\r\n                loanTokenSent,\r\n                \"29\"\r\n            );\r\n        }\r\n    }\r\n\r\n    function _safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 amount,\r\n        string memory errorMsg\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                IERC20Sovryn(token).transfer.selector,\r\n                to,\r\n                amount\r\n            ),\r\n            errorMsg\r\n        );\r\n    }\r\n\r\n    function _safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        string memory errorMsg\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                IERC20Sovryn(token).transferFrom.selector,\r\n                from,\r\n                to,\r\n                amount\r\n            ),\r\n            errorMsg\r\n        );\r\n    }\r\n\r\n    function _callOptionalReturn(\r\n        address token,\r\n        bytes memory data,\r\n        string memory errorMsg\r\n    ) internal {\r\n        (bool success, bytes memory returndata) = token.call(data);\r\n        require(success, errorMsg);\r\n\r\n        if (returndata.length != 0) {\r\n            require(abi.decode(returndata, (bool)), errorMsg);\r\n        }\r\n    }\r\n\r\n    function _underlyingBalance() internal view returns (uint256) {\r\n        return IERC20Sovryn(loanTokenAddress).balanceOf(address(this));\r\n    }\r\n\r\n    /* Internal View functions */\r\n\r\n    function _tokenPrice(uint256 assetSupply) internal view returns (uint256) {\r\n        uint256 totalTokenSupply = totalSupply_;\r\n\r\n        return\r\n            totalTokenSupply != 0\r\n                ? assetSupply.mul(10**18).div(totalTokenSupply)\r\n                : initialPrice;\r\n    }\r\n\r\n    function _avgBorrowInterestRate(uint256 assetBorrow)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (assetBorrow != 0) {\r\n            (uint256 interestOwedPerDay, ) = _getAllInterest();\r\n            return interestOwedPerDay.mul(10**20).div(assetBorrow).mul(365);\r\n        }\r\n    }\r\n\r\n    // next supply interest adjustment\r\n    function _supplyInterestRate(uint256 assetBorrow, uint256 assetSupply)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (assetBorrow != 0 && assetSupply >= assetBorrow) {\r\n            return\r\n                _avgBorrowInterestRate(assetBorrow)\r\n                    .mul(_utilizationRate(assetBorrow, assetSupply))\r\n                    .mul(\r\n                    SafeMathSovryn.sub(\r\n                        10**20,\r\n                        ProtocolLike(sovrynContractAddress).lendingFeePercent()\r\n                    )\r\n                )\r\n                    .div(10**40);\r\n        }\r\n    }\r\n\r\n    function _nextBorrowInterestRate(uint256 borrowAmount)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 interestUnPaid;\r\n        if (borrowAmount != 0) {\r\n            if (lastSettleTime_ != uint88(block.timestamp)) {\r\n                (, interestUnPaid) = _getAllInterest();\r\n            }\r\n\r\n            uint256 balance = _underlyingBalance().add(interestUnPaid);\r\n            if (borrowAmount > balance) {\r\n                borrowAmount = balance;\r\n            }\r\n        }\r\n\r\n        return\r\n            _nextBorrowInterestRate2(\r\n                borrowAmount,\r\n                _totalAssetSupply(interestUnPaid)\r\n            );\r\n    }\r\n\r\n    function _nextBorrowInterestRate2(\r\n        uint256 newBorrowAmount,\r\n        uint256 assetSupply\r\n    ) internal view returns (uint256 nextRate) {\r\n        uint256 utilRate = _utilizationRate(\r\n            totalAssetBorrow().add(newBorrowAmount),\r\n            assetSupply\r\n        );\r\n\r\n        uint256 thisMinRate;\r\n        uint256 thisMaxRate;\r\n        uint256 thisBaseRate = baseRate;\r\n        uint256 thisRateMultiplier = rateMultiplier;\r\n        uint256 thisTargetLevel = targetLevel;\r\n        uint256 thisKinkLevel = kinkLevel;\r\n        uint256 thisMaxScaleRate = maxScaleRate;\r\n\r\n        if (utilRate < thisTargetLevel) {\r\n            // target targetLevel utilization when utilization is under targetLevel\r\n            utilRate = thisTargetLevel;\r\n        }\r\n\r\n        if (utilRate > thisKinkLevel) {\r\n            // scale rate proportionally up to 100%\r\n            uint256 thisMaxRange = WEI_PERCENT_PRECISION - thisKinkLevel; // will not overflow\r\n\r\n            utilRate -= thisKinkLevel;\r\n            if (utilRate > thisMaxRange) utilRate = thisMaxRange;\r\n\r\n            thisMaxRate = thisRateMultiplier\r\n                .add(thisBaseRate)\r\n                .mul(thisKinkLevel)\r\n                .div(WEI_PERCENT_PRECISION);\r\n\r\n            nextRate = utilRate\r\n                .mul(SafeMathSovryn.sub(thisMaxScaleRate, thisMaxRate))\r\n                .div(thisMaxRange)\r\n                .add(thisMaxRate);\r\n        } else {\r\n            nextRate = utilRate\r\n                .mul(thisRateMultiplier)\r\n                .div(WEI_PERCENT_PRECISION)\r\n                .add(thisBaseRate);\r\n\r\n            thisMinRate = thisBaseRate;\r\n            thisMaxRate = thisRateMultiplier.add(thisBaseRate);\r\n\r\n            if (nextRate < thisMinRate) nextRate = thisMinRate;\r\n            else if (nextRate > thisMaxRate) nextRate = thisMaxRate;\r\n        }\r\n    }\r\n\r\n    function _getAllInterest()\r\n        internal\r\n        view\r\n        returns (uint256 interestOwedPerDay, uint256 interestUnPaid)\r\n    {\r\n        // interestPaid, interestPaidDate, interestOwedPerDay, interestUnPaid, interestFeePercent, principalTotal\r\n        uint256 interestFeePercent;\r\n        (\r\n            ,\r\n            ,\r\n            interestOwedPerDay,\r\n            interestUnPaid,\r\n            interestFeePercent,\r\n\r\n        ) = ProtocolLike(sovrynContractAddress).getLenderInterestData(\r\n            address(this),\r\n            loanTokenAddress\r\n        );\r\n\r\n        interestUnPaid = interestUnPaid\r\n            .mul(SafeMathSovryn.sub(10**20, interestFeePercent))\r\n            .div(10**20);\r\n    }\r\n\r\n    function _getMarginBorrowAmountAndRate(\r\n        uint256 leverageAmount,\r\n        uint256 depositAmount\r\n    ) internal view returns (uint256 borrowAmount, uint256 interestRate) {\r\n        uint256 initialMargin = SafeMathSovryn.div(10**38, leverageAmount);\r\n\r\n        interestRate = _nextBorrowInterestRate2(\r\n            depositAmount.mul(10**20).div(initialMargin),\r\n            _totalAssetSupply(0)\r\n        );\r\n\r\n        // assumes that loan, collateral, and interest token are the same\r\n        borrowAmount = depositAmount\r\n            .mul(10**40)\r\n            .div(\r\n            _adjustValue(\r\n                interestRate,\r\n                2419200, // 28 day duration for margin trades\r\n                initialMargin\r\n            )\r\n        )\r\n            .div(initialMargin);\r\n    }\r\n\r\n    function _totalAssetSupply(uint256 interestUnPaid)\r\n        internal\r\n        view\r\n        returns (uint256 assetSupply)\r\n    {\r\n        if (totalSupply_ != 0) {\r\n            uint256 assetsBalance = _flTotalAssetSupply; // temporary locked totalAssetSupply during a flash loan transaction\r\n            if (assetsBalance == 0) {\r\n                assetsBalance = _underlyingBalance().add(totalAssetBorrow());\r\n            }\r\n\r\n            return assetsBalance.add(interestUnPaid);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * used to read externally from the smart contract to see if a function is paused\r\n     * returns a bool\r\n     * */\r\n    function checkPause(string memory funcId)\r\n        public\r\n        view\r\n        returns (bool isPaused)\r\n    {\r\n        bytes4 sig = bytes4(keccak256(abi.encodePacked(funcId)));\r\n        bytes32 slot = keccak256(\r\n            abi.encodePacked(\r\n                sig,\r\n                uint256(\r\n                    0xd46a704bc285dbd6ff5ad3863506260b1df02812f4f857c8cc852317a6ac64f2\r\n                )\r\n            )\r\n        );\r\n        assembly {\r\n            isPaused := sload(slot)\r\n        }\r\n        return isPaused;\r\n    }\r\n\r\n    /**\r\n     * used for internal verification if the called function is paused.\r\n     * throws an exception in case it's not\r\n     * */\r\n    function _checkPause() internal view {\r\n        //keccak256(\"iToken_FunctionPause\")\r\n        bytes32 slot = keccak256(\r\n            abi.encodePacked(\r\n                msg.sig,\r\n                uint256(\r\n                    0xd46a704bc285dbd6ff5ad3863506260b1df02812f4f857c8cc852317a6ac64f2\r\n                )\r\n            )\r\n        );\r\n        bool isPaused;\r\n        assembly {\r\n            isPaused := sload(slot)\r\n        }\r\n        require(!isPaused, \"unauthorized\");\r\n    }\r\n\r\n    function _adjustValue(\r\n        uint256 interestRate,\r\n        uint256 maxDuration,\r\n        uint256 marginAmount\r\n    ) internal pure returns (uint256) {\r\n        return\r\n            maxDuration != 0\r\n                ? interestRate\r\n                    .mul(10**20)\r\n                    .div(31536000) // 86400 * 365\r\n                    .mul(maxDuration)\r\n                    .div(marginAmount)\r\n                    .add(10**20)\r\n                : 10**20;\r\n    }\r\n\r\n    function _utilizationRate(uint256 assetBorrow, uint256 assetSupply)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (assetBorrow != 0 && assetSupply != 0) {\r\n            // U = total_borrow / total_supply\r\n            return assetBorrow.mul(10**20).div(assetSupply);\r\n        }\r\n    }\r\n\r\n    /* Owner-Only functions */\r\n\r\n    function updateSettings(address settingsTarget, bytes memory callData)\r\n        public\r\n        onlyOwner\r\n    {\r\n        address currentTarget = target_;\r\n        target_ = settingsTarget;\r\n\r\n        (bool result, ) = address(this).call(callData);\r\n\r\n        uint256 size;\r\n        uint256 ptr;\r\n        assembly {\r\n            size := returndatasize\r\n            ptr := mload(0x40)\r\n            returndatacopy(ptr, 0, size)\r\n            if eq(result, 0) {\r\n                revert(ptr, size)\r\n            }\r\n        }\r\n\r\n        target_ = currentTarget;\r\n\r\n        assembly {\r\n            return(ptr, size)\r\n        }\r\n    }\r\n\r\n    function setEarlyAccessToken(address _earlyAccessTokenAddress)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(Address.isContract(_earlyAccessTokenAddress), \"\");\r\n\r\n        address oldEarlyAccessToken = earlyAccessToken;\r\n        earlyAccessToken = _earlyAccessTokenAddress;\r\n\r\n        emit SetEarlyAccessToken(\r\n            msg.sender,\r\n            oldEarlyAccessToken,\r\n            earlyAccessToken\r\n        );\r\n    }\r\n}\r\n\r\ncontract LoanTokenLogicWrbtc is LoanTokenLogicStandard {\r\n    function mintWithBTC(address receiver)\r\n        external\r\n        payable\r\n        nonReentrant\r\n        returns (uint256 mintAmount)\r\n    {\r\n        return _mintToken(receiver, msg.value);\r\n    }\r\n\r\n    function burnToBTC(address receiver, uint256 burnAmount)\r\n        external\r\n        nonReentrant\r\n        returns (uint256 loanAmountPaid)\r\n    {\r\n        loanAmountPaid = _burnToken(burnAmount);\r\n\r\n        if (loanAmountPaid != 0) {\r\n            IWrbtcERC20(wrbtcTokenAddress).withdraw(loanAmountPaid);\r\n            Address.sendValue(address(uint160(receiver)), loanAmountPaid);\r\n        }\r\n    }\r\n\r\n    /* Internal functions */\r\n\r\n    // sentAddresses[0]: lender\r\n    // sentAddresses[1]: borrower\r\n    // sentAddresses[2]: receiver\r\n    // sentAddresses[3]: manager\r\n    // sentAmounts[0]: interestRate\r\n    // sentAmounts[1]: newPrincipal\r\n    // sentAmounts[2]: interestInitialAmount\r\n    // sentAmounts[3]: loanTokenSent\r\n    // sentAmounts[4]: collateralTokenSent\r\n    function _verifyTransfers(\r\n        address collateralTokenAddress,\r\n        address[4] memory sentAddresses,\r\n        uint256[5] memory sentAmounts,\r\n        uint256 withdrawalAmount\r\n    ) internal returns (uint256 msgValue) {\r\n        address _wrbtcToken = wrbtcTokenAddress;\r\n        address _loanTokenAddress = _wrbtcToken;\r\n        address receiver = sentAddresses[2];\r\n        uint256 newPrincipal = sentAmounts[1];\r\n        uint256 loanTokenSent = sentAmounts[3];\r\n        uint256 collateralTokenSent = sentAmounts[4];\r\n\r\n        require(_loanTokenAddress != collateralTokenAddress, \"26\");\r\n\r\n        msgValue = msg.value;\r\n\r\n        if (withdrawalAmount != 0) {\r\n            // withdrawOnOpen == true\r\n            IWrbtcERC20(_wrbtcToken).withdraw(withdrawalAmount);\r\n            Address.sendValue(address(uint160(receiver)), withdrawalAmount);\r\n            if (newPrincipal > withdrawalAmount) {\r\n                _safeTransfer(\r\n                    _loanTokenAddress,\r\n                    sovrynContractAddress,\r\n                    newPrincipal - withdrawalAmount,\r\n                    \"\"\r\n                );\r\n            }\r\n        } else {\r\n            _safeTransfer(\r\n                _loanTokenAddress,\r\n                sovrynContractAddress,\r\n                newPrincipal,\r\n                \"27\"\r\n            );\r\n        }\r\n\r\n        if (collateralTokenSent != 0) {\r\n            _safeTransferFrom(\r\n                collateralTokenAddress,\r\n                msg.sender,\r\n                sovrynContractAddress,\r\n                collateralTokenSent,\r\n                \"28\"\r\n            );\r\n        }\r\n\r\n        if (loanTokenSent != 0) {\r\n            if (msgValue != 0 && msgValue >= loanTokenSent) {\r\n                IWrbtc(_wrbtcToken).deposit.value(loanTokenSent)();\r\n                _safeTransfer(\r\n                    _loanTokenAddress,\r\n                    sovrynContractAddress,\r\n                    loanTokenSent,\r\n                    \"29\"\r\n                );\r\n                msgValue -= loanTokenSent;\r\n            } else {\r\n                _safeTransferFrom(\r\n                    _loanTokenAddress,\r\n                    msg.sender,\r\n                    sovrynContractAddress,\r\n                    loanTokenSent,\r\n                    \"29\"\r\n                );\r\n            }\r\n        }\r\n    }\r\n}\r\n",
  "imports": [
    {
      "name": "WRBTC_LoanTokenLogic.sol",
      "contents": "/**\r\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0.\r\n */\r\n\r\npragma solidity 0.5.17;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @title SignedSafeMath\r\n * @dev Signed math operations with safety checks that revert on error.\r\n */\r\nlibrary SignedSafeMath {\r\n    int256 private constant _INT256_MIN = -2**255;\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(\r\n            !(a == -1 && b == _INT256_MIN),\r\n            \"SignedSafeMath: multiplication overflow\"\r\n        );\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two signed integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0, \"SignedSafeMath: division by zero\");\r\n        require(\r\n            !(b == -1 && a == _INT256_MIN),\r\n            \"SignedSafeMath: division overflow\"\r\n        );\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require(\r\n            (b >= 0 && c <= a) || (b < 0 && c > a),\r\n            \"SignedSafeMath: subtraction overflow\"\r\n        );\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require(\r\n            (b >= 0 && c >= a) || (b < 0 && c < a),\r\n            \"SignedSafeMath: addition overflow\"\r\n        );\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMathSovryn {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function min256(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        return _a < _b ? _a : _b;\r\n    }\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract ContextSovryn {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor() internal {}\r\n\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev Constant for unlocked guard state - non-zero to prevent extra gas costs.\r\n    /// See: https://github.com/OpenZeppelin/openzeppelin-solidity/issues/1056\r\n    uint256 internal constant REENTRANCY_GUARD_FREE = 1;\r\n\r\n    /// @dev Constant for locked guard state\r\n    uint256 internal constant REENTRANCY_GUARD_LOCKED = 2;\r\n\r\n    /**\r\n     * @dev We use a single lock for the whole contract.\r\n     */\r\n    uint256 internal reentrancyLock = REENTRANCY_GUARD_FREE;\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * If you mark a function `nonReentrant`, you should also\r\n     * mark it `external`. Calling one `nonReentrant` function from\r\n     * another is not supported. Instead, you can implement a\r\n     * `private` function doing the actual work, and an `external`\r\n     * wrapper marked as `nonReentrant`.\r\n     */\r\n    modifier nonReentrant() {\r\n        require(reentrancyLock == REENTRANCY_GUARD_FREE, \"nonReentrant\");\r\n        reentrancyLock = REENTRANCY_GUARD_LOCKED;\r\n        _;\r\n        reentrancyLock = REENTRANCY_GUARD_FREE;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is ContextSovryn {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"unauthorized\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n\r\n\r\n            bytes32 accountHash\r\n         = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account)\r\n        internal\r\n        pure\r\n        returns (address payable)\r\n    {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n}\r\n\r\ninterface IWrbtc {\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256 wad) external;\r\n}\r\n\r\ncontract IERC20Sovryn {\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function balanceOf(address _who) public view returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n\r\n    function allowance(address _owner, address _spender)\r\n        public\r\n        view\r\n        returns (uint256);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) public returns (bool);\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ncontract IWrbtcERC20 is IWrbtc, IERC20Sovryn {}\r\n\r\ncontract Pausable {\r\n    // keccak256(\"Pausable_FunctionPause\")\r\n    bytes32\r\n        internal constant Pausable_FunctionPause = 0xa7143c84d793a15503da6f19bf9119a2dac94448ca45d77c8bf08f57b2e91047;\r\n\r\n    modifier pausable(bytes4 sig) {\r\n        require(!_isPaused(sig), \"unauthorized\");\r\n        _;\r\n    }\r\n\r\n    function _isPaused(bytes4 sig) internal view returns (bool isPaused) {\r\n        bytes32 slot = keccak256(abi.encodePacked(sig, Pausable_FunctionPause));\r\n        assembly {\r\n            isPaused := sload(slot)\r\n        }\r\n    }\r\n}\r\n\r\ncontract LoanTokenBase is ReentrancyGuard, Ownable {\r\n    uint256 internal constant WEI_PRECISION = 10**18;\r\n    uint256 internal constant WEI_PERCENT_PRECISION = 10**20;\r\n\r\n    int256 internal constant sWEI_PRECISION = 10**18;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    address public loanTokenAddress;\r\n\r\n    uint256 public baseRate;\r\n    uint256 public rateMultiplier;\r\n    uint256 public lowUtilBaseRate;\r\n    uint256 public lowUtilRateMultiplier;\r\n\r\n    uint256 public targetLevel;\r\n    uint256 public kinkLevel;\r\n    uint256 public maxScaleRate;\r\n\r\n    uint256 internal _flTotalAssetSupply;\r\n    uint256 public checkpointSupply;\r\n    uint256 public initialPrice;\r\n\r\n    // uint88 for tight packing -> 8 + 88 + 160 = 256\r\n    uint88 internal lastSettleTime_;\r\n\r\n    mapping(uint256 => bytes32) public loanParamsIds; // mapping of keccak256(collateralToken, isTorqueLoan) to loanParamsId\r\n    mapping(address => uint256) internal checkpointPrices_; // price of token at last user checkpoint\r\n\r\n    mapping(address => uint256) public transactionLimit; // the maximum trading/borrowing/lending limit per token address\r\n    // 0 -> no limit\r\n}\r\n\r\ncontract AdvancedTokenStorage is LoanTokenBase {\r\n    using SafeMathSovryn for uint256;\r\n\r\n    // topic: 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // topic: 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    // topic: 0xb4c03061fb5b7fed76389d5af8f2e0ddb09f8c70d1333abbb62582835e10accb\r\n    event Mint(\r\n        address indexed minter,\r\n        uint256 tokenAmount,\r\n        uint256 assetAmount,\r\n        uint256 price\r\n    );\r\n\r\n    // topic: 0x743033787f4738ff4d6a7225ce2bd0977ee5f86b91a902a58f5e4d0b297b4644\r\n    event Burn(\r\n        address indexed burner,\r\n        uint256 tokenAmount,\r\n        uint256 assetAmount,\r\n        uint256 price\r\n    );\r\n\r\n    mapping(address => uint256) internal balances;\r\n    mapping(address => mapping(address => uint256)) internal allowed;\r\n    uint256 internal totalSupply_;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function allowance(address _owner, address _spender)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\ncontract AdvancedToken is AdvancedTokenStorage {\r\n    using SafeMathSovryn for uint256;\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function _mint(\r\n        address _to,\r\n        uint256 _tokenAmount,\r\n        uint256 _assetAmount,\r\n        uint256 _price\r\n    ) internal returns (uint256) {\r\n        require(_to != address(0), \"15\");\r\n\r\n        uint256 _balance = balances[_to].add(_tokenAmount);\r\n        balances[_to] = _balance;\r\n\r\n        totalSupply_ = totalSupply_.add(_tokenAmount);\r\n\r\n        emit Mint(_to, _tokenAmount, _assetAmount, _price);\r\n        emit Transfer(address(0), _to, _tokenAmount);\r\n\r\n        return _balance;\r\n    }\r\n\r\n    function _burn(\r\n        address _who,\r\n        uint256 _tokenAmount,\r\n        uint256 _assetAmount,\r\n        uint256 _price\r\n    ) internal returns (uint256) {\r\n        require(_tokenAmount <= balances[_who], \"16\");\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n        uint256 _balance = balances[_who].sub(_tokenAmount);\r\n        if (_balance <= 10) {\r\n            // we can't leave such small balance quantities\r\n            _tokenAmount = _tokenAmount.add(_balance);\r\n            _balance = 0;\r\n        }\r\n        balances[_who] = _balance;\r\n\r\n        totalSupply_ = totalSupply_.sub(_tokenAmount);\r\n\r\n        emit Burn(_who, _tokenAmount, _assetAmount, _price);\r\n        emit Transfer(_who, address(0), _tokenAmount);\r\n\r\n        return _balance;\r\n    }\r\n}\r\n\r\ninterface ProtocolLike {\r\n    function borrowOrTradeFromPool(\r\n        bytes32 loanParamsId,\r\n        bytes32 loanId, // if 0, start a new loan\r\n        bool isTorqueLoan,\r\n        uint256 initialMargin,\r\n        address[4] calldata sentAddresses,\r\n        // lender: must match loan if loanId provided\r\n        // borrower: must match loan if loanId provided\r\n        // receiver: receiver of funds (address(0) assumes borrower address)\r\n        // manager: delegated manager of loan unless address(0)\r\n        uint256[5] calldata sentValues,\r\n        // newRate: new loan interest rate\r\n        // newPrincipal: new loan size (borrowAmount + any borrowed interest)\r\n        // torqueInterest: new amount of interest to escrow for Torque loan (determines initial loan length)\r\n        // loanTokenReceived: total loanToken deposit (amount not sent to borrower in the case of Torque loans)\r\n        // collateralTokenReceived: total collateralToken deposit\r\n        bytes calldata loanDataBytes\r\n    ) external payable returns (uint256 newPrincipal, uint256 newCollateral);\r\n\r\n    function getTotalPrincipal(address lender, address loanToken)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function withdrawAccruedInterest(address loanToken) external;\r\n\r\n    function getLenderInterestData(address lender, address loanToken)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 interestPaid,\r\n            uint256 interestPaidDate,\r\n            uint256 interestOwedPerDay,\r\n            uint256 interestUnPaid,\r\n            uint256 interestFeePercent,\r\n            uint256 principalTotal\r\n        );\r\n\r\n    function priceFeeds() external view returns (address);\r\n\r\n    function getEstimatedMarginExposure(\r\n        address loanToken,\r\n        address collateralToken,\r\n        uint256 loanTokenSent,\r\n        uint256 collateralTokenSent,\r\n        uint256 interestRate,\r\n        uint256 newPrincipal\r\n    ) external view returns (uint256);\r\n\r\n    function getRequiredCollateral(\r\n        address loanToken,\r\n        address collateralToken,\r\n        uint256 newPrincipal,\r\n        uint256 marginAmount,\r\n        bool isTorqueLoan\r\n    ) external view returns (uint256 collateralAmountRequired);\r\n\r\n    function getBorrowAmount(\r\n        address loanToken,\r\n        address collateralToken,\r\n        uint256 collateralTokenAmount,\r\n        uint256 marginAmount,\r\n        bool isTorqueLoan\r\n    ) external view returns (uint256 borrowAmount);\r\n\r\n    function isLoanPool(address loanPool) external view returns (bool);\r\n\r\n    function lendingFeePercent() external view returns (uint256);\r\n}\r\n\r\ninterface FeedsLike {\r\n    function queryRate(address sourceTokenAddress, address destTokenAddress)\r\n        external\r\n        view\r\n        returns (uint256 rate, uint256 precision);\r\n}\r\n\r\ncontract LoanTokenLogicStandard is AdvancedToken {\r\n    using SafeMathSovryn for uint256;\r\n    using SignedSafeMath for int256;\r\n\r\n    // It is important to maintain the variables order so the delegate calls can access sovrynContractAddress and wrbtcTokenAddress\r\n    address public sovrynContractAddress;\r\n    address public wrbtcTokenAddress;\r\n    address internal target_;\r\n\r\n    uint256 public constant VERSION = 5;\r\n    address\r\n        internal constant arbitraryCaller = 0x000F400e6818158D541C3EBE45FE3AA0d47372FF;\r\n    address public earlyAccessToken;\r\n\r\n    modifier hasEarlyAccessToken() {\r\n        require(\r\n            IERC20Sovryn(earlyAccessToken).balanceOf(msg.sender) > 0,\r\n            \"No early access tokens\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function() external {\r\n        revert(\"loan token logic - fallback not allowed\");\r\n    }\r\n\r\n    event SetEarlyAccessToken(\r\n        address indexed sender,\r\n        address indexed oldValue,\r\n        address indexed newValue\r\n    );\r\n\r\n    /* Public functions */\r\n\r\n    function mint(address receiver, uint256 depositAmount)\r\n        external\r\n        nonReentrant\r\n        hasEarlyAccessToken\r\n        returns (uint256 mintAmount)\r\n    {\r\n        //temporary: limit transaction size\r\n        if (transactionLimit[loanTokenAddress] > 0)\r\n            require(depositAmount <= transactionLimit[loanTokenAddress]);\r\n\r\n        return _mintToken(receiver, depositAmount);\r\n    }\r\n\r\n    function burn(address receiver, uint256 burnAmount)\r\n        external\r\n        nonReentrant\r\n        returns (uint256 loanAmountPaid)\r\n    {\r\n        loanAmountPaid = _burnToken(burnAmount);\r\n\r\n        if (loanAmountPaid != 0) {\r\n            _safeTransfer(loanTokenAddress, receiver, loanAmountPaid, \"5\");\r\n        }\r\n    }\r\n\r\n    /*\r\n    flashBorrow is disabled for the MVP, but is going to be added later.\r\n    therefore, it needs to be revised\r\n    \r\n    function flashBorrow(\r\n        uint256 borrowAmount,\r\n        address borrower,\r\n        address target,\r\n        string calldata signature,\r\n        bytes calldata data)\r\n        external\r\n        payable\r\n        nonReentrant\r\n        returns (bytes memory)\r\n    {\r\n        require(borrowAmount != 0, \"38\");\r\n\r\n        _checkPause();\r\n\r\n        _settleInterest();\r\n\r\n        // save before balances\r\n        uint256 beforeEtherBalance = address(this).balance.sub(msg.value);\r\n        uint256 beforeAssetsBalance = _underlyingBalance()\r\n            .add(totalAssetBorrow());\r\n\r\n        // lock totalAssetSupply for duration of flash loan\r\n        _flTotalAssetSupply = beforeAssetsBalance;\r\n\r\n        // transfer assets to calling contract\r\n        _safeTransfer(loanTokenAddress, borrower, borrowAmount, \"39\");\r\n\r\n        bytes memory callData;\r\n        if (bytes(signature).length == 0) {\r\n            callData = data;\r\n        } else {\r\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\r\n        }\r\n\r\n        // arbitrary call\r\n        (bool success, bytes memory returnData) = arbitraryCaller.call.value(msg.value)(\r\n            abi.encodeWithSelector(\r\n                0xde064e0d, // sendCall(address,bytes)\r\n                target,\r\n                callData\r\n            )\r\n        );\r\n        require(success, \"call failed\");\r\n\r\n        // unlock totalAssetSupply\r\n        _flTotalAssetSupply = 0;\r\n\r\n        // verifies return of flash loan\r\n        require(\r\n            address(this).balance >= beforeEtherBalance &&\r\n            _underlyingBalance()\r\n                .add(totalAssetBorrow()) >= beforeAssetsBalance,\r\n            \"40\"\r\n        );\r\n\r\n        return returnData;\r\n    }\r\n    */\r\n\r\n    /**\r\n     * borrows funds from the pool. The underlying loan token may not be used as collateral.\r\n     * @param loanId the ID of the loan, 0 for a new loan\r\n     * @param withdrawAmount the amount to be withdrawn (actually borrowed)\r\n     * @param initialLoanDuration the duration of the loan in seconds. if the loan is not paid back until then, it'll need to be rolled over\r\n     * @param collateralTokenSent the amount of collateral token sent (150% of the withdrawn amount worth in collateral tokenns)\r\n     * @param collateralTokenAddress the address of the tokenn to be used as collateral. cannot be the loan token address\r\n     * @param borrower the one paying for the collateral\r\n     * @param receiver the one receiving the withdrawn amount\r\n     * */\r\n    function borrow(\r\n        bytes32 loanId, // 0 if new loan\r\n        uint256 withdrawAmount,\r\n        uint256 initialLoanDuration, // duration in seconds\r\n        uint256 collateralTokenSent, // if 0, loanId must be provided; any ETH sent must equal this value\r\n        address collateralTokenAddress, // if address(0), this means ETH and ETH must be sent with the call or loanId must be provided\r\n        address borrower,\r\n        address receiver,\r\n        bytes memory // arbitrary order data (for future use) /*loanDataBytes*/\r\n    )\r\n        public\r\n        payable\r\n        nonReentrant //note: needs to be removed to allow flashloan use cases\r\n        hasEarlyAccessToken\r\n        returns (\r\n            uint256,\r\n            uint256 // returns new principal and new collateral added to loan\r\n        )\r\n    {\r\n        require(withdrawAmount != 0, \"6\");\r\n\r\n        _checkPause();\r\n\r\n        //temporary: limit transaction size\r\n        if (transactionLimit[collateralTokenAddress] > 0)\r\n            require(\r\n                collateralTokenSent <= transactionLimit[collateralTokenAddress]\r\n            );\r\n\r\n        require(msg.value == 0 || msg.value == collateralTokenSent, \"7\");\r\n        require(collateralTokenSent != 0 || loanId != 0, \"8\");\r\n        require(\r\n            collateralTokenAddress != address(0) ||\r\n                msg.value != 0 ||\r\n                loanId != 0,\r\n            \"9\"\r\n        );\r\n\r\n        if (collateralTokenAddress == address(0)) {\r\n            collateralTokenAddress = wrbtcTokenAddress;\r\n        }\r\n        require(collateralTokenAddress != loanTokenAddress, \"10\");\r\n\r\n        _settleInterest();\r\n\r\n        address[4] memory sentAddresses;\r\n        uint256[5] memory sentAmounts;\r\n\r\n        sentAddresses[0] = address(this); // lender\r\n        sentAddresses[1] = borrower;\r\n        sentAddresses[2] = receiver;\r\n        //sentAddresses[3] = address(0); // manager\r\n\r\n        sentAmounts[1] = withdrawAmount;\r\n\r\n        // interestRate, interestInitialAmount, borrowAmount (newBorrowAmount)\r\n        (\r\n            sentAmounts[0],\r\n            sentAmounts[2],\r\n            sentAmounts[1]\r\n        ) = _getInterestRateAndBorrowAmount(\r\n            sentAmounts[1],\r\n            _totalAssetSupply(0), // interest is settled above\r\n            initialLoanDuration\r\n        );\r\n\r\n        //sentAmounts[3] = 0; // loanTokenSent\r\n        sentAmounts[4] = collateralTokenSent;\r\n\r\n        return\r\n            _borrowOrTrade(\r\n                loanId,\r\n                withdrawAmount,\r\n                2 * 10**18, // leverageAmount (translates to 150% margin for a Torque loan)\r\n                collateralTokenAddress,\r\n                sentAddresses,\r\n                sentAmounts,\r\n                \"\" // loanDataBytes\r\n            );\r\n    }\r\n\r\n    // Called to borrow and immediately get into a positions\r\n    function marginTrade(\r\n        bytes32 loanId, // 0 if new loan\r\n        uint256 leverageAmount, // expected in x * 10**18 where x is the actual leverage (2, 3, 4, or 5)\r\n        uint256 loanTokenSent,\r\n        uint256 collateralTokenSent,\r\n        address collateralTokenAddress,\r\n        address trader,\r\n        bytes memory loanDataBytes // arbitrary order data\r\n    )\r\n        public\r\n        payable\r\n        nonReentrant //note: needs to be removed to allow flashloan use cases\r\n        hasEarlyAccessToken\r\n        returns (\r\n            uint256,\r\n            uint256 // returns new principal and new collateral added to trade\r\n        )\r\n    {\r\n        _checkPause();\r\n\r\n        if (collateralTokenAddress == address(0)) {\r\n            collateralTokenAddress = wrbtcTokenAddress;\r\n        }\r\n\r\n        require(collateralTokenAddress != loanTokenAddress, \"11\");\r\n\r\n        //temporary: limit transaction size\r\n        if (transactionLimit[collateralTokenAddress] > 0)\r\n            require(\r\n                collateralTokenSent <= transactionLimit[collateralTokenAddress]\r\n            );\r\n        if (transactionLimit[loanTokenAddress] > 0)\r\n            require(loanTokenSent <= transactionLimit[loanTokenAddress]);\r\n\r\n        //computes the worth of the total deposit in loan tokens.\r\n        //(loanTokenSent + convert(collateralTokenSent))\r\n        //no actual swap happening here.\r\n        uint256 totalDeposit = _totalDeposit(\r\n            collateralTokenAddress,\r\n            collateralTokenSent,\r\n            loanTokenSent\r\n        );\r\n        require(totalDeposit != 0, \"12\");\r\n\r\n        address[4] memory sentAddresses;\r\n        uint256[5] memory sentAmounts;\r\n\r\n        sentAddresses[0] = address(this); // lender\r\n        sentAddresses[1] = trader;\r\n        sentAddresses[2] = trader;\r\n        //sentAddresses[3] = address(0); // manager\r\n\r\n        //sentAmounts[0] = 0; // interestRate (found later)\r\n        sentAmounts[1] = totalDeposit; // total amount of deposit\r\n        //sentAmounts[2] = 0; // interestInitialAmount (interest is calculated based on fixed-term loan)\r\n        sentAmounts[3] = loanTokenSent;\r\n        sentAmounts[4] = collateralTokenSent;\r\n\r\n        _settleInterest();\r\n\r\n        (sentAmounts[1], sentAmounts[0]) = _getMarginBorrowAmountAndRate( // borrowAmount, interestRate\r\n            leverageAmount,\r\n            sentAmounts[1] // depositAmount\r\n        );\r\n\r\n        return\r\n            _borrowOrTrade(\r\n                loanId,\r\n                0, // withdrawAmount\r\n                leverageAmount,\r\n                collateralTokenAddress,\r\n                sentAddresses,\r\n                sentAmounts,\r\n                loanDataBytes\r\n            );\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool) {\r\n        return _internalTransferFrom(msg.sender, _to, _value, uint256(-1));\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool) {\r\n        return\r\n            _internalTransferFrom(\r\n                _from,\r\n                _to,\r\n                _value,\r\n                ProtocolLike(sovrynContractAddress).isLoanPool(msg.sender)\r\n                    ? uint256(-1)\r\n                    : allowed[_from][msg.sender]\r\n            );\r\n    }\r\n\r\n    function _internalTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _allowanceAmount\r\n    ) internal returns (bool) {\r\n        if (_allowanceAmount != uint256(-1)) {\r\n            require(_value <= _allowanceAmount, \"14\");\r\n            allowed[_from][msg.sender] = _allowanceAmount.sub(_value);\r\n        }\r\n\r\n        uint256 _balancesFrom = balances[_from];\r\n        require(_value <= _balancesFrom && _to != address(0), \"14\");\r\n\r\n        uint256 _balancesFromNew = _balancesFrom.sub(_value);\r\n        balances[_from] = _balancesFromNew;\r\n\r\n        uint256 _balancesTo = balances[_to];\r\n        uint256 _balancesToNew = _balancesTo.add(_value);\r\n        balances[_to] = _balancesToNew;\r\n\r\n        // handle checkpoint update\r\n        uint256 _currentPrice = tokenPrice();\r\n\r\n        _updateCheckpoints(\r\n            _from,\r\n            _balancesFrom,\r\n            _balancesFromNew,\r\n            _currentPrice\r\n        );\r\n        _updateCheckpoints(_to, _balancesTo, _balancesToNew, _currentPrice);\r\n\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    event Debug(bytes32 slot, uint256 one, uint256 two);\r\n\r\n    function _updateCheckpoints(\r\n        address _user,\r\n        uint256 _oldBalance,\r\n        uint256 _newBalance,\r\n        uint256 _currentPrice\r\n    ) internal {\r\n        // keccak256(\"iToken_ProfitSoFar\")\r\n        bytes32 slot = keccak256(\r\n            abi.encodePacked(\r\n                _user,\r\n                uint256(\r\n                    0x37aa2b7d583612f016e4a4de4292cb015139b3d7762663d06a53964912ea2fb6\r\n                )\r\n            )\r\n        );\r\n\r\n        uint256 _currentProfit;\r\n        if (_oldBalance != 0 && _newBalance != 0) {\r\n            _currentProfit = _profitOf(\r\n                slot,\r\n                _oldBalance,\r\n                _currentPrice,\r\n                checkpointPrices_[_user]\r\n            );\r\n        } else if (_newBalance == 0) {\r\n            _currentPrice = 0;\r\n        }\r\n\r\n        assembly {\r\n            sstore(slot, _currentProfit)\r\n        }\r\n\r\n        checkpointPrices_[_user] = _currentPrice;\r\n\r\n        emit Debug(slot, _currentProfit, _currentPrice);\r\n    }\r\n\r\n    /* Public View functions */\r\n\r\n    function profitOf(address user) public view returns (uint256) {\r\n        // keccak256(\"iToken_ProfitSoFar\")\r\n        bytes32 slot = keccak256(\r\n            abi.encodePacked(\r\n                user,\r\n                uint256(\r\n                    0x37aa2b7d583612f016e4a4de4292cb015139b3d7762663d06a53964912ea2fb6\r\n                )\r\n            )\r\n        );\r\n\r\n        return\r\n            _profitOf(\r\n                slot,\r\n                balances[user],\r\n                tokenPrice(),\r\n                checkpointPrices_[user]\r\n            );\r\n    }\r\n\r\n    function _profitOf(\r\n        bytes32 slot,\r\n        uint256 _balance,\r\n        uint256 _currentPrice,\r\n        uint256 _checkpointPrice\r\n    ) internal view returns (uint256) {\r\n        if (_checkpointPrice == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 profitSoFar;\r\n        uint256 profitDiff;\r\n\r\n        assembly {\r\n            profitSoFar := sload(slot)\r\n        }\r\n\r\n        if (_currentPrice > _checkpointPrice) {\r\n            profitDiff = _balance.mul(_currentPrice - _checkpointPrice).div(\r\n                10**18\r\n            );\r\n            profitSoFar = profitSoFar.add(profitDiff);\r\n        } else {\r\n            profitDiff = _balance.mul(_checkpointPrice - _currentPrice).div(\r\n                10**18\r\n            );\r\n            if (profitSoFar > profitDiff) {\r\n                profitSoFar = profitSoFar - profitDiff;\r\n            } else {\r\n                profitSoFar = 0;\r\n            }\r\n        }\r\n\r\n        return profitSoFar;\r\n    }\r\n\r\n    function tokenPrice() public view returns (uint256 price) {\r\n        uint256 interestUnPaid;\r\n        if (lastSettleTime_ != uint88(block.timestamp)) {\r\n            (, interestUnPaid) = _getAllInterest();\r\n        }\r\n\r\n        return _tokenPrice(_totalAssetSupply(interestUnPaid));\r\n    }\r\n\r\n    function checkpointPrice(address _user)\r\n        public\r\n        view\r\n        returns (uint256 price)\r\n    {\r\n        return checkpointPrices_[_user];\r\n    }\r\n\r\n    function marketLiquidity() public view returns (uint256) {\r\n        uint256 totalSupply = _totalAssetSupply(0);\r\n        uint256 totalBorrow = totalAssetBorrow();\r\n        if (totalSupply > totalBorrow) {\r\n            return totalSupply.sub(totalBorrow);\r\n        }\r\n    }\r\n\r\n    function avgBorrowInterestRate() public view returns (uint256) {\r\n        return _avgBorrowInterestRate(totalAssetBorrow());\r\n    }\r\n\r\n    // the minimum rate the next base protocol borrower will receive for variable-rate loans\r\n    function borrowInterestRate() public view returns (uint256) {\r\n        return _nextBorrowInterestRate(0);\r\n    }\r\n\r\n    function nextBorrowInterestRate(uint256 borrowAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _nextBorrowInterestRate(borrowAmount);\r\n    }\r\n\r\n    // interest that lenders are currently receiving when supplying to the pool\r\n    function supplyInterestRate() public view returns (uint256) {\r\n        return totalSupplyInterestRate(_totalAssetSupply(0));\r\n    }\r\n\r\n    function nextSupplyInterestRate(uint256 supplyAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalSupplyInterestRate(_totalAssetSupply(0).add(supplyAmount));\r\n    }\r\n\r\n    function totalSupplyInterestRate(uint256 assetSupply)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 assetBorrow = totalAssetBorrow();\r\n        if (assetBorrow != 0) {\r\n            return _supplyInterestRate(assetBorrow, assetSupply);\r\n        }\r\n    }\r\n\r\n    function totalAssetBorrow() public view returns (uint256) {\r\n        return\r\n            ProtocolLike(sovrynContractAddress).getTotalPrincipal(\r\n                address(this),\r\n                loanTokenAddress\r\n            );\r\n    }\r\n\r\n    function totalAssetSupply() public view returns (uint256) {\r\n        uint256 interestUnPaid;\r\n        if (lastSettleTime_ != uint88(block.timestamp)) {\r\n            (, interestUnPaid) = _getAllInterest();\r\n        }\r\n\r\n        return _totalAssetSupply(interestUnPaid);\r\n    }\r\n\r\n    function getMaxEscrowAmount(uint256 leverageAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 initialMargin = SafeMathSovryn.div(10**38, leverageAmount);\r\n        return\r\n            marketLiquidity().mul(initialMargin).div(\r\n                _adjustValue(\r\n                    10**20, // maximum possible interest (100%)\r\n                    2419200, // 28 day duration for margin trades\r\n                    initialMargin\r\n                )\r\n            );\r\n    }\r\n\r\n    // returns the user's balance of underlying token\r\n    function assetBalanceOf(address _owner) public view returns (uint256) {\r\n        return balanceOf(_owner).mul(tokenPrice()).div(10**18);\r\n    }\r\n\r\n    function getEstimatedMarginDetails(\r\n        uint256 leverageAmount,\r\n        uint256 loanTokenSent,\r\n        uint256 collateralTokenSent,\r\n        address collateralTokenAddress // address(0) means ETH\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            uint256 principal,\r\n            uint256 collateral,\r\n            uint256 interestRate\r\n        )\r\n    {\r\n        if (collateralTokenAddress == address(0)) {\r\n            collateralTokenAddress = wrbtcTokenAddress;\r\n        }\r\n\r\n        uint256 totalDeposit = _totalDeposit(\r\n            collateralTokenAddress,\r\n            collateralTokenSent,\r\n            loanTokenSent\r\n        );\r\n\r\n        (principal, interestRate) = _getMarginBorrowAmountAndRate(\r\n            leverageAmount,\r\n            totalDeposit\r\n        );\r\n        if (principal > _underlyingBalance()) {\r\n            return (0, 0, 0);\r\n        }\r\n\r\n        loanTokenSent = loanTokenSent.add(principal);\r\n\r\n        collateral = ProtocolLike(sovrynContractAddress)\r\n            .getEstimatedMarginExposure(\r\n            loanTokenAddress,\r\n            collateralTokenAddress,\r\n            loanTokenSent,\r\n            collateralTokenSent,\r\n            interestRate,\r\n            principal\r\n        );\r\n    }\r\n\r\n    function getDepositAmountForBorrow(\r\n        uint256 borrowAmount,\r\n        uint256 initialLoanDuration, // duration in seconds\r\n        address collateralTokenAddress // address(0) means ETH\r\n    ) public view returns (uint256 depositAmount) {\r\n        if (borrowAmount != 0) {\r\n            (, , uint256 newBorrowAmount) = _getInterestRateAndBorrowAmount(\r\n                borrowAmount,\r\n                totalAssetSupply(),\r\n                initialLoanDuration\r\n            );\r\n\r\n            if (newBorrowAmount <= _underlyingBalance()) {\r\n                return\r\n                    ProtocolLike(sovrynContractAddress)\r\n                        .getRequiredCollateral(\r\n                        loanTokenAddress,\r\n                        collateralTokenAddress != address(0)\r\n                            ? collateralTokenAddress\r\n                            : wrbtcTokenAddress,\r\n                        newBorrowAmount,\r\n                        50 * 10**18, // initialMargin\r\n                        true // isTorqueLoan\r\n                    )\r\n                        .add(10); // some dust to compensate for rounding errors\r\n            }\r\n        }\r\n    }\r\n\r\n    function getBorrowAmountForDeposit(\r\n        uint256 depositAmount,\r\n        uint256 initialLoanDuration, // duration in seconds\r\n        address collateralTokenAddress // address(0) means ETH\r\n    ) public view returns (uint256 borrowAmount) {\r\n        if (depositAmount != 0) {\r\n            borrowAmount = ProtocolLike(sovrynContractAddress).getBorrowAmount(\r\n                loanTokenAddress,\r\n                collateralTokenAddress != address(0)\r\n                    ? collateralTokenAddress\r\n                    : wrbtcTokenAddress,\r\n                depositAmount,\r\n                50 * 10**18, // initialMargin,\r\n                true // isTorqueLoan\r\n            );\r\n\r\n            (, , borrowAmount) = _getInterestRateAndBorrowAmount(\r\n                borrowAmount,\r\n                totalAssetSupply(),\r\n                initialLoanDuration\r\n            );\r\n\r\n            if (borrowAmount > _underlyingBalance()) {\r\n                borrowAmount = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    /* Internal functions */\r\n\r\n    function _mintToken(address receiver, uint256 depositAmount)\r\n        internal\r\n        returns (uint256 mintAmount)\r\n    {\r\n        require(depositAmount != 0, \"17\");\r\n\r\n        _settleInterest();\r\n\r\n        uint256 currentPrice = _tokenPrice(_totalAssetSupply(0));\r\n        mintAmount = depositAmount.mul(10**18).div(currentPrice);\r\n\r\n        if (msg.value == 0) {\r\n            _safeTransferFrom(\r\n                loanTokenAddress,\r\n                msg.sender,\r\n                address(this),\r\n                depositAmount,\r\n                \"18\"\r\n            );\r\n        } else {\r\n            IWrbtc(wrbtcTokenAddress).deposit.value(depositAmount)();\r\n        }\r\n\r\n        uint256 oldBalance = balances[receiver];\r\n        _updateCheckpoints(\r\n            receiver,\r\n            oldBalance,\r\n            _mint(receiver, mintAmount, depositAmount, currentPrice), // newBalance\r\n            currentPrice\r\n        );\r\n    }\r\n\r\n    function _burnToken(uint256 burnAmount)\r\n        internal\r\n        returns (uint256 loanAmountPaid)\r\n    {\r\n        require(burnAmount != 0, \"19\");\r\n\r\n        if (burnAmount > balanceOf(msg.sender)) {\r\n            burnAmount = balanceOf(msg.sender);\r\n        }\r\n\r\n        _settleInterest();\r\n\r\n        uint256 currentPrice = _tokenPrice(_totalAssetSupply(0));\r\n\r\n        uint256 loanAmountOwed = burnAmount.mul(currentPrice).div(10**18);\r\n        uint256 loanAmountAvailableInContract = _underlyingBalance();\r\n\r\n        loanAmountPaid = loanAmountOwed;\r\n        require(loanAmountPaid <= loanAmountAvailableInContract, \"37\");\r\n\r\n        uint256 oldBalance = balances[msg.sender];\r\n        _updateCheckpoints(\r\n            msg.sender,\r\n            oldBalance,\r\n            _burn(msg.sender, burnAmount, loanAmountPaid, currentPrice), // newBalance\r\n            currentPrice\r\n        );\r\n    }\r\n\r\n    function _settleInterest() internal {\r\n        uint88 ts = uint88(block.timestamp);\r\n        if (lastSettleTime_ != ts) {\r\n            ProtocolLike(sovrynContractAddress).withdrawAccruedInterest(\r\n                loanTokenAddress\r\n            );\r\n\r\n            lastSettleTime_ = ts;\r\n        }\r\n    }\r\n\r\n    function _totalDeposit(\r\n        address collateralTokenAddress,\r\n        uint256 collateralTokenSent,\r\n        uint256 loanTokenSent\r\n    ) internal view returns (uint256 totalDeposit) {\r\n        totalDeposit = loanTokenSent;\r\n        if (collateralTokenSent != 0) {\r\n            (\r\n                uint256 sourceToDestRate,\r\n                uint256 sourceToDestPrecision\r\n            ) = FeedsLike(ProtocolLike(sovrynContractAddress).priceFeeds())\r\n                .queryRate(collateralTokenAddress, loanTokenAddress);\r\n            if (sourceToDestPrecision != 0) {\r\n                totalDeposit = collateralTokenSent\r\n                    .mul(sourceToDestRate)\r\n                    .div(sourceToDestPrecision)\r\n                    .add(totalDeposit);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _getInterestRateAndBorrowAmount(\r\n        uint256 borrowAmount,\r\n        uint256 assetSupply,\r\n        uint256 initialLoanDuration // duration in seconds\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 interestRate,\r\n            uint256 interestInitialAmount,\r\n            uint256 newBorrowAmount\r\n        )\r\n    {\r\n        interestRate = _nextBorrowInterestRate2(borrowAmount, assetSupply);\r\n\r\n        // newBorrowAmount = borrowAmount * 10^18 / (10^18 - interestRate * 7884000 * 10^18 / 31536000 / 10^20)\r\n        newBorrowAmount = borrowAmount.mul(10**18).div(\r\n            SafeMathSovryn.sub(\r\n                10**18,\r\n                interestRate.mul(initialLoanDuration).mul(10**18).div(\r\n                    31536000 * 10**20\r\n                ) // 365 * 86400 * 10**20\r\n            )\r\n        );\r\n\r\n        interestInitialAmount = newBorrowAmount.sub(borrowAmount);\r\n    }\r\n\r\n    // returns newPrincipal\r\n    function _borrowOrTrade(\r\n        bytes32 loanId,\r\n        uint256 withdrawAmount,\r\n        uint256 leverageAmount,\r\n        address collateralTokenAddress,\r\n        address[4] memory sentAddresses,\r\n        uint256[5] memory sentAmounts,\r\n        bytes memory loanDataBytes\r\n    ) internal returns (uint256, uint256) {\r\n        _checkPause();\r\n\r\n        require(\r\n            sentAmounts[1] <= _underlyingBalance() && // newPrincipal (borrowed amount + fees)\r\n                sentAddresses[1] != address(0), // borrower\r\n            \"24\"\r\n        );\r\n\r\n        if (sentAddresses[2] == address(0)) {\r\n            sentAddresses[2] = sentAddresses[1]; // receiver = borrower\r\n        }\r\n\r\n        // handle transfers prior to adding newPrincipal to loanTokenSent\r\n        uint256 msgValue = _verifyTransfers(\r\n            collateralTokenAddress,\r\n            sentAddresses,\r\n            sentAmounts,\r\n            withdrawAmount\r\n        );\r\n\r\n        // adding the loan token portion from the lender to loanTokenSent\r\n        // (add the loan to the loan tokens sent from the user)\r\n        sentAmounts[3] = sentAmounts[3].add(sentAmounts[1]); // newPrincipal\r\n\r\n        if (withdrawAmount != 0) {\r\n            // withdrawAmount already sent to the borrower, so we aren't sending it to the protocol\r\n            sentAmounts[3] = sentAmounts[3].sub(withdrawAmount);\r\n        }\r\n\r\n        bytes32 loanParamsId = loanParamsIds[uint256(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    collateralTokenAddress,\r\n                    withdrawAmount != 0 // isTorqueLoan\r\n                        ? true\r\n                        : false\r\n                )\r\n            )\r\n        )];\r\n\r\n        // converting to initialMargin\r\n        leverageAmount = SafeMathSovryn.div(10**38, leverageAmount);\r\n\r\n        (sentAmounts[1], sentAmounts[4]) = ProtocolLike(sovrynContractAddress)\r\n            .borrowOrTradeFromPool\r\n            .value(msgValue)( // newPrincipal, newCollateral\r\n            loanParamsId,\r\n            loanId,\r\n            withdrawAmount != 0 // isTorqueLoan\r\n                ? true\r\n                : false,\r\n            leverageAmount, // initialMargin\r\n            sentAddresses,\r\n            sentAmounts,\r\n            loanDataBytes\r\n        );\r\n        require(sentAmounts[1] != 0, \"25\");\r\n\r\n        return (sentAmounts[1], sentAmounts[4]); // newPrincipal, newCollateral\r\n    }\r\n\r\n    // sentAddresses[0]: lender\r\n    // sentAddresses[1]: borrower\r\n    // sentAddresses[2]: receiver\r\n    // sentAddresses[3]: manager\r\n    // sentAmounts[0]: interestRate\r\n    // sentAmounts[1]: newPrincipal\r\n    // sentAmounts[2]: interestInitialAmount\r\n    // sentAmounts[3]: loanTokenSent\r\n    // sentAmounts[4]: collateralTokenSent\r\n    function _verifyTransfers(\r\n        address collateralTokenAddress,\r\n        address[4] memory sentAddresses,\r\n        uint256[5] memory sentAmounts,\r\n        uint256 withdrawalAmount\r\n    ) internal returns (uint256 msgValue) {\r\n        address _wrbtcToken = wrbtcTokenAddress;\r\n        address _loanTokenAddress = loanTokenAddress;\r\n        address receiver = sentAddresses[2];\r\n        uint256 newPrincipal = sentAmounts[1];\r\n        uint256 loanTokenSent = sentAmounts[3];\r\n        uint256 collateralTokenSent = sentAmounts[4];\r\n\r\n        require(_loanTokenAddress != collateralTokenAddress, \"26\");\r\n\r\n        msgValue = msg.value;\r\n\r\n        if (withdrawalAmount != 0) {\r\n            // withdrawOnOpen == true\r\n            _safeTransfer(_loanTokenAddress, receiver, withdrawalAmount, \"\");\r\n            if (newPrincipal > withdrawalAmount) {\r\n                _safeTransfer(\r\n                    _loanTokenAddress,\r\n                    sovrynContractAddress,\r\n                    newPrincipal - withdrawalAmount,\r\n                    \"\"\r\n                );\r\n            }\r\n        } else {\r\n            _safeTransfer(\r\n                _loanTokenAddress,\r\n                sovrynContractAddress,\r\n                newPrincipal,\r\n                \"27\"\r\n            );\r\n        }\r\n        //this is a critical piece of code!\r\n        //wEth are supposed to be held by the contract itself, while other tokens are being transfered from the sender directly\r\n        if (collateralTokenSent != 0) {\r\n            if (\r\n                collateralTokenAddress == _wrbtcToken &&\r\n                msgValue != 0 &&\r\n                msgValue >= collateralTokenSent\r\n            ) {\r\n                IWrbtc(_wrbtcToken).deposit.value(collateralTokenSent)();\r\n                _safeTransfer(\r\n                    collateralTokenAddress,\r\n                    sovrynContractAddress,\r\n                    collateralTokenSent,\r\n                    \"28-a\"\r\n                );\r\n                msgValue -= collateralTokenSent;\r\n            } else {\r\n                _safeTransferFrom(\r\n                    collateralTokenAddress,\r\n                    msg.sender,\r\n                    sovrynContractAddress,\r\n                    collateralTokenSent,\r\n                    \"28-b\"\r\n                );\r\n            }\r\n        }\r\n\r\n        if (loanTokenSent != 0) {\r\n            _safeTransferFrom(\r\n                _loanTokenAddress,\r\n                msg.sender,\r\n                sovrynContractAddress,\r\n                loanTokenSent,\r\n                \"29\"\r\n            );\r\n        }\r\n    }\r\n\r\n    function _safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 amount,\r\n        string memory errorMsg\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                IERC20Sovryn(token).transfer.selector,\r\n                to,\r\n                amount\r\n            ),\r\n            errorMsg\r\n        );\r\n    }\r\n\r\n    function _safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        string memory errorMsg\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                IERC20Sovryn(token).transferFrom.selector,\r\n                from,\r\n                to,\r\n                amount\r\n            ),\r\n            errorMsg\r\n        );\r\n    }\r\n\r\n    function _callOptionalReturn(\r\n        address token,\r\n        bytes memory data,\r\n        string memory errorMsg\r\n    ) internal {\r\n        (bool success, bytes memory returndata) = token.call(data);\r\n        require(success, errorMsg);\r\n\r\n        if (returndata.length != 0) {\r\n            require(abi.decode(returndata, (bool)), errorMsg);\r\n        }\r\n    }\r\n\r\n    function _underlyingBalance() internal view returns (uint256) {\r\n        return IERC20Sovryn(loanTokenAddress).balanceOf(address(this));\r\n    }\r\n\r\n    /* Internal View functions */\r\n\r\n    function _tokenPrice(uint256 assetSupply) internal view returns (uint256) {\r\n        uint256 totalTokenSupply = totalSupply_;\r\n\r\n        return\r\n            totalTokenSupply != 0\r\n                ? assetSupply.mul(10**18).div(totalTokenSupply)\r\n                : initialPrice;\r\n    }\r\n\r\n    function _avgBorrowInterestRate(uint256 assetBorrow)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (assetBorrow != 0) {\r\n            (uint256 interestOwedPerDay, ) = _getAllInterest();\r\n            return interestOwedPerDay.mul(10**20).div(assetBorrow).mul(365);\r\n        }\r\n    }\r\n\r\n    // next supply interest adjustment\r\n    function _supplyInterestRate(uint256 assetBorrow, uint256 assetSupply)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (assetBorrow != 0 && assetSupply >= assetBorrow) {\r\n            return\r\n                _avgBorrowInterestRate(assetBorrow)\r\n                    .mul(_utilizationRate(assetBorrow, assetSupply))\r\n                    .mul(\r\n                    SafeMathSovryn.sub(\r\n                        10**20,\r\n                        ProtocolLike(sovrynContractAddress).lendingFeePercent()\r\n                    )\r\n                )\r\n                    .div(10**40);\r\n        }\r\n    }\r\n\r\n    function _nextBorrowInterestRate(uint256 borrowAmount)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 interestUnPaid;\r\n        if (borrowAmount != 0) {\r\n            if (lastSettleTime_ != uint88(block.timestamp)) {\r\n                (, interestUnPaid) = _getAllInterest();\r\n            }\r\n\r\n            uint256 balance = _underlyingBalance().add(interestUnPaid);\r\n            if (borrowAmount > balance) {\r\n                borrowAmount = balance;\r\n            }\r\n        }\r\n\r\n        return\r\n            _nextBorrowInterestRate2(\r\n                borrowAmount,\r\n                _totalAssetSupply(interestUnPaid)\r\n            );\r\n    }\r\n\r\n    function _nextBorrowInterestRate2(\r\n        uint256 newBorrowAmount,\r\n        uint256 assetSupply\r\n    ) internal view returns (uint256 nextRate) {\r\n        uint256 utilRate = _utilizationRate(\r\n            totalAssetBorrow().add(newBorrowAmount),\r\n            assetSupply\r\n        );\r\n\r\n        uint256 thisMinRate;\r\n        uint256 thisMaxRate;\r\n        uint256 thisBaseRate = baseRate;\r\n        uint256 thisRateMultiplier = rateMultiplier;\r\n        uint256 thisTargetLevel = targetLevel;\r\n        uint256 thisKinkLevel = kinkLevel;\r\n        uint256 thisMaxScaleRate = maxScaleRate;\r\n\r\n        if (utilRate < thisTargetLevel) {\r\n            // target targetLevel utilization when utilization is under targetLevel\r\n            utilRate = thisTargetLevel;\r\n        }\r\n\r\n        if (utilRate > thisKinkLevel) {\r\n            // scale rate proportionally up to 100%\r\n            uint256 thisMaxRange = WEI_PERCENT_PRECISION - thisKinkLevel; // will not overflow\r\n\r\n            utilRate -= thisKinkLevel;\r\n            if (utilRate > thisMaxRange) utilRate = thisMaxRange;\r\n\r\n            thisMaxRate = thisRateMultiplier\r\n                .add(thisBaseRate)\r\n                .mul(thisKinkLevel)\r\n                .div(WEI_PERCENT_PRECISION);\r\n\r\n            nextRate = utilRate\r\n                .mul(SafeMathSovryn.sub(thisMaxScaleRate, thisMaxRate))\r\n                .div(thisMaxRange)\r\n                .add(thisMaxRate);\r\n        } else {\r\n            nextRate = utilRate\r\n                .mul(thisRateMultiplier)\r\n                .div(WEI_PERCENT_PRECISION)\r\n                .add(thisBaseRate);\r\n\r\n            thisMinRate = thisBaseRate;\r\n            thisMaxRate = thisRateMultiplier.add(thisBaseRate);\r\n\r\n            if (nextRate < thisMinRate) nextRate = thisMinRate;\r\n            else if (nextRate > thisMaxRate) nextRate = thisMaxRate;\r\n        }\r\n    }\r\n\r\n    function _getAllInterest()\r\n        internal\r\n        view\r\n        returns (uint256 interestOwedPerDay, uint256 interestUnPaid)\r\n    {\r\n        // interestPaid, interestPaidDate, interestOwedPerDay, interestUnPaid, interestFeePercent, principalTotal\r\n        uint256 interestFeePercent;\r\n        (\r\n            ,\r\n            ,\r\n            interestOwedPerDay,\r\n            interestUnPaid,\r\n            interestFeePercent,\r\n\r\n        ) = ProtocolLike(sovrynContractAddress).getLenderInterestData(\r\n            address(this),\r\n            loanTokenAddress\r\n        );\r\n\r\n        interestUnPaid = interestUnPaid\r\n            .mul(SafeMathSovryn.sub(10**20, interestFeePercent))\r\n            .div(10**20);\r\n    }\r\n\r\n    function _getMarginBorrowAmountAndRate(\r\n        uint256 leverageAmount,\r\n        uint256 depositAmount\r\n    ) internal view returns (uint256 borrowAmount, uint256 interestRate) {\r\n        uint256 initialMargin = SafeMathSovryn.div(10**38, leverageAmount);\r\n\r\n        interestRate = _nextBorrowInterestRate2(\r\n            depositAmount.mul(10**20).div(initialMargin),\r\n            _totalAssetSupply(0)\r\n        );\r\n\r\n        // assumes that loan, collateral, and interest token are the same\r\n        borrowAmount = depositAmount\r\n            .mul(10**40)\r\n            .div(\r\n            _adjustValue(\r\n                interestRate,\r\n                2419200, // 28 day duration for margin trades\r\n                initialMargin\r\n            )\r\n        )\r\n            .div(initialMargin);\r\n    }\r\n\r\n    function _totalAssetSupply(uint256 interestUnPaid)\r\n        internal\r\n        view\r\n        returns (uint256 assetSupply)\r\n    {\r\n        if (totalSupply_ != 0) {\r\n            uint256 assetsBalance = _flTotalAssetSupply; // temporary locked totalAssetSupply during a flash loan transaction\r\n            if (assetsBalance == 0) {\r\n                assetsBalance = _underlyingBalance().add(totalAssetBorrow());\r\n            }\r\n\r\n            return assetsBalance.add(interestUnPaid);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * used to read externally from the smart contract to see if a function is paused\r\n     * returns a bool\r\n     * */\r\n    function checkPause(string memory funcId)\r\n        public\r\n        view\r\n        returns (bool isPaused)\r\n    {\r\n        bytes4 sig = bytes4(keccak256(abi.encodePacked(funcId)));\r\n        bytes32 slot = keccak256(\r\n            abi.encodePacked(\r\n                sig,\r\n                uint256(\r\n                    0xd46a704bc285dbd6ff5ad3863506260b1df02812f4f857c8cc852317a6ac64f2\r\n                )\r\n            )\r\n        );\r\n        assembly {\r\n            isPaused := sload(slot)\r\n        }\r\n        return isPaused;\r\n    }\r\n\r\n    /**\r\n     * used for internal verification if the called function is paused.\r\n     * throws an exception in case it's not\r\n     * */\r\n    function _checkPause() internal view {\r\n        //keccak256(\"iToken_FunctionPause\")\r\n        bytes32 slot = keccak256(\r\n            abi.encodePacked(\r\n                msg.sig,\r\n                uint256(\r\n                    0xd46a704bc285dbd6ff5ad3863506260b1df02812f4f857c8cc852317a6ac64f2\r\n                )\r\n            )\r\n        );\r\n        bool isPaused;\r\n        assembly {\r\n            isPaused := sload(slot)\r\n        }\r\n        require(!isPaused, \"unauthorized\");\r\n    }\r\n\r\n    function _adjustValue(\r\n        uint256 interestRate,\r\n        uint256 maxDuration,\r\n        uint256 marginAmount\r\n    ) internal pure returns (uint256) {\r\n        return\r\n            maxDuration != 0\r\n                ? interestRate\r\n                    .mul(10**20)\r\n                    .div(31536000) // 86400 * 365\r\n                    .mul(maxDuration)\r\n                    .div(marginAmount)\r\n                    .add(10**20)\r\n                : 10**20;\r\n    }\r\n\r\n    function _utilizationRate(uint256 assetBorrow, uint256 assetSupply)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (assetBorrow != 0 && assetSupply != 0) {\r\n            // U = total_borrow / total_supply\r\n            return assetBorrow.mul(10**20).div(assetSupply);\r\n        }\r\n    }\r\n\r\n    /* Owner-Only functions */\r\n\r\n    function updateSettings(address settingsTarget, bytes memory callData)\r\n        public\r\n        onlyOwner\r\n    {\r\n        address currentTarget = target_;\r\n        target_ = settingsTarget;\r\n\r\n        (bool result, ) = address(this).call(callData);\r\n\r\n        uint256 size;\r\n        uint256 ptr;\r\n        assembly {\r\n            size := returndatasize\r\n            ptr := mload(0x40)\r\n            returndatacopy(ptr, 0, size)\r\n            if eq(result, 0) {\r\n                revert(ptr, size)\r\n            }\r\n        }\r\n\r\n        target_ = currentTarget;\r\n\r\n        assembly {\r\n            return(ptr, size)\r\n        }\r\n    }\r\n\r\n    function setEarlyAccessToken(address _earlyAccessTokenAddress)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(Address.isContract(_earlyAccessTokenAddress), \"\");\r\n\r\n        address oldEarlyAccessToken = earlyAccessToken;\r\n        earlyAccessToken = _earlyAccessTokenAddress;\r\n\r\n        emit SetEarlyAccessToken(\r\n            msg.sender,\r\n            oldEarlyAccessToken,\r\n            earlyAccessToken\r\n        );\r\n    }\r\n}\r\n\r\ncontract LoanTokenLogicWrbtc is LoanTokenLogicStandard {\r\n    function mintWithBTC(address receiver)\r\n        external\r\n        payable\r\n        nonReentrant\r\n        returns (uint256 mintAmount)\r\n    {\r\n        return _mintToken(receiver, msg.value);\r\n    }\r\n\r\n    function burnToBTC(address receiver, uint256 burnAmount)\r\n        external\r\n        nonReentrant\r\n        returns (uint256 loanAmountPaid)\r\n    {\r\n        loanAmountPaid = _burnToken(burnAmount);\r\n\r\n        if (loanAmountPaid != 0) {\r\n            IWrbtcERC20(wrbtcTokenAddress).withdraw(loanAmountPaid);\r\n            Address.sendValue(address(uint160(receiver)), loanAmountPaid);\r\n        }\r\n    }\r\n\r\n    /* Internal functions */\r\n\r\n    // sentAddresses[0]: lender\r\n    // sentAddresses[1]: borrower\r\n    // sentAddresses[2]: receiver\r\n    // sentAddresses[3]: manager\r\n    // sentAmounts[0]: interestRate\r\n    // sentAmounts[1]: newPrincipal\r\n    // sentAmounts[2]: interestInitialAmount\r\n    // sentAmounts[3]: loanTokenSent\r\n    // sentAmounts[4]: collateralTokenSent\r\n    function _verifyTransfers(\r\n        address collateralTokenAddress,\r\n        address[4] memory sentAddresses,\r\n        uint256[5] memory sentAmounts,\r\n        uint256 withdrawalAmount\r\n    ) internal returns (uint256 msgValue) {\r\n        address _wrbtcToken = wrbtcTokenAddress;\r\n        address _loanTokenAddress = _wrbtcToken;\r\n        address receiver = sentAddresses[2];\r\n        uint256 newPrincipal = sentAmounts[1];\r\n        uint256 loanTokenSent = sentAmounts[3];\r\n        uint256 collateralTokenSent = sentAmounts[4];\r\n\r\n        require(_loanTokenAddress != collateralTokenAddress, \"26\");\r\n\r\n        msgValue = msg.value;\r\n\r\n        if (withdrawalAmount != 0) {\r\n            // withdrawOnOpen == true\r\n            IWrbtcERC20(_wrbtcToken).withdraw(withdrawalAmount);\r\n            Address.sendValue(address(uint160(receiver)), withdrawalAmount);\r\n            if (newPrincipal > withdrawalAmount) {\r\n                _safeTransfer(\r\n                    _loanTokenAddress,\r\n                    sovrynContractAddress,\r\n                    newPrincipal - withdrawalAmount,\r\n                    \"\"\r\n                );\r\n            }\r\n        } else {\r\n            _safeTransfer(\r\n                _loanTokenAddress,\r\n                sovrynContractAddress,\r\n                newPrincipal,\r\n                \"27\"\r\n            );\r\n        }\r\n\r\n        if (collateralTokenSent != 0) {\r\n            _safeTransferFrom(\r\n                collateralTokenAddress,\r\n                msg.sender,\r\n                sovrynContractAddress,\r\n                collateralTokenSent,\r\n                \"28\"\r\n            );\r\n        }\r\n\r\n        if (loanTokenSent != 0) {\r\n            if (msgValue != 0 && msgValue >= loanTokenSent) {\r\n                IWrbtc(_wrbtcToken).deposit.value(loanTokenSent)();\r\n                _safeTransfer(\r\n                    _loanTokenAddress,\r\n                    sovrynContractAddress,\r\n                    loanTokenSent,\r\n                    \"29\"\r\n                );\r\n                msgValue -= loanTokenSent;\r\n            } else {\r\n                _safeTransferFrom(\r\n                    _loanTokenAddress,\r\n                    msg.sender,\r\n                    sovrynContractAddress,\r\n                    loanTokenSent,\r\n                    \"29\"\r\n                );\r\n            }\r\n        }\r\n    }\r\n}\r\n",
      "file": "WRBTC_LoanTokenLogic.sol"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x2c6a3493f9dbb66bcafa371842bdd8ff9c14e6ba3cf84ff2dd87ec62593ba06e",
    "blockNumber": 2742493,
    "transactionHash": "0x100a058091a4e075ba67cd079d30284e7904a4a83cadaf0519a4a1ee1d9476bc",
    "timestamp": 1601479297
  }
}