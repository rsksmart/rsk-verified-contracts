{
  "address": "0x5269f5bc51cdd8aa62755c97229b7eeddd8e69a6",
  "net": {
    "id": "30",
    "name": "RSK Mainnet"
  },
  "name": "TokenRegistrar",
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "evmVersion": "byzantium",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "metadata",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ]
      }
    }
  },
  "version": "0.4.24+commit.e67f0147",
  "source": "pragma solidity ^0.4.24;\n\n\n/*\n\nTemporary Hash Registrar\n========================\n\nThis is a simplified version of a hash registrar. It is purporsefully limited:\nnames cannot be six letters or shorter, new auctions will stop after 4 years.\n\nThe plan is to test the basic features and then move to a new contract in at most\n2 years, when some sort of renewal mechanism will be enabled.\n\nRefund schedule\n===============\n\nCase A: Reveal Period\n------------------------------------------------------------------------------------\n| (I) Auction winner | Funds are locked in Deed. 80% are returned on Deed release  |\n------------------------------------------------------------------------------------\n| (II) Auction losser | 100% refund over the losing bid                            |\n------------------------------------------------------------------------------------\n\nCase B: Late-Reveal Period (2 weeks after auction finish)\n---------------------------------------------------------------------------------------------------\n| (I) Bid that would have won                 | 20% taken as fee                                  |\n---------------------------------------------------------------------------------------------------\n| (II) Bid that would have affected 2nd place | Difference with the actual 2nd place taken as fee |\n---------------------------------------------------------------------------------------------------\n| (III) Otherwise                             | 0.5% taken as fee                                 |\n---------------------------------------------------------------------------------------------------\n\nCase C: Any bid unsealed beyond the Late-Reveal period won't be refunded\n*/\n\n\nimport './TokenDeed.sol';\nimport '../../common/RNS.sol';\nimport '../../tokens/ERC677TokenContract.sol';\n\n/**\n * @title TokenRegistrar\n * @dev The registrar handles the auction process for each subnode of the node it owns.\n */\ncontract TokenRegistrar {\n    using SafeMath for uint256;\n\n    RNS public rns;\n    bytes32 public rootNode;\n\tERC677TokenContract public tokenContract;\n\n    mapping (bytes32 => Entry) _entries;\n    mapping (address => mapping (bytes32 => TokenDeed)) public sealedBids;\n    \n    enum Mode { Open, Auction, Owned, Forbidden, Reveal }\n\n    bytes4 constant SIGN_NEW_BID = 0x1413151f;  // sha3('newBidWithToken(address,uint256,bytes32)')\n    bytes4 constant SIGN_PAY_RENT = 0xe1ac9915; // sha3('payRentWithToken(address,uint256,bytes32)')\n    uint32 constant TOTAL_AUCTION_LENGTH = 5 days;\n    uint32 constant REVEAL_PERIOD = 48 hours;\n    uint32 constant LATE_UNSEAL_PERIOD = 15 days;\n    uint constant RELEASE_FEE_PER_MIL = 200;    // 200 of 1000 = 20%\n    uint constant MIN_TOKEN_QUANTITY = 1 * 10**18;  // 1 token\n    uint constant RENT_VALUE = 1 * 10**18;  // 1 token\n    \n    event AuctionStarted(bytes32 indexed hash, uint registrationDate);\n    event NewBid(bytes32 indexed hash, address indexed bidder, uint deposit);\n    event BidRevealed(bytes32 indexed hash, address indexed owner, uint value, uint8 status);\n    event HashRegistered(bytes32 indexed hash, address indexed owner, uint value, uint registrationDate);\n    event HashReleased(bytes32 indexed hash, uint value);\n\n    struct Entry {\n        TokenDeed deed;\n        uint registrationDate;\n        uint value;\n        uint highestBid;\n    }\n\n    modifier inState(bytes32 _hash, Mode _state) {\n        require(state(_hash) == _state);\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _hash) {\n        require(state(_hash) == Mode.Owned && msg.sender == _entries[_hash].deed.owner());\n        _;\n    }\n\n    modifier registryOpen() {\n        require(rns.owner(rootNode) == address(this));\n        _;\n    }\n\n    /**\n     * @dev Constructs a new Registrar, with the provided address as the owner of the root node.\n     *\n     * @param _rns The address of the RNS\n     * @param _rootNode The hash of the rootnode.\n     * @param _tokenAddr The ERC677 contract address to handle tokens\n     */\n    constructor(RNS _rns, bytes32 _rootNode, ERC677TokenContract _tokenAddr) public {\n        rns = _rns;\n        rootNode = _rootNode;\n        tokenContract = _tokenAddr;\n    }\n\n    /**\n     * @dev Start an auction for an available hash\n     *\n     * @param _hash The hash to start an auction on\n     */\n    function startAuction(bytes32 _hash) public registryOpen() {\n        Mode mode = state(_hash);\n        if (mode == Mode.Auction) return;\n        require(mode == Mode.Open);\n\n        Entry storage newAuction = _entries[_hash];\n        newAuction.registrationDate = now + TOTAL_AUCTION_LENGTH;\n        newAuction.value = 0;\n        newAuction.highestBid = 0;\n        newAuction.deed = TokenDeed(0);\n\n        emit AuctionStarted(_hash, newAuction.registrationDate);\n    }\n\n    /**\n     * @dev Start multiple auctions for better anonymity\n     *\n     * Anyone can start an auction by sending an array of hashes that they want to bid for.\n     * Arrays are sent so that someone can open up an auction for X dummy hashes when they\n     * are only really interested in bidding for one. This will increase the cost for an\n     * attacker to simply bid blindly on all new auctions. Dummy auctions that are\n     * open but not bid on are closed after a week.\n     *\n     * @param _hashes An array of hashes, at least one of which you presumably want to bid on\n     */\n    function startAuctions(bytes32[] _hashes) public {\n        for (uint i = 0; i < _hashes.length; i ++) {\n            startAuction(_hashes[i]);\n        }\n    }\n\n    /**\n     * @dev Submit a new sealed bid on a desired hash in a blind auction\n     *\n     * Bids are sent by sending a message to the main contract with a hash and an amount. The hash\n     * contains information about the bid, including the bidded hash, the bid amount, and a random\n     * salt. Bids are not tied to any one auction until they are revealed. The value of the bid\n     * itself can be masqueraded by sending more than the value of your actual bid. This is\n     * followed by a 48h reveal period. For bids revealed after this period, a percentage (defined in the late unsealing \n     * Refund schedule) will be sent to a special resource pool address.\n     * Since this is an auction, it is expected that most public hashes, like known domains and common dictionary\n     * words, will have multiple bidders pushing the price up.\n     *\n     * This method requires the sender to approve the Registrar to use the specified tokenQuantity in the ERC677 contract.\n     * Otherwise it can be done through the tokenFallback after a transfer with the corresponding parameters\n     *\n     * @param _sealedBid A sealedBid, created by the shaBid function\n     * @param _tokenQuantity token quantity to bid\n     */\n    function newBid(bytes32 _sealedBid, uint _tokenQuantity) public {\n        require(tokenContract.transferFrom(msg.sender, address(this), _tokenQuantity));\n\n        newBidAfterTransfer(msg.sender, _tokenQuantity, _sealedBid);\n    }\n\n    /**  \n     * @dev Method to be called through a dynamic invocation from an ERC677 token contract\n     *\n     * @param _from Address sending the tokens as well as submitting the bid\n     * @param _tokenQuantity Amount in tokens received throuh the transference\n     * @param _sealedBid Sealed bid, created through the shaBid function\n    **/\n    function newBidWithToken(address _from, uint _tokenQuantity, bytes32 _sealedBid) public {\n        require(msg.sender == address(tokenContract));\n        newBidAfterTransfer(_from, _tokenQuantity, _sealedBid);\n    }\n\n    /** \n     * @dev Internal method which handles the new bidding logic\n     *\n     * @param _from Address sending the tokens as well as submitting the bid\n     * @param _tokenQuantity Amount in tokens received through the transference. To be used to mask the actual bidded value\n     * @param _sealedBid Sealed bid, created through the shaBid function\n    **/\n    function newBidAfterTransfer(address _from, uint _tokenQuantity, bytes32 _sealedBid) private {\n        require(address(sealedBids[_from][_sealedBid]) == 0x0);\n\n        // Creates a new hash contract with the owner\n        TokenDeed createdBid = new TokenDeed(_from, _tokenQuantity, tokenContract);\n        require(tokenContract.transfer(createdBid, _tokenQuantity));\n        sealedBids[_from][_sealedBid] = createdBid;\n\t\t\n        emit NewBid(_sealedBid, _from, _tokenQuantity);\n    }\n\n    /**\n     * @dev Start a set of auctions and bid on one of them\n     *\n     * This method functions identically to calling `startAuctions` followed by `newBid`,\n     * but all in one transaction.\n     *\n     * @param _hashes A list of hashes to start auctions on.\n     * @param _sealedBid A sealed bid for one of the auctions.\n     * @param _tokenQuantity Amount of tokens to mask the bid with.\n     */\n    function startAuctionsAndBid(bytes32[] _hashes, bytes32 _sealedBid, uint _tokenQuantity) public payable {\n        startAuctions(_hashes);\n        newBid(_sealedBid, _tokenQuantity);\n    }\n\n    /**\n     * @dev Submit the properties of a bid to reveal them\n     *\n     * @param _hash The node in the sealedBid\n     * @param _value The bid amount in the sealedBid\n     * @param _salt The sale in the sealedBid\n     */\n    function unsealBid(bytes32 _hash, uint _value, bytes32 _salt) public {\n        bytes32 seal = shaBid(_hash, msg.sender, _value, _salt);\n        TokenDeed bid = sealedBids[msg.sender][seal];\n        require(address(bid) != 0);\n\n        sealedBids[msg.sender][seal] = TokenDeed(0);\n        Entry storage h = _entries[_hash];\n        uint value = min(_value, bid.tokenQuantity());\n        bid.setBalance(value, true);\n\n        Mode auctionState = state(_hash);\n\n        if (auctionState == Mode.Owned) {\n            // By this point the auction has ended. The refund values are defined in the above Refund Schedule\n\n            uint256 refundRatio = 995; // See: Case B)III\n\n            if (h.registrationDate + LATE_UNSEAL_PERIOD < now) {\n                refundRatio = 0; // See: Case C\n            } else {\n                if (value > h.highestBid) {\n                    refundRatio = 800; // See: Case B)I\n                } else if (value > h.value) {\n                    // See: Case B)II\n                    // Compute percentage corresponding to the difference between the actual 2nd place (h.value)\n                    // and the late unsealed bid (value)\n                    refundRatio = h.value.mul(1000).div(value);\n                }\n            }\n\n            bid.closeDeed(refundRatio);\n            emit BidRevealed(_hash, msg.sender, value, 1);\n        } else if (auctionState != Mode.Reveal) {\n            // invalid phase for unsealing\n            revert();\n        } else if (value < MIN_TOKEN_QUANTITY || bid.creationDate() > h.registrationDate - REVEAL_PERIOD) {\n            // Bid below the minimum or too late (created in the reveal period)\n            bid.closeDeed(1000);\n            emit BidRevealed(_hash, msg.sender, value, 0);\n        } else if (value > h.highestBid) {\n            // New winner\n            // Cancel the other bid\n            if (address(h.deed) != 0) {\n                TokenDeed previousWinner = h.deed;\n                previousWinner.closeDeed(1000);\n            }\n\n            // Set new winner\n            // Per the rules of a vickery auction, the value becomes the previous highestBid\n            h.value = h.highestBid;  // will be zero if there's only 1 bidder\n            h.highestBid = value;\n            h.deed = bid;\n            emit BidRevealed(_hash, msg.sender, value, 2);\n        } else if (value > h.value) {\n            // Not winner, but affects second place\n            h.value = value;\n            bid.closeDeed(1000);\n            emit BidRevealed(_hash, msg.sender, value, 3);\n        } else {\n            // Bid doesn't affect auction\n            bid.closeDeed(1000);\n            emit BidRevealed(_hash, msg.sender, value, 4);\n        }\n    }\n\n    /**\n     * @dev Finalize an auction after the registration date has passed\n     *\n     * Updates the Registry to reflect the new node owner. Starts the winning Deed's expiration period.\n     *\n     * @param _hash The hash of the name the auction is for\n     */\n    function finalizeAuction(bytes32 _hash) public onlyOwner(_hash) {\n        Entry storage h = _entries[_hash];\n        \n        // Handles the case when there's only a single bidder (h.value is zero)\n        h.value = max(h.value, MIN_TOKEN_QUANTITY);\n        h.deed.setBalance(h.value, true);\n        h.deed.startExpiration(h.registrationDate, RENT_VALUE);\n\n        trySetSubnodeOwner(_hash, h.deed.owner());\n        emit HashRegistered(_hash, h.deed.owner(), h.value, h.registrationDate);\n    }\n\n    /**\n     * @dev The owner of a domain may transfer it to someone else at any time.\n     *\n     * @param _hash The node to transfer\n     * @param _newOwner The address to transfer ownership to\n     */\n    function transfer(bytes32 _hash, address _newOwner) public onlyOwner(_hash) {\n        require(_newOwner != 0);\n\n        Entry storage h = _entries[_hash];\n        h.deed.setOwner(_newOwner);\n        trySetSubnodeOwner(_hash, _newOwner);\n    }\n\n    /**\n     * @dev After some time, or if we're no longer the registrar, the owner can release\n     *      the name and get a part of their tokens back.\n     *\n     * The allowed release period is within the rent payment period, which starts 3 months before the expiration date\n     *\n     * @param _hash The node to release\n     */\n    function releaseDeed(bytes32 _hash) public onlyOwner(_hash) {\n        Entry storage h = _entries[_hash];\n        TokenDeed deedContract = h.deed;\n\n        require(now < deedContract.expirationDate() || rns.owner(rootNode) != address(this));\n\n        h.value = 0;\n        h.highestBid = 0;\n        h.deed = TokenDeed(0);\n\n        _tryEraseSingleNode(_hash);\n\n        // return funds after deducting a fee and close the deed\n        deedContract.closeDeed(1000 - RELEASE_FEE_PER_MIL);\n\n        emit HashReleased(_hash, h.value);        \n    }\n\n    /**\n     * @dev Allows anyone to delete the owner and resolver records for a (subdomain of) a\n     *      name that is not currently owned in the registrar. If passing, eg, 'foo.bar.rsk',\n     *      the owner and resolver fields on 'foo.bar.rsk' and 'bar.rsk' will all be cleared.\n     *\n     * @param _labels A series of label hashes identifying the name to zero out, rooted at the\n     *        registrar's root. Must contain at least one element. For instance, to zero \n     *        'foo.bar.rsk' on a registrar that owns '.rsk', pass an array containing\n     *        [keccak256('foo'), keccak256('bar')].\n     */\n    function eraseNode(bytes32[] _labels) public {\n        require(_labels.length != 0);\n        require(state(_labels[_labels.length - 1]) != Mode.Owned);\n\n        _eraseNodeHierarchy(_labels.length - 1, _labels, rootNode);\n    }\n\n    /**\n     * @dev Transfers the deed to the current registrar, if different from this one.\n     *\n     * Used during the upgrade process to a permanent registrar.\n     *\n     * @param _hash The name hash to transfer.\n     */\n    function transferRegistrars(bytes32 _hash) public onlyOwner(_hash) {\n        address registrar = rns.owner(rootNode);\n        require(registrar != address(this));\n\n        // Migrate the deed\n        Entry storage h = _entries[_hash];\n        h.deed.setRegistrar(registrar);\n\n        // Call the new registrar to accept the transfer\n        TokenRegistrar(registrar).acceptRegistrarTransfer(_hash, h.deed, h.registrationDate);\n\n        // Zero out the Entry\n        h.deed = TokenDeed(0);\n        h.registrationDate = 0;\n        h.value = 0;\n        h.highestBid = 0;\n    }\n\n    /**\n     * @dev Pay the yearly rent for a name\n     *\n     * Names have a vigency of 1 year after the registration date. Said expiry date is reflected through the associated Deed \n     * contract. Owners have a period of 3 months before the expiryDate to pay the rent and extend their ownership for 1 year\n     *\n     * @param _hash The hash of the name to pay the rent for\n     */\n    function payRent(bytes32 _hash) public {\n        require(tokenContract.transferFrom(msg.sender, address(this), RENT_VALUE));\n        payRentAfterTransfer(_hash);\n    }\n\n    /**  \n     * @dev Method to be called through a dynamic invocation from an ERC677 token contract\n     *\n     * @param _from Address sending the tokens as well as submitting the bid\n     * @param _tokenQuantity Amount in tokens received throuh the transference\n     * @param _hash Hash of the name to pay the rent for\n    **/\n    function payRentWithToken(address _from, uint _tokenQuantity, bytes32 _hash) public {\n        require(_tokenQuantity == RENT_VALUE);\n        require(msg.sender == address(tokenContract));\n        payRentAfterTransfer(_hash);\n    }\n\n    /** \n     * @dev Internal method which handles the rent payment logic\n     *\n     * @param _hash Hash of the name to pay the rent for\n    **/\n    function payRentAfterTransfer(bytes32 _hash) private {\n        require(state(_hash) == Mode.Owned);\n\n        Entry storage h = _entries[_hash];\n\n        require(address(h.deed) != 0);\n\n        require(tokenContract.transfer(h.deed, RENT_VALUE));\n        require(h.deed.payRent(RENT_VALUE));\n    }\n\n    /**\n     * @dev Accepts a transfer from a previous registrar; stubbed out here since there\n     *      is no previous registrar implementing this interface.\n     *\n     * @param _hash The sha3 hash of the label to transfer.\n     * @param _deed The TokenDeed object for the name being transferred in.\n     * @param _registrationDate The date at which the name was originally registered.\n     */\n    function acceptRegistrarTransfer(bytes32 _hash, TokenDeed _deed, uint _registrationDate) public pure {\n        _hash; _deed; _registrationDate; // Don't warn about unused variables\n    }\n\n    // State transitions for names:\n    //   Open -> Auction (startAuction)\n    //   Auction -> Reveal\n    //   Reveal -> Owned\n    //   Reveal -> Open (if nobody bid)\n    //   Owned -> Open (releaseDeed or the deed has expired)\n    function state(bytes32 _hash) public view returns (Mode) {\n        Entry storage entry = _entries[_hash];\n\n        if (now < entry.registrationDate) {\n            if (now < entry.registrationDate - REVEAL_PERIOD) {\n                return Mode.Auction;\n            } else {\n                return Mode.Reveal;\n            }\n        } else {\n            // there may not be any bid (not yet auctioned) or there is and it may have already expired (Expired)\n            if (entry.highestBid == 0 || entry.deed.expired()) {\n                return Mode.Open;\n            } else {\n                return Mode.Owned;\n            }\n        }\n    }\n\n    /** \n     * @dev Returns information related to a certain name\n     *\n     * @param _hash Hash of the name to query about\n    **/\n    function entries(bytes32 _hash) public view returns (Mode, address, uint, uint, uint) {\n        Entry storage h = _entries[_hash];\n        return (state(_hash), h.deed, h.registrationDate, h.value, h.highestBid);\n    }\n\n    /**\n     * @dev Hash the values required for a secret bid\n     *\n     * @param _hash The node corresponding to the desired namehash\n     * @param _value The bid amount in tokens\n     * @param _salt A random value to ensure secrecy of the bid\n     * @return The hash of the bid values\n     */\n    function shaBid(bytes32 _hash, address _owner, uint _value, bytes32 _salt) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_hash, _owner, _value, _salt));\n    }\n\n    function _tryEraseSingleNode(bytes32 _label) internal {\n        if (rns.owner(rootNode) == address(this)) {\n            rns.setSubnodeOwner(rootNode, _label, address(this));\n            bytes32 node = keccak256(abi.encodePacked(rootNode, _label));\n            rns.setResolver(node, 0);\n            rns.setOwner(node, 0);\n        }\n    }\n\n    function _eraseNodeHierarchy(uint _idx, bytes32[] _labels, bytes32 _node) internal {\n        // Take ownership of the node\n        rns.setSubnodeOwner(_node, _labels[_idx], address(this));\n        _node = keccak256(abi.encodePacked(_node, _labels[_idx]));\n\n        // Recurse if there are more labels\n        if (_idx > 0) {\n            _eraseNodeHierarchy(_idx - 1, _labels, _node);\n        }\n\n        // Erase the resolver and owner records\n        rns.setResolver(_node, 0);\n        rns.setOwner(_node, 0);\n    }\n\n    /**\n     * @dev Assign the owner in RNS, if we're still the registrar\n     *\n     * @param _hash hash to change owner\n     * @param _newOwner new owner to transfer to\n     */\n    function trySetSubnodeOwner(bytes32 _hash, address _newOwner) internal {\n        if (rns.owner(rootNode) == address(this))\n            rns.setSubnodeOwner(rootNode, _hash, _newOwner);\n    }\n\n    /**\n     * @dev Returns the maximum of two unsigned integers\n     *\n     * @param a A number to compare\n     * @param b A number to compare\n     * @return The maximum of two unsigned integers\n     */\n    function max(uint a, uint b) internal pure returns (uint) {\n        if (a > b)\n            return a;\n        else\n            return b;\n    }\n\n    /**\n     * @dev Returns the minimum of two unsigned integers\n     *\n     * @param a A number to compare\n     * @param b A number to compare\n     * @return The minimum of two unsigned integers\n     */\n    function min(uint a, uint b) internal pure returns (uint) {\n        if (a < b)\n            return a;\n        else\n            return b;\n    }\n\n    /** \n     * @dev Fallback function to be called when the contract receives a transference through an ERC677 contract\n     *\n     * Functions supported:\n     * - newBidWithToken (signature 0x1413151f) with a 32 byte parameter (sealedBid to submit)\n     * - payRentWithToken (signature 0xe1ac9915) with a 32 byte parameter (hash of the name to pay the rent for)\n     *\n     * @param _from Address which sent the tokens\n     * @param _value Amount of tokens sent\n     * @param _data Byte array with information of which function to call and the parameters used for the invocation\n    **/\n    function tokenFallback(address _from, uint256 _value, bytes _data) public returns (bool) {\n        if (_data.length < 4) return true;\n\n        require(msg.sender == address(tokenContract));\n\n        bytes4 signature = bytes4(uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24));\n\n        if (signature == SIGN_NEW_BID) {\n            bytes32 sealedBid = bytesToBytes32(_data, 4);\n\n            newBidWithToken(_from, _value, sealedBid);\n        } else if (signature == SIGN_PAY_RENT) {\n            bytes32 name = bytesToBytes32(_data, 4);\n\n            payRentWithToken(_from, _value, name);\n        } else {\n            revert();\n        }\n\n        return true;\n    }\n    \n    /** \n     * @dev Given a byte array and a given offset, extract the following 32 bytes into an array\n     *\n     * from https://ethereum.stackexchange.com/questions/7702/how-to-convert-byte-array-to-bytes32-in-solidity\n    **/\n    function bytesToBytes32(bytes _b, uint _offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        for (uint i = 0; i < 32; i++) {\n            out |= bytes32(_b[_offset + i] & 0xFF) >> (i * 8);\n        }\n\n        return out;\n    }\n}\n",
  "imports": [
    {
      "name": "TokenRegistrar.sol",
      "contents": "pragma solidity ^0.4.24;\n\n\n/*\n\nTemporary Hash Registrar\n========================\n\nThis is a simplified version of a hash registrar. It is purporsefully limited:\nnames cannot be six letters or shorter, new auctions will stop after 4 years.\n\nThe plan is to test the basic features and then move to a new contract in at most\n2 years, when some sort of renewal mechanism will be enabled.\n\nRefund schedule\n===============\n\nCase A: Reveal Period\n------------------------------------------------------------------------------------\n| (I) Auction winner | Funds are locked in Deed. 80% are returned on Deed release  |\n------------------------------------------------------------------------------------\n| (II) Auction losser | 100% refund over the losing bid                            |\n------------------------------------------------------------------------------------\n\nCase B: Late-Reveal Period (2 weeks after auction finish)\n---------------------------------------------------------------------------------------------------\n| (I) Bid that would have won                 | 20% taken as fee                                  |\n---------------------------------------------------------------------------------------------------\n| (II) Bid that would have affected 2nd place | Difference with the actual 2nd place taken as fee |\n---------------------------------------------------------------------------------------------------\n| (III) Otherwise                             | 0.5% taken as fee                                 |\n---------------------------------------------------------------------------------------------------\n\nCase C: Any bid unsealed beyond the Late-Reveal period won't be refunded\n*/\n\n\nimport './TokenDeed.sol';\nimport '../../common/RNS.sol';\nimport '../../tokens/ERC677TokenContract.sol';\n\n/**\n * @title TokenRegistrar\n * @dev The registrar handles the auction process for each subnode of the node it owns.\n */\ncontract TokenRegistrar {\n    using SafeMath for uint256;\n\n    RNS public rns;\n    bytes32 public rootNode;\n\tERC677TokenContract public tokenContract;\n\n    mapping (bytes32 => Entry) _entries;\n    mapping (address => mapping (bytes32 => TokenDeed)) public sealedBids;\n    \n    enum Mode { Open, Auction, Owned, Forbidden, Reveal }\n\n    bytes4 constant SIGN_NEW_BID = 0x1413151f;  // sha3('newBidWithToken(address,uint256,bytes32)')\n    bytes4 constant SIGN_PAY_RENT = 0xe1ac9915; // sha3('payRentWithToken(address,uint256,bytes32)')\n    uint32 constant TOTAL_AUCTION_LENGTH = 5 days;\n    uint32 constant REVEAL_PERIOD = 48 hours;\n    uint32 constant LATE_UNSEAL_PERIOD = 15 days;\n    uint constant RELEASE_FEE_PER_MIL = 200;    // 200 of 1000 = 20%\n    uint constant MIN_TOKEN_QUANTITY = 1 * 10**18;  // 1 token\n    uint constant RENT_VALUE = 1 * 10**18;  // 1 token\n    \n    event AuctionStarted(bytes32 indexed hash, uint registrationDate);\n    event NewBid(bytes32 indexed hash, address indexed bidder, uint deposit);\n    event BidRevealed(bytes32 indexed hash, address indexed owner, uint value, uint8 status);\n    event HashRegistered(bytes32 indexed hash, address indexed owner, uint value, uint registrationDate);\n    event HashReleased(bytes32 indexed hash, uint value);\n\n    struct Entry {\n        TokenDeed deed;\n        uint registrationDate;\n        uint value;\n        uint highestBid;\n    }\n\n    modifier inState(bytes32 _hash, Mode _state) {\n        require(state(_hash) == _state);\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _hash) {\n        require(state(_hash) == Mode.Owned && msg.sender == _entries[_hash].deed.owner());\n        _;\n    }\n\n    modifier registryOpen() {\n        require(rns.owner(rootNode) == address(this));\n        _;\n    }\n\n    /**\n     * @dev Constructs a new Registrar, with the provided address as the owner of the root node.\n     *\n     * @param _rns The address of the RNS\n     * @param _rootNode The hash of the rootnode.\n     * @param _tokenAddr The ERC677 contract address to handle tokens\n     */\n    constructor(RNS _rns, bytes32 _rootNode, ERC677TokenContract _tokenAddr) public {\n        rns = _rns;\n        rootNode = _rootNode;\n        tokenContract = _tokenAddr;\n    }\n\n    /**\n     * @dev Start an auction for an available hash\n     *\n     * @param _hash The hash to start an auction on\n     */\n    function startAuction(bytes32 _hash) public registryOpen() {\n        Mode mode = state(_hash);\n        if (mode == Mode.Auction) return;\n        require(mode == Mode.Open);\n\n        Entry storage newAuction = _entries[_hash];\n        newAuction.registrationDate = now + TOTAL_AUCTION_LENGTH;\n        newAuction.value = 0;\n        newAuction.highestBid = 0;\n        newAuction.deed = TokenDeed(0);\n\n        emit AuctionStarted(_hash, newAuction.registrationDate);\n    }\n\n    /**\n     * @dev Start multiple auctions for better anonymity\n     *\n     * Anyone can start an auction by sending an array of hashes that they want to bid for.\n     * Arrays are sent so that someone can open up an auction for X dummy hashes when they\n     * are only really interested in bidding for one. This will increase the cost for an\n     * attacker to simply bid blindly on all new auctions. Dummy auctions that are\n     * open but not bid on are closed after a week.\n     *\n     * @param _hashes An array of hashes, at least one of which you presumably want to bid on\n     */\n    function startAuctions(bytes32[] _hashes) public {\n        for (uint i = 0; i < _hashes.length; i ++) {\n            startAuction(_hashes[i]);\n        }\n    }\n\n    /**\n     * @dev Submit a new sealed bid on a desired hash in a blind auction\n     *\n     * Bids are sent by sending a message to the main contract with a hash and an amount. The hash\n     * contains information about the bid, including the bidded hash, the bid amount, and a random\n     * salt. Bids are not tied to any one auction until they are revealed. The value of the bid\n     * itself can be masqueraded by sending more than the value of your actual bid. This is\n     * followed by a 48h reveal period. For bids revealed after this period, a percentage (defined in the late unsealing \n     * Refund schedule) will be sent to a special resource pool address.\n     * Since this is an auction, it is expected that most public hashes, like known domains and common dictionary\n     * words, will have multiple bidders pushing the price up.\n     *\n     * This method requires the sender to approve the Registrar to use the specified tokenQuantity in the ERC677 contract.\n     * Otherwise it can be done through the tokenFallback after a transfer with the corresponding parameters\n     *\n     * @param _sealedBid A sealedBid, created by the shaBid function\n     * @param _tokenQuantity token quantity to bid\n     */\n    function newBid(bytes32 _sealedBid, uint _tokenQuantity) public {\n        require(tokenContract.transferFrom(msg.sender, address(this), _tokenQuantity));\n\n        newBidAfterTransfer(msg.sender, _tokenQuantity, _sealedBid);\n    }\n\n    /**  \n     * @dev Method to be called through a dynamic invocation from an ERC677 token contract\n     *\n     * @param _from Address sending the tokens as well as submitting the bid\n     * @param _tokenQuantity Amount in tokens received throuh the transference\n     * @param _sealedBid Sealed bid, created through the shaBid function\n    **/\n    function newBidWithToken(address _from, uint _tokenQuantity, bytes32 _sealedBid) public {\n        require(msg.sender == address(tokenContract));\n        newBidAfterTransfer(_from, _tokenQuantity, _sealedBid);\n    }\n\n    /** \n     * @dev Internal method which handles the new bidding logic\n     *\n     * @param _from Address sending the tokens as well as submitting the bid\n     * @param _tokenQuantity Amount in tokens received through the transference. To be used to mask the actual bidded value\n     * @param _sealedBid Sealed bid, created through the shaBid function\n    **/\n    function newBidAfterTransfer(address _from, uint _tokenQuantity, bytes32 _sealedBid) private {\n        require(address(sealedBids[_from][_sealedBid]) == 0x0);\n\n        // Creates a new hash contract with the owner\n        TokenDeed createdBid = new TokenDeed(_from, _tokenQuantity, tokenContract);\n        require(tokenContract.transfer(createdBid, _tokenQuantity));\n        sealedBids[_from][_sealedBid] = createdBid;\n\t\t\n        emit NewBid(_sealedBid, _from, _tokenQuantity);\n    }\n\n    /**\n     * @dev Start a set of auctions and bid on one of them\n     *\n     * This method functions identically to calling `startAuctions` followed by `newBid`,\n     * but all in one transaction.\n     *\n     * @param _hashes A list of hashes to start auctions on.\n     * @param _sealedBid A sealed bid for one of the auctions.\n     * @param _tokenQuantity Amount of tokens to mask the bid with.\n     */\n    function startAuctionsAndBid(bytes32[] _hashes, bytes32 _sealedBid, uint _tokenQuantity) public payable {\n        startAuctions(_hashes);\n        newBid(_sealedBid, _tokenQuantity);\n    }\n\n    /**\n     * @dev Submit the properties of a bid to reveal them\n     *\n     * @param _hash The node in the sealedBid\n     * @param _value The bid amount in the sealedBid\n     * @param _salt The sale in the sealedBid\n     */\n    function unsealBid(bytes32 _hash, uint _value, bytes32 _salt) public {\n        bytes32 seal = shaBid(_hash, msg.sender, _value, _salt);\n        TokenDeed bid = sealedBids[msg.sender][seal];\n        require(address(bid) != 0);\n\n        sealedBids[msg.sender][seal] = TokenDeed(0);\n        Entry storage h = _entries[_hash];\n        uint value = min(_value, bid.tokenQuantity());\n        bid.setBalance(value, true);\n\n        Mode auctionState = state(_hash);\n\n        if (auctionState == Mode.Owned) {\n            // By this point the auction has ended. The refund values are defined in the above Refund Schedule\n\n            uint256 refundRatio = 995; // See: Case B)III\n\n            if (h.registrationDate + LATE_UNSEAL_PERIOD < now) {\n                refundRatio = 0; // See: Case C\n            } else {\n                if (value > h.highestBid) {\n                    refundRatio = 800; // See: Case B)I\n                } else if (value > h.value) {\n                    // See: Case B)II\n                    // Compute percentage corresponding to the difference between the actual 2nd place (h.value)\n                    // and the late unsealed bid (value)\n                    refundRatio = h.value.mul(1000).div(value);\n                }\n            }\n\n            bid.closeDeed(refundRatio);\n            emit BidRevealed(_hash, msg.sender, value, 1);\n        } else if (auctionState != Mode.Reveal) {\n            // invalid phase for unsealing\n            revert();\n        } else if (value < MIN_TOKEN_QUANTITY || bid.creationDate() > h.registrationDate - REVEAL_PERIOD) {\n            // Bid below the minimum or too late (created in the reveal period)\n            bid.closeDeed(1000);\n            emit BidRevealed(_hash, msg.sender, value, 0);\n        } else if (value > h.highestBid) {\n            // New winner\n            // Cancel the other bid\n            if (address(h.deed) != 0) {\n                TokenDeed previousWinner = h.deed;\n                previousWinner.closeDeed(1000);\n            }\n\n            // Set new winner\n            // Per the rules of a vickery auction, the value becomes the previous highestBid\n            h.value = h.highestBid;  // will be zero if there's only 1 bidder\n            h.highestBid = value;\n            h.deed = bid;\n            emit BidRevealed(_hash, msg.sender, value, 2);\n        } else if (value > h.value) {\n            // Not winner, but affects second place\n            h.value = value;\n            bid.closeDeed(1000);\n            emit BidRevealed(_hash, msg.sender, value, 3);\n        } else {\n            // Bid doesn't affect auction\n            bid.closeDeed(1000);\n            emit BidRevealed(_hash, msg.sender, value, 4);\n        }\n    }\n\n    /**\n     * @dev Finalize an auction after the registration date has passed\n     *\n     * Updates the Registry to reflect the new node owner. Starts the winning Deed's expiration period.\n     *\n     * @param _hash The hash of the name the auction is for\n     */\n    function finalizeAuction(bytes32 _hash) public onlyOwner(_hash) {\n        Entry storage h = _entries[_hash];\n        \n        // Handles the case when there's only a single bidder (h.value is zero)\n        h.value = max(h.value, MIN_TOKEN_QUANTITY);\n        h.deed.setBalance(h.value, true);\n        h.deed.startExpiration(h.registrationDate, RENT_VALUE);\n\n        trySetSubnodeOwner(_hash, h.deed.owner());\n        emit HashRegistered(_hash, h.deed.owner(), h.value, h.registrationDate);\n    }\n\n    /**\n     * @dev The owner of a domain may transfer it to someone else at any time.\n     *\n     * @param _hash The node to transfer\n     * @param _newOwner The address to transfer ownership to\n     */\n    function transfer(bytes32 _hash, address _newOwner) public onlyOwner(_hash) {\n        require(_newOwner != 0);\n\n        Entry storage h = _entries[_hash];\n        h.deed.setOwner(_newOwner);\n        trySetSubnodeOwner(_hash, _newOwner);\n    }\n\n    /**\n     * @dev After some time, or if we're no longer the registrar, the owner can release\n     *      the name and get a part of their tokens back.\n     *\n     * The allowed release period is within the rent payment period, which starts 3 months before the expiration date\n     *\n     * @param _hash The node to release\n     */\n    function releaseDeed(bytes32 _hash) public onlyOwner(_hash) {\n        Entry storage h = _entries[_hash];\n        TokenDeed deedContract = h.deed;\n\n        require(now < deedContract.expirationDate() || rns.owner(rootNode) != address(this));\n\n        h.value = 0;\n        h.highestBid = 0;\n        h.deed = TokenDeed(0);\n\n        _tryEraseSingleNode(_hash);\n\n        // return funds after deducting a fee and close the deed\n        deedContract.closeDeed(1000 - RELEASE_FEE_PER_MIL);\n\n        emit HashReleased(_hash, h.value);        \n    }\n\n    /**\n     * @dev Allows anyone to delete the owner and resolver records for a (subdomain of) a\n     *      name that is not currently owned in the registrar. If passing, eg, 'foo.bar.rsk',\n     *      the owner and resolver fields on 'foo.bar.rsk' and 'bar.rsk' will all be cleared.\n     *\n     * @param _labels A series of label hashes identifying the name to zero out, rooted at the\n     *        registrar's root. Must contain at least one element. For instance, to zero \n     *        'foo.bar.rsk' on a registrar that owns '.rsk', pass an array containing\n     *        [keccak256('foo'), keccak256('bar')].\n     */\n    function eraseNode(bytes32[] _labels) public {\n        require(_labels.length != 0);\n        require(state(_labels[_labels.length - 1]) != Mode.Owned);\n\n        _eraseNodeHierarchy(_labels.length - 1, _labels, rootNode);\n    }\n\n    /**\n     * @dev Transfers the deed to the current registrar, if different from this one.\n     *\n     * Used during the upgrade process to a permanent registrar.\n     *\n     * @param _hash The name hash to transfer.\n     */\n    function transferRegistrars(bytes32 _hash) public onlyOwner(_hash) {\n        address registrar = rns.owner(rootNode);\n        require(registrar != address(this));\n\n        // Migrate the deed\n        Entry storage h = _entries[_hash];\n        h.deed.setRegistrar(registrar);\n\n        // Call the new registrar to accept the transfer\n        TokenRegistrar(registrar).acceptRegistrarTransfer(_hash, h.deed, h.registrationDate);\n\n        // Zero out the Entry\n        h.deed = TokenDeed(0);\n        h.registrationDate = 0;\n        h.value = 0;\n        h.highestBid = 0;\n    }\n\n    /**\n     * @dev Pay the yearly rent for a name\n     *\n     * Names have a vigency of 1 year after the registration date. Said expiry date is reflected through the associated Deed \n     * contract. Owners have a period of 3 months before the expiryDate to pay the rent and extend their ownership for 1 year\n     *\n     * @param _hash The hash of the name to pay the rent for\n     */\n    function payRent(bytes32 _hash) public {\n        require(tokenContract.transferFrom(msg.sender, address(this), RENT_VALUE));\n        payRentAfterTransfer(_hash);\n    }\n\n    /**  \n     * @dev Method to be called through a dynamic invocation from an ERC677 token contract\n     *\n     * @param _from Address sending the tokens as well as submitting the bid\n     * @param _tokenQuantity Amount in tokens received throuh the transference\n     * @param _hash Hash of the name to pay the rent for\n    **/\n    function payRentWithToken(address _from, uint _tokenQuantity, bytes32 _hash) public {\n        require(_tokenQuantity == RENT_VALUE);\n        require(msg.sender == address(tokenContract));\n        payRentAfterTransfer(_hash);\n    }\n\n    /** \n     * @dev Internal method which handles the rent payment logic\n     *\n     * @param _hash Hash of the name to pay the rent for\n    **/\n    function payRentAfterTransfer(bytes32 _hash) private {\n        require(state(_hash) == Mode.Owned);\n\n        Entry storage h = _entries[_hash];\n\n        require(address(h.deed) != 0);\n\n        require(tokenContract.transfer(h.deed, RENT_VALUE));\n        require(h.deed.payRent(RENT_VALUE));\n    }\n\n    /**\n     * @dev Accepts a transfer from a previous registrar; stubbed out here since there\n     *      is no previous registrar implementing this interface.\n     *\n     * @param _hash The sha3 hash of the label to transfer.\n     * @param _deed The TokenDeed object for the name being transferred in.\n     * @param _registrationDate The date at which the name was originally registered.\n     */\n    function acceptRegistrarTransfer(bytes32 _hash, TokenDeed _deed, uint _registrationDate) public pure {\n        _hash; _deed; _registrationDate; // Don't warn about unused variables\n    }\n\n    // State transitions for names:\n    //   Open -> Auction (startAuction)\n    //   Auction -> Reveal\n    //   Reveal -> Owned\n    //   Reveal -> Open (if nobody bid)\n    //   Owned -> Open (releaseDeed or the deed has expired)\n    function state(bytes32 _hash) public view returns (Mode) {\n        Entry storage entry = _entries[_hash];\n\n        if (now < entry.registrationDate) {\n            if (now < entry.registrationDate - REVEAL_PERIOD) {\n                return Mode.Auction;\n            } else {\n                return Mode.Reveal;\n            }\n        } else {\n            // there may not be any bid (not yet auctioned) or there is and it may have already expired (Expired)\n            if (entry.highestBid == 0 || entry.deed.expired()) {\n                return Mode.Open;\n            } else {\n                return Mode.Owned;\n            }\n        }\n    }\n\n    /** \n     * @dev Returns information related to a certain name\n     *\n     * @param _hash Hash of the name to query about\n    **/\n    function entries(bytes32 _hash) public view returns (Mode, address, uint, uint, uint) {\n        Entry storage h = _entries[_hash];\n        return (state(_hash), h.deed, h.registrationDate, h.value, h.highestBid);\n    }\n\n    /**\n     * @dev Hash the values required for a secret bid\n     *\n     * @param _hash The node corresponding to the desired namehash\n     * @param _value The bid amount in tokens\n     * @param _salt A random value to ensure secrecy of the bid\n     * @return The hash of the bid values\n     */\n    function shaBid(bytes32 _hash, address _owner, uint _value, bytes32 _salt) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_hash, _owner, _value, _salt));\n    }\n\n    function _tryEraseSingleNode(bytes32 _label) internal {\n        if (rns.owner(rootNode) == address(this)) {\n            rns.setSubnodeOwner(rootNode, _label, address(this));\n            bytes32 node = keccak256(abi.encodePacked(rootNode, _label));\n            rns.setResolver(node, 0);\n            rns.setOwner(node, 0);\n        }\n    }\n\n    function _eraseNodeHierarchy(uint _idx, bytes32[] _labels, bytes32 _node) internal {\n        // Take ownership of the node\n        rns.setSubnodeOwner(_node, _labels[_idx], address(this));\n        _node = keccak256(abi.encodePacked(_node, _labels[_idx]));\n\n        // Recurse if there are more labels\n        if (_idx > 0) {\n            _eraseNodeHierarchy(_idx - 1, _labels, _node);\n        }\n\n        // Erase the resolver and owner records\n        rns.setResolver(_node, 0);\n        rns.setOwner(_node, 0);\n    }\n\n    /**\n     * @dev Assign the owner in RNS, if we're still the registrar\n     *\n     * @param _hash hash to change owner\n     * @param _newOwner new owner to transfer to\n     */\n    function trySetSubnodeOwner(bytes32 _hash, address _newOwner) internal {\n        if (rns.owner(rootNode) == address(this))\n            rns.setSubnodeOwner(rootNode, _hash, _newOwner);\n    }\n\n    /**\n     * @dev Returns the maximum of two unsigned integers\n     *\n     * @param a A number to compare\n     * @param b A number to compare\n     * @return The maximum of two unsigned integers\n     */\n    function max(uint a, uint b) internal pure returns (uint) {\n        if (a > b)\n            return a;\n        else\n            return b;\n    }\n\n    /**\n     * @dev Returns the minimum of two unsigned integers\n     *\n     * @param a A number to compare\n     * @param b A number to compare\n     * @return The minimum of two unsigned integers\n     */\n    function min(uint a, uint b) internal pure returns (uint) {\n        if (a < b)\n            return a;\n        else\n            return b;\n    }\n\n    /** \n     * @dev Fallback function to be called when the contract receives a transference through an ERC677 contract\n     *\n     * Functions supported:\n     * - newBidWithToken (signature 0x1413151f) with a 32 byte parameter (sealedBid to submit)\n     * - payRentWithToken (signature 0xe1ac9915) with a 32 byte parameter (hash of the name to pay the rent for)\n     *\n     * @param _from Address which sent the tokens\n     * @param _value Amount of tokens sent\n     * @param _data Byte array with information of which function to call and the parameters used for the invocation\n    **/\n    function tokenFallback(address _from, uint256 _value, bytes _data) public returns (bool) {\n        if (_data.length < 4) return true;\n\n        require(msg.sender == address(tokenContract));\n\n        bytes4 signature = bytes4(uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24));\n\n        if (signature == SIGN_NEW_BID) {\n            bytes32 sealedBid = bytesToBytes32(_data, 4);\n\n            newBidWithToken(_from, _value, sealedBid);\n        } else if (signature == SIGN_PAY_RENT) {\n            bytes32 name = bytesToBytes32(_data, 4);\n\n            payRentWithToken(_from, _value, name);\n        } else {\n            revert();\n        }\n\n        return true;\n    }\n    \n    /** \n     * @dev Given a byte array and a given offset, extract the following 32 bytes into an array\n     *\n     * from https://ethereum.stackexchange.com/questions/7702/how-to-convert-byte-array-to-bytes32-in-solidity\n    **/\n    function bytesToBytes32(bytes _b, uint _offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        for (uint i = 0; i < 32; i++) {\n            out |= bytes32(_b[_offset + i] & 0xFF) >> (i * 8);\n        }\n\n        return out;\n    }\n}\n",
      "file": "TokenRegistrar.sol"
    },
    {
      "name": "TokenDeed.sol",
      "contents": "pragma solidity ^0.4.24;\n\nimport '../../tokens/ERC677TokenContract.sol';\n\n/**\n * @title Deed to hold RIF tokens in exchange for ownership of a node\n *\n * @dev The deed can be controlled only by the registrar and can only send tokens back to the owner.\n */\ncontract TokenDeed {\n\n    address constant RESOURCE_POOL_ADDRESS = 0xe594df49aa7a13ccdd2db3a7917312e02374f744;\n    uint constant RENT_PAYMENT_TIME = 3 * 30 days; // 3 months\n    uint constant VALIDITY = 365 days; // 1 year\n\n    address public registrar;\n    address public owner;\n    address public previousOwner;\n\n    uint public creationDate;\n    uint public expirationDate;\n\tuint public tokenQuantity;\n\n\tERC677TokenContract public tokenContract;\n\n    bool active;\n\n    event OwnerChanged(address newOwner);\n    event DeedClosed();\n\n    modifier onlyRegistrar {\n        require(msg.sender == registrar);\n        _;\n    }\n\n    modifier onlyActive {\n        require(active);\n        _;\n    }\n\n    /** \n     * @dev Constructor for a TokenDeed\n     *\n     * @param _owner The deed's owner\n     * @param _tokenQuantity Amount of tokens locked in the Deed\n     * @param _tokenContract Address of the contract which handles tokens\n    **/\n    constructor(address _owner, uint _tokenQuantity, ERC677TokenContract _tokenContract) public {\n        owner = _owner;\n        registrar = msg.sender;\n        creationDate = now;\n        expirationDate = 0;\n        active = true;\n        tokenQuantity = _tokenQuantity;\n        tokenContract = _tokenContract;\n    }\n\n    function setOwner(address newOwner) public onlyRegistrar {\n        require(newOwner != 0);\n        previousOwner = owner;  // This allows contracts to check who sent them the ownership\n        owner = newOwner;\n        emit OwnerChanged(newOwner);\n    }\n\n    function setRegistrar(address newRegistrar) public onlyRegistrar {\n        registrar = newRegistrar;\n    }\n\n    /** \n     * @dev Sets the Deed's new balance, returning the difference to the owner\n     *\n     * The new balance MUST be lower or equal than the current one\n     *\n     * @param newTokenQuantity The new balance in tokens\n     * @param throwOnFailure Flag to indicate if the token transference should throw or not\n    **/\n    function setBalance(uint newTokenQuantity, bool throwOnFailure) public onlyRegistrar onlyActive {\n        // Check if it has enough balance to set the value\n        require(tokenQuantity >= newTokenQuantity);\n        uint diffTokenQuantity = tokenQuantity - newTokenQuantity;\n        tokenQuantity = newTokenQuantity;\n        // Send the difference to the owner\n        require(tokenContract.transfer(owner, diffTokenQuantity) || !throwOnFailure);\n    }\n\n    /** \n     * @dev Computes and sets the expirationDate from a given date, starting the vigency period\n     *\n     * @param startDate Date to calculate the expirationDate from\n     * @param rentValue The value of the initial rent fee to pay in tokens\n    **/\n    function startExpiration(uint startDate, uint rentValue) public onlyRegistrar onlyActive {\n        require(expirationDate == 0 && startDate <= now); // require expiration hasn't started\n        require(rentValue <= tokenQuantity);\n\n        expirationDate = startDate + VALIDITY;\n\n        // transfer the fee to the resource pool address\n        tokenQuantity = tokenQuantity - rentValue;\n        require(tokenContract.transfer(RESOURCE_POOL_ADDRESS, rentValue));\n    }\n\n    /** \n     * @dev Pay the Deed's rent, thus extending the expirationDate and the vigency period\n     *\n     * Can only be called when the current date falls within the payment period (3 months)\n     *\n     * @param rentValue The value to pay in tokens\n    **/\n    function payRent(uint rentValue) public onlyRegistrar onlyActive returns(bool) {\n        require(canPayRent());\n        \n        require(tokenContract.transfer(RESOURCE_POOL_ADDRESS, rentValue));\n\n        expirationDate = expirationDate + VALIDITY;\n\n        return true;\n    }\n\n    /** \n     * @dev Returns wheter the current date falls within the Deed's rent payment period\n    **/\n    function canPayRent() public view returns(bool) {\n        return expirationDate - RENT_PAYMENT_TIME <= now && now <= expirationDate;\n    }\n\n\n    /** \n     * @dev Returns wether the Deed is expired or not\n    **/\n    function expired() public view returns(bool) {\n        return 0 < expirationDate && expirationDate < now;\n    }\n\n    /**\n     * @dev Close a deed and refund a specified fraction of the bid value\n     *\n     * @param refundRatio The amount*1/1000 to refund in tokens\n     */\n    function closeDeed(uint refundRatio) public onlyRegistrar onlyActive {\n        refundAndDestroy(refundRatio);\n    }\n\n    /** \n     * @dev Close an expired deed. No funds are returned\n    **/\n    function closeExpiredDeed() public onlyActive {\n        require(expired(), \"Deed should be expired\");\n        refundAndDestroy(0);\n    }\n\n    /** \n     * @dev Internal method which handles fund returns/burning and the Deed's destruction\n     *\n     * @param refundRatio The amount*1/1000 to refund in tokens\n    **/\n    function refundAndDestroy(uint refundRatio) private onlyActive {\n        require(refundRatio <= 1000);\n\n        active = false;\n        uint torefund = (1000 - refundRatio) * tokenQuantity / 1000;\n        require(tokenContract.transfer(RESOURCE_POOL_ADDRESS, torefund));\n        tokenQuantity -= torefund;\n        emit DeedClosed();\n        destroyDeed();\n    }\n\n    /**\n     * @dev Close a deed and refund a specified fraction of the bid value\n     */\n    function destroyDeed() private {\n        require(!active);\n\n        if (tokenContract.transfer(owner, tokenQuantity)) {\n            selfdestruct(RESOURCE_POOL_ADDRESS);\n        }\n    }\n\n    function tokenFallback(address from, uint256 amount, bytes data) public returns (bool) {\n        return true;\n    }\n}\n"
    },
    {
      "name": "TestRegistrar.sol",
      "contents": "pragma solidity ^0.4.24;\n\nimport '../../common/AbstractRNS.sol';\n\n/**\n * A registrar that allocates subdomains to the first person to claim them, but\n * expires registrations a fixed period after they're initially claimed.\n */\ncontract TestRegistrar {\n    uint constant registrationPeriod = 4 weeks;\n\n    AbstractRNS public rns;\n    bytes32 public rootNode;\n    mapping(bytes32=>uint) public expiryTimes;\n\n    /**\n     * Constructor.\n     * @param rnsAddr The address of the RNS registry.\n     * @param node The node that this registrar administers.\n     */\n    constructor(AbstractRNS rnsAddr, bytes32 node) public {\n        rns = rnsAddr;\n        rootNode = node;\n    }\n\n    /**\n     * Register a name that's not currently registered\n     * @param subnode The hash of the label to register.\n     * @param owner The address of the new owner.\n     */\n    function register(bytes32 subnode, address owner) public {\n        require(expiryTimes[subnode] < now);\n\n        expiryTimes[subnode] = now + registrationPeriod;\n        rns.setSubnodeOwner(rootNode, subnode, owner);\n    }\n}"
    },
    {
      "name": "StandardToken.sol",
      "contents": "pragma solidity ^0.4.24;\n\nimport \"./BasicToken.sol\";\nimport \"./ERC20.sol\";\n\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/issues/20\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n    require(_to != address(0));\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint256 _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint256 _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue >= oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n"
    },
    {
      "name": "SafeMath.sol",
      "contents": "pragma solidity ^0.4.24;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    assert(c / _a == _b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n    return _a / _b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    assert(_b <= _a);\n    return _a - _b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    assert(c >= _a);\n    return c;\n  }\n}\n"
    },
    {
      "name": "SafeERC20.sol",
      "contents": "pragma solidity ^0.4.24;\n\nimport \"./ERC20Basic.sol\";\nimport \"./ERC20.sol\";\n\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  function safeTransfer(\n    ERC20Basic _token,\n    address _to,\n    uint256 _value\n  )\n    internal\n  {\n    require(_token.transfer(_to, _value));\n  }\n\n  function safeTransferFrom(\n    ERC20 _token,\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    internal\n  {\n    require(_token.transferFrom(_from, _to, _value));\n  }\n\n  function safeApprove(\n    ERC20 _token,\n    address _spender,\n    uint256 _value\n  )\n    internal\n  {\n    require(_token.approve(_spender, _value));\n  }\n}\n"
    },
    {
      "name": "RNS.sol",
      "contents": "pragma solidity ^0.4.24;\n\nimport './AbstractRNS.sol';\n\n/**\n * The RNS registry contract.\n */\ncontract RNS is AbstractRNS {\n    struct Record {\n        address owner;\n        address resolver;\n        uint64 ttl;\n    }\n\n    mapping(bytes32=>Record) records;\n\n    // Permits modifications only by the owner of the specified node.\n    modifier only_owner(bytes32 node) {\n        require(records[node].owner == msg.sender);\n        _;\n    }\n\n    /**\n     * Constructs a new RNS registrar.\n     */\n    constructor() public {\n        records[bytes32(0)].owner = msg.sender;\n    }\n\n    /**\n     * Returns the address that owns the specified node.\n     */\n    function owner(bytes32 node) public view returns (address) {\n        return records[node].owner;\n    }\n\n    /**\n     * Returns the address of the resolver for the specified node.\n     */\n    function resolver(bytes32 node) public view returns (address) {\n        return records[node].resolver;\n    }\n\n    /**\n     * Returns the TTL of a node, and any records associated with it.\n     */\n    function ttl(bytes32 node) public view returns (uint64) {\n        return records[node].ttl;\n    }\n\n    /**\n     * Transfers ownership of a node to a new address. May only be called by the current\n     * owner of the node.\n     * @param node The node to transfer ownership of.\n     * @param ownerAddress The address of the new owner.\n     */\n    function setOwner(bytes32 node, address ownerAddress) public only_owner(node) {\n        emit Transfer(node, ownerAddress);\n        records[node].owner = ownerAddress;\n    }\n\n    /**\n     * Transfers ownership of a subnode keccak256(node, label) to a new address. May only be\n     * called by the owner of the parent node.\n     * @param node The parent node.\n     * @param label The hash of the label specifying the subnode.\n     * @param ownerAddress The address of the new owner.\n     */\n    function setSubnodeOwner(bytes32 node, bytes32 label, address ownerAddress) public only_owner(node) {\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\n        emit NewOwner(node, label, ownerAddress);\n        records[subnode].owner = ownerAddress;\n\n        emit NewResolver(subnode, records[node].resolver);\n        records[subnode].resolver = records[node].resolver;\n    }\n\n    /**\n     * Sets the resolver address for the specified node.\n     * @param node The node to update.\n     * @param resolverAddress The address of the resolver.\n     */\n    function setResolver(bytes32 node, address resolverAddress) public only_owner(node) {\n        emit NewResolver(node, resolverAddress);\n        records[node].resolver = resolverAddress;\n    }\n\n    /**\n     * Sets the TTL for the specified node.\n     * @param node The node to update.\n     * @param ttlValue The TTL in seconds.\n     */\n    function setTTL(bytes32 node, uint64 ttlValue) public only_owner(node) {\n        emit NewTTL(node, ttlValue);\n        records[node].ttl = ttlValue;\n    }\n\n    /**\n     * Sets the default resolver for new nodes\n     * @param resolver The address of the new defaultResolver\n     */\n    function setDefaultResolver(address resolver) public only_owner(0) {\n        records[bytes32(0)].resolver = resolver;\n    }\n}\n"
    },
    {
      "name": "ResolverInterface.sol",
      "contents": "pragma solidity ^0.4.24;\n\ncontract AbstractPublicResolver {\n    function PublicResolver(address rnsAddr) public;\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool);\n    function addr(bytes32 node) public view returns (address ret);\n    function setAddr(bytes32 node, address addrValue) public;\n    function content(bytes32 node) public view returns (bytes32 ret);\n    function setContent(bytes32 node, bytes32 hashValue) public;\n    function has(bytes32 node, bytes32 kind) public view returns (bool);\n}\n"
    },
    {
      "name": "PublicResolver.sol",
      "contents": "pragma solidity ^0.4.24;\n\nimport './AbstractRNS.sol';\n\n/**\n * A simple resolver anyone can use; only allows the owner of a node to set its\n * address.\n */\ncontract PublicResolver {\n    AbstractRNS rns;\n    mapping(bytes32=>address) addresses;\n    mapping(bytes32=>bytes32) hashes;\n\n    modifier only_owner(bytes32 node) {\n        require(rns.owner(node) == msg.sender);\n        _;\n    }\n\n    /**\n     * Constructor.\n     * @param rnsAddr The RNS registrar contract.\n     */\n    constructor(AbstractRNS rnsAddr) public {\n        rns = rnsAddr;\n    }\n\n    /**\n     * Fallback function.\n     */\n    function() public {\n        revert();\n    }\n\n    /**\n     * Returns true if the specified node has the specified record type.\n     * @param node The RNS node to query.\n     * @param kind The record type name, as specified in EIP137.\n     * @return True if this resolver has a record of the provided type on the\n     *         provided node.\n     */\n    function has(bytes32 node, bytes32 kind) public view returns (bool) {\n        return  (kind == \"addr\" && addresses[node] != 0) || \n        (kind == \"hash\" && hashes[node] != 0);\n    }\n\n    /**\n     * Returns true if the resolver implements the interface specified by the provided hash.\n     * @param interfaceID The ID of the interface to check for.\n     * @return True if the contract implements the requested interface.\n     */\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\n        return interfaceID == 0x3b3b57de || interfaceID == 0xd8389dc5;\n    }\n\n    /**\n     * Returns the address associated with an RNS node.\n     * @param node The RNS node to query.\n     * @return The associated address.\n     */\n    function addr(bytes32 node) public view returns (address) {\n        return addresses[node];\n    }\n\n    /**\n     * Sets the address associated with an RNS node.\n     * May only be called by the owner of that node in the RNS registry.\n     * @param node The node to update.\n     * @param addrValue The address to set.\n     */\n    function setAddr(bytes32 node, address addrValue) public only_owner(node) {\n        addresses[node] = addrValue;\n    }\n\n    /**\n     * Returns the content hash associated with an RNS node.\n     * Note that this resource type is not standardized, and will likely change\n     * in future to a resource type based on multihash.\n     * @param node The RNS node to query.\n     * @return The associated content hash.\n     */\n    function content(bytes32 node) public view returns (bytes32) {\n        return hashes[node];\n    }\n\n    /**\n     * Sets the content hash associated with an RNS node.\n     * May only be called by the owner of that node in the RNS registry.\n     * Note that this resource type is not standardized, and will likely change\n     * in future to a resource type based on multihash.\n     * @param node The node to update.\n     * @param hash The content hash to set\n     */\n    function setContent(bytes32 node, bytes32 hash) public only_owner(node) {\n        hashes[node] = hash;\n    }\n}\n"
    },
    {
      "name": "FixedFeeFIFSRegistrar.sol",
      "contents": "pragma solidity ^0.4.24;\n\nimport \"../../common/RNS.sol\";\nimport \"../../tokens/ERC677TokenContract.sol\";\n\n/** \n    First come first serve registrar. Registers a name for the first person to claim it in exchange\n    for a fixed value. Each registered name lasts one year. Owner may renew their names any time during \n    the last 3 months of said year.\n */\ncontract FixedFeeFIFSRegistrar {\n    RNS public rns;\n    bytes32 public rootNode;\n    uint256 public registerFeeValue;\n    uint256 public renewFeeValue;\n    ERC677TokenContract public tokenContract;\n    address public resourcePool;    \n    mapping (bytes32 => Entry) entries;\n\n    enum State { Open, _, Owned, __, ___, Expired, Renew }\n\n    uint256 constant VALIDITY = 365 days;\n    uint256 constant RENEW_PERIOD = 3 * 30 days;\n    bytes4 constant SIGN_REGISTER = 0x78810c57;\n    bytes4 constant SIGN_RENEW = 0x9d6bb36c;\n\n    event HashRegistered(bytes32 indexed hash, address indexed owner, uint registrationDate);\n    event HashRenewed(bytes32 indexed hash);\n    event HashTransfered(bytes32 indexed hash, address indexed oldOwner, address indexed newOwner);\n    event HashReleased(bytes32 indexed hash);\n\n    struct Entry {\n        address owner;\n        uint256 registrationDate;\n        uint256 expirationDate;\n    }\n\n    modifier isAvailable(bytes32 _hash) {\n        State s = state(_hash);\n        require(s == State.Open || s == State.Expired, \"Name is not available\");\n        _;\n    }\n\n    modifier isRenewable(bytes32 _hash) {\n        require(state(_hash) == State.Renew, \"Name is not renewable\");\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _hash) {\n        require(state(_hash) == State.Owned && entries[_hash].owner == msg.sender, \"Sender is not the owner\");\n        _;\n    }\n\n    modifier registrarOpen() {\n        require(address(this) == rns.owner(rootNode), \"Registrar is not open\");\n        _;\n    }\n\n    /**\n        @dev Construct a new First-Come-First-Serve registrar which consumes tokens from an ERC677 token contract.\n        Registration and renewal fees, as well as the resource pool, are configured through this constructor. \n\n        @param _rns The address of the RNS registry\n        @param _rootNode The node managed by this registrar\n        @param _registerFeeValue The fee for registering new names\n        @param _resourcePool The fee for renewing a name\n        @param _tokenContract The address of an ERC677 token contract\n        @param _resourcePool Address where the fees are sent to\n     */\n    constructor (RNS _rns, bytes32 _rootNode, uint256 _registerFeeValue, uint256 _renewFeeValue, \n                 ERC677TokenContract _tokenContract, address _resourcePool) public {\n        rns = _rns;\n        rootNode = _rootNode;\n        registerFeeValue = _registerFeeValue;\n        renewFeeValue = _renewFeeValue;\n        tokenContract = _tokenContract;\n        resourcePool = _resourcePool;\n    }\n\n    /**\n        @dev Register the hash of a given name. Requires pre-approving this registrar to use at least 1 token.\n\n        @param _hash The hash of the label to register. For example: for 'domain.tld' it would be sha3('domain')\n     */\n    function register(bytes32 _hash) public {\n        require(tokenContract.transferFrom(msg.sender, address(this), registerFeeValue), \"Failed to transfer tokens from sender\");\n\n        innerRegister(msg.sender, registerFeeValue, _hash);\n    }\n    \n    /**\n        @dev Renew a given name, extending the ownership for 1 year. Renewal can be done only in the three months prior to expiration. Requires pre-approving this registrar to use at least 1 token.\n\n        @param _hash The hash of the label to register. For example: for 'domain.tld' it would be sha3('domain')\n     */\n    function renew(bytes32 _hash) public {\n        require(tokenContract.transferFrom(msg.sender, address(this), renewFeeValue), \"Failed to transfer tokens from sender\");\n\n        innerRenew(msg.sender, renewFeeValue, _hash);\n    }\n\n    /** \n        @dev Handles the inner registration logic. Updates ownership of the name for a given address both in the registry and registrar after collecting the fee\n\n        @param _address The address of the new owner\n        @param _value The value in tokens sent by the registrant\n        @param _hash The hash of the label to register\n    */\n    function innerRegister(address _address, uint256 _value, bytes32 _hash) private isAvailable(_hash) registrarOpen() {\n        collectFee(_address, _value, registerFeeValue);\n\n        Entry storage entry = entries[_hash];\n\n        entry.owner = _address;\n        entry.registrationDate = now;\n        entry.expirationDate = now + VALIDITY;\n\n        rns.setSubnodeOwner(rootNode, _hash, _address);\n\n        emit HashRegistered(_hash, _address, entry.registrationDate);\n    }\n\n    /** \n        @dev Handles the inner logic for renewing a name. Extends the ownership by furthering the expiration date, after collecting a fee\n\n        @param _address The address of the new owner\n        @param _value The value in tokens sent by the registrant\n        @param _hash The hash of the label to renew\n    */\n    function innerRenew(address _address, uint256 _value, bytes32 _hash) private isRenewable(_hash) registrarOpen() {\n        collectFee(_address, _value, renewFeeValue);\n\n        entries[_hash].expirationDate += VALIDITY;\n\n        emit HashRenewed(_hash);\n    }\n\n    /**\n        @dev Transfers ownership to a new owner\n\n        @param _hash The hash of the label to transfer\n        @param _newOwner The new owner of the name\n     */\n    function transfer(bytes32 _hash, address _newOwner) public onlyOwner(_hash) registrarOpen() {\n        require(_newOwner != 0, \"Owner is zero\");\n        \n        entries[_hash].owner = _newOwner;\n\n        rns.setSubnodeOwner(rootNode, _hash, _newOwner);\n\n        emit HashTransfered(_hash, msg.sender, _newOwner);\n    }\n\n    /**\n        @dev Releases a name, forefeiting ownership of it and clearing its information in the registrar and registry\n\n        @param _hash The hash of the label to be released\n     */\n    function release(bytes32 _hash) public onlyOwner(_hash) registrarOpen() {\n        rns.setSubnodeOwner(rootNode, _hash, 0);\n\n        clearEntry(_hash);\n\n        emit HashReleased(_hash);\n    }\n\n    /**\n        @dev Migrates the name and its ownership to a new registrar\n\n        @param _hash The hash of the label to transfer\n     */\n    function transferRegistrar(bytes32 _hash) public onlyOwner(_hash) {\n        address newRegistrar = rns.owner(rootNode);\n        require(newRegistrar != address(this), \"Registrar still owns the root node\");\n\n        Entry storage entry = entries[_hash];\n\n        FixedFeeFIFSRegistrar(newRegistrar).acceptRegistrarTransfer(_hash, entry.owner, entry.registrationDate, entry.expirationDate);\n\n        clearEntry(_hash);\n    }\n    function acceptRegistrarTransfer(bytes32 _hash, address _owner, uint256 _registrationDate, uint256 _expirationDate) public {\n        _hash; _owner; _registrationDate; _expirationDate;\n    }\n\n    /** \n        @dev Clears the entry for a given hash\n\n        @param _hash The hash of a label\n     */\n    function clearEntry(bytes32 _hash) private {\n        Entry storage entry = entries[_hash];\n\n        entry.owner = address(0);\n        entry.registrationDate = 0;\n        entry.expirationDate = 0;\n    }\n\n    /**\n        @dev Returns the state of a given name\n\n        @param _hash The hash of the label to query the state for\n     */\n    function state(bytes32 _hash) public view returns (State) {\n        Entry storage entry = entries[_hash];\n\n        if (entry.expirationDate != 0 && entry.expirationDate < now) {\n            return State.Expired;\n        } else {\n            if (entry.owner != 0) {\n                if ((entry.expirationDate - RENEW_PERIOD) <= now && now < entry.expirationDate) { \n                    return State.Renew;\n                } else {\n                    return State.Owned;\n                }\n            } else {\n                return State.Open;\n            }\n        }\n    }\n\n    /**\n        @dev Returns information about a given name. I.E:\n            - The current state\n            - The current owner\n            - The registration date\n            - The expiration date\n\n        @param _hash The hash of the label to query the information for\n     */\n    function entry(bytes32 _hash) public view returns (State, address, uint256, uint256) {\n        Entry storage entry = entries[_hash];\n\n        return (state(_hash), entry.owner, entry.registrationDate, entry.expirationDate);\n    }\n\n    /**\n        @dev Handles the fee collection logic. Given a sender, an amount and a fee value, substracts the fee from the amount, transferring it to the resource pool and refunding the difference to the sender\n\n        @param _sender The sender address the funds will be collected from and refunded to\n        @param _amount The amount sent by the sender\n        @param _fee The fee value to collect\n     */\n    function collectFee(address _sender, uint256 _amount, uint256 _fee) private {\n        require(_amount >= _fee, \"Amount less than fee\");\n\n        uint256 refund = _amount - _fee;\n        \n        require(tokenContract.transfer(resourcePool, _fee), \"Failed to fee\");\n        require(tokenContract.transfer(_sender, refund), \"Failed to refund difference\");\n    }\n\n    /**\n        @dev Fallback function used when interacting with an ERC677 token contract.\n        Supported methods:\n            - innerRegister, through the signature 0x78810c57\n            - innerRenew, through the signature 0x9d6bb36c\n\n        @param _from The address which sent the tokens\n        @param _value The amount of tokens sent\n        @param _data Byte array with information specifying which function to call and the parameters used for the invocation\n     */\n    function tokenFallback(address _from, uint256 _value, bytes _data) public returns (bool) {\n        if (_data.length < 4) revert();\n\n        require(msg.sender == address(tokenContract), \"Sender is not token contract\");\n\n        bytes4 signature = bytes4(uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24));\n\n        bytes32 hash;\n        if (signature == SIGN_REGISTER) {\n            hash = bytesToBytes32(_data, 4);\n\n            innerRegister(_from, _value, hash);\n        } else if (signature == SIGN_RENEW) {\n            hash = bytesToBytes32(_data, 4);\n\n            innerRenew(_from, _value, hash);\n        } else {\n            revert();\n        }\n\n        return true;\n    }\n\n    /** \n     * @dev Given a byte array and a given offset, extract the following 32 bytes into an array\n     *\n     * from https://ethereum.stackexchange.com/questions/7702/how-to-convert-byte-array-to-bytes32-in-solidity\n    **/\n    function bytesToBytes32(bytes _b, uint _offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        for (uint i = 0; i < 32; i++) {\n            out |= bytes32(_b[_offset + i] & 0xFF) >> (i * 8);\n        }\n\n        return out;\n    }\n}"
    },
    {
      "name": "ERC677TokenContract.sol",
      "contents": "pragma solidity ^0.4.24;\n\n\nimport \"../third-party/openzeppelin/token/ERC20/StandardToken.sol\";\nimport \"../third-party/openzeppelin/token/ERC20/DetailedERC20.sol\";\nimport \"./ContractReceiver.sol\";\nimport \"./ERC677.sol\";\n\ncontract ERC677TokenContract is StandardToken, ERC677, DetailedERC20 {\n\n    constructor(address initialAccount, uint256 initialBalance) DetailedERC20(\"Token\", \"TOK\", 18) public {\n        balances[initialAccount] = initialBalance;\n        totalSupply_ = initialBalance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) public returns (bool) {\n        super.transfer(to, value);\n\n        ContractReceiver(to).tokenFallback(msg.sender, value, data);\n\n        Transfer(msg.sender, to, value, data);\n\n        return true;\n    }\n}\n"
    },
    {
      "name": "ERC677.sol",
      "contents": "\n// See https://github.com/ethereum/EIPs/issues/677\n\npragma solidity ^0.4.24;\n\n /* ERC677 contract interface */\n \ncontract ERC677 {\n    function transferAndCall(address to, uint256 value, bytes data) public returns (bool ok);\n\n    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);\n}\n"
    },
    {
      "name": "ERC20Basic.sol",
      "contents": "pragma solidity ^0.4.24;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address _who) public view returns (uint256);\n  function transfer(address _to, uint256 _value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n"
    },
    {
      "name": "ERC20.sol",
      "contents": "pragma solidity ^0.4.24;\n\nimport \"./ERC20Basic.sol\";\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address _owner, address _spender)\n    public view returns (uint256);\n\n  function transferFrom(address _from, address _to, uint256 _value)\n    public returns (bool);\n\n  function approve(address _spender, uint256 _value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n"
    },
    {
      "name": "DetailedERC20.sol",
      "contents": "pragma solidity ^0.4.24;\n\nimport \"./ERC20.sol\";\n\n\n/**\n * @title DetailedERC20 token\n * @dev The decimals are only for visualization purposes.\n * All the operations are done using the smallest and indivisible token unit,\n * just as on Ethereum all the operations are done in wei.\n */\ncontract DetailedERC20 is ERC20 {\n  string public name;\n  string public symbol;\n  uint8 public decimals;\n\n  constructor(string _name, string _symbol, uint8 _decimals) public {\n    name = _name;\n    symbol = _symbol;\n    decimals = _decimals;\n  }\n}\n"
    },
    {
      "name": "ContractReceiver.sol",
      "contents": "pragma solidity ^0.4.24;\n\n /*\n * Contract interface that is working with ERC677 tokens\n */\n \ncontract ContractReceiver {\n    function tokenFallback(address _from, uint _value, bytes _data) public returns(bool);\n}\n\n"
    },
    {
      "name": "BasicToken.sol",
      "contents": "pragma solidity ^0.4.24;\n\n\nimport \"./ERC20Basic.sol\";\nimport \"../../math/SafeMath.sol\";\n\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) internal balances;\n\n  uint256 internal totalSupply_;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_value <= balances[msg.sender]);\n    require(_to != address(0));\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n"
    },
    {
      "name": "AbstractRNS.sol",
      "contents": "pragma solidity ^0.4.24;\n\ncontract AbstractRNS {\n    function owner(bytes32 node) public view returns(address);\n    function resolver(bytes32 node) public view returns(address);\n    function ttl(bytes32 node) public view returns(uint64);\n    function setOwner(bytes32 node, address ownerAddress) public;\n    function setSubnodeOwner(bytes32 node, bytes32 label, address ownerAddress) public;\n    function setResolver(bytes32 node, address resolverAddress) public;\n    function setTTL(bytes32 node, uint64 ttlValue) public;\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address ownerAddress);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address ownerAddress);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolverAddress);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttlValue);\n}\n"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x1e1077933df5dcb1df448b2bf6fb951b25af0c5f257cb42d7e4dbed64401db8f",
    "blockNumber": 905033,
    "transactionHash": "0x3522be1c1137de9f372fc3906d9d65955405c0e6464bf1e254ec3ce170f314cc",
    "timestamp": 1542225694
  },
  "constructorArguments": [
    "0xcb868aeabd31e2b66f74e9a55cf064abb31a4ad5",
    "0x0cd5c10192478cd220936e91293afc15e3f6de4d419de5de7506b679cbdd8ec4",
    "0x2acc95758f8b5f583470ba265eb685a8f45fc9d5"
  ]
}