{
  "address": "0x0cfc08501780bc02ca4c16324d22f32511b309a9",
  "net": {
    "id": "30",
    "name": "RSK Mainnet"
  },
  "name": "MoCConverter",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": "1"
    },
    "evmVersion": "byzantium"
  },
  "version": "0.5.8+commit.23d335f2",
  "source": "pragma solidity 0.5.8;\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ncontract MoCState  {\r\n\r\n\r\n  // This is the current state.\r\n  States public state;\r\n\r\n  event StateTransition(States newState);\r\n  event PriceProviderUpdated(address oldAddress, address newAddress);\r\n\r\n  // One Day based on 15 seconds blocks\r\n  uint256 public dayBlockSpan;\r\n  // Relation between DOC and dollar\r\n  uint256 public peg;\r\n  // BPro max discount rate\r\n  // Reflects the discount spot rate at Liquidation level\r\n  uint256 public bproMaxDiscountRate;\r\n  // Liquidation limit\r\n  // [using mocPrecision]\r\n  uint256 public liq;\r\n  // BPro with discount limit\r\n  // [using mocPrecision]\r\n  uint256 public utpdu;\r\n  // Complete amount of Bitcoin in the system\r\n  // this represents basically MoC Balance\r\n  uint256 public rbtcInSystem;\r\n  // Price to use at doc redemption at\r\n  // liquidation event\r\n  uint256 public liquidationPrice;\r\n\r\n  function initialize(\r\n    address connectorAddress,\r\n    address _governor,\r\n    address _btcPriceProvider,\r\n    uint256 _liq,\r\n    uint256 _utpdu,\r\n    uint256 _maxDiscRate,\r\n    uint256 _dayBlockSpan,\r\n    uint256 _ema,\r\n    uint256 _smoothFactor,\r\n    uint256 _emaBlockSpan\r\n  ) public;\r\n\r\n  /**\r\n  * @param rate Discount rate at liquidation level [using mocPrecision]\r\n  **/\r\n  function setMaxDiscountRate(uint256 rate) public;\r\n\r\n    /**\r\n   * @dev return the value of the BPro max discount rate configuration param\r\n   * @return bproMaxDiscountRate BPro max discount rate\r\n   */\r\n  function getMaxDiscountRate() public view returns(uint256);\r\n\r\n  /**\r\n  * @dev Defines how many blocks there are in a day\r\n  * @param blockSpan blocks there are in a day\r\n  **/\r\n  function setDayBlockSpan(uint256 blockSpan) public;\r\n\r\n  /**\r\n  * @dev Sets a new BTCProvider contract\r\n  * @param btcProviderAddress blocks there are in a day\r\n  **/\r\n  function setBtcPriceProvider(address btcProviderAddress) public;\r\n\r\n  /**\r\n  * @dev Gets the BTCPriceProviderAddress\r\n  * @return btcPriceProvider blocks there are in a day\r\n  **/\r\n  function getBtcPriceProvider() public view returns(address);\r\n\r\n  /**\r\n   * @dev Gets how many blocks there are in a day\r\n   * @return blocks there are in a day\r\n   */\r\n  function getDayBlockSpan() public view returns(uint256);\r\n\r\n\r\n  /******STATE MACHINE*********/\r\n\r\n  enum States {\r\n    // State 0\r\n    Liquidated,\r\n    // State 1\r\n    BProDiscount,\r\n    // State 2\r\n    BelowCobj,\r\n    // State 3\r\n    AboveCobj\r\n  }\r\n\r\n/**\r\n  * @dev Subtract the btc amount passed by parameter to the total Bitcoin Amount\r\n  * @param btcAmount Amount that will be subtract to rbtcInSystem\r\n  */\r\n  function subtractRbtcFromSystem(uint256 btcAmount) public;\r\n  /**\r\n  * @dev btcAmount Add the btc amount passed by parameter to the total Bitcoin Amount\r\n  * @param btcAmount Amount that will be added to rbtcInSystem\r\n  */\r\n  function addToRbtcInSystem(uint256 btcAmount) public;\r\n  /**\r\n    @dev All BPros in circulation\r\n   */\r\n  function bproTotalSupply() public view returns(uint256);\r\n\r\n  /**\r\n    @dev All docs in circulation\r\n   */\r\n  function docTotalSupply() public view returns(uint256);\r\n  /**\r\n    @dev Target coverage for complete system\r\n   */\r\n  function cobj() public view returns(uint256);\r\n\r\n  /**\r\n    * @dev Amount of Bitcoins in the system excluding\r\n    * BTCx values and interests holdings\r\n    */\r\n  function collateralRbtcInSystem() public view returns(uint256);\r\n\r\n  /** @dev GLOBAL Coverage\r\n    * @return coverage [using mocPrecision]\r\n    */\r\n  function globalCoverage() public view returns(uint256);\r\n  /**\r\n  * @dev BUCKET lockedBitcoin\r\n  * @param bucket Name of the bucket used\r\n  * @return lockedBitcoin amount [using reservePrecision]\r\n  */\r\n  function lockedBitcoin(bytes32 bucket) public view returns(uint256);\r\n\r\n  /**\r\n  * @dev Gets RBTC in BitPro within specified bucket\r\n  * @param bucket Name of the bucket used\r\n  * @return Bitcoin amount of BitPro in Bucket [using reservePrecision]\r\n  */\r\n  function getRbtcInBitPro(bytes32 bucket) public view returns(uint256);\r\n\r\n  /**\r\n  * @dev Gets the RBTC in the contract that not corresponds\r\n    to Doc collateral\r\n  * @return RBTC remainder [using reservePrecision]\r\n  */\r\n  function getRbtcRemainder() public view returns(uint256);\r\n\r\n  /**\r\n  * @dev BUCKET Coverage\r\n  * @param bucket Name of the bucket used\r\n  * @return coverage [using coveragePrecision]\r\n  */\r\n  function coverage(bytes32 bucket) public view returns(uint256);\r\n    /**\r\n  * @dev Abundance ratio, receives tha amount of doc to use the value of doc0 and Doc total supply\r\n  * @return abundance ratio [using mocPrecision]\r\n  */\r\n  function abundanceRatio(uint256 doc0) public view returns(uint256);\r\n\r\n  /**\r\n  * @dev Relation between docs in bucket 0 and Doc total supply\r\n  * @return abundance ratio [using mocPrecision]\r\n  */\r\n  function currentAbundanceRatio() public view returns(uint256);\r\n  /**\r\n  * @dev BUCKET Leverage\r\n  * @param bucket Name of the bucket used\r\n  * @return coverage [using mocPrecision]\r\n  */\r\n  function leverage(bytes32 bucket) public view returns(uint256);\r\n\r\n  /**\r\n  * @dev GLOBAL maxDoc\r\n  * @return abundance ratio [using mocPrecision]\r\n  */\r\n  function globalMaxDoc() public view returns(uint256);\r\n\r\n  /**\r\n  * @return amount of docs in bucket 0, that can be redeemed outside of settlement [using mocPrecision]\r\n  */\r\n  function freeDoc() public view returns(uint256);\r\n\r\n  /**\r\n  * @dev BUCKET maxDoc\r\n  * @return abundance ratio [using mocPrecision]\r\n  */\r\n  function maxDoc(bytes32 bucket) public view returns(uint256);\r\n  /**\r\n  * @dev GLOBAL maxBPro\r\n  * @return maxBPro for redeem [using reservePrecision]\r\n  */\r\n  function globalMaxBPro() public view returns(uint256);\r\n\r\n  /**\r\n  * @dev ABSOLUTE maxDoc\r\n  * @return maxDoc to issue [using mocPrecision]\r\n  */\r\n  function absoluteMaxDoc() public view returns(uint256);\r\n\r\n  /** @dev BUCKET maxBPro to redeem / mint\r\n      @param bucket Name of the bucket used\r\n    * @return maxBPro for redeem [using mocPrecision]\r\n    */\r\n  function maxBPro(bytes32 bucket) public view returns(uint256);\r\n\r\n /**\r\n  * @dev GLOBAL max bprox to mint\r\n  * @param bucket Name of the bucket used\r\n  * @return maxBProx [using reservePrecision]\r\n  */\r\n  function maxBProx(bytes32 bucket) public view returns(uint256);\r\n\r\n  /**\r\n  * @dev GLOBAL max bprox to mint\r\n  * @param bucket Name of the bucket used\r\n  * @return maxBProx BTC value to mint [using reservePrecision]\r\n  */\r\n  function maxBProxBtcValue(bytes32 bucket) public view returns(uint256);\r\n\r\n  /** @dev ABSOLUTE maxBPro\r\n  * @return maxDoc to issue [using mocPrecision]\r\n  */\r\n  function absoluteMaxBPro() public view returns(uint256);\r\n  /**\r\n  * @dev DISCOUNT maxBPro\r\n  * @return maxBPro for mint with discount [using mocPrecision]\r\n  */\r\n  function maxBProWithDiscount() public view returns(uint256);\r\n\r\n  /**\r\n  * @dev GLOBAL lockedBitcoin\r\n  * @return lockedBitcoin amount [using reservePrecision]\r\n  */\r\n  function globalLockedBitcoin() public view returns(uint256);\r\n\r\n  /**\r\n  * @dev BTC price of BPro\r\n  * @return the BPro Tec Price [using reservePrecision]\r\n  */\r\n  function bproTecPrice() public view returns(uint256);\r\n\r\n  /**\r\n  * @dev BUCKET BTC price of BPro\r\n  * @param bucket Name of the bucket used\r\n  * @return the BPro Tec Price [using reservePrecision]\r\n  */\r\n  function bucketBProTecPrice(bytes32 bucket) public view returns(uint256);\r\n  /**\r\n  * @dev BTC price of BPro with spot discount applied\r\n  * @return the BPro Tec Price [using reservePrecision]\r\n  */\r\n  function bproDiscountPrice() public view returns(uint256);\r\n\r\n  /**\r\n  * @dev BPro USD PRICE\r\n  * @return the BPro USD Price [using mocPrecision]\r\n  */\r\n  function bproUsdPrice() public view returns(uint256);\r\n /**\r\n  * @dev GLOBAL max bprox to mint\r\n  * @param bucket Name of the bucket used\r\n  * @return max BPro allowed to be spent to mint BProx [using reservePrecision]\r\n  **/\r\n  function maxBProxBProValue(bytes32 bucket) public view returns(uint256);\r\n\r\n  /**\r\n  * @dev BUCKET BProx price in BPro\r\n  * @param bucket Name of the bucket used\r\n  * @return BProx BPro Price [using mocPrecision]\r\n  */\r\n  function bproxBProPrice(bytes32 bucket) public view returns(uint256);\r\n\r\n  /**\r\n  * @dev GLOBAL BTC Discount rate to apply to BProPrice.\r\n  * @return BPro discount rate [using DISCOUNT_PRECISION].\r\n   */\r\n  function bproSpotDiscountRate() public view returns(uint256);\r\n\r\n  /**\r\n    @dev Calculates the number of days to next settlement based dayBlockSpan\r\n   */\r\n  function daysToSettlement() public view returns(uint256);\r\n  /**\r\n    @dev Number of blocks to settlement\r\n   */\r\n  function blocksToSettlement() public view returns(uint256);\r\n  /**\r\n   * @dev Verifies if forced liquidation is reached checking if globalCoverage <= liquidation (currently 1.04)\r\n   * @return true if liquidation state is reached, false otherwise\r\n   */\r\n  function isLiquidationReached() public view returns(bool);\r\n\r\n  /**\r\n    @dev Returns the price to use for doc redeem in a liquidation event\r\n   */\r\n  function getLiquidationPrice() public view returns(uint256);\r\n\r\n  function getBucketNBTC(bytes32 bucket) public view returns(uint256);\r\n\r\n  function getBucketNBPro(bytes32 bucket) public view returns(uint256);\r\n  function getBucketNDoc(bytes32 bucket) public view returns(uint256);\r\n\r\n  function getBucketCobj(bytes32 bucket) public view returns(uint256);\r\n  function getInrateBag(bytes32 bucket) public view returns(uint256);\r\n  /**********************\r\n    BTC PRICE PROVIDER\r\n   *********************/\r\n\r\n  function getBcons() public view returns(uint256);\r\n  function getBitcoinPrice() public view returns(uint256);\r\n\r\n\r\n  function calculateBitcoinMovingAverage() public;\r\n\r\n  /**\r\n   * @dev return the value of the liq threshold configuration param\r\n   * @return liq threshold, currently 1.04\r\n   */\r\n  function getLiq() public view returns(uint256);\r\n\r\n  /**\r\n   * @dev sets the value of the liq threshold configuration param\r\n   * @param _liq liquidation threshold\r\n   */\r\n  function setLiq(uint _liq) public;\r\n\r\n  /**\r\n   * @dev return the value of the utpdu threshold configuration param\r\n   * @return utpdu Universal TPro discount sales coverage threshold\r\n   */\r\n  function getUtpdu() public view returns(uint256);\r\n\r\n  /**\r\n   * @dev sets the value of the utpdu threshold configuration param\r\n   * @param _utpdu Universal TPro discount sales coverage threshold\r\n   */\r\n  function setUtpdu(uint _utpdu) public;\r\n\r\n  /**\r\n   * @dev returns the relation between DOC and dollar. By default it is 1.\r\n   * @return peg relation between DOC and dollar\r\n   */\r\n  function getPeg() public view returns(uint256);\r\n\r\n  /**\r\n   * @dev sets the relation between DOC and dollar. By default it is 1.\r\n   * @param _peg relation between DOC and dollar\r\n   */\r\n  function setPeg(uint _peg) public;\r\n\r\n  function nextState() public;\r\n}\r\n\r\n\r\n/**\r\n * @dev Defines special constants to use along all the MoC System\r\n */\r\ncontract MoCConstants {\r\n  bytes32 constant public BUCKET_X2 = \"X2\";\r\n  bytes32 constant public BUCKET_C0 = \"C0\";\r\n}\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(address) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts/base/MoCWhitelist.sol\r\n\r\npragma solidity 0.5.8;\r\n\r\n/**\r\n  @dev Provides access control between all MoC Contracts\r\n */\r\ncontract MoCWhitelist {\r\n  mapping(address => bool) whitelist;\r\n\r\n  /**\r\n   * @dev Check if an account is whitelisted\r\n   * @return Bool\r\n   */\r\n  function isWhitelisted(address account)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(account != address(0), \"Account must not be 0x0\");\r\n    return whitelist[account];\r\n  }\r\n\r\n  /**\r\n   * @dev Add account to whitelist\r\n   */\r\n  function add(address account) internal {\r\n    require(account != address(0), \"Account must not be 0x0\");\r\n    require(!isWhitelisted(account), \"Account not allowed to add accounts into white list\");\r\n    whitelist[account] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Remove account to whitelist\r\n   */\r\n  function remove(address account) internal {\r\n    require(account != address(0), \"Account must not be 0x0\");\r\n    require(isWhitelisted(account), \"Account is not allowed to remove address from the white list\");\r\n\r\n    whitelist[account] = false;\r\n  }\r\n\r\n  // Leave a gap betweeen inherited contracts variables in order to be\r\n  // able to add more variables in them later\r\n  uint256[50] private upgradeGap;\r\n}\r\n\r\n\r\n\r\n/**\r\n  @dev Provides access control between all MoC Contracts\r\n */\r\ncontract MoCConnector is MoCWhitelist, Initializable {\r\n  // References\r\n  address payable public moc;\r\n  address public docToken;\r\n  address public bproToken;\r\n  address public bproxManager;\r\n  address public mocState;\r\n  address public mocConverter;\r\n  address public mocSettlement;\r\n  address public mocExchange;\r\n  address public mocInrate;\r\n  address public mocBurnout;\r\n\r\n  bool internal initialized;\r\n\r\n  function initialize(\r\n    address payable mocAddress,\r\n    address docAddress,\r\n    address bproAddress,\r\n    address bproxAddress,\r\n    address stateAddress,\r\n    address settlementAddress,\r\n    address converterAddress,\r\n    address exchangeAddress,\r\n    address inrateAddress,\r\n    address burnoutBookAddress\r\n  ) public initializer {\r\n    moc = mocAddress;\r\n    docToken = docAddress;\r\n    bproToken = bproAddress;\r\n    bproxManager = bproxAddress;\r\n    mocState = stateAddress;\r\n    mocSettlement = settlementAddress;\r\n    mocConverter = converterAddress;\r\n    mocExchange = exchangeAddress;\r\n    mocInrate = inrateAddress;\r\n    mocBurnout = burnoutBookAddress;\r\n\r\n    // Add to Whitelist\r\n    add(mocAddress);\r\n    add(docAddress);\r\n    add(bproAddress);\r\n    add(bproxAddress);\r\n    add(stateAddress);\r\n    add(settlementAddress);\r\n    add(converterAddress);\r\n    add(exchangeAddress);\r\n    add(inrateAddress);\r\n    add(burnoutBookAddress);\r\n  }\r\n\r\n  // Leave a gap betweeen inherited contracts variables in order to be\r\n  // able to add more variables in them later\r\n  uint256[50] private upgradeGap;\r\n}\r\n\r\n/**\r\n  @dev General usefull modifiers and functions\r\n */\r\ncontract MoCBase is MoCConstants, Initializable {\r\n  // Contracts\r\n  MoCConnector public connector;\r\n\r\n  bool internal initialized;\r\n\r\n  function initializeBase(address connectorAddress) internal initializer {\r\n    connector = MoCConnector(connectorAddress);\r\n  }\r\n\r\n  modifier onlyWhitelisted(address account) {\r\n    require(connector.isWhitelisted(account), \"Address is not whitelisted\");\r\n    _;\r\n  }\r\n\r\n  // Leave a gap betweeen inherited contracts variables in order to be\r\n  // able to add more variables in them later\r\n  uint256[50] private upgradeGap;\r\n}\r\n\r\n\r\nlibrary MoCHelperLib {\r\n\r\n  struct MocLibConfig {\r\n    uint256 reservePrecision;\r\n    uint256 dayPrecision;\r\n    uint256 mocPrecision;\r\n  }\r\n\r\n  using SafeMath for uint256;\r\n\r\n  uint256 constant UINT256_MAX = ~uint256(0);\r\n\r\n  /**\r\n    Calculates average interest using integral function\r\n\r\n    @dev T =  Rate = a * (x ** b) + c\r\n    @param tMax maxInterestRate [using mocPrecision]\r\n    @param power factor [using noPrecision]\r\n    @param tMin minInterestRate C0 doc amount [using mocPrecision]\r\n    @param abRat1 initial abundance ratio [using mocPrecision]\r\n    @param abRat2 final abundance ratio [using mocPrecision]\r\n    @return average interest rate [using mocPrecision]\r\n  */\r\n  function inrateAvg(MocLibConfig storage config, uint256 tMax, uint256 power, uint256 tMin, uint256 abRat1, uint256 abRat2)\r\n  public view returns(uint256) {\r\n    require(tMax > tMin, \"Max inrate should be bigger than Min inrate\");\r\n    uint256 abRat1Comp = config.mocPrecision.sub(abRat1);\r\n    uint256 abRat2Comp = config.mocPrecision.sub(abRat2);\r\n\r\n    if (abRat1 == abRat2) {\r\n      return potential(config, tMax, power, tMin, abRat1Comp);\r\n    }\r\n    else if (abRat2 < abRat1) {\r\n      return avgInt(config, tMax, power, tMin, abRat1Comp, abRat2Comp);\r\n    }\r\n    else {\r\n      return avgInt(config, tMax, power, tMin, abRat2Comp, abRat1Comp);\r\n    }\r\n  }\r\n\r\n  /**\r\n    Calculates spot interest rate that BProx owners should pay to BPro owners\r\n\r\n    @dev Rate = tMax * (abRatio ** power) + tMin\r\n    @param tMin min interest rate [using mocPrecision]\r\n    @param power power to use in the formula [using NoPrecision]\r\n    @param tMax max interest rate [using mocPrecision]\r\n    @param abRatio bucket C0  abundance Ratio [using mocPrecision]\r\n\r\n   */\r\n  function spotInrate(\r\n    MocLibConfig storage config, uint256 tMax, uint256 power, uint256 tMin, uint256 abRatio\r\n  ) public view returns(uint256) {\r\n    uint256 abRatioComp = config.mocPrecision.sub(abRatio);\r\n\r\n    return potential(config, tMax, power, tMin, abRatioComp);\r\n  }\r\n\r\n  /**\r\n    Calculates potential interests function with given parameters\r\n\r\n    @dev Rate = a * (x ** b) + c\r\n    @param a maxInterestRate [using mocPrecision]\r\n    @param b factor [using NoPrecision]\r\n    @param c minInterestRate C0 doc amount [using mocPrecision]\r\n    @param value global doc amount [using mocPrecision]\r\n  */\r\n  function potential(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value)\r\n  public view returns(uint256) {\r\n    // value ** b\r\n    // [MOC] ** [] = [MOC]\r\n    uint256 aux1 = pow(value, b, config.mocPrecision);\r\n    // (a * aux1) + c\r\n    // [MOC] [MOC] / [MOC] + [MOC] = [MOC]\r\n    return a.mul(aux1).div(config.mocPrecision).add(c);\r\n  }\r\n\r\n  /**\r\n    Calculates average of the integral function\r\n\r\n    @dev T = (\r\n              (c * xf + ((a * (xf ** (b + 1))) / (b + 1))) -\r\n              (c * xi + ((a * (xi ** (b + 1))) / (b + 1)))\r\n             ) / (xf - xi)\r\n    @param a maxInterestRate [using mocPrecision]\r\n    @param b factor [using NoPrecision]\r\n    @param c minInterestRate C0 doc amount [using mocPrecision]\r\n    @param value1 value to put in the function [using mocPrecision]\r\n    @param value2 value to put in the function [using mocPrecision]\r\n    @return average interest rate [using mocPrecision]\r\n   */\r\n  function avgInt(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value1, uint256 value2)\r\n  public view returns(uint256) {\r\n    // value2 - value1\r\n    // [MOC]\r\n    uint256 diff = value2.sub(value1);\r\n    // ((c * (1 - value1) + ((a * ((1 - value1) ** (b + 1))) / (b + 1)))\r\n    uint256 intV1 = integral(config, a, b, c, value1);\r\n    // ((c * (1 - value2) + ((a * ((1 - value2) ** (b + 1))) / (b + 1)))\r\n    uint256 intV2 = integral(config,  a, b, c, value2);\r\n    // (secOp - first) / diff\r\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\r\n    return intV2.sub(intV1).div(diff);\r\n  }\r\n\r\n  /**\r\n    Calculates integral of the exponential function\r\n\r\n    @dev T = c * (value) + (a * value ** (b + 1)) / (b + 1))\r\n    @param a maxInterestRate [using mocPrecision]\r\n    @param b factor [using NoPrecision]\r\n    @param c minInterestRate C0 doc amount [using mocPrecision]\r\n    @param value value to put in the function [using mocPrecision]\r\n    @return integration result [using mocPrecision]\r\n\r\n   */\r\n  function integral(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value)\r\n  public view returns(uint256) {\r\n    // b + 1\r\n    // [NONE]\r\n    uint256 b2 = b.add(1);\r\n    // c * value\r\n    // [MOC][MOC]\r\n    uint256 firstOp = c.mul(value);\r\n    // [MOC]\r\n    uint256 pow = pow(value, b2, config.mocPrecision);\r\n    // (a * value ** b2) / b2)\r\n    // [MOC][MOC]\r\n    uint256 secOp = a.mul(pow).div(b2);\r\n    // (firstOp + secOp)\r\n    // [MOC][MOC] + [MOC][MOC] = [MOC][MOC]\r\n    return firstOp.add(secOp);\r\n  }\r\n\r\n  /**\r\n  * @dev Relation between docs in bucket 0 and Doc total supply\r\n  * @param doc0 doc count in bucket 0 [using mocPrecision]\r\n  * @param doct total doc supply [using mocPrecision]\r\n  * @return abundance ratio [using mocPrecision]\r\n  */\r\n  function abundanceRatio(MocLibConfig storage config, uint256 doc0, uint256 doct)\r\n  public view returns(uint256) {\r\n    if (doct == 0) {\r\n      return config.mocPrecision;\r\n    }\r\n    // [DOC] [MOC] / [DOC] = [MOC]\r\n    return doc0.mul(config.mocPrecision).div(doct);\r\n  }\r\n\r\n  /**\r\n    SpotDiscountRate = TPD * (utpdu - cob) / (uptdu -liq)\r\n\r\n    @dev Returns the Ratio to apply to BPro Price in discount situations\r\n    @param bproLiqDiscountRate Discount rate applied at Liquidation level coverage [using mocPrecision]\r\n    @param liq Liquidation coverage threshold [using mocPrecision]\r\n    @param utpdu Discount coverage threshold [using mocPrecision]\r\n    @param cov Actual global Coverage threshold [using mocPrecision]\r\n    @return Spot discount rate [using mocPrecision]\r\n  **/\r\n  function bproSpotDiscountRate(\r\n    MocLibConfig storage libConfig, uint256 bproLiqDiscountRate,\r\n    uint256 liq, uint256 utpdu, uint256 cov\r\n  ) public view returns(uint256) {\r\n    require(bproLiqDiscountRate < libConfig.mocPrecision, \"Discount rate should be lower than 1\");\r\n\r\n    if (cov >= utpdu) {\r\n      return 0;\r\n    }\r\n\r\n    // utpdu - liq\r\n    // [MOC] - [MOC] = [MOC]\r\n    uint256 utpduLiqDiff = utpdu.sub(liq);\r\n\r\n    // utpdu - cov\r\n    // [MOC] - [MOC] = [MOC]\r\n    uint256 utpduCovDiff = utpdu.sub(cov);\r\n\r\n    // TPD * utpduCovDiff / utpduLiqDiff\r\n    // [MOC] * [MOC] / [MOC] = [MOC]\r\n    return bproLiqDiscountRate.mul(utpduCovDiff).div(utpduLiqDiff);\r\n  }\r\n\r\n  /**\r\n    MaxBProWithDiscount = (uTPDU * nDOC * PEG - (nBTC * B)) / (TPusd * TPD)\r\n\r\n    @dev Max amount of BPro to available with discount\r\n    @param nB Total BTC amount [using reservePrecision]\r\n    @param nDoc DOC amount [using mocPrecision]\r\n    @param utpdu Discount coverage threshold [using mocPrecision]\r\n    @param peg peg value\r\n    @param btcPrice BTC price [using mocPrecision]\r\n    @param bproUsdPrice bproUsdPrice [using mocPrecision]\r\n    @param spotDiscount spot discount [using mocPrecision]\r\n    @return Total BPro amount [using mocPrecision]\r\n  **/\r\n  function maxBProWithDiscount(\r\n    MocLibConfig storage libConfig, uint256 nB, uint256 nDoc, uint256 utpdu,\r\n    uint256 peg, uint256 btcPrice, uint256 bproUsdPrice, uint256 spotDiscount\r\n  ) public view returns(uint256)  {\r\n    require(spotDiscount < libConfig.mocPrecision, \"Discount Rate should be lower than 1\");\r\n\r\n    if (spotDiscount == 0) {\r\n      return 0;\r\n    }\r\n\r\n    // nBTC * B\r\n    // [RES] * [MOC] / [RES] = [MOC]\r\n    uint256 nbUsdValue = nB.mul(btcPrice).div(libConfig.reservePrecision);\r\n\r\n    // (TPusd * (1 - TPD))\r\n    // [MOC] * [MOC] / [MOC] = [MOC]\r\n    uint256 bproDiscountPrice = bproUsdPrice.mul(libConfig.mocPrecision.sub(spotDiscount))\r\n      .div(libConfig.mocPrecision);\r\n\r\n    return maxBProWithDiscountAux(libConfig, nbUsdValue, nDoc, utpdu, peg, bproDiscountPrice);\r\n  }\r\n\r\n  /**\r\n    MaxBProWithDiscount = (uTPDU * nDOC * PEG - (nBTC * B)) / (TPusd * TPD)\r\n\r\n    @dev Max amount of BPro to available with discount\r\n    @param nbUsdValue Total amount of BTC in USD [using mocPrecision]\r\n    @param nDoc DOC amount [using mocPrecision]\r\n    @param utpdu Discount coverage threshold [using mocPrecision]\r\n    @param bproDiscountPrice bproUsdPrice with discount applied [using mocPrecision]\r\n    @param peg peg value\r\n    @return Total BPro amount [using mocPrecision]\r\n  **/\r\n  function maxBProWithDiscountAux(\r\n    MocLibConfig storage libConfig, uint256 nbUsdValue, uint256 nDoc,\r\n    uint256 utpdu, uint256 peg, uint256 bproDiscountPrice\r\n  ) internal view returns(uint256) {\r\n\r\n    // uTPDU * nDOC * PEG\r\n    // [MOC] * [MOC] / [MOC] = [MOC]\r\n    uint256 coverageUSDAmount = utpdu.mul(nDoc).mul(peg).div(libConfig.mocPrecision);\r\n\r\n    // This case only occurs with Coverage below 1\r\n    if (coverageUSDAmount <= nbUsdValue) {\r\n      return 0;\r\n    }\r\n\r\n    // ([MOC] - [MOC]) * [RES] / [MOC] = [RES]\r\n    return coverageUSDAmount.sub(nbUsdValue).mul(libConfig.reservePrecision).div(bproDiscountPrice);\r\n  }\r\n\r\n  /**\r\n\r\n    @dev Calculates Locked bitcoin\r\n    @param btcPrice BTC price [using mocPrecision]\r\n    @param nDoc Docs amount [using mocPrecision]\r\n    @param peg peg value\r\n    @return Locked bitcoin [using reservePrecision]\r\n  **/\r\n  function lockedBitcoin(\r\n    MocLibConfig storage libConfig, uint256 btcPrice, uint256 nDoc, uint256 peg\r\n  ) public view returns(uint256) {\r\n    return nDoc.mul(peg).mul(libConfig.reservePrecision).div(btcPrice);\r\n  }\r\n\r\n  /**\r\n    @dev Calculates price at liquidation event as a relation between the doc total supply\r\n    and the amount of RBTC available to distribute\r\n    @param rbtcAmount RBTC to distribute [using reservePrecision]\r\n    @param nDoc Docs amount [using mocPrecision]\r\n    @return Price at liquidation event [using mocPrecision]\r\n  **/\r\n  function liquidationPrice(MocLibConfig storage libConfig, uint256 rbtcAmount, uint256 nDoc)\r\n  public view returns(uint256) {\r\n    // [MOC] * [RES] / [RES]\r\n    return nDoc.mul(libConfig.reservePrecision).div(rbtcAmount);\r\n  }\r\n\r\n  /**\r\n   TPbtc = (nB-LB) / nTP\r\n\r\n    @dev Calculates BPro BTC price\r\n    @param nB Total BTC amount [using reservePrecision]\r\n    @param lb Locked bitcoins amount [using reservePrecision]\r\n    @param nTP BPro amount [using mocPrecision]\r\n    @return BPro BTC price [using reservePrecision]\r\n  **/\r\n  function bproTecPrice(MocLibConfig storage libConfig, uint256 nB, uint256 lb, uint256 nTP)\r\n    public view returns(uint256) {\r\n    // Liquidation happens before this condition turns true\r\n    if (nB < lb) {\r\n      return 0;\r\n    }\r\n\r\n    if (nTP == 0) {\r\n      return libConfig.mocPrecision;\r\n    }\r\n    // ([RES] - [RES]) * [MOC] / [MOC]\r\n    return nB.sub(lb).mul(libConfig.mocPrecision).div(nTP);\r\n  }\r\n\r\n  /**\r\n   BProxInBPro = bproxTecPrice / bproPrice\r\n\r\n    @dev Calculates BPro BTC price\r\n    @param bproxTecPrice BProx BTC price [using reservePrecision]\r\n    @param bproPrice Trog BTC price [using reservePrecision]\r\n    @return BProx price in BPro [using mocPrecision]\r\n  **/\r\n  function bproxBProPrice(\r\n    MocLibConfig storage libConfig, uint256 bproxTecPrice, uint256 bproPrice\r\n  ) public view returns(uint256) {\r\n    // [RES] * [MOC] / [RES] = [MOC]\r\n    return bproxTecPrice.mul(libConfig.mocPrecision).div(bproPrice);\r\n  }\r\n\r\n  /**\r\n   TPbtc = (price)* (1 - discountRate)\r\n\r\n    @dev Returns a new value with the discountRate applied\r\n    @param price Price [using SomePrecision]\r\n    @param discountRate Discount rate to apply [using mocPrecision]\r\n    @return Price with discount applied [using SomePrecision]\r\n  **/\r\n  function applyDiscountRate(MocLibConfig storage libConfig, uint256 price, uint256 discountRate)\r\n    public view returns(uint256) {\r\n\r\n    uint256 discountCoeff = libConfig.mocPrecision.sub(discountRate);\r\n\r\n    return price.mul(discountCoeff).div(libConfig.mocPrecision);\r\n  }\r\n\r\n  /**\r\n   TPbtc = price * interestRate\r\n\r\n    @dev Returns the amount of interest to pay\r\n    @param value Cost to apply interest [using SomePrecision]\r\n    @param interestRate Interest rate to apply [using mocPrecision]\r\n    @return Interest cost based on the value and interestRate [using SomePrecision]\r\n  **/\r\n  function getInterestCost(MocLibConfig storage libConfig, uint256 value, uint256 interestRate)\r\n    public view returns(uint256) {\r\n    // [ORIGIN] * [MOC] / [MOC] = [ORIGIN]\r\n    return value.mul(interestRate).div(libConfig.mocPrecision);\r\n  }\r\n\r\n  /**\r\n    Coverage = nB / LB\r\n\r\n    @dev Calculates Coverage\r\n    @param nB Total BTC amount [using reservePrecision]\r\n    @param lB Locked bitcoins amount [using reservePrecision]\r\n    @return Coverage [using mocPrecision]\r\n  **/\r\n  function coverage(MocLibConfig storage libConfig, uint256 nB, uint256 lB) public view\r\n    returns(uint256) {\r\n    if (lB == 0) {\r\n      return UINT256_MAX;\r\n    }\r\n\r\n    return nB.mul(libConfig.mocPrecision).div(lB);\r\n  }\r\n\r\n /**\r\n  Leverage = C / (C - 1)\r\n\r\n    @dev Calculates Leverage\r\n    @param cov Coverage [using mocPrecision]\r\n    @return Leverage [using mocPrecision]\r\n  **/\r\n  function leverageFromCoverage(MocLibConfig storage libConfig, uint256 cov)\r\n  public view returns(uint256) {\r\n    if (cov == UINT256_MAX) {\r\n      return libConfig.mocPrecision;\r\n    }\r\n\r\n    if (cov <= libConfig.mocPrecision) {\r\n      return UINT256_MAX;\r\n    }\r\n\r\n    return cov.mul(libConfig.mocPrecision).div(cov.sub(libConfig.mocPrecision));\r\n  }\r\n\r\n /**\r\n  Leverage = nB / (nB - lB)\r\n\r\n    @dev Calculates Leverage\r\n    @param nB Total BTC amount [using reservePrecision]\r\n    @param lB Locked bitcoins amount [using reservePrecision]\r\n    @return Leverage [using mocPrecision]\r\n  **/\r\n  function leverage(MocLibConfig storage libConfig, uint256 nB,uint256 lB)\r\n  public view returns(uint256) {\r\n    if (lB == 0) {\r\n      return libConfig.mocPrecision;\r\n    }\r\n\r\n    if (nB <= lB) {\r\n      return UINT256_MAX;\r\n    }\r\n\r\n    return nB.mul(libConfig.mocPrecision).div(nB.sub(lB));\r\n  }\r\n\r\n  /**\r\n    @dev Price in BTC of the amount of Docs\r\n    @param amount Total BTC amount [using reservePrecision]\r\n    @param btcPrice BTC price [using mocPrecision]\r\n    @return Total value [using reservePrecision]\r\n  **/\r\n  function docsBtcValue(\r\n    MocLibConfig storage libConfig, uint256 amount,uint256 peg, uint256 btcPrice\r\n  ) public view returns(uint256) {\r\n    require(btcPrice > 0,\"Bitcoin price should be more than zero\");\r\n    require(libConfig.reservePrecision > 0, \"Precision should be more than zero\");\r\n    //Total = amount / satoshi price\r\n    //Total = amount / (btcPrice / precision)\r\n    // [RES] * [MOC] / [MOC]\r\n    uint256 docBtcTotal = amount.mul(libConfig.mocPrecision).mul(peg).div(btcPrice);\r\n\r\n    return docBtcTotal;\r\n  }\r\n\r\n /**\r\n    @dev Price in RBTC of the amount of BPros\r\n    @param bproAmount amount of BPro [using mocPrecision]\r\n    @param bproBtcPrice BPro price in RBTC [using reservePrecision]\r\n    @return Total value [using reservePrecision]\r\n  **/\r\n  function bproBtcValue(MocLibConfig storage libConfig, uint256 bproAmount, uint256 bproBtcPrice)\r\n    public view returns(uint256) {\r\n    require(libConfig.reservePrecision > 0, \"Precision should be more than zero\");\r\n\r\n    // [MOC] * [RES] / [MOC] =  [RES]\r\n    uint256 bproBtcTotal = bproAmount.mul(bproBtcPrice).div(libConfig.mocPrecision);\r\n\r\n    return bproBtcTotal;\r\n  }\r\n\r\n  /**\r\n   MaxDoc = ((nB*B)-(Cobj*B/Bcons*nDoc*PEG))/(PEG*(Cobj*B/BCons-1))\r\n\r\n    @dev Max amount of Docs to issue\r\n    @param nB Total BTC amount [using reservePrecision]\r\n    @param cobj Target Coverage [using mocPrecision]\r\n    @param nDoc DOC amount [using mocPrecision]\r\n    @param peg peg value\r\n    @param btcPrice BTC price [using mocPrecision]\r\n    @param bCons BTC conservative price [using mocPrecision]\r\n    @return Total Docs amount [using mocPrecision]\r\n  **/\r\n  function maxDoc(\r\n    MocLibConfig storage libConfig, uint256 nB,\r\n    uint256 cobj, uint256 nDoc, uint256 peg, uint256 btcPrice, uint256 bCons\r\n  ) public view returns(uint256) {\r\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\r\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\r\n\r\n    // If cobj is less than 1, just return zero\r\n    if (cobj < libConfig.mocPrecision)\r\n      return 0;\r\n\r\n    // Cobj * B / BCons\r\n    // [MOC] * [MOC] / [MOC] = [MOC]\r\n    uint256 adjCobj = cobj.mul(btcPrice).div(bCons);\r\n\r\n    return maxDocAux(libConfig, nB, adjCobj, nDoc, peg, btcPrice);\r\n  }\r\n\r\n  function maxDocAux(MocLibConfig storage libConfig, uint256 nB, uint256 adjCobj, uint256 nDoc, uint256 peg, uint256 btcPrice)\r\n  internal view returns(uint256) {\r\n    // (nB*B)\r\n    // [RES] [MOC] [MOC] / [RES] = [MOC] [MOC]\r\n    uint256 firstOperand = nB.mul(btcPrice).mul(libConfig.mocPrecision).div(libConfig.reservePrecision);\r\n    // (adjCobj*nDoc*PEG)\r\n    // [MOC] [MOC]\r\n    uint256 secOperand = adjCobj.mul(nDoc).mul(peg);\r\n    // (PEG*(adjCobj-1)\r\n    // [MOC]\r\n    uint256 denom = adjCobj.sub(libConfig.mocPrecision).mul(peg);\r\n\r\n    if (firstOperand <= secOperand)\r\n      return 0;\r\n\r\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\r\n    return (firstOperand.sub(secOperand)).div(denom);\r\n  }\r\n\r\n  /**\r\n   MaxBPro = ((nB*B)-(Cobj*nDoc*PEG))/TPusd\r\n\r\n    @dev Max amount of BPro to redeem\r\n    @param nB Total BTC amount [using reservePrecision]\r\n    @param cobj Target Coverage [using mocPrecision]\r\n    @param nDoc Target Coverage [using mocPrecision]\r\n    @param peg peg value\r\n    @param btcPrice BTC price [using mocPrecision]\r\n    @param bCons BTC conservative price [using mocPrecision]\r\n    @param bproUsdPrice bproUsdPrice [using mocPrecision]\r\n    @return Total BPro amount [using mocPrecision]\r\n  **/\r\n  function maxBPro(\r\n    MocLibConfig storage libConfig, uint256 nB, uint256 cobj,\r\n    uint256 nDoc, uint256 peg, uint256 btcPrice, uint256 bCons, uint256 bproUsdPrice\r\n  ) public view returns(uint256) {\r\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\r\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\r\n\r\n    // Cobj * btcPrice / BCons\r\n    // [MOC] * [MOC] / [MOC] = [MOC]\r\n    uint256 adjCobj = cobj.mul(btcPrice).div(bCons);\r\n    // (nB * btcPrice)\r\n    // [RES] * [MOC] * [MOC] / [RES] = [MOC] [MOC]\r\n    uint256 firstOperand = nB.mul(btcPrice)\r\n      .mul(libConfig.mocPrecision)\r\n      .div(libConfig.reservePrecision);\r\n    // (adjCobj * nDoc * PEG)\r\n    // [MOC] * [MOC]\r\n    uint256 secOperand = adjCobj.mul(nDoc).mul(peg);\r\n\r\n    if (firstOperand <= secOperand)\r\n      return 0;\r\n\r\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\r\n    return (firstOperand.sub(secOperand)).div(bproUsdPrice);\r\n  }\r\n\r\n  /**\r\n    @dev Calculates the total BTC price of the amount of BPros\r\n    @param amount Amount of BPro [using mocPrecision]\r\n    @param bproPrice BPro BTC Price [using reservePrecision]\r\n    @return BPro total value in BTC [using reservePrecision]\r\n  **/\r\n  function totalBProInBtc(\r\n    MocLibConfig storage libConfig, uint256 amount, uint256 bproPrice\r\n  ) public view returns(uint256) {\r\n    // [RES] * [MOC] / [MOC] = [RES]\r\n    return bproPrice.mul(amount).div(libConfig.mocPrecision);\r\n  }\r\n\r\n  /**\r\n    @dev Calculates the equivalent in Docs of the btcAmount\r\n    @param btcAmount BTC  amount [using reservePrecision]\r\n    @param btcPrice BTC price [using mocPrecision]\r\n    @return Equivalent Doc amount [using mocPrecision]\r\n  **/\r\n  function maxDocsWithBtc(\r\n    MocLibConfig storage libConfig, uint256 btcAmount, uint256 btcPrice\r\n  ) public view returns(uint256) {\r\n    // [RES] * [MOC] / [RES] = [MOC]\r\n    return btcAmount.mul(btcPrice).div(libConfig.reservePrecision);\r\n  }\r\n\r\n  /**\r\n    @dev Calculates the equivalent in BPro of the btcAmount\r\n    @param btcAmount BTC amount [using reservePrecision]\r\n    @param bproPrice BPro BTC price [using reservePrecision]\r\n    @return Equivalent Bpro amount [using mocPrecision]\r\n  **/\r\n  function maxBProWithBtc(\r\n    MocLibConfig storage libConfig, uint256 btcAmount, uint256 bproPrice\r\n  ) public view returns(uint256) {\r\n    if (bproPrice == 0) {\r\n      return 0;\r\n    }\r\n\r\n    // [RES] * [MOC] / [RES]\r\n    return btcAmount.mul(libConfig.mocPrecision).div(bproPrice);\r\n  }\r\n\r\n  /**\r\n    toMove = btcAmount * (lev - 1)\r\n\r\n    @dev Calculates the Btc amount to move from C0 bucket to\r\n    an L bucket when a BProx minting occurs\r\n    @param btcAmount Total BTC amount [using reservePrecision]\r\n    @param lev L bucket leverage [using mocPrecision]\r\n    @return btc to move [using reservePrecision]\r\n    **/\r\n  function bucketTransferAmount(\r\n    MocLibConfig storage libConfig, uint256 btcAmount, uint256 lev\r\n  ) public view returns(uint256) {\r\n    require(lev > libConfig.mocPrecision, \"Leverage should be more than 1\");\r\n\r\n    if (lev == UINT256_MAX || btcAmount == 0) {\r\n      return 0;\r\n    }\r\n\r\n    // (lev-1)\r\n    uint256 levSubOne = lev.sub(libConfig.mocPrecision);\r\n\r\n    // Intentionally avaoid SafeMath\r\n    // [RES] * [MOC]\r\n    uint256 transferAmount = btcAmount * levSubOne;\r\n    if (transferAmount / btcAmount != levSubOne)\r\n      return 0;\r\n\r\n    // [RES] * [MOC] / [MOC] = [RES]\r\n    return transferAmount.div(libConfig.mocPrecision);\r\n  }\r\n\r\n   /**\r\n    Maxbprox = nDOC/ (PEG*B*(lev-1))\r\n\r\n    @dev Max amount of BTC allowed to be used to mint bprox\r\n    @param nDoc number of DOC [using mocPrecision]\r\n    @param peg peg value\r\n    @param btcPrice BTC price [using mocPrecision]\r\n    @param lev leverage [using mocPrecision]\r\n    @return Max bprox BTC value [using reservePrecision]\r\n  **/\r\n  function maxBProxBtcValue(\r\n    MocLibConfig storage libConfig, uint256 nDoc, uint256 peg, uint256 btcPrice, uint256 lev\r\n  ) public view returns(uint256)  {\r\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\r\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\r\n\r\n    if (lev <= libConfig.mocPrecision) {\r\n      return 0;\r\n    }\r\n    // (lev-1)\r\n    // [MOC]\r\n    uint256 levSubOne = lev.sub(libConfig.mocPrecision);\r\n\r\n    // PEG * BtcPrice\r\n    // [MOC]\r\n    uint256 pegTimesPrice = peg.mul(btcPrice);\r\n\r\n    // This intentionally avoid using safeMath to handle overflow case\r\n    // PEG * BtcPrice * (lev - 1)\r\n    // [MOC] * [MOC]\r\n    uint256 dividend = pegTimesPrice * levSubOne;\r\n\r\n    if (dividend / pegTimesPrice != levSubOne)\r\n      return 0; // INFINIT dividend means 0\r\n\r\n    // nDoc adjusted with precisions\r\n    // [MOC] [RES]\r\n    uint256 divider = nDoc.mul(libConfig.reservePrecision);\r\n\r\n    // [MOC] [RES] [MOC] / [MOC] [MOC]\r\n    return divider.mul(libConfig.mocPrecision).div(dividend);\r\n  }\r\n\r\n  /**\r\n    @dev Rounding product adapted from DSMath but with custom precision\r\n    @param x Multiplicand\r\n    @param y Multiplier\r\n    @return Product\r\n  **/\r\n  function mulr(uint x, uint y, uint256 precision) internal pure returns (uint z) {\r\n    return x.mul(y).add(precision.div(2)).div(precision);\r\n  }\r\n\r\n  /**\r\n    @dev Potentiation by squaring adapted from DSMath but with custom precision\r\n    @param x Base\r\n    @param n Exponent\r\n    @return power\r\n  **/\r\n  function pow(uint256 x, uint256 n, uint256 precision) internal pure returns (uint z) {\r\n    uint256 x2 = x;\r\n    z = n % 2 != 0 ? x : precision;\r\n\r\n    for (n /= 2; n != 0; n /= 2) {\r\n      x2 = mulr(x2, x2, precision);\r\n\r\n      if (n % 2 != 0) {\r\n        z = mulr(z, x2, precision);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/**\r\n  @dev Interface with MocHelperLib\r\n */\r\ncontract MoCLibConnection {\r\n  using MoCHelperLib for MoCHelperLib.MocLibConfig;\r\n  MoCHelperLib.MocLibConfig internal mocLibConfig;\r\n\r\n  /*\r\n  * Precision getters\r\n  */\r\n  function getMocPrecision() public view returns(uint256) {\r\n    return mocLibConfig.mocPrecision;\r\n  }\r\n\r\n  function getReservePrecision() public view returns(uint256) {\r\n    return mocLibConfig.reservePrecision;\r\n  }\r\n\r\n  function getDayPrecision() public view returns(uint256) {\r\n    return mocLibConfig.dayPrecision;\r\n  }\r\n\r\n  function initializePrecisions() internal {\r\n    mocLibConfig = MoCHelperLib.MocLibConfig({\r\n      reservePrecision: 10 ** 18,\r\n      mocPrecision: 10 ** 18,\r\n      dayPrecision: 1\r\n    });\r\n  }\r\n\r\n  // Leave a gap betweeen inherited contracts variables in order to be\r\n  // able to add more variables in them later\r\n  uint256[50] private upgradeGap;\r\n}\r\n\r\ncontract MoCConverter is MoCBase, MoCLibConnection {\r\n  MoCState internal mocState;\r\n\r\n  function initialize(address connectorAddress) public initializer {\r\n    initializePrecisions();\r\n    initializeBase(connectorAddress);\r\n    mocState = MoCState(connector.mocState());\r\n  }\r\n\r\n  /**\r\n  * @dev BTC equivalent for the amount of bpros given\r\n  * @param amount Amount of BPro to calculate the total price\r\n  * @return total BTC Price of the amount BPros [using reservePrecision]\r\n  */\r\n  function bproToBtc(uint256 amount) public view returns(uint256) {\r\n    uint256 tecPrice = mocState.bproTecPrice();\r\n\r\n    return mocLibConfig.totalBProInBtc(amount, tecPrice);\r\n  }\r\n\r\n  function btcToBPro(uint256 btcAmount) public view returns(uint256) {\r\n    return mocLibConfig.maxBProWithBtc(btcAmount, mocState.bproTecPrice());\r\n  }\r\n\r\n  /**\r\n  * @dev BTC equivalent for the amount of bpro given applying the spotDiscountRate\r\n  * @param amount amount of BPro [using mocPrecision]\r\n   */\r\n  function bproDiscToBtc(uint256 amount) public view returns(uint256) {\r\n    uint256 discountRate = mocState.bproSpotDiscountRate();\r\n    uint256 totalBtcValue = bproToBtc(amount);\r\n\r\n    return mocLibConfig.applyDiscountRate(totalBtcValue, discountRate);\r\n  }\r\n\r\n  function btcToBProDisc(uint256 btcAmount) public view returns(uint256) {\r\n    return mocLibConfig.maxBProWithBtc(btcAmount, mocState.bproDiscountPrice());\r\n  }\r\n\r\n  function docsToBtc(uint256 docAmount) public view returns(uint256) {\r\n    return mocLibConfig.docsBtcValue(docAmount, mocState.peg(), mocState.getBitcoinPrice());\r\n  }\r\n\r\n  function docsToBtcWithPrice(uint256 docAmount, uint256 btcPrice) public view returns(uint256) {\r\n    return mocLibConfig.docsBtcValue(docAmount, mocState.peg(), btcPrice);\r\n  }\r\n\r\n  function btcToDoc(uint256 btcAmount) public view returns(uint256) {\r\n    return mocLibConfig.maxDocsWithBtc(btcAmount, mocState.getBitcoinPrice());\r\n  }\r\n\r\n  function bproxToBtc(uint256 bproxAmount, bytes32 bucket) public view returns(uint256) {\r\n    return mocLibConfig.bproBtcValue(bproxAmount, mocState.bucketBProTecPrice(bucket));\r\n  }\r\n\r\n  function btcToBProx(uint256 btcAmount, bytes32 bucket) public view returns(uint256) {\r\n    return mocLibConfig.maxBProWithBtc(btcAmount, mocState.bucketBProTecPrice(bucket));\r\n  }\r\n\r\n  function btcToBProWithPrice(uint256 btcAmount, uint256 price) public view returns(uint256) {\r\n    return mocLibConfig.maxBProWithBtc(btcAmount, price);\r\n  }\r\n\r\n  function bproToBtcWithPrice(uint256 bproAmount, uint256 bproPrice) public view returns(uint256) {\r\n    return mocLibConfig.bproBtcValue(bproAmount, bproPrice);\r\n  }\r\n  // Leave a gap betweeen inherited contracts variables in order to be\r\n  // able to add more variables in them later\r\n  uint256[50] private upgradeGap;\r\n}\r\n",
  "imports": [
    {
      "name": "MoCConverter.sol",
      "contents": "pragma solidity 0.5.8;\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ncontract MoCState  {\r\n\r\n\r\n  // This is the current state.\r\n  States public state;\r\n\r\n  event StateTransition(States newState);\r\n  event PriceProviderUpdated(address oldAddress, address newAddress);\r\n\r\n  // One Day based on 15 seconds blocks\r\n  uint256 public dayBlockSpan;\r\n  // Relation between DOC and dollar\r\n  uint256 public peg;\r\n  // BPro max discount rate\r\n  // Reflects the discount spot rate at Liquidation level\r\n  uint256 public bproMaxDiscountRate;\r\n  // Liquidation limit\r\n  // [using mocPrecision]\r\n  uint256 public liq;\r\n  // BPro with discount limit\r\n  // [using mocPrecision]\r\n  uint256 public utpdu;\r\n  // Complete amount of Bitcoin in the system\r\n  // this represents basically MoC Balance\r\n  uint256 public rbtcInSystem;\r\n  // Price to use at doc redemption at\r\n  // liquidation event\r\n  uint256 public liquidationPrice;\r\n\r\n  function initialize(\r\n    address connectorAddress,\r\n    address _governor,\r\n    address _btcPriceProvider,\r\n    uint256 _liq,\r\n    uint256 _utpdu,\r\n    uint256 _maxDiscRate,\r\n    uint256 _dayBlockSpan,\r\n    uint256 _ema,\r\n    uint256 _smoothFactor,\r\n    uint256 _emaBlockSpan\r\n  ) public;\r\n\r\n  /**\r\n  * @param rate Discount rate at liquidation level [using mocPrecision]\r\n  **/\r\n  function setMaxDiscountRate(uint256 rate) public;\r\n\r\n    /**\r\n   * @dev return the value of the BPro max discount rate configuration param\r\n   * @return bproMaxDiscountRate BPro max discount rate\r\n   */\r\n  function getMaxDiscountRate() public view returns(uint256);\r\n\r\n  /**\r\n  * @dev Defines how many blocks there are in a day\r\n  * @param blockSpan blocks there are in a day\r\n  **/\r\n  function setDayBlockSpan(uint256 blockSpan) public;\r\n\r\n  /**\r\n  * @dev Sets a new BTCProvider contract\r\n  * @param btcProviderAddress blocks there are in a day\r\n  **/\r\n  function setBtcPriceProvider(address btcProviderAddress) public;\r\n\r\n  /**\r\n  * @dev Gets the BTCPriceProviderAddress\r\n  * @return btcPriceProvider blocks there are in a day\r\n  **/\r\n  function getBtcPriceProvider() public view returns(address);\r\n\r\n  /**\r\n   * @dev Gets how many blocks there are in a day\r\n   * @return blocks there are in a day\r\n   */\r\n  function getDayBlockSpan() public view returns(uint256);\r\n\r\n\r\n  /******STATE MACHINE*********/\r\n\r\n  enum States {\r\n    // State 0\r\n    Liquidated,\r\n    // State 1\r\n    BProDiscount,\r\n    // State 2\r\n    BelowCobj,\r\n    // State 3\r\n    AboveCobj\r\n  }\r\n\r\n/**\r\n  * @dev Subtract the btc amount passed by parameter to the total Bitcoin Amount\r\n  * @param btcAmount Amount that will be subtract to rbtcInSystem\r\n  */\r\n  function subtractRbtcFromSystem(uint256 btcAmount) public;\r\n  /**\r\n  * @dev btcAmount Add the btc amount passed by parameter to the total Bitcoin Amount\r\n  * @param btcAmount Amount that will be added to rbtcInSystem\r\n  */\r\n  function addToRbtcInSystem(uint256 btcAmount) public;\r\n  /**\r\n    @dev All BPros in circulation\r\n   */\r\n  function bproTotalSupply() public view returns(uint256);\r\n\r\n  /**\r\n    @dev All docs in circulation\r\n   */\r\n  function docTotalSupply() public view returns(uint256);\r\n  /**\r\n    @dev Target coverage for complete system\r\n   */\r\n  function cobj() public view returns(uint256);\r\n\r\n  /**\r\n    * @dev Amount of Bitcoins in the system excluding\r\n    * BTCx values and interests holdings\r\n    */\r\n  function collateralRbtcInSystem() public view returns(uint256);\r\n\r\n  /** @dev GLOBAL Coverage\r\n    * @return coverage [using mocPrecision]\r\n    */\r\n  function globalCoverage() public view returns(uint256);\r\n  /**\r\n  * @dev BUCKET lockedBitcoin\r\n  * @param bucket Name of the bucket used\r\n  * @return lockedBitcoin amount [using reservePrecision]\r\n  */\r\n  function lockedBitcoin(bytes32 bucket) public view returns(uint256);\r\n\r\n  /**\r\n  * @dev Gets RBTC in BitPro within specified bucket\r\n  * @param bucket Name of the bucket used\r\n  * @return Bitcoin amount of BitPro in Bucket [using reservePrecision]\r\n  */\r\n  function getRbtcInBitPro(bytes32 bucket) public view returns(uint256);\r\n\r\n  /**\r\n  * @dev Gets the RBTC in the contract that not corresponds\r\n    to Doc collateral\r\n  * @return RBTC remainder [using reservePrecision]\r\n  */\r\n  function getRbtcRemainder() public view returns(uint256);\r\n\r\n  /**\r\n  * @dev BUCKET Coverage\r\n  * @param bucket Name of the bucket used\r\n  * @return coverage [using coveragePrecision]\r\n  */\r\n  function coverage(bytes32 bucket) public view returns(uint256);\r\n    /**\r\n  * @dev Abundance ratio, receives tha amount of doc to use the value of doc0 and Doc total supply\r\n  * @return abundance ratio [using mocPrecision]\r\n  */\r\n  function abundanceRatio(uint256 doc0) public view returns(uint256);\r\n\r\n  /**\r\n  * @dev Relation between docs in bucket 0 and Doc total supply\r\n  * @return abundance ratio [using mocPrecision]\r\n  */\r\n  function currentAbundanceRatio() public view returns(uint256);\r\n  /**\r\n  * @dev BUCKET Leverage\r\n  * @param bucket Name of the bucket used\r\n  * @return coverage [using mocPrecision]\r\n  */\r\n  function leverage(bytes32 bucket) public view returns(uint256);\r\n\r\n  /**\r\n  * @dev GLOBAL maxDoc\r\n  * @return abundance ratio [using mocPrecision]\r\n  */\r\n  function globalMaxDoc() public view returns(uint256);\r\n\r\n  /**\r\n  * @return amount of docs in bucket 0, that can be redeemed outside of settlement [using mocPrecision]\r\n  */\r\n  function freeDoc() public view returns(uint256);\r\n\r\n  /**\r\n  * @dev BUCKET maxDoc\r\n  * @return abundance ratio [using mocPrecision]\r\n  */\r\n  function maxDoc(bytes32 bucket) public view returns(uint256);\r\n  /**\r\n  * @dev GLOBAL maxBPro\r\n  * @return maxBPro for redeem [using reservePrecision]\r\n  */\r\n  function globalMaxBPro() public view returns(uint256);\r\n\r\n  /**\r\n  * @dev ABSOLUTE maxDoc\r\n  * @return maxDoc to issue [using mocPrecision]\r\n  */\r\n  function absoluteMaxDoc() public view returns(uint256);\r\n\r\n  /** @dev BUCKET maxBPro to redeem / mint\r\n      @param bucket Name of the bucket used\r\n    * @return maxBPro for redeem [using mocPrecision]\r\n    */\r\n  function maxBPro(bytes32 bucket) public view returns(uint256);\r\n\r\n /**\r\n  * @dev GLOBAL max bprox to mint\r\n  * @param bucket Name of the bucket used\r\n  * @return maxBProx [using reservePrecision]\r\n  */\r\n  function maxBProx(bytes32 bucket) public view returns(uint256);\r\n\r\n  /**\r\n  * @dev GLOBAL max bprox to mint\r\n  * @param bucket Name of the bucket used\r\n  * @return maxBProx BTC value to mint [using reservePrecision]\r\n  */\r\n  function maxBProxBtcValue(bytes32 bucket) public view returns(uint256);\r\n\r\n  /** @dev ABSOLUTE maxBPro\r\n  * @return maxDoc to issue [using mocPrecision]\r\n  */\r\n  function absoluteMaxBPro() public view returns(uint256);\r\n  /**\r\n  * @dev DISCOUNT maxBPro\r\n  * @return maxBPro for mint with discount [using mocPrecision]\r\n  */\r\n  function maxBProWithDiscount() public view returns(uint256);\r\n\r\n  /**\r\n  * @dev GLOBAL lockedBitcoin\r\n  * @return lockedBitcoin amount [using reservePrecision]\r\n  */\r\n  function globalLockedBitcoin() public view returns(uint256);\r\n\r\n  /**\r\n  * @dev BTC price of BPro\r\n  * @return the BPro Tec Price [using reservePrecision]\r\n  */\r\n  function bproTecPrice() public view returns(uint256);\r\n\r\n  /**\r\n  * @dev BUCKET BTC price of BPro\r\n  * @param bucket Name of the bucket used\r\n  * @return the BPro Tec Price [using reservePrecision]\r\n  */\r\n  function bucketBProTecPrice(bytes32 bucket) public view returns(uint256);\r\n  /**\r\n  * @dev BTC price of BPro with spot discount applied\r\n  * @return the BPro Tec Price [using reservePrecision]\r\n  */\r\n  function bproDiscountPrice() public view returns(uint256);\r\n\r\n  /**\r\n  * @dev BPro USD PRICE\r\n  * @return the BPro USD Price [using mocPrecision]\r\n  */\r\n  function bproUsdPrice() public view returns(uint256);\r\n /**\r\n  * @dev GLOBAL max bprox to mint\r\n  * @param bucket Name of the bucket used\r\n  * @return max BPro allowed to be spent to mint BProx [using reservePrecision]\r\n  **/\r\n  function maxBProxBProValue(bytes32 bucket) public view returns(uint256);\r\n\r\n  /**\r\n  * @dev BUCKET BProx price in BPro\r\n  * @param bucket Name of the bucket used\r\n  * @return BProx BPro Price [using mocPrecision]\r\n  */\r\n  function bproxBProPrice(bytes32 bucket) public view returns(uint256);\r\n\r\n  /**\r\n  * @dev GLOBAL BTC Discount rate to apply to BProPrice.\r\n  * @return BPro discount rate [using DISCOUNT_PRECISION].\r\n   */\r\n  function bproSpotDiscountRate() public view returns(uint256);\r\n\r\n  /**\r\n    @dev Calculates the number of days to next settlement based dayBlockSpan\r\n   */\r\n  function daysToSettlement() public view returns(uint256);\r\n  /**\r\n    @dev Number of blocks to settlement\r\n   */\r\n  function blocksToSettlement() public view returns(uint256);\r\n  /**\r\n   * @dev Verifies if forced liquidation is reached checking if globalCoverage <= liquidation (currently 1.04)\r\n   * @return true if liquidation state is reached, false otherwise\r\n   */\r\n  function isLiquidationReached() public view returns(bool);\r\n\r\n  /**\r\n    @dev Returns the price to use for doc redeem in a liquidation event\r\n   */\r\n  function getLiquidationPrice() public view returns(uint256);\r\n\r\n  function getBucketNBTC(bytes32 bucket) public view returns(uint256);\r\n\r\n  function getBucketNBPro(bytes32 bucket) public view returns(uint256);\r\n  function getBucketNDoc(bytes32 bucket) public view returns(uint256);\r\n\r\n  function getBucketCobj(bytes32 bucket) public view returns(uint256);\r\n  function getInrateBag(bytes32 bucket) public view returns(uint256);\r\n  /**********************\r\n    BTC PRICE PROVIDER\r\n   *********************/\r\n\r\n  function getBcons() public view returns(uint256);\r\n  function getBitcoinPrice() public view returns(uint256);\r\n\r\n\r\n  function calculateBitcoinMovingAverage() public;\r\n\r\n  /**\r\n   * @dev return the value of the liq threshold configuration param\r\n   * @return liq threshold, currently 1.04\r\n   */\r\n  function getLiq() public view returns(uint256);\r\n\r\n  /**\r\n   * @dev sets the value of the liq threshold configuration param\r\n   * @param _liq liquidation threshold\r\n   */\r\n  function setLiq(uint _liq) public;\r\n\r\n  /**\r\n   * @dev return the value of the utpdu threshold configuration param\r\n   * @return utpdu Universal TPro discount sales coverage threshold\r\n   */\r\n  function getUtpdu() public view returns(uint256);\r\n\r\n  /**\r\n   * @dev sets the value of the utpdu threshold configuration param\r\n   * @param _utpdu Universal TPro discount sales coverage threshold\r\n   */\r\n  function setUtpdu(uint _utpdu) public;\r\n\r\n  /**\r\n   * @dev returns the relation between DOC and dollar. By default it is 1.\r\n   * @return peg relation between DOC and dollar\r\n   */\r\n  function getPeg() public view returns(uint256);\r\n\r\n  /**\r\n   * @dev sets the relation between DOC and dollar. By default it is 1.\r\n   * @param _peg relation between DOC and dollar\r\n   */\r\n  function setPeg(uint _peg) public;\r\n\r\n  function nextState() public;\r\n}\r\n\r\n\r\n/**\r\n * @dev Defines special constants to use along all the MoC System\r\n */\r\ncontract MoCConstants {\r\n  bytes32 constant public BUCKET_X2 = \"X2\";\r\n  bytes32 constant public BUCKET_C0 = \"C0\";\r\n}\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(address) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts/base/MoCWhitelist.sol\r\n\r\npragma solidity 0.5.8;\r\n\r\n/**\r\n  @dev Provides access control between all MoC Contracts\r\n */\r\ncontract MoCWhitelist {\r\n  mapping(address => bool) whitelist;\r\n\r\n  /**\r\n   * @dev Check if an account is whitelisted\r\n   * @return Bool\r\n   */\r\n  function isWhitelisted(address account)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(account != address(0), \"Account must not be 0x0\");\r\n    return whitelist[account];\r\n  }\r\n\r\n  /**\r\n   * @dev Add account to whitelist\r\n   */\r\n  function add(address account) internal {\r\n    require(account != address(0), \"Account must not be 0x0\");\r\n    require(!isWhitelisted(account), \"Account not allowed to add accounts into white list\");\r\n    whitelist[account] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Remove account to whitelist\r\n   */\r\n  function remove(address account) internal {\r\n    require(account != address(0), \"Account must not be 0x0\");\r\n    require(isWhitelisted(account), \"Account is not allowed to remove address from the white list\");\r\n\r\n    whitelist[account] = false;\r\n  }\r\n\r\n  // Leave a gap betweeen inherited contracts variables in order to be\r\n  // able to add more variables in them later\r\n  uint256[50] private upgradeGap;\r\n}\r\n\r\n\r\n\r\n/**\r\n  @dev Provides access control between all MoC Contracts\r\n */\r\ncontract MoCConnector is MoCWhitelist, Initializable {\r\n  // References\r\n  address payable public moc;\r\n  address public docToken;\r\n  address public bproToken;\r\n  address public bproxManager;\r\n  address public mocState;\r\n  address public mocConverter;\r\n  address public mocSettlement;\r\n  address public mocExchange;\r\n  address public mocInrate;\r\n  address public mocBurnout;\r\n\r\n  bool internal initialized;\r\n\r\n  function initialize(\r\n    address payable mocAddress,\r\n    address docAddress,\r\n    address bproAddress,\r\n    address bproxAddress,\r\n    address stateAddress,\r\n    address settlementAddress,\r\n    address converterAddress,\r\n    address exchangeAddress,\r\n    address inrateAddress,\r\n    address burnoutBookAddress\r\n  ) public initializer {\r\n    moc = mocAddress;\r\n    docToken = docAddress;\r\n    bproToken = bproAddress;\r\n    bproxManager = bproxAddress;\r\n    mocState = stateAddress;\r\n    mocSettlement = settlementAddress;\r\n    mocConverter = converterAddress;\r\n    mocExchange = exchangeAddress;\r\n    mocInrate = inrateAddress;\r\n    mocBurnout = burnoutBookAddress;\r\n\r\n    // Add to Whitelist\r\n    add(mocAddress);\r\n    add(docAddress);\r\n    add(bproAddress);\r\n    add(bproxAddress);\r\n    add(stateAddress);\r\n    add(settlementAddress);\r\n    add(converterAddress);\r\n    add(exchangeAddress);\r\n    add(inrateAddress);\r\n    add(burnoutBookAddress);\r\n  }\r\n\r\n  // Leave a gap betweeen inherited contracts variables in order to be\r\n  // able to add more variables in them later\r\n  uint256[50] private upgradeGap;\r\n}\r\n\r\n/**\r\n  @dev General usefull modifiers and functions\r\n */\r\ncontract MoCBase is MoCConstants, Initializable {\r\n  // Contracts\r\n  MoCConnector public connector;\r\n\r\n  bool internal initialized;\r\n\r\n  function initializeBase(address connectorAddress) internal initializer {\r\n    connector = MoCConnector(connectorAddress);\r\n  }\r\n\r\n  modifier onlyWhitelisted(address account) {\r\n    require(connector.isWhitelisted(account), \"Address is not whitelisted\");\r\n    _;\r\n  }\r\n\r\n  // Leave a gap betweeen inherited contracts variables in order to be\r\n  // able to add more variables in them later\r\n  uint256[50] private upgradeGap;\r\n}\r\n\r\n\r\nlibrary MoCHelperLib {\r\n\r\n  struct MocLibConfig {\r\n    uint256 reservePrecision;\r\n    uint256 dayPrecision;\r\n    uint256 mocPrecision;\r\n  }\r\n\r\n  using SafeMath for uint256;\r\n\r\n  uint256 constant UINT256_MAX = ~uint256(0);\r\n\r\n  /**\r\n    Calculates average interest using integral function\r\n\r\n    @dev T =  Rate = a * (x ** b) + c\r\n    @param tMax maxInterestRate [using mocPrecision]\r\n    @param power factor [using noPrecision]\r\n    @param tMin minInterestRate C0 doc amount [using mocPrecision]\r\n    @param abRat1 initial abundance ratio [using mocPrecision]\r\n    @param abRat2 final abundance ratio [using mocPrecision]\r\n    @return average interest rate [using mocPrecision]\r\n  */\r\n  function inrateAvg(MocLibConfig storage config, uint256 tMax, uint256 power, uint256 tMin, uint256 abRat1, uint256 abRat2)\r\n  public view returns(uint256) {\r\n    require(tMax > tMin, \"Max inrate should be bigger than Min inrate\");\r\n    uint256 abRat1Comp = config.mocPrecision.sub(abRat1);\r\n    uint256 abRat2Comp = config.mocPrecision.sub(abRat2);\r\n\r\n    if (abRat1 == abRat2) {\r\n      return potential(config, tMax, power, tMin, abRat1Comp);\r\n    }\r\n    else if (abRat2 < abRat1) {\r\n      return avgInt(config, tMax, power, tMin, abRat1Comp, abRat2Comp);\r\n    }\r\n    else {\r\n      return avgInt(config, tMax, power, tMin, abRat2Comp, abRat1Comp);\r\n    }\r\n  }\r\n\r\n  /**\r\n    Calculates spot interest rate that BProx owners should pay to BPro owners\r\n\r\n    @dev Rate = tMax * (abRatio ** power) + tMin\r\n    @param tMin min interest rate [using mocPrecision]\r\n    @param power power to use in the formula [using NoPrecision]\r\n    @param tMax max interest rate [using mocPrecision]\r\n    @param abRatio bucket C0  abundance Ratio [using mocPrecision]\r\n\r\n   */\r\n  function spotInrate(\r\n    MocLibConfig storage config, uint256 tMax, uint256 power, uint256 tMin, uint256 abRatio\r\n  ) public view returns(uint256) {\r\n    uint256 abRatioComp = config.mocPrecision.sub(abRatio);\r\n\r\n    return potential(config, tMax, power, tMin, abRatioComp);\r\n  }\r\n\r\n  /**\r\n    Calculates potential interests function with given parameters\r\n\r\n    @dev Rate = a * (x ** b) + c\r\n    @param a maxInterestRate [using mocPrecision]\r\n    @param b factor [using NoPrecision]\r\n    @param c minInterestRate C0 doc amount [using mocPrecision]\r\n    @param value global doc amount [using mocPrecision]\r\n  */\r\n  function potential(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value)\r\n  public view returns(uint256) {\r\n    // value ** b\r\n    // [MOC] ** [] = [MOC]\r\n    uint256 aux1 = pow(value, b, config.mocPrecision);\r\n    // (a * aux1) + c\r\n    // [MOC] [MOC] / [MOC] + [MOC] = [MOC]\r\n    return a.mul(aux1).div(config.mocPrecision).add(c);\r\n  }\r\n\r\n  /**\r\n    Calculates average of the integral function\r\n\r\n    @dev T = (\r\n              (c * xf + ((a * (xf ** (b + 1))) / (b + 1))) -\r\n              (c * xi + ((a * (xi ** (b + 1))) / (b + 1)))\r\n             ) / (xf - xi)\r\n    @param a maxInterestRate [using mocPrecision]\r\n    @param b factor [using NoPrecision]\r\n    @param c minInterestRate C0 doc amount [using mocPrecision]\r\n    @param value1 value to put in the function [using mocPrecision]\r\n    @param value2 value to put in the function [using mocPrecision]\r\n    @return average interest rate [using mocPrecision]\r\n   */\r\n  function avgInt(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value1, uint256 value2)\r\n  public view returns(uint256) {\r\n    // value2 - value1\r\n    // [MOC]\r\n    uint256 diff = value2.sub(value1);\r\n    // ((c * (1 - value1) + ((a * ((1 - value1) ** (b + 1))) / (b + 1)))\r\n    uint256 intV1 = integral(config, a, b, c, value1);\r\n    // ((c * (1 - value2) + ((a * ((1 - value2) ** (b + 1))) / (b + 1)))\r\n    uint256 intV2 = integral(config,  a, b, c, value2);\r\n    // (secOp - first) / diff\r\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\r\n    return intV2.sub(intV1).div(diff);\r\n  }\r\n\r\n  /**\r\n    Calculates integral of the exponential function\r\n\r\n    @dev T = c * (value) + (a * value ** (b + 1)) / (b + 1))\r\n    @param a maxInterestRate [using mocPrecision]\r\n    @param b factor [using NoPrecision]\r\n    @param c minInterestRate C0 doc amount [using mocPrecision]\r\n    @param value value to put in the function [using mocPrecision]\r\n    @return integration result [using mocPrecision]\r\n\r\n   */\r\n  function integral(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value)\r\n  public view returns(uint256) {\r\n    // b + 1\r\n    // [NONE]\r\n    uint256 b2 = b.add(1);\r\n    // c * value\r\n    // [MOC][MOC]\r\n    uint256 firstOp = c.mul(value);\r\n    // [MOC]\r\n    uint256 pow = pow(value, b2, config.mocPrecision);\r\n    // (a * value ** b2) / b2)\r\n    // [MOC][MOC]\r\n    uint256 secOp = a.mul(pow).div(b2);\r\n    // (firstOp + secOp)\r\n    // [MOC][MOC] + [MOC][MOC] = [MOC][MOC]\r\n    return firstOp.add(secOp);\r\n  }\r\n\r\n  /**\r\n  * @dev Relation between docs in bucket 0 and Doc total supply\r\n  * @param doc0 doc count in bucket 0 [using mocPrecision]\r\n  * @param doct total doc supply [using mocPrecision]\r\n  * @return abundance ratio [using mocPrecision]\r\n  */\r\n  function abundanceRatio(MocLibConfig storage config, uint256 doc0, uint256 doct)\r\n  public view returns(uint256) {\r\n    if (doct == 0) {\r\n      return config.mocPrecision;\r\n    }\r\n    // [DOC] [MOC] / [DOC] = [MOC]\r\n    return doc0.mul(config.mocPrecision).div(doct);\r\n  }\r\n\r\n  /**\r\n    SpotDiscountRate = TPD * (utpdu - cob) / (uptdu -liq)\r\n\r\n    @dev Returns the Ratio to apply to BPro Price in discount situations\r\n    @param bproLiqDiscountRate Discount rate applied at Liquidation level coverage [using mocPrecision]\r\n    @param liq Liquidation coverage threshold [using mocPrecision]\r\n    @param utpdu Discount coverage threshold [using mocPrecision]\r\n    @param cov Actual global Coverage threshold [using mocPrecision]\r\n    @return Spot discount rate [using mocPrecision]\r\n  **/\r\n  function bproSpotDiscountRate(\r\n    MocLibConfig storage libConfig, uint256 bproLiqDiscountRate,\r\n    uint256 liq, uint256 utpdu, uint256 cov\r\n  ) public view returns(uint256) {\r\n    require(bproLiqDiscountRate < libConfig.mocPrecision, \"Discount rate should be lower than 1\");\r\n\r\n    if (cov >= utpdu) {\r\n      return 0;\r\n    }\r\n\r\n    // utpdu - liq\r\n    // [MOC] - [MOC] = [MOC]\r\n    uint256 utpduLiqDiff = utpdu.sub(liq);\r\n\r\n    // utpdu - cov\r\n    // [MOC] - [MOC] = [MOC]\r\n    uint256 utpduCovDiff = utpdu.sub(cov);\r\n\r\n    // TPD * utpduCovDiff / utpduLiqDiff\r\n    // [MOC] * [MOC] / [MOC] = [MOC]\r\n    return bproLiqDiscountRate.mul(utpduCovDiff).div(utpduLiqDiff);\r\n  }\r\n\r\n  /**\r\n    MaxBProWithDiscount = (uTPDU * nDOC * PEG - (nBTC * B)) / (TPusd * TPD)\r\n\r\n    @dev Max amount of BPro to available with discount\r\n    @param nB Total BTC amount [using reservePrecision]\r\n    @param nDoc DOC amount [using mocPrecision]\r\n    @param utpdu Discount coverage threshold [using mocPrecision]\r\n    @param peg peg value\r\n    @param btcPrice BTC price [using mocPrecision]\r\n    @param bproUsdPrice bproUsdPrice [using mocPrecision]\r\n    @param spotDiscount spot discount [using mocPrecision]\r\n    @return Total BPro amount [using mocPrecision]\r\n  **/\r\n  function maxBProWithDiscount(\r\n    MocLibConfig storage libConfig, uint256 nB, uint256 nDoc, uint256 utpdu,\r\n    uint256 peg, uint256 btcPrice, uint256 bproUsdPrice, uint256 spotDiscount\r\n  ) public view returns(uint256)  {\r\n    require(spotDiscount < libConfig.mocPrecision, \"Discount Rate should be lower than 1\");\r\n\r\n    if (spotDiscount == 0) {\r\n      return 0;\r\n    }\r\n\r\n    // nBTC * B\r\n    // [RES] * [MOC] / [RES] = [MOC]\r\n    uint256 nbUsdValue = nB.mul(btcPrice).div(libConfig.reservePrecision);\r\n\r\n    // (TPusd * (1 - TPD))\r\n    // [MOC] * [MOC] / [MOC] = [MOC]\r\n    uint256 bproDiscountPrice = bproUsdPrice.mul(libConfig.mocPrecision.sub(spotDiscount))\r\n      .div(libConfig.mocPrecision);\r\n\r\n    return maxBProWithDiscountAux(libConfig, nbUsdValue, nDoc, utpdu, peg, bproDiscountPrice);\r\n  }\r\n\r\n  /**\r\n    MaxBProWithDiscount = (uTPDU * nDOC * PEG - (nBTC * B)) / (TPusd * TPD)\r\n\r\n    @dev Max amount of BPro to available with discount\r\n    @param nbUsdValue Total amount of BTC in USD [using mocPrecision]\r\n    @param nDoc DOC amount [using mocPrecision]\r\n    @param utpdu Discount coverage threshold [using mocPrecision]\r\n    @param bproDiscountPrice bproUsdPrice with discount applied [using mocPrecision]\r\n    @param peg peg value\r\n    @return Total BPro amount [using mocPrecision]\r\n  **/\r\n  function maxBProWithDiscountAux(\r\n    MocLibConfig storage libConfig, uint256 nbUsdValue, uint256 nDoc,\r\n    uint256 utpdu, uint256 peg, uint256 bproDiscountPrice\r\n  ) internal view returns(uint256) {\r\n\r\n    // uTPDU * nDOC * PEG\r\n    // [MOC] * [MOC] / [MOC] = [MOC]\r\n    uint256 coverageUSDAmount = utpdu.mul(nDoc).mul(peg).div(libConfig.mocPrecision);\r\n\r\n    // This case only occurs with Coverage below 1\r\n    if (coverageUSDAmount <= nbUsdValue) {\r\n      return 0;\r\n    }\r\n\r\n    // ([MOC] - [MOC]) * [RES] / [MOC] = [RES]\r\n    return coverageUSDAmount.sub(nbUsdValue).mul(libConfig.reservePrecision).div(bproDiscountPrice);\r\n  }\r\n\r\n  /**\r\n\r\n    @dev Calculates Locked bitcoin\r\n    @param btcPrice BTC price [using mocPrecision]\r\n    @param nDoc Docs amount [using mocPrecision]\r\n    @param peg peg value\r\n    @return Locked bitcoin [using reservePrecision]\r\n  **/\r\n  function lockedBitcoin(\r\n    MocLibConfig storage libConfig, uint256 btcPrice, uint256 nDoc, uint256 peg\r\n  ) public view returns(uint256) {\r\n    return nDoc.mul(peg).mul(libConfig.reservePrecision).div(btcPrice);\r\n  }\r\n\r\n  /**\r\n    @dev Calculates price at liquidation event as a relation between the doc total supply\r\n    and the amount of RBTC available to distribute\r\n    @param rbtcAmount RBTC to distribute [using reservePrecision]\r\n    @param nDoc Docs amount [using mocPrecision]\r\n    @return Price at liquidation event [using mocPrecision]\r\n  **/\r\n  function liquidationPrice(MocLibConfig storage libConfig, uint256 rbtcAmount, uint256 nDoc)\r\n  public view returns(uint256) {\r\n    // [MOC] * [RES] / [RES]\r\n    return nDoc.mul(libConfig.reservePrecision).div(rbtcAmount);\r\n  }\r\n\r\n  /**\r\n   TPbtc = (nB-LB) / nTP\r\n\r\n    @dev Calculates BPro BTC price\r\n    @param nB Total BTC amount [using reservePrecision]\r\n    @param lb Locked bitcoins amount [using reservePrecision]\r\n    @param nTP BPro amount [using mocPrecision]\r\n    @return BPro BTC price [using reservePrecision]\r\n  **/\r\n  function bproTecPrice(MocLibConfig storage libConfig, uint256 nB, uint256 lb, uint256 nTP)\r\n    public view returns(uint256) {\r\n    // Liquidation happens before this condition turns true\r\n    if (nB < lb) {\r\n      return 0;\r\n    }\r\n\r\n    if (nTP == 0) {\r\n      return libConfig.mocPrecision;\r\n    }\r\n    // ([RES] - [RES]) * [MOC] / [MOC]\r\n    return nB.sub(lb).mul(libConfig.mocPrecision).div(nTP);\r\n  }\r\n\r\n  /**\r\n   BProxInBPro = bproxTecPrice / bproPrice\r\n\r\n    @dev Calculates BPro BTC price\r\n    @param bproxTecPrice BProx BTC price [using reservePrecision]\r\n    @param bproPrice Trog BTC price [using reservePrecision]\r\n    @return BProx price in BPro [using mocPrecision]\r\n  **/\r\n  function bproxBProPrice(\r\n    MocLibConfig storage libConfig, uint256 bproxTecPrice, uint256 bproPrice\r\n  ) public view returns(uint256) {\r\n    // [RES] * [MOC] / [RES] = [MOC]\r\n    return bproxTecPrice.mul(libConfig.mocPrecision).div(bproPrice);\r\n  }\r\n\r\n  /**\r\n   TPbtc = (price)* (1 - discountRate)\r\n\r\n    @dev Returns a new value with the discountRate applied\r\n    @param price Price [using SomePrecision]\r\n    @param discountRate Discount rate to apply [using mocPrecision]\r\n    @return Price with discount applied [using SomePrecision]\r\n  **/\r\n  function applyDiscountRate(MocLibConfig storage libConfig, uint256 price, uint256 discountRate)\r\n    public view returns(uint256) {\r\n\r\n    uint256 discountCoeff = libConfig.mocPrecision.sub(discountRate);\r\n\r\n    return price.mul(discountCoeff).div(libConfig.mocPrecision);\r\n  }\r\n\r\n  /**\r\n   TPbtc = price * interestRate\r\n\r\n    @dev Returns the amount of interest to pay\r\n    @param value Cost to apply interest [using SomePrecision]\r\n    @param interestRate Interest rate to apply [using mocPrecision]\r\n    @return Interest cost based on the value and interestRate [using SomePrecision]\r\n  **/\r\n  function getInterestCost(MocLibConfig storage libConfig, uint256 value, uint256 interestRate)\r\n    public view returns(uint256) {\r\n    // [ORIGIN] * [MOC] / [MOC] = [ORIGIN]\r\n    return value.mul(interestRate).div(libConfig.mocPrecision);\r\n  }\r\n\r\n  /**\r\n    Coverage = nB / LB\r\n\r\n    @dev Calculates Coverage\r\n    @param nB Total BTC amount [using reservePrecision]\r\n    @param lB Locked bitcoins amount [using reservePrecision]\r\n    @return Coverage [using mocPrecision]\r\n  **/\r\n  function coverage(MocLibConfig storage libConfig, uint256 nB, uint256 lB) public view\r\n    returns(uint256) {\r\n    if (lB == 0) {\r\n      return UINT256_MAX;\r\n    }\r\n\r\n    return nB.mul(libConfig.mocPrecision).div(lB);\r\n  }\r\n\r\n /**\r\n  Leverage = C / (C - 1)\r\n\r\n    @dev Calculates Leverage\r\n    @param cov Coverage [using mocPrecision]\r\n    @return Leverage [using mocPrecision]\r\n  **/\r\n  function leverageFromCoverage(MocLibConfig storage libConfig, uint256 cov)\r\n  public view returns(uint256) {\r\n    if (cov == UINT256_MAX) {\r\n      return libConfig.mocPrecision;\r\n    }\r\n\r\n    if (cov <= libConfig.mocPrecision) {\r\n      return UINT256_MAX;\r\n    }\r\n\r\n    return cov.mul(libConfig.mocPrecision).div(cov.sub(libConfig.mocPrecision));\r\n  }\r\n\r\n /**\r\n  Leverage = nB / (nB - lB)\r\n\r\n    @dev Calculates Leverage\r\n    @param nB Total BTC amount [using reservePrecision]\r\n    @param lB Locked bitcoins amount [using reservePrecision]\r\n    @return Leverage [using mocPrecision]\r\n  **/\r\n  function leverage(MocLibConfig storage libConfig, uint256 nB,uint256 lB)\r\n  public view returns(uint256) {\r\n    if (lB == 0) {\r\n      return libConfig.mocPrecision;\r\n    }\r\n\r\n    if (nB <= lB) {\r\n      return UINT256_MAX;\r\n    }\r\n\r\n    return nB.mul(libConfig.mocPrecision).div(nB.sub(lB));\r\n  }\r\n\r\n  /**\r\n    @dev Price in BTC of the amount of Docs\r\n    @param amount Total BTC amount [using reservePrecision]\r\n    @param btcPrice BTC price [using mocPrecision]\r\n    @return Total value [using reservePrecision]\r\n  **/\r\n  function docsBtcValue(\r\n    MocLibConfig storage libConfig, uint256 amount,uint256 peg, uint256 btcPrice\r\n  ) public view returns(uint256) {\r\n    require(btcPrice > 0,\"Bitcoin price should be more than zero\");\r\n    require(libConfig.reservePrecision > 0, \"Precision should be more than zero\");\r\n    //Total = amount / satoshi price\r\n    //Total = amount / (btcPrice / precision)\r\n    // [RES] * [MOC] / [MOC]\r\n    uint256 docBtcTotal = amount.mul(libConfig.mocPrecision).mul(peg).div(btcPrice);\r\n\r\n    return docBtcTotal;\r\n  }\r\n\r\n /**\r\n    @dev Price in RBTC of the amount of BPros\r\n    @param bproAmount amount of BPro [using mocPrecision]\r\n    @param bproBtcPrice BPro price in RBTC [using reservePrecision]\r\n    @return Total value [using reservePrecision]\r\n  **/\r\n  function bproBtcValue(MocLibConfig storage libConfig, uint256 bproAmount, uint256 bproBtcPrice)\r\n    public view returns(uint256) {\r\n    require(libConfig.reservePrecision > 0, \"Precision should be more than zero\");\r\n\r\n    // [MOC] * [RES] / [MOC] =  [RES]\r\n    uint256 bproBtcTotal = bproAmount.mul(bproBtcPrice).div(libConfig.mocPrecision);\r\n\r\n    return bproBtcTotal;\r\n  }\r\n\r\n  /**\r\n   MaxDoc = ((nB*B)-(Cobj*B/Bcons*nDoc*PEG))/(PEG*(Cobj*B/BCons-1))\r\n\r\n    @dev Max amount of Docs to issue\r\n    @param nB Total BTC amount [using reservePrecision]\r\n    @param cobj Target Coverage [using mocPrecision]\r\n    @param nDoc DOC amount [using mocPrecision]\r\n    @param peg peg value\r\n    @param btcPrice BTC price [using mocPrecision]\r\n    @param bCons BTC conservative price [using mocPrecision]\r\n    @return Total Docs amount [using mocPrecision]\r\n  **/\r\n  function maxDoc(\r\n    MocLibConfig storage libConfig, uint256 nB,\r\n    uint256 cobj, uint256 nDoc, uint256 peg, uint256 btcPrice, uint256 bCons\r\n  ) public view returns(uint256) {\r\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\r\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\r\n\r\n    // If cobj is less than 1, just return zero\r\n    if (cobj < libConfig.mocPrecision)\r\n      return 0;\r\n\r\n    // Cobj * B / BCons\r\n    // [MOC] * [MOC] / [MOC] = [MOC]\r\n    uint256 adjCobj = cobj.mul(btcPrice).div(bCons);\r\n\r\n    return maxDocAux(libConfig, nB, adjCobj, nDoc, peg, btcPrice);\r\n  }\r\n\r\n  function maxDocAux(MocLibConfig storage libConfig, uint256 nB, uint256 adjCobj, uint256 nDoc, uint256 peg, uint256 btcPrice)\r\n  internal view returns(uint256) {\r\n    // (nB*B)\r\n    // [RES] [MOC] [MOC] / [RES] = [MOC] [MOC]\r\n    uint256 firstOperand = nB.mul(btcPrice).mul(libConfig.mocPrecision).div(libConfig.reservePrecision);\r\n    // (adjCobj*nDoc*PEG)\r\n    // [MOC] [MOC]\r\n    uint256 secOperand = adjCobj.mul(nDoc).mul(peg);\r\n    // (PEG*(adjCobj-1)\r\n    // [MOC]\r\n    uint256 denom = adjCobj.sub(libConfig.mocPrecision).mul(peg);\r\n\r\n    if (firstOperand <= secOperand)\r\n      return 0;\r\n\r\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\r\n    return (firstOperand.sub(secOperand)).div(denom);\r\n  }\r\n\r\n  /**\r\n   MaxBPro = ((nB*B)-(Cobj*nDoc*PEG))/TPusd\r\n\r\n    @dev Max amount of BPro to redeem\r\n    @param nB Total BTC amount [using reservePrecision]\r\n    @param cobj Target Coverage [using mocPrecision]\r\n    @param nDoc Target Coverage [using mocPrecision]\r\n    @param peg peg value\r\n    @param btcPrice BTC price [using mocPrecision]\r\n    @param bCons BTC conservative price [using mocPrecision]\r\n    @param bproUsdPrice bproUsdPrice [using mocPrecision]\r\n    @return Total BPro amount [using mocPrecision]\r\n  **/\r\n  function maxBPro(\r\n    MocLibConfig storage libConfig, uint256 nB, uint256 cobj,\r\n    uint256 nDoc, uint256 peg, uint256 btcPrice, uint256 bCons, uint256 bproUsdPrice\r\n  ) public view returns(uint256) {\r\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\r\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\r\n\r\n    // Cobj * btcPrice / BCons\r\n    // [MOC] * [MOC] / [MOC] = [MOC]\r\n    uint256 adjCobj = cobj.mul(btcPrice).div(bCons);\r\n    // (nB * btcPrice)\r\n    // [RES] * [MOC] * [MOC] / [RES] = [MOC] [MOC]\r\n    uint256 firstOperand = nB.mul(btcPrice)\r\n      .mul(libConfig.mocPrecision)\r\n      .div(libConfig.reservePrecision);\r\n    // (adjCobj * nDoc * PEG)\r\n    // [MOC] * [MOC]\r\n    uint256 secOperand = adjCobj.mul(nDoc).mul(peg);\r\n\r\n    if (firstOperand <= secOperand)\r\n      return 0;\r\n\r\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\r\n    return (firstOperand.sub(secOperand)).div(bproUsdPrice);\r\n  }\r\n\r\n  /**\r\n    @dev Calculates the total BTC price of the amount of BPros\r\n    @param amount Amount of BPro [using mocPrecision]\r\n    @param bproPrice BPro BTC Price [using reservePrecision]\r\n    @return BPro total value in BTC [using reservePrecision]\r\n  **/\r\n  function totalBProInBtc(\r\n    MocLibConfig storage libConfig, uint256 amount, uint256 bproPrice\r\n  ) public view returns(uint256) {\r\n    // [RES] * [MOC] / [MOC] = [RES]\r\n    return bproPrice.mul(amount).div(libConfig.mocPrecision);\r\n  }\r\n\r\n  /**\r\n    @dev Calculates the equivalent in Docs of the btcAmount\r\n    @param btcAmount BTC  amount [using reservePrecision]\r\n    @param btcPrice BTC price [using mocPrecision]\r\n    @return Equivalent Doc amount [using mocPrecision]\r\n  **/\r\n  function maxDocsWithBtc(\r\n    MocLibConfig storage libConfig, uint256 btcAmount, uint256 btcPrice\r\n  ) public view returns(uint256) {\r\n    // [RES] * [MOC] / [RES] = [MOC]\r\n    return btcAmount.mul(btcPrice).div(libConfig.reservePrecision);\r\n  }\r\n\r\n  /**\r\n    @dev Calculates the equivalent in BPro of the btcAmount\r\n    @param btcAmount BTC amount [using reservePrecision]\r\n    @param bproPrice BPro BTC price [using reservePrecision]\r\n    @return Equivalent Bpro amount [using mocPrecision]\r\n  **/\r\n  function maxBProWithBtc(\r\n    MocLibConfig storage libConfig, uint256 btcAmount, uint256 bproPrice\r\n  ) public view returns(uint256) {\r\n    if (bproPrice == 0) {\r\n      return 0;\r\n    }\r\n\r\n    // [RES] * [MOC] / [RES]\r\n    return btcAmount.mul(libConfig.mocPrecision).div(bproPrice);\r\n  }\r\n\r\n  /**\r\n    toMove = btcAmount * (lev - 1)\r\n\r\n    @dev Calculates the Btc amount to move from C0 bucket to\r\n    an L bucket when a BProx minting occurs\r\n    @param btcAmount Total BTC amount [using reservePrecision]\r\n    @param lev L bucket leverage [using mocPrecision]\r\n    @return btc to move [using reservePrecision]\r\n    **/\r\n  function bucketTransferAmount(\r\n    MocLibConfig storage libConfig, uint256 btcAmount, uint256 lev\r\n  ) public view returns(uint256) {\r\n    require(lev > libConfig.mocPrecision, \"Leverage should be more than 1\");\r\n\r\n    if (lev == UINT256_MAX || btcAmount == 0) {\r\n      return 0;\r\n    }\r\n\r\n    // (lev-1)\r\n    uint256 levSubOne = lev.sub(libConfig.mocPrecision);\r\n\r\n    // Intentionally avaoid SafeMath\r\n    // [RES] * [MOC]\r\n    uint256 transferAmount = btcAmount * levSubOne;\r\n    if (transferAmount / btcAmount != levSubOne)\r\n      return 0;\r\n\r\n    // [RES] * [MOC] / [MOC] = [RES]\r\n    return transferAmount.div(libConfig.mocPrecision);\r\n  }\r\n\r\n   /**\r\n    Maxbprox = nDOC/ (PEG*B*(lev-1))\r\n\r\n    @dev Max amount of BTC allowed to be used to mint bprox\r\n    @param nDoc number of DOC [using mocPrecision]\r\n    @param peg peg value\r\n    @param btcPrice BTC price [using mocPrecision]\r\n    @param lev leverage [using mocPrecision]\r\n    @return Max bprox BTC value [using reservePrecision]\r\n  **/\r\n  function maxBProxBtcValue(\r\n    MocLibConfig storage libConfig, uint256 nDoc, uint256 peg, uint256 btcPrice, uint256 lev\r\n  ) public view returns(uint256)  {\r\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\r\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\r\n\r\n    if (lev <= libConfig.mocPrecision) {\r\n      return 0;\r\n    }\r\n    // (lev-1)\r\n    // [MOC]\r\n    uint256 levSubOne = lev.sub(libConfig.mocPrecision);\r\n\r\n    // PEG * BtcPrice\r\n    // [MOC]\r\n    uint256 pegTimesPrice = peg.mul(btcPrice);\r\n\r\n    // This intentionally avoid using safeMath to handle overflow case\r\n    // PEG * BtcPrice * (lev - 1)\r\n    // [MOC] * [MOC]\r\n    uint256 dividend = pegTimesPrice * levSubOne;\r\n\r\n    if (dividend / pegTimesPrice != levSubOne)\r\n      return 0; // INFINIT dividend means 0\r\n\r\n    // nDoc adjusted with precisions\r\n    // [MOC] [RES]\r\n    uint256 divider = nDoc.mul(libConfig.reservePrecision);\r\n\r\n    // [MOC] [RES] [MOC] / [MOC] [MOC]\r\n    return divider.mul(libConfig.mocPrecision).div(dividend);\r\n  }\r\n\r\n  /**\r\n    @dev Rounding product adapted from DSMath but with custom precision\r\n    @param x Multiplicand\r\n    @param y Multiplier\r\n    @return Product\r\n  **/\r\n  function mulr(uint x, uint y, uint256 precision) internal pure returns (uint z) {\r\n    return x.mul(y).add(precision.div(2)).div(precision);\r\n  }\r\n\r\n  /**\r\n    @dev Potentiation by squaring adapted from DSMath but with custom precision\r\n    @param x Base\r\n    @param n Exponent\r\n    @return power\r\n  **/\r\n  function pow(uint256 x, uint256 n, uint256 precision) internal pure returns (uint z) {\r\n    uint256 x2 = x;\r\n    z = n % 2 != 0 ? x : precision;\r\n\r\n    for (n /= 2; n != 0; n /= 2) {\r\n      x2 = mulr(x2, x2, precision);\r\n\r\n      if (n % 2 != 0) {\r\n        z = mulr(z, x2, precision);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/**\r\n  @dev Interface with MocHelperLib\r\n */\r\ncontract MoCLibConnection {\r\n  using MoCHelperLib for MoCHelperLib.MocLibConfig;\r\n  MoCHelperLib.MocLibConfig internal mocLibConfig;\r\n\r\n  /*\r\n  * Precision getters\r\n  */\r\n  function getMocPrecision() public view returns(uint256) {\r\n    return mocLibConfig.mocPrecision;\r\n  }\r\n\r\n  function getReservePrecision() public view returns(uint256) {\r\n    return mocLibConfig.reservePrecision;\r\n  }\r\n\r\n  function getDayPrecision() public view returns(uint256) {\r\n    return mocLibConfig.dayPrecision;\r\n  }\r\n\r\n  function initializePrecisions() internal {\r\n    mocLibConfig = MoCHelperLib.MocLibConfig({\r\n      reservePrecision: 10 ** 18,\r\n      mocPrecision: 10 ** 18,\r\n      dayPrecision: 1\r\n    });\r\n  }\r\n\r\n  // Leave a gap betweeen inherited contracts variables in order to be\r\n  // able to add more variables in them later\r\n  uint256[50] private upgradeGap;\r\n}\r\n\r\ncontract MoCConverter is MoCBase, MoCLibConnection {\r\n  MoCState internal mocState;\r\n\r\n  function initialize(address connectorAddress) public initializer {\r\n    initializePrecisions();\r\n    initializeBase(connectorAddress);\r\n    mocState = MoCState(connector.mocState());\r\n  }\r\n\r\n  /**\r\n  * @dev BTC equivalent for the amount of bpros given\r\n  * @param amount Amount of BPro to calculate the total price\r\n  * @return total BTC Price of the amount BPros [using reservePrecision]\r\n  */\r\n  function bproToBtc(uint256 amount) public view returns(uint256) {\r\n    uint256 tecPrice = mocState.bproTecPrice();\r\n\r\n    return mocLibConfig.totalBProInBtc(amount, tecPrice);\r\n  }\r\n\r\n  function btcToBPro(uint256 btcAmount) public view returns(uint256) {\r\n    return mocLibConfig.maxBProWithBtc(btcAmount, mocState.bproTecPrice());\r\n  }\r\n\r\n  /**\r\n  * @dev BTC equivalent for the amount of bpro given applying the spotDiscountRate\r\n  * @param amount amount of BPro [using mocPrecision]\r\n   */\r\n  function bproDiscToBtc(uint256 amount) public view returns(uint256) {\r\n    uint256 discountRate = mocState.bproSpotDiscountRate();\r\n    uint256 totalBtcValue = bproToBtc(amount);\r\n\r\n    return mocLibConfig.applyDiscountRate(totalBtcValue, discountRate);\r\n  }\r\n\r\n  function btcToBProDisc(uint256 btcAmount) public view returns(uint256) {\r\n    return mocLibConfig.maxBProWithBtc(btcAmount, mocState.bproDiscountPrice());\r\n  }\r\n\r\n  function docsToBtc(uint256 docAmount) public view returns(uint256) {\r\n    return mocLibConfig.docsBtcValue(docAmount, mocState.peg(), mocState.getBitcoinPrice());\r\n  }\r\n\r\n  function docsToBtcWithPrice(uint256 docAmount, uint256 btcPrice) public view returns(uint256) {\r\n    return mocLibConfig.docsBtcValue(docAmount, mocState.peg(), btcPrice);\r\n  }\r\n\r\n  function btcToDoc(uint256 btcAmount) public view returns(uint256) {\r\n    return mocLibConfig.maxDocsWithBtc(btcAmount, mocState.getBitcoinPrice());\r\n  }\r\n\r\n  function bproxToBtc(uint256 bproxAmount, bytes32 bucket) public view returns(uint256) {\r\n    return mocLibConfig.bproBtcValue(bproxAmount, mocState.bucketBProTecPrice(bucket));\r\n  }\r\n\r\n  function btcToBProx(uint256 btcAmount, bytes32 bucket) public view returns(uint256) {\r\n    return mocLibConfig.maxBProWithBtc(btcAmount, mocState.bucketBProTecPrice(bucket));\r\n  }\r\n\r\n  function btcToBProWithPrice(uint256 btcAmount, uint256 price) public view returns(uint256) {\r\n    return mocLibConfig.maxBProWithBtc(btcAmount, price);\r\n  }\r\n\r\n  function bproToBtcWithPrice(uint256 bproAmount, uint256 bproPrice) public view returns(uint256) {\r\n    return mocLibConfig.bproBtcValue(bproAmount, bproPrice);\r\n  }\r\n  // Leave a gap betweeen inherited contracts variables in order to be\r\n  // able to add more variables in them later\r\n  uint256[50] private upgradeGap;\r\n}\r\n",
      "file": "MoCConverter.sol"
    }
  ],
  "libraries": {
    "MoCHelperLib": "0x4e1894debd18b470706a20ac8fe0cc2d9e904218"
  },
  "creationData": {
    "blockHash": "0x04b1e52a1288dba09d496eb605e1bcee9ff9e3dbaaf5a95a935a406457e41a2d",
    "blockNumber": 1764713,
    "transactionHash": "0x1b2bceec801d03712394c86c5830d115122af6a7ae8d8fa44cf352602d91ed1b",
    "timestamp": 1570240959
  }
}