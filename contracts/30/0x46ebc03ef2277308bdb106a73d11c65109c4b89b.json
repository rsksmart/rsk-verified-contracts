{
  "address": "0x46ebc03ef2277308bdb106a73d11c65109c4b89b",
  "net": {
    "id": "30",
    "name": "RSK Mainnet"
  },
  "name": "ContractRegistry",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    }
  },
  "version": "0.4.26+commit.4563c3fc",
  "source": "pragma solidity 0.4.26;\r\n\r\n/*\r\n    Owned contract interface\r\n*/\r\ncontract IOwned {\r\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\r\n    function owner() public view returns (address) {this;}\r\n\r\n    function transferOwnership(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n}\r\n\r\n\r\n/*\r\n    Contract Registry interface\r\n*/\r\ncontract IContractRegistry {\r\n    function addressOf(bytes32 _contractName) public view returns (address);\r\n\r\n    // deprecated, backward compatibility\r\n    function getAddress(bytes32 _contractName) public view returns (address);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n  * @dev Provides support and utilities for contract ownership\r\n*/\r\ncontract Owned is IOwned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    /**\r\n      * @dev triggered when the owner is updated\r\n      *\r\n      * @param _prevOwner previous owner\r\n      * @param _newOwner  new owner\r\n    */\r\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\r\n\r\n    /**\r\n      * @dev initializes a new Owned instance\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        _ownerOnly();\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _ownerOnly() internal view {\r\n        require(msg.sender == owner, \"ERR_ACCESS_DENIED\");\r\n    }\r\n\r\n    /**\r\n      * @dev allows transferring the contract ownership\r\n      * the new owner still needs to accept the transfer\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner, \"ERR_SAME_OWNER\");\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n      * @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner, \"ERR_ACCESS_DENIED\");\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n  * @dev Utilities & Common Modifiers\r\n*/\r\ncontract Utils {\r\n    // verifies that a value is greater than zero\r\n    modifier greaterThanZero(uint256 _value) {\r\n        _greaterThanZero(_value);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _greaterThanZero(uint256 _value) internal pure {\r\n        require(_value > 0, \"ERR_ZERO_VALUE\");\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        _validAddress(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validAddress(address _address) internal pure {\r\n        require(_address != address(0), \"ERR_INVALID_ADDRESS\");\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        _notThis(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _notThis(address _address) internal view {\r\n        require(_address != address(this), \"ERR_ADDRESS_IS_SELF\");\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n  * @dev Contract Registry\r\n  *\r\n  * The contract registry keeps contract addresses by name.\r\n  * The owner can update contract addresses so that a contract name always points to the latest version\r\n  * of the given contract.\r\n  * Other contracts can query the registry to get updated addresses instead of depending on specific\r\n  * addresses.\r\n  *\r\n  * Note that contract names are limited to 32 bytes UTF8 encoded ASCII strings to optimize gas costs\r\n*/\r\ncontract ContractRegistry is IContractRegistry, Owned, Utils {\r\n    struct RegistryItem {\r\n        address contractAddress;    // contract address\r\n        uint256 nameIndex;          // index of the item in the list of contract names\r\n    }\r\n\r\n    mapping (bytes32 => RegistryItem) private items;    // name -> RegistryItem mapping\r\n    string[] public contractNames;                      // list of all registered contract names\r\n\r\n    /**\r\n      * @dev triggered when an address pointed to by a contract name is modified\r\n      *\r\n      * @param _contractName    contract name\r\n      * @param _contractAddress new contract address\r\n    */\r\n    event AddressUpdate(bytes32 indexed _contractName, address _contractAddress);\r\n\r\n    /**\r\n      * @dev returns the number of items in the registry\r\n      *\r\n      * @return number of items\r\n    */\r\n    function itemCount() public view returns (uint256) {\r\n        return contractNames.length;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the address associated with the given contract name\r\n      *\r\n      * @param _contractName    contract name\r\n      *\r\n      * @return contract address\r\n    */\r\n    function addressOf(bytes32 _contractName) public view returns (address) {\r\n        return items[_contractName].contractAddress;\r\n    }\r\n\r\n    /**\r\n      * @dev registers a new address for the contract name in the registry\r\n      *\r\n      * @param _contractName     contract name\r\n      * @param _contractAddress  contract address\r\n    */\r\n    function registerAddress(bytes32 _contractName, address _contractAddress)\r\n        public\r\n        ownerOnly\r\n        validAddress(_contractAddress)\r\n    {\r\n        // validate input\r\n        require(_contractName.length > 0, \"ERR_INVALID_NAME\");\r\n\r\n        // check if any change is needed\r\n        address currentAddress = items[_contractName].contractAddress;\r\n        if (_contractAddress == currentAddress)\r\n            return;\r\n\r\n        if (currentAddress == address(0)) {\r\n            // add the contract name to the name list\r\n            uint256 i = contractNames.push(bytes32ToString(_contractName));\r\n            // update the item's index in the list\r\n            items[_contractName].nameIndex = i - 1;\r\n        }\r\n\r\n        // update the address in the registry\r\n        items[_contractName].contractAddress = _contractAddress;\r\n\r\n        // dispatch the address update event\r\n        emit AddressUpdate(_contractName, _contractAddress);\r\n    }\r\n\r\n    /**\r\n      * @dev removes an existing contract address from the registry\r\n      *\r\n      * @param _contractName contract name\r\n    */\r\n    function unregisterAddress(bytes32 _contractName) public ownerOnly {\r\n        // validate input\r\n        require(_contractName.length > 0, \"ERR_INVALID_NAME\");\r\n        require(items[_contractName].contractAddress != address(0), \"ERR_INVALID_NAME\");\r\n\r\n        // remove the address from the registry\r\n        items[_contractName].contractAddress = address(0);\r\n\r\n        // if there are multiple items in the registry, move the last element to the deleted element's position\r\n        // and modify last element's registryItem.nameIndex in the items collection to point to the right position in contractNames\r\n        if (contractNames.length > 1) {\r\n            string memory lastContractNameString = contractNames[contractNames.length - 1];\r\n            uint256 unregisterIndex = items[_contractName].nameIndex;\r\n\r\n            contractNames[unregisterIndex] = lastContractNameString;\r\n            bytes32 lastContractName = stringToBytes32(lastContractNameString);\r\n            RegistryItem storage registryItem = items[lastContractName];\r\n            registryItem.nameIndex = unregisterIndex;\r\n        }\r\n\r\n        // remove the last element from the name list\r\n        contractNames.length--;\r\n        // zero the deleted element's index\r\n        items[_contractName].nameIndex = 0;\r\n\r\n        // dispatch the address update event\r\n        emit AddressUpdate(_contractName, address(0));\r\n    }\r\n\r\n    /**\r\n      * @dev utility, converts bytes32 to a string\r\n      * note that the bytes32 argument is assumed to be UTF8 encoded ASCII string\r\n      *\r\n      * @return string representation of the given bytes32 argument\r\n    */\r\n    function bytes32ToString(bytes32 _bytes) private pure returns (string) {\r\n        bytes memory byteArray = new bytes(32);\r\n        for (uint256 i = 0; i < 32; i++) {\r\n            byteArray[i] = _bytes[i];\r\n        }\r\n\r\n        return string(byteArray);\r\n    }\r\n\r\n    /**\r\n      * @dev utility, converts string to bytes32\r\n      * note that the bytes32 argument is assumed to be UTF8 encoded ASCII string\r\n      *\r\n      * @return string representation of the given bytes32 argument\r\n    */\r\n    function stringToBytes32(string memory _string) private pure returns (bytes32) {\r\n        bytes32 result;\r\n        assembly {\r\n            result := mload(add(_string,32))\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function getAddress(bytes32 _contractName) public view returns (address) {\r\n        return addressOf(_contractName);\r\n    }\r\n}\r\n\r\n\r\n\r\n",
  "imports": [
    {
      "name": "01_ContractRegistry_flat.sol",
      "contents": "pragma solidity 0.4.26;\r\n\r\n/*\r\n    Owned contract interface\r\n*/\r\ncontract IOwned {\r\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\r\n    function owner() public view returns (address) {this;}\r\n\r\n    function transferOwnership(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n}\r\n\r\n\r\n/*\r\n    Contract Registry interface\r\n*/\r\ncontract IContractRegistry {\r\n    function addressOf(bytes32 _contractName) public view returns (address);\r\n\r\n    // deprecated, backward compatibility\r\n    function getAddress(bytes32 _contractName) public view returns (address);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n  * @dev Provides support and utilities for contract ownership\r\n*/\r\ncontract Owned is IOwned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    /**\r\n      * @dev triggered when the owner is updated\r\n      *\r\n      * @param _prevOwner previous owner\r\n      * @param _newOwner  new owner\r\n    */\r\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\r\n\r\n    /**\r\n      * @dev initializes a new Owned instance\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        _ownerOnly();\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _ownerOnly() internal view {\r\n        require(msg.sender == owner, \"ERR_ACCESS_DENIED\");\r\n    }\r\n\r\n    /**\r\n      * @dev allows transferring the contract ownership\r\n      * the new owner still needs to accept the transfer\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner, \"ERR_SAME_OWNER\");\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n      * @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner, \"ERR_ACCESS_DENIED\");\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n  * @dev Utilities & Common Modifiers\r\n*/\r\ncontract Utils {\r\n    // verifies that a value is greater than zero\r\n    modifier greaterThanZero(uint256 _value) {\r\n        _greaterThanZero(_value);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _greaterThanZero(uint256 _value) internal pure {\r\n        require(_value > 0, \"ERR_ZERO_VALUE\");\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        _validAddress(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validAddress(address _address) internal pure {\r\n        require(_address != address(0), \"ERR_INVALID_ADDRESS\");\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        _notThis(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _notThis(address _address) internal view {\r\n        require(_address != address(this), \"ERR_ADDRESS_IS_SELF\");\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n  * @dev Contract Registry\r\n  *\r\n  * The contract registry keeps contract addresses by name.\r\n  * The owner can update contract addresses so that a contract name always points to the latest version\r\n  * of the given contract.\r\n  * Other contracts can query the registry to get updated addresses instead of depending on specific\r\n  * addresses.\r\n  *\r\n  * Note that contract names are limited to 32 bytes UTF8 encoded ASCII strings to optimize gas costs\r\n*/\r\ncontract ContractRegistry is IContractRegistry, Owned, Utils {\r\n    struct RegistryItem {\r\n        address contractAddress;    // contract address\r\n        uint256 nameIndex;          // index of the item in the list of contract names\r\n    }\r\n\r\n    mapping (bytes32 => RegistryItem) private items;    // name -> RegistryItem mapping\r\n    string[] public contractNames;                      // list of all registered contract names\r\n\r\n    /**\r\n      * @dev triggered when an address pointed to by a contract name is modified\r\n      *\r\n      * @param _contractName    contract name\r\n      * @param _contractAddress new contract address\r\n    */\r\n    event AddressUpdate(bytes32 indexed _contractName, address _contractAddress);\r\n\r\n    /**\r\n      * @dev returns the number of items in the registry\r\n      *\r\n      * @return number of items\r\n    */\r\n    function itemCount() public view returns (uint256) {\r\n        return contractNames.length;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the address associated with the given contract name\r\n      *\r\n      * @param _contractName    contract name\r\n      *\r\n      * @return contract address\r\n    */\r\n    function addressOf(bytes32 _contractName) public view returns (address) {\r\n        return items[_contractName].contractAddress;\r\n    }\r\n\r\n    /**\r\n      * @dev registers a new address for the contract name in the registry\r\n      *\r\n      * @param _contractName     contract name\r\n      * @param _contractAddress  contract address\r\n    */\r\n    function registerAddress(bytes32 _contractName, address _contractAddress)\r\n        public\r\n        ownerOnly\r\n        validAddress(_contractAddress)\r\n    {\r\n        // validate input\r\n        require(_contractName.length > 0, \"ERR_INVALID_NAME\");\r\n\r\n        // check if any change is needed\r\n        address currentAddress = items[_contractName].contractAddress;\r\n        if (_contractAddress == currentAddress)\r\n            return;\r\n\r\n        if (currentAddress == address(0)) {\r\n            // add the contract name to the name list\r\n            uint256 i = contractNames.push(bytes32ToString(_contractName));\r\n            // update the item's index in the list\r\n            items[_contractName].nameIndex = i - 1;\r\n        }\r\n\r\n        // update the address in the registry\r\n        items[_contractName].contractAddress = _contractAddress;\r\n\r\n        // dispatch the address update event\r\n        emit AddressUpdate(_contractName, _contractAddress);\r\n    }\r\n\r\n    /**\r\n      * @dev removes an existing contract address from the registry\r\n      *\r\n      * @param _contractName contract name\r\n    */\r\n    function unregisterAddress(bytes32 _contractName) public ownerOnly {\r\n        // validate input\r\n        require(_contractName.length > 0, \"ERR_INVALID_NAME\");\r\n        require(items[_contractName].contractAddress != address(0), \"ERR_INVALID_NAME\");\r\n\r\n        // remove the address from the registry\r\n        items[_contractName].contractAddress = address(0);\r\n\r\n        // if there are multiple items in the registry, move the last element to the deleted element's position\r\n        // and modify last element's registryItem.nameIndex in the items collection to point to the right position in contractNames\r\n        if (contractNames.length > 1) {\r\n            string memory lastContractNameString = contractNames[contractNames.length - 1];\r\n            uint256 unregisterIndex = items[_contractName].nameIndex;\r\n\r\n            contractNames[unregisterIndex] = lastContractNameString;\r\n            bytes32 lastContractName = stringToBytes32(lastContractNameString);\r\n            RegistryItem storage registryItem = items[lastContractName];\r\n            registryItem.nameIndex = unregisterIndex;\r\n        }\r\n\r\n        // remove the last element from the name list\r\n        contractNames.length--;\r\n        // zero the deleted element's index\r\n        items[_contractName].nameIndex = 0;\r\n\r\n        // dispatch the address update event\r\n        emit AddressUpdate(_contractName, address(0));\r\n    }\r\n\r\n    /**\r\n      * @dev utility, converts bytes32 to a string\r\n      * note that the bytes32 argument is assumed to be UTF8 encoded ASCII string\r\n      *\r\n      * @return string representation of the given bytes32 argument\r\n    */\r\n    function bytes32ToString(bytes32 _bytes) private pure returns (string) {\r\n        bytes memory byteArray = new bytes(32);\r\n        for (uint256 i = 0; i < 32; i++) {\r\n            byteArray[i] = _bytes[i];\r\n        }\r\n\r\n        return string(byteArray);\r\n    }\r\n\r\n    /**\r\n      * @dev utility, converts string to bytes32\r\n      * note that the bytes32 argument is assumed to be UTF8 encoded ASCII string\r\n      *\r\n      * @return string representation of the given bytes32 argument\r\n    */\r\n    function stringToBytes32(string memory _string) private pure returns (bytes32) {\r\n        bytes32 result;\r\n        assembly {\r\n            result := mload(add(_string,32))\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function getAddress(bytes32 _contractName) public view returns (address) {\r\n        return addressOf(_contractName);\r\n    }\r\n}\r\n\r\n\r\n\r\n",
      "file": "01_ContractRegistry_flat.sol"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x1647bd9e19d67339790390c86441eb7f39452cab22d9342d4eee9c92fe3326f8",
    "blockNumber": 2742570,
    "transactionHash": "0x5dfd94e64251165920a944f555f563958fb1d1758789d1451a9a4ae3cddbdf74",
    "timestamp": 1601481832
  }
}