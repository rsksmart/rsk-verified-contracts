{
  "address": "0x73eef416cb8b63dbfcc66719f0b74bb7baea48fe",
  "net": {
    "id": "30",
    "name": "RSK Mainnet"
  },
  "name": "ConverterRegistryData",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "metadata",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ]
      }
    }
  },
  "version": "0.4.26+commit.4563c3fc",
  "source": "pragma solidity 0.4.26;\r\n\r\n/*\r\n    Owned contract interface\r\n*/\r\ncontract IOwned {\r\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\r\n    function owner() public view returns (address) {this;}\r\n\r\n    function transferOwnership(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n}\r\n\r\n\r\n/*\r\n    Contract Registry interface\r\n*/\r\ncontract IContractRegistry {\r\n    function addressOf(bytes32 _contractName) public view returns (address);\r\n\r\n    // deprecated, backward compatibility\r\n    function getAddress(bytes32 _contractName) public view returns (address);\r\n}\r\n\r\n\r\ninterface IConverterRegistryData {\r\n    function addSmartToken(address _smartToken) external;\r\n    function removeSmartToken(address _smartToken) external;\r\n    function addLiquidityPool(address _liquidityPool) external;\r\n    function removeLiquidityPool(address _liquidityPool) external;\r\n    function addConvertibleToken(address _convertibleToken, address _smartToken) external;\r\n    function removeConvertibleToken(address _convertibleToken, address _smartToken) external;\r\n    function getSmartTokenCount() external view returns (uint256);\r\n    function getSmartTokens() external view returns (address[]);\r\n    function getSmartToken(uint256 _index) external view returns (address);\r\n    function isSmartToken(address _value) external view returns (bool);\r\n    function getLiquidityPoolCount() external view returns (uint256);\r\n    function getLiquidityPools() external view returns (address[]);\r\n    function getLiquidityPool(uint256 _index) external view returns (address);\r\n    function isLiquidityPool(address _value) external view returns (bool);\r\n    function getConvertibleTokenCount() external view returns (uint256);\r\n    function getConvertibleTokens() external view returns (address[]);\r\n    function getConvertibleToken(uint256 _index) external view returns (address);\r\n    function isConvertibleToken(address _value) external view returns (bool);\r\n    function getConvertibleTokenSmartTokenCount(address _convertibleToken) external view returns (uint256);\r\n    function getConvertibleTokenSmartTokens(address _convertibleToken) external view returns (address[]);\r\n    function getConvertibleTokenSmartToken(address _convertibleToken, uint256 _index) external view returns (address);\r\n    function isConvertibleTokenSmartToken(address _convertibleToken, address _value) external view returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n  * @dev Provides support and utilities for contract ownership\r\n*/\r\ncontract Owned is IOwned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    /**\r\n      * @dev triggered when the owner is updated\r\n      *\r\n      * @param _prevOwner previous owner\r\n      * @param _newOwner  new owner\r\n    */\r\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\r\n\r\n    /**\r\n      * @dev initializes a new Owned instance\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        _ownerOnly();\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _ownerOnly() internal view {\r\n        require(msg.sender == owner, \"ERR_ACCESS_DENIED\");\r\n    }\r\n\r\n    /**\r\n      * @dev allows transferring the contract ownership\r\n      * the new owner still needs to accept the transfer\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner, \"ERR_SAME_OWNER\");\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n      * @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner, \"ERR_ACCESS_DENIED\");\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n  * @dev Utilities & Common Modifiers\r\n*/\r\ncontract Utils {\r\n    // verifies that a value is greater than zero\r\n    modifier greaterThanZero(uint256 _value) {\r\n        _greaterThanZero(_value);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _greaterThanZero(uint256 _value) internal pure {\r\n        require(_value > 0, \"ERR_ZERO_VALUE\");\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        _validAddress(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validAddress(address _address) internal pure {\r\n        require(_address != address(0), \"ERR_INVALID_ADDRESS\");\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        _notThis(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _notThis(address _address) internal view {\r\n        require(_address != address(this), \"ERR_ADDRESS_IS_SELF\");\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n  * @dev Base contract for ContractRegistry clients\r\n*/\r\ncontract ContractRegistryClient is Owned, Utils {\r\n    bytes32 internal constant CONTRACT_REGISTRY = \"ContractRegistry\";\r\n    bytes32 internal constant SOVRYNSWAP_NETWORK = \"SovrynSwapNetwork\";\r\n    bytes32 internal constant SOVRYNSWAP_FORMULA = \"SovrynSwapFormula\";\r\n    bytes32 internal constant CONVERTER_FACTORY = \"ConverterFactory\";\r\n    bytes32 internal constant CONVERSION_PATH_FINDER = \"ConversionPathFinder\";\r\n    bytes32 internal constant CONVERTER_UPGRADER = \"SovrynSwapConverterUpgrader\";\r\n    bytes32 internal constant CONVERTER_REGISTRY = \"SovrynSwapConverterRegistry\";\r\n    bytes32 internal constant CONVERTER_REGISTRY_DATA = \"SovrynSwapConverterRegistryData\";\r\n    bytes32 internal constant BNT_TOKEN = \"BNTToken\";\r\n    bytes32 internal constant SOVRYNSWAP_X = \"SovrynSwapX\";\r\n    bytes32 internal constant SOVRYNSWAP_X_UPGRADER = \"SovrynSwapXUpgrader\";\r\n    bytes32 internal constant CHAINLINK_ORACLE_WHITELIST = \"ChainlinkOracleWhitelist\";\r\n\r\n    IContractRegistry public registry;      // address of the current contract-registry\r\n    IContractRegistry public prevRegistry;  // address of the previous contract-registry\r\n    bool public onlyOwnerCanUpdateRegistry; // only an owner can update the contract-registry\r\n\r\n    /**\r\n      * @dev verifies that the caller is mapped to the given contract name\r\n      *\r\n      * @param _contractName    contract name\r\n    */\r\n    modifier only(bytes32 _contractName) {\r\n        _only(_contractName);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _only(bytes32 _contractName) internal view {\r\n        require(msg.sender == addressOf(_contractName), \"ERR_ACCESS_DENIED\");\r\n    }\r\n\r\n    /**\r\n      * @dev initializes a new ContractRegistryClient instance\r\n      *\r\n      * @param  _registry   address of a contract-registry contract\r\n    */\r\n    constructor(IContractRegistry _registry) internal validAddress(_registry) {\r\n        registry = IContractRegistry(_registry);\r\n        prevRegistry = IContractRegistry(_registry);\r\n    }\r\n\r\n    /**\r\n      * @dev updates to the new contract-registry\r\n     */\r\n    function updateRegistry() public {\r\n        // verify that this function is permitted\r\n        require(msg.sender == owner || !onlyOwnerCanUpdateRegistry, \"ERR_ACCESS_DENIED\");\r\n\r\n        // get the new contract-registry\r\n        IContractRegistry newRegistry = IContractRegistry(addressOf(CONTRACT_REGISTRY));\r\n\r\n        // verify that the new contract-registry is different and not zero\r\n        require(newRegistry != address(registry) && newRegistry != address(0), \"ERR_INVALID_REGISTRY\");\r\n\r\n        // verify that the new contract-registry is pointing to a non-zero contract-registry\r\n        require(newRegistry.addressOf(CONTRACT_REGISTRY) != address(0), \"ERR_INVALID_REGISTRY\");\r\n\r\n        // save a backup of the current contract-registry before replacing it\r\n        prevRegistry = registry;\r\n\r\n        // replace the current contract-registry with the new contract-registry\r\n        registry = newRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev restores the previous contract-registry\r\n    */\r\n    function restoreRegistry() public ownerOnly {\r\n        // restore the previous contract-registry\r\n        registry = prevRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev restricts the permission to update the contract-registry\r\n      *\r\n      * @param _onlyOwnerCanUpdateRegistry  indicates whether or not permission is restricted to owner only\r\n    */\r\n    function restrictRegistryUpdate(bool _onlyOwnerCanUpdateRegistry) public ownerOnly {\r\n        // change the permission to update the contract-registry\r\n        onlyOwnerCanUpdateRegistry = _onlyOwnerCanUpdateRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the address associated with the given contract name\r\n      *\r\n      * @param _contractName    contract name\r\n      *\r\n      * @return contract address\r\n    */\r\n    function addressOf(bytes32 _contractName) internal view returns (address) {\r\n        return registry.addressOf(_contractName);\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n  * @dev The ConverterRegistryData contract is an integral part of the converter registry\r\n  * as it serves as the database contract that holds all registry data.\r\n  *\r\n  * The registry is separated into two different contracts for upgradability - the data contract\r\n  * is harder to upgrade as it requires migrating all registry data into a new contract, while\r\n  * the registry contract itself can be easily upgraded.\r\n  *\r\n  * For that same reason, the data contract is simple and contains no logic beyond the basic data\r\n  * access utilities that it exposes.\r\n*/\r\ncontract ConverterRegistryData is IConverterRegistryData, ContractRegistryClient {\r\n    struct Item {\r\n        bool valid;\r\n        uint256 index;\r\n    }\r\n\r\n    struct Items {\r\n        address[] array;\r\n        mapping(address => Item) table;\r\n    }\r\n\r\n    struct List {\r\n        uint256 index;\r\n        Items items;\r\n    }\r\n\r\n    struct Lists {\r\n        address[] array;\r\n        mapping(address => List) table;\r\n    }\r\n\r\n    Items private smartTokens;\r\n    Items private liquidityPools;\r\n    Lists private convertibleTokens;\r\n\r\n    /**\r\n      * @dev initializes a new ConverterRegistryData instance\r\n      *\r\n      * @param _registry address of a contract registry contract\r\n    */\r\n    constructor(IContractRegistry _registry) ContractRegistryClient(_registry) public {\r\n    }\r\n\r\n    /**\r\n      * @dev adds a smart token\r\n      *\r\n      * @param _smartToken smart token\r\n    */\r\n    function addSmartToken(address _smartToken) external only(CONVERTER_REGISTRY) {\r\n        addItem(smartTokens, _smartToken);\r\n    }\r\n\r\n    /**\r\n      * @dev removes a smart token\r\n      *\r\n      * @param _smartToken smart token\r\n    */\r\n    function removeSmartToken(address _smartToken) external only(CONVERTER_REGISTRY) {\r\n        removeItem(smartTokens, _smartToken);\r\n    }\r\n\r\n    /**\r\n      * @dev adds a liquidity pool\r\n      *\r\n      * @param _liquidityPool liquidity pool\r\n    */\r\n    function addLiquidityPool(address _liquidityPool) external only(CONVERTER_REGISTRY) {\r\n        addItem(liquidityPools, _liquidityPool);\r\n    }\r\n\r\n    /**\r\n      * @dev removes a liquidity pool\r\n      *\r\n      * @param _liquidityPool liquidity pool\r\n    */\r\n    function removeLiquidityPool(address _liquidityPool) external only(CONVERTER_REGISTRY) {\r\n        removeItem(liquidityPools, _liquidityPool);\r\n    }\r\n\r\n    /**\r\n      * @dev adds a convertible token\r\n      *\r\n      * @param _convertibleToken convertible token\r\n      * @param _smartToken associated smart token\r\n    */\r\n    function addConvertibleToken(address _convertibleToken, address _smartToken) external only(CONVERTER_REGISTRY) {\r\n        List storage list = convertibleTokens.table[_convertibleToken];\r\n        if (list.items.array.length == 0) {\r\n            list.index = convertibleTokens.array.push(_convertibleToken) - 1;\r\n        }\r\n        addItem(list.items, _smartToken);\r\n    }\r\n\r\n    /**\r\n      * @dev removes a convertible token\r\n      *\r\n      * @param _convertibleToken convertible token\r\n      * @param _smartToken associated smart token\r\n    */\r\n    function removeConvertibleToken(address _convertibleToken, address _smartToken) external only(CONVERTER_REGISTRY) {\r\n        List storage list = convertibleTokens.table[_convertibleToken];\r\n        removeItem(list.items, _smartToken);\r\n        if (list.items.array.length == 0) {\r\n            address lastConvertibleToken = convertibleTokens.array[convertibleTokens.array.length - 1];\r\n            convertibleTokens.table[lastConvertibleToken].index = list.index;\r\n            convertibleTokens.array[list.index] = lastConvertibleToken;\r\n            convertibleTokens.array.length--;\r\n            delete convertibleTokens.table[_convertibleToken];\r\n        }\r\n    }\r\n\r\n    /**\r\n      * @dev returns the number of smart tokens\r\n      *\r\n      * @return number of smart tokens\r\n    */\r\n    function getSmartTokenCount() external view returns (uint256) {\r\n        return smartTokens.array.length;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the list of smart tokens\r\n      *\r\n      * @return list of smart tokens\r\n    */\r\n    function getSmartTokens() external view returns (address[]) {\r\n        return smartTokens.array;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the smart token at a given index\r\n      *\r\n      * @param _index index\r\n      * @return smart token at the given index\r\n    */\r\n    function getSmartToken(uint256 _index) external view returns (address) {\r\n        return smartTokens.array[_index];\r\n    }\r\n\r\n    /**\r\n      * @dev checks whether or not a given value is a smart token\r\n      *\r\n      * @param _value value\r\n      * @return true if the given value is a smart token, false if not\r\n    */\r\n    function isSmartToken(address _value) external view returns (bool) {\r\n        return smartTokens.table[_value].valid;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the number of liquidity pools\r\n      *\r\n      * @return number of liquidity pools\r\n    */\r\n    function getLiquidityPoolCount() external view returns (uint256) {\r\n        return liquidityPools.array.length;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the list of liquidity pools\r\n      *\r\n      * @return list of liquidity pools\r\n    */\r\n    function getLiquidityPools() external view returns (address[]) {\r\n        return liquidityPools.array;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the liquidity pool at a given index\r\n      *\r\n      * @param _index index\r\n      * @return liquidity pool at the given index\r\n    */\r\n    function getLiquidityPool(uint256 _index) external view returns (address) {\r\n        return liquidityPools.array[_index];\r\n    }\r\n\r\n    /**\r\n      * @dev checks whether or not a given value is a liquidity pool\r\n      *\r\n      * @param _value value\r\n      * @return true if the given value is a liquidity pool, false if not\r\n    */\r\n    function isLiquidityPool(address _value) external view returns (bool) {\r\n        return liquidityPools.table[_value].valid;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the number of convertible tokens\r\n      *\r\n      * @return number of convertible tokens\r\n    */\r\n    function getConvertibleTokenCount() external view returns (uint256) {\r\n        return convertibleTokens.array.length;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the list of convertible tokens\r\n      *\r\n      * @return list of convertible tokens\r\n    */\r\n    function getConvertibleTokens() external view returns (address[]) {\r\n        return convertibleTokens.array;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the convertible token at a given index\r\n      *\r\n      * @param _index index\r\n      * @return convertible token at the given index\r\n    */\r\n    function getConvertibleToken(uint256 _index) external view returns (address) {\r\n        return convertibleTokens.array[_index];\r\n    }\r\n\r\n    /**\r\n      * @dev checks whether or not a given value is a convertible token\r\n      *\r\n      * @param _value value\r\n      * @return true if the given value is a convertible token, false if not\r\n    */\r\n    function isConvertibleToken(address _value) external view returns (bool) {\r\n        return convertibleTokens.table[_value].items.array.length > 0;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the number of smart tokens associated with a given convertible token\r\n      *\r\n      * @param _convertibleToken convertible token\r\n      * @return number of smart tokens associated with the given convertible token\r\n    */\r\n    function getConvertibleTokenSmartTokenCount(address _convertibleToken) external view returns (uint256) {\r\n        return convertibleTokens.table[_convertibleToken].items.array.length;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the list of smart tokens associated with a given convertible token\r\n      *\r\n      * @param _convertibleToken convertible token\r\n      * @return list of smart tokens associated with the given convertible token\r\n    */\r\n    function getConvertibleTokenSmartTokens(address _convertibleToken) external view returns (address[]) {\r\n        return convertibleTokens.table[_convertibleToken].items.array;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the smart token associated with a given convertible token at a given index\r\n      *\r\n      * @param _index index\r\n      * @return smart token associated with the given convertible token at the given index\r\n    */\r\n    function getConvertibleTokenSmartToken(address _convertibleToken, uint256 _index) external view returns (address) {\r\n        return convertibleTokens.table[_convertibleToken].items.array[_index];\r\n    }\r\n\r\n    /**\r\n      * @dev checks whether or not a given value is a smart token of a given convertible token\r\n      *\r\n      * @param _convertibleToken convertible token\r\n      * @param _value value\r\n      * @return true if the given value is a smart token of the given convertible token, false it not\r\n    */\r\n    function isConvertibleTokenSmartToken(address _convertibleToken, address _value) external view returns (bool) {\r\n        return convertibleTokens.table[_convertibleToken].items.table[_value].valid;\r\n    }\r\n\r\n    /**\r\n      * @dev adds an item to a list of items\r\n      *\r\n      * @param _items list of items\r\n      * @param _value item's value\r\n    */\r\n    function addItem(Items storage _items, address _value) internal validAddress(_value) {\r\n        Item storage item = _items.table[_value];\r\n        require(!item.valid, \"ERR_INVALID_ITEM\");\r\n\r\n        item.index = _items.array.push(_value) - 1;\r\n        item.valid = true;\r\n    }\r\n\r\n    /**\r\n      * @dev removes an item from a list of items\r\n      *\r\n      * @param _items list of items\r\n      * @param _value item's value\r\n    */\r\n    function removeItem(Items storage _items, address _value) internal validAddress(_value) {\r\n        Item storage item = _items.table[_value];\r\n        require(item.valid, \"ERR_INVALID_ITEM\");\r\n\r\n        address lastValue = _items.array[_items.array.length - 1];\r\n        _items.table[lastValue].index = item.index;\r\n        _items.array[item.index] = lastValue;\r\n        _items.array.length--;\r\n        delete _items.table[_value];\r\n    }\r\n}\r\n\r\n\r\n\r\n",
  "imports": [
    {
      "name": "08_ConverterRegistryData_flat.sol",
      "contents": "pragma solidity 0.4.26;\r\n\r\n/*\r\n    Owned contract interface\r\n*/\r\ncontract IOwned {\r\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\r\n    function owner() public view returns (address) {this;}\r\n\r\n    function transferOwnership(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n}\r\n\r\n\r\n/*\r\n    Contract Registry interface\r\n*/\r\ncontract IContractRegistry {\r\n    function addressOf(bytes32 _contractName) public view returns (address);\r\n\r\n    // deprecated, backward compatibility\r\n    function getAddress(bytes32 _contractName) public view returns (address);\r\n}\r\n\r\n\r\ninterface IConverterRegistryData {\r\n    function addSmartToken(address _smartToken) external;\r\n    function removeSmartToken(address _smartToken) external;\r\n    function addLiquidityPool(address _liquidityPool) external;\r\n    function removeLiquidityPool(address _liquidityPool) external;\r\n    function addConvertibleToken(address _convertibleToken, address _smartToken) external;\r\n    function removeConvertibleToken(address _convertibleToken, address _smartToken) external;\r\n    function getSmartTokenCount() external view returns (uint256);\r\n    function getSmartTokens() external view returns (address[]);\r\n    function getSmartToken(uint256 _index) external view returns (address);\r\n    function isSmartToken(address _value) external view returns (bool);\r\n    function getLiquidityPoolCount() external view returns (uint256);\r\n    function getLiquidityPools() external view returns (address[]);\r\n    function getLiquidityPool(uint256 _index) external view returns (address);\r\n    function isLiquidityPool(address _value) external view returns (bool);\r\n    function getConvertibleTokenCount() external view returns (uint256);\r\n    function getConvertibleTokens() external view returns (address[]);\r\n    function getConvertibleToken(uint256 _index) external view returns (address);\r\n    function isConvertibleToken(address _value) external view returns (bool);\r\n    function getConvertibleTokenSmartTokenCount(address _convertibleToken) external view returns (uint256);\r\n    function getConvertibleTokenSmartTokens(address _convertibleToken) external view returns (address[]);\r\n    function getConvertibleTokenSmartToken(address _convertibleToken, uint256 _index) external view returns (address);\r\n    function isConvertibleTokenSmartToken(address _convertibleToken, address _value) external view returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n  * @dev Provides support and utilities for contract ownership\r\n*/\r\ncontract Owned is IOwned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    /**\r\n      * @dev triggered when the owner is updated\r\n      *\r\n      * @param _prevOwner previous owner\r\n      * @param _newOwner  new owner\r\n    */\r\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\r\n\r\n    /**\r\n      * @dev initializes a new Owned instance\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        _ownerOnly();\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _ownerOnly() internal view {\r\n        require(msg.sender == owner, \"ERR_ACCESS_DENIED\");\r\n    }\r\n\r\n    /**\r\n      * @dev allows transferring the contract ownership\r\n      * the new owner still needs to accept the transfer\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner, \"ERR_SAME_OWNER\");\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n      * @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner, \"ERR_ACCESS_DENIED\");\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n  * @dev Utilities & Common Modifiers\r\n*/\r\ncontract Utils {\r\n    // verifies that a value is greater than zero\r\n    modifier greaterThanZero(uint256 _value) {\r\n        _greaterThanZero(_value);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _greaterThanZero(uint256 _value) internal pure {\r\n        require(_value > 0, \"ERR_ZERO_VALUE\");\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        _validAddress(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validAddress(address _address) internal pure {\r\n        require(_address != address(0), \"ERR_INVALID_ADDRESS\");\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        _notThis(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _notThis(address _address) internal view {\r\n        require(_address != address(this), \"ERR_ADDRESS_IS_SELF\");\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n  * @dev Base contract for ContractRegistry clients\r\n*/\r\ncontract ContractRegistryClient is Owned, Utils {\r\n    bytes32 internal constant CONTRACT_REGISTRY = \"ContractRegistry\";\r\n    bytes32 internal constant SOVRYNSWAP_NETWORK = \"SovrynSwapNetwork\";\r\n    bytes32 internal constant SOVRYNSWAP_FORMULA = \"SovrynSwapFormula\";\r\n    bytes32 internal constant CONVERTER_FACTORY = \"ConverterFactory\";\r\n    bytes32 internal constant CONVERSION_PATH_FINDER = \"ConversionPathFinder\";\r\n    bytes32 internal constant CONVERTER_UPGRADER = \"SovrynSwapConverterUpgrader\";\r\n    bytes32 internal constant CONVERTER_REGISTRY = \"SovrynSwapConverterRegistry\";\r\n    bytes32 internal constant CONVERTER_REGISTRY_DATA = \"SovrynSwapConverterRegistryData\";\r\n    bytes32 internal constant BNT_TOKEN = \"BNTToken\";\r\n    bytes32 internal constant SOVRYNSWAP_X = \"SovrynSwapX\";\r\n    bytes32 internal constant SOVRYNSWAP_X_UPGRADER = \"SovrynSwapXUpgrader\";\r\n    bytes32 internal constant CHAINLINK_ORACLE_WHITELIST = \"ChainlinkOracleWhitelist\";\r\n\r\n    IContractRegistry public registry;      // address of the current contract-registry\r\n    IContractRegistry public prevRegistry;  // address of the previous contract-registry\r\n    bool public onlyOwnerCanUpdateRegistry; // only an owner can update the contract-registry\r\n\r\n    /**\r\n      * @dev verifies that the caller is mapped to the given contract name\r\n      *\r\n      * @param _contractName    contract name\r\n    */\r\n    modifier only(bytes32 _contractName) {\r\n        _only(_contractName);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _only(bytes32 _contractName) internal view {\r\n        require(msg.sender == addressOf(_contractName), \"ERR_ACCESS_DENIED\");\r\n    }\r\n\r\n    /**\r\n      * @dev initializes a new ContractRegistryClient instance\r\n      *\r\n      * @param  _registry   address of a contract-registry contract\r\n    */\r\n    constructor(IContractRegistry _registry) internal validAddress(_registry) {\r\n        registry = IContractRegistry(_registry);\r\n        prevRegistry = IContractRegistry(_registry);\r\n    }\r\n\r\n    /**\r\n      * @dev updates to the new contract-registry\r\n     */\r\n    function updateRegistry() public {\r\n        // verify that this function is permitted\r\n        require(msg.sender == owner || !onlyOwnerCanUpdateRegistry, \"ERR_ACCESS_DENIED\");\r\n\r\n        // get the new contract-registry\r\n        IContractRegistry newRegistry = IContractRegistry(addressOf(CONTRACT_REGISTRY));\r\n\r\n        // verify that the new contract-registry is different and not zero\r\n        require(newRegistry != address(registry) && newRegistry != address(0), \"ERR_INVALID_REGISTRY\");\r\n\r\n        // verify that the new contract-registry is pointing to a non-zero contract-registry\r\n        require(newRegistry.addressOf(CONTRACT_REGISTRY) != address(0), \"ERR_INVALID_REGISTRY\");\r\n\r\n        // save a backup of the current contract-registry before replacing it\r\n        prevRegistry = registry;\r\n\r\n        // replace the current contract-registry with the new contract-registry\r\n        registry = newRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev restores the previous contract-registry\r\n    */\r\n    function restoreRegistry() public ownerOnly {\r\n        // restore the previous contract-registry\r\n        registry = prevRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev restricts the permission to update the contract-registry\r\n      *\r\n      * @param _onlyOwnerCanUpdateRegistry  indicates whether or not permission is restricted to owner only\r\n    */\r\n    function restrictRegistryUpdate(bool _onlyOwnerCanUpdateRegistry) public ownerOnly {\r\n        // change the permission to update the contract-registry\r\n        onlyOwnerCanUpdateRegistry = _onlyOwnerCanUpdateRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the address associated with the given contract name\r\n      *\r\n      * @param _contractName    contract name\r\n      *\r\n      * @return contract address\r\n    */\r\n    function addressOf(bytes32 _contractName) internal view returns (address) {\r\n        return registry.addressOf(_contractName);\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n  * @dev The ConverterRegistryData contract is an integral part of the converter registry\r\n  * as it serves as the database contract that holds all registry data.\r\n  *\r\n  * The registry is separated into two different contracts for upgradability - the data contract\r\n  * is harder to upgrade as it requires migrating all registry data into a new contract, while\r\n  * the registry contract itself can be easily upgraded.\r\n  *\r\n  * For that same reason, the data contract is simple and contains no logic beyond the basic data\r\n  * access utilities that it exposes.\r\n*/\r\ncontract ConverterRegistryData is IConverterRegistryData, ContractRegistryClient {\r\n    struct Item {\r\n        bool valid;\r\n        uint256 index;\r\n    }\r\n\r\n    struct Items {\r\n        address[] array;\r\n        mapping(address => Item) table;\r\n    }\r\n\r\n    struct List {\r\n        uint256 index;\r\n        Items items;\r\n    }\r\n\r\n    struct Lists {\r\n        address[] array;\r\n        mapping(address => List) table;\r\n    }\r\n\r\n    Items private smartTokens;\r\n    Items private liquidityPools;\r\n    Lists private convertibleTokens;\r\n\r\n    /**\r\n      * @dev initializes a new ConverterRegistryData instance\r\n      *\r\n      * @param _registry address of a contract registry contract\r\n    */\r\n    constructor(IContractRegistry _registry) ContractRegistryClient(_registry) public {\r\n    }\r\n\r\n    /**\r\n      * @dev adds a smart token\r\n      *\r\n      * @param _smartToken smart token\r\n    */\r\n    function addSmartToken(address _smartToken) external only(CONVERTER_REGISTRY) {\r\n        addItem(smartTokens, _smartToken);\r\n    }\r\n\r\n    /**\r\n      * @dev removes a smart token\r\n      *\r\n      * @param _smartToken smart token\r\n    */\r\n    function removeSmartToken(address _smartToken) external only(CONVERTER_REGISTRY) {\r\n        removeItem(smartTokens, _smartToken);\r\n    }\r\n\r\n    /**\r\n      * @dev adds a liquidity pool\r\n      *\r\n      * @param _liquidityPool liquidity pool\r\n    */\r\n    function addLiquidityPool(address _liquidityPool) external only(CONVERTER_REGISTRY) {\r\n        addItem(liquidityPools, _liquidityPool);\r\n    }\r\n\r\n    /**\r\n      * @dev removes a liquidity pool\r\n      *\r\n      * @param _liquidityPool liquidity pool\r\n    */\r\n    function removeLiquidityPool(address _liquidityPool) external only(CONVERTER_REGISTRY) {\r\n        removeItem(liquidityPools, _liquidityPool);\r\n    }\r\n\r\n    /**\r\n      * @dev adds a convertible token\r\n      *\r\n      * @param _convertibleToken convertible token\r\n      * @param _smartToken associated smart token\r\n    */\r\n    function addConvertibleToken(address _convertibleToken, address _smartToken) external only(CONVERTER_REGISTRY) {\r\n        List storage list = convertibleTokens.table[_convertibleToken];\r\n        if (list.items.array.length == 0) {\r\n            list.index = convertibleTokens.array.push(_convertibleToken) - 1;\r\n        }\r\n        addItem(list.items, _smartToken);\r\n    }\r\n\r\n    /**\r\n      * @dev removes a convertible token\r\n      *\r\n      * @param _convertibleToken convertible token\r\n      * @param _smartToken associated smart token\r\n    */\r\n    function removeConvertibleToken(address _convertibleToken, address _smartToken) external only(CONVERTER_REGISTRY) {\r\n        List storage list = convertibleTokens.table[_convertibleToken];\r\n        removeItem(list.items, _smartToken);\r\n        if (list.items.array.length == 0) {\r\n            address lastConvertibleToken = convertibleTokens.array[convertibleTokens.array.length - 1];\r\n            convertibleTokens.table[lastConvertibleToken].index = list.index;\r\n            convertibleTokens.array[list.index] = lastConvertibleToken;\r\n            convertibleTokens.array.length--;\r\n            delete convertibleTokens.table[_convertibleToken];\r\n        }\r\n    }\r\n\r\n    /**\r\n      * @dev returns the number of smart tokens\r\n      *\r\n      * @return number of smart tokens\r\n    */\r\n    function getSmartTokenCount() external view returns (uint256) {\r\n        return smartTokens.array.length;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the list of smart tokens\r\n      *\r\n      * @return list of smart tokens\r\n    */\r\n    function getSmartTokens() external view returns (address[]) {\r\n        return smartTokens.array;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the smart token at a given index\r\n      *\r\n      * @param _index index\r\n      * @return smart token at the given index\r\n    */\r\n    function getSmartToken(uint256 _index) external view returns (address) {\r\n        return smartTokens.array[_index];\r\n    }\r\n\r\n    /**\r\n      * @dev checks whether or not a given value is a smart token\r\n      *\r\n      * @param _value value\r\n      * @return true if the given value is a smart token, false if not\r\n    */\r\n    function isSmartToken(address _value) external view returns (bool) {\r\n        return smartTokens.table[_value].valid;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the number of liquidity pools\r\n      *\r\n      * @return number of liquidity pools\r\n    */\r\n    function getLiquidityPoolCount() external view returns (uint256) {\r\n        return liquidityPools.array.length;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the list of liquidity pools\r\n      *\r\n      * @return list of liquidity pools\r\n    */\r\n    function getLiquidityPools() external view returns (address[]) {\r\n        return liquidityPools.array;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the liquidity pool at a given index\r\n      *\r\n      * @param _index index\r\n      * @return liquidity pool at the given index\r\n    */\r\n    function getLiquidityPool(uint256 _index) external view returns (address) {\r\n        return liquidityPools.array[_index];\r\n    }\r\n\r\n    /**\r\n      * @dev checks whether or not a given value is a liquidity pool\r\n      *\r\n      * @param _value value\r\n      * @return true if the given value is a liquidity pool, false if not\r\n    */\r\n    function isLiquidityPool(address _value) external view returns (bool) {\r\n        return liquidityPools.table[_value].valid;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the number of convertible tokens\r\n      *\r\n      * @return number of convertible tokens\r\n    */\r\n    function getConvertibleTokenCount() external view returns (uint256) {\r\n        return convertibleTokens.array.length;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the list of convertible tokens\r\n      *\r\n      * @return list of convertible tokens\r\n    */\r\n    function getConvertibleTokens() external view returns (address[]) {\r\n        return convertibleTokens.array;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the convertible token at a given index\r\n      *\r\n      * @param _index index\r\n      * @return convertible token at the given index\r\n    */\r\n    function getConvertibleToken(uint256 _index) external view returns (address) {\r\n        return convertibleTokens.array[_index];\r\n    }\r\n\r\n    /**\r\n      * @dev checks whether or not a given value is a convertible token\r\n      *\r\n      * @param _value value\r\n      * @return true if the given value is a convertible token, false if not\r\n    */\r\n    function isConvertibleToken(address _value) external view returns (bool) {\r\n        return convertibleTokens.table[_value].items.array.length > 0;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the number of smart tokens associated with a given convertible token\r\n      *\r\n      * @param _convertibleToken convertible token\r\n      * @return number of smart tokens associated with the given convertible token\r\n    */\r\n    function getConvertibleTokenSmartTokenCount(address _convertibleToken) external view returns (uint256) {\r\n        return convertibleTokens.table[_convertibleToken].items.array.length;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the list of smart tokens associated with a given convertible token\r\n      *\r\n      * @param _convertibleToken convertible token\r\n      * @return list of smart tokens associated with the given convertible token\r\n    */\r\n    function getConvertibleTokenSmartTokens(address _convertibleToken) external view returns (address[]) {\r\n        return convertibleTokens.table[_convertibleToken].items.array;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the smart token associated with a given convertible token at a given index\r\n      *\r\n      * @param _index index\r\n      * @return smart token associated with the given convertible token at the given index\r\n    */\r\n    function getConvertibleTokenSmartToken(address _convertibleToken, uint256 _index) external view returns (address) {\r\n        return convertibleTokens.table[_convertibleToken].items.array[_index];\r\n    }\r\n\r\n    /**\r\n      * @dev checks whether or not a given value is a smart token of a given convertible token\r\n      *\r\n      * @param _convertibleToken convertible token\r\n      * @param _value value\r\n      * @return true if the given value is a smart token of the given convertible token, false it not\r\n    */\r\n    function isConvertibleTokenSmartToken(address _convertibleToken, address _value) external view returns (bool) {\r\n        return convertibleTokens.table[_convertibleToken].items.table[_value].valid;\r\n    }\r\n\r\n    /**\r\n      * @dev adds an item to a list of items\r\n      *\r\n      * @param _items list of items\r\n      * @param _value item's value\r\n    */\r\n    function addItem(Items storage _items, address _value) internal validAddress(_value) {\r\n        Item storage item = _items.table[_value];\r\n        require(!item.valid, \"ERR_INVALID_ITEM\");\r\n\r\n        item.index = _items.array.push(_value) - 1;\r\n        item.valid = true;\r\n    }\r\n\r\n    /**\r\n      * @dev removes an item from a list of items\r\n      *\r\n      * @param _items list of items\r\n      * @param _value item's value\r\n    */\r\n    function removeItem(Items storage _items, address _value) internal validAddress(_value) {\r\n        Item storage item = _items.table[_value];\r\n        require(item.valid, \"ERR_INVALID_ITEM\");\r\n\r\n        address lastValue = _items.array[_items.array.length - 1];\r\n        _items.table[lastValue].index = item.index;\r\n        _items.array[item.index] = lastValue;\r\n        _items.array.length--;\r\n        delete _items.table[_value];\r\n    }\r\n}\r\n\r\n\r\n\r\n",
      "file": "08_ConverterRegistryData_flat.sol"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x7f5546463c422b684f3639213e5d374f90956777235185ba1992e7c6e4bc2edb",
    "blockNumber": 2742581,
    "transactionHash": "0xd5d4499fea57e743074ea40757a5f1dc6e049d88229bf05d5462874cbed4aaa8",
    "timestamp": 1601482174
  },
  "constructorArguments": [
    "0x46ebc03ef2277308bdb106a73d11c65109c4b89b"
  ]
}