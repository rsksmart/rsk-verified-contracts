{
  "address": "0x36a5d791897469b724992a3fd9d55082da4b4442",
  "net": {
    "id": "30",
    "name": "RSK Mainnet"
  },
  "name": "SuperDAO",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": "1"
    },
    "evmVersion": "byzantium"
  },
  "version": "0.5.8+commit.23d335f2",
  "source": "// File: @openzeppelin/upgrades/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.7.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: @openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\n\npragma solidity ^0.5.0;\n\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context is Initializable {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts-ethereum-package/contracts/ownership/Ownable.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Initializable, Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function initialize(address sender) public initializer {\n        _owner = sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    uint256[50] private ______gap;\n}\n\n// File: @openzeppelin/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: @openzeppelin/upgrades/contracts/upgradeability/Proxy.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title Proxy\n * @dev Implements delegation of calls to other contracts, with proper\n * forwarding of return values and bubbling of failures.\n * It defines a fallback function that delegates all calls to the address\n * returned by the abstract _implementation() internal function.\n */\ncontract Proxy {\n  /**\n   * @dev Fallback function.\n   * Implemented entirely in `_fallback`.\n   */\n  function () payable external {\n    _fallback();\n  }\n\n  /**\n   * @return The Address of the implementation.\n   */\n  function _implementation() internal view returns (address);\n\n  /**\n   * @dev Delegates execution to an implementation contract.\n   * This is a low level function that doesn't return to its internal call site.\n   * It will return to the external caller whatever the implementation returns.\n   * @param implementation Address to delegate.\n   */\n  function _delegate(address implementation) internal {\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize)\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize)\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 { revert(0, returndatasize) }\n      default { return(0, returndatasize) }\n    }\n  }\n\n  /**\n   * @dev Function that is run as the first thing in the fallback function.\n   * Can be redefined in derived contracts to add functionality.\n   * Redefinitions must call super._willFallback().\n   */\n  function _willFallback() internal {\n  }\n\n  /**\n   * @dev fallback implementation.\n   * Extracted to enable manual triggering.\n   */\n  function _fallback() internal {\n    _willFallback();\n    _delegate(_implementation());\n  }\n}\n\n// File: @openzeppelin/upgrades/contracts/utils/Address.sol\n\npragma solidity ^0.5.0;\n\n/**\n * Utility library of inline functions on addresses\n *\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/utils/Address.sol\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\n * build/artifacts folder) as well as the vanilla Address implementation from an openzeppelin version.\n */\nlibrary OpenZeppelinUpgradesAddress {\n    /**\n     * Returns whether the target address is a contract\n     * @dev This function will return false if invoked during the constructor of a contract,\n     * as the code is not actually created until after the constructor finishes.\n     * @param account address of the account to check\n     * @return whether the target address is a contract\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // XXX Currently there is no better way to check if there is a contract in an address\n        // than to check the size of the code at that address.\n        // See https://ethereum.stackexchange.com/a/14016/36603\n        // for more details about how this works.\n        // TODO Check this again before the Serenity release, because all addresses will be\n        // contracts then.\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n\n// File: @openzeppelin/upgrades/contracts/upgradeability/BaseUpgradeabilityProxy.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @title BaseUpgradeabilityProxy\n * @dev This contract implements a proxy that allows to change the\n * implementation address to which it will delegate.\n * Such a change is called an implementation upgrade.\n */\ncontract BaseUpgradeabilityProxy is Proxy {\n  /**\n   * @dev Emitted when the implementation is upgraded.\n   * @param implementation Address of the new implementation.\n   */\n  event Upgraded(address indexed implementation);\n\n  /**\n   * @dev Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /**\n   * @dev Returns the current implementation.\n   * @return Address of the current implementation\n   */\n  function _implementation() internal view returns (address impl) {\n    bytes32 slot = IMPLEMENTATION_SLOT;\n    assembly {\n      impl := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Upgrades the proxy to a new implementation.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /**\n   * @dev Sets the implementation address of the proxy.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _setImplementation(address newImplementation) internal {\n    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\n\n    bytes32 slot = IMPLEMENTATION_SLOT;\n\n    assembly {\n      sstore(slot, newImplementation)\n    }\n  }\n}\n\n// File: @openzeppelin/upgrades/contracts/upgradeability/UpgradeabilityProxy.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @title UpgradeabilityProxy\n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\n * implementation and init data.\n */\ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy {\n  /**\n   * @dev Contract constructor.\n   * @param _logic Address of the initial implementation.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(address _logic, bytes memory _data) public payable {\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }  \n}\n\n// File: @openzeppelin/upgrades/contracts/upgradeability/BaseAdminUpgradeabilityProxy.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @title BaseAdminUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n  /**\n   * @dev Emitted when the administration has been transferred.\n   * @param previousAdmin Address of the previous admin.\n   * @param newAdmin Address of the new admin.\n   */\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n\n  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  /**\n   * @dev Modifier to check whether the `msg.sender` is the admin.\n   * If it is, it will run the function. Otherwise, it will delegate the call\n   * to the implementation.\n   */\n  modifier ifAdmin() {\n    if (msg.sender == _admin()) {\n      _;\n    } else {\n      _fallback();\n    }\n  }\n\n  /**\n   * @return The address of the proxy admin.\n   */\n  function admin() external ifAdmin returns (address) {\n    return _admin();\n  }\n\n  /**\n   * @return The address of the implementation.\n   */\n  function implementation() external ifAdmin returns (address) {\n    return _implementation();\n  }\n\n  /**\n   * @dev Changes the admin of the proxy.\n   * Only the current admin can call this function.\n   * @param newAdmin Address to transfer proxy administration to.\n   */\n  function changeAdmin(address newAdmin) external ifAdmin {\n    require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n    emit AdminChanged(_admin(), newAdmin);\n    _setAdmin(newAdmin);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy.\n   * Only the admin can call this function.\n   * @param newImplementation Address of the new implementation.\n   */\n  function upgradeTo(address newImplementation) external ifAdmin {\n    _upgradeTo(newImplementation);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy and call a function\n   * on the new implementation.\n   * This is useful to initialize the proxied contract.\n   * @param newImplementation Address of the new implementation.\n   * @param data Data to send as msg.data in the low level call.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   */\n  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\n    _upgradeTo(newImplementation);\n    (bool success,) = newImplementation.delegatecall(data);\n    require(success);\n  }\n\n  /**\n   * @return The admin slot.\n   */\n  function _admin() internal view returns (address adm) {\n    bytes32 slot = ADMIN_SLOT;\n    assembly {\n      adm := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the address of the proxy admin.\n   * @param newAdmin Address of the new proxy admin.\n   */\n  function _setAdmin(address newAdmin) internal {\n    bytes32 slot = ADMIN_SLOT;\n\n    assembly {\n      sstore(slot, newAdmin)\n    }\n  }\n\n  /**\n   * @dev Only fall back when the sender is not the admin.\n   */\n  function _willFallback() internal {\n    require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\n    super._willFallback();\n  }\n}\n\n// File: @openzeppelin/upgrades/contracts/upgradeability/AdminUpgradeabilityProxy.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @title AdminUpgradeabilityProxy\n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for \n * initializing the implementation, admin, and init data.\n */\ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\n  /**\n   * Contract constructor.\n   * @param _logic address of the initial implementation.\n   * @param _admin Address of the proxy administrator.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(address _logic, address _admin, bytes memory _data) UpgradeabilityProxy(_logic, _data) public payable {\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(_admin);\n  }\n}\n\n// File: src/contracts/Project.sol\n\npragma solidity ^0.5.8;\n\n\n\n\ncontract Project is Initializable, Ownable {\n    using SafeMath for uint256;\n\n    string public name;\n    address public entrepreneurAddress;\n\n    mapping (bytes32 => bool) public isClaimValidated;\n\n    function initialize(string memory _name) public payable initializer {\n        Ownable.initialize(msg.sender);\n        name = _name;\n    }\n\n    uint256[50] private _gap;\n}\n\n// File: src/contracts/ClaimsRegistry.sol\n\npragma solidity ^0.5.8;\n\n\n/**\n * @title This contract holds information about claims made buy COA members\n * @dev loosely based on ERC780 Ethereum Claims Registry https://github.com/ethereum/EIPs/issues/780 now it has been heavily changed.\n */\ncontract ClaimsRegistry is Initializable{\n    struct Claim {\n        bool approved;\n        bytes32 proof;\n    }\n\n    // Claim[] can be used to amend previous verifications\n    // Claim by project address => validator address => claim's hash => claim.\n    mapping(address => mapping(address => mapping(bytes32 => Claim))) public registry;\n\n    // Emitted when a claim is added\n    event ClaimApproved(\n        address indexed project,\n        address indexed validator,\n        bytes32 indexed claim,\n        bool _approved,\n        bytes32 proof,\n        uint256 verifiedAt,\n        uint256 milestone\n    );\n\n    function initialize() public initializer {\n    }\n\n    /**\n     * @notice Adds a claim into the registry.\n     * @param _project - address of a project.\n     * @param _claim - bytes32 of the claim's hash.\n     * @param _proof - bytes32 of the proof's hash.\n     * @param _approved - true if the claim is approved, false otherwise.\n     */\n    function addClaim(\n        address _project,\n        bytes32 _claim,\n        bytes32 _proof,\n        bool _approved,\n        uint256 _milestone\n    ) public {\n        address validator = msg.sender;\n        registry[_project][validator][_claim] = Claim({\n            approved: _approved,\n            proof: _proof\n        });\n\n        emit ClaimApproved(\n            _project,\n            validator,\n            _claim,\n            _approved,\n            _proof,\n            now,\n            _milestone\n        );\n    }\n\n    /**\n     * @notice Checks whether the tasks from a project's milestone are approved).\n     * @param _project - address of a project.\n     * @param _validators - array of addresses of the validators.\n     * @param _claims - array of bytes32 hashes of the claims.\n     */\n    function areApproved(\n        address _project,\n        address[] calldata _validators,\n        bytes32[] calldata _claims\n    ) external view returns (bool) {\n        require(\n            _validators.length == _claims.length,\n            'arrays must be equal size'\n        );\n        for (uint256 i = 0; i < _claims.length; i++) {\n            Claim memory claim = registry[_project][_validators[i]][_claims[i]];\n            if (!claim.approved) return false;\n        }\n        return true;\n    }\n\n    uint256[50] private _gap;\n}\n\n// File: src/contracts/AbstractDAO.sol\n\npragma solidity ^0.5.8;\n\n\n\n\n/// @title A DAO contract based on MolochDAO ideas\ncontract AbstractDAO is Initializable {\n    using SafeMath for uint256;\n\n    /// DAO members\n    mapping(address => Member) public members;\n    /// Array of DAO proposals inlcuding already processed ones\n    Proposal[] public proposalQueue;\n    /// DAO's name.\n    string public name;\n    uint256 public creationTime;\n\n    enum ProposalType {\n        NewMember, /// Adds a new member to the DAO\n        NewDAO, /// Create a new dao\n        AssignBank, /// Assigns bank role to a member\n        AssignCurator /// Assigns curator role to a member\n    }\n\n    enum Role {Normal, Bank, Curator}\n\n    /// TODO: actually define these numbers\n    uint256 public periodDuration; /// seconds\n    uint256 public votingPeriodLength; /// periods\n    uint256 public gracePeriodLength;\n    uint256 public processingPeriodLength;\n\n    /// Emitted then a proposal was successfuly submitted\n    event SubmitProposal(\n        uint256 proposalIndex,\n        address indexed memberAddress,\n        address indexed applicant,\n        ProposalType indexed proposalType\n    );\n    /// Emitted when a vote was succesfuly received\n    event SubmitVote(\n        uint256 indexed proposalIndex,\n        address indexed memberAddress,\n        uint8 vote\n    );\n    /// Emitted when a proposal was successfuly been processed\n    event ProcessProposal(\n        uint256 indexed proposalIndex,\n        address indexed applicant,\n        address indexed memberAddress,\n        ProposalType proposalType,\n        bool didPass\n    );\n\n    enum Vote {Null, Yes, No}\n\n    struct Member {\n        Role role; /// Member current role\n        bool exists; /// To check if it exists in the mapping\n        uint256 shares; /// Amount of shares\n    }\n\n    struct Proposal {\n        address proposer; /// Member that sent the proposal\n        address applicant; ///\n        ProposalType proposalType; /// The type of the proposal being voted\n        uint256 yesVotes; /// Total amount of Yes votes\n        uint256 noVotes; /// Total amount of No votes\n        bool didPass; /// True if the proposal has been approved, no otherwise\n        string description; /// ipfs / rif storage hash\n        mapping(address => Vote) votesByMember; /// All the votes made for this proposal\n        uint256 startingPeriod; /// the period in which voting can start for this proposal\n        bool processed; /// True if it has been processed, false otherwise\n    }\n\n    /**\n     * @param _name DAO name\n     * @param _creator User that will be assigned as the first member\n     */\n    function initialize(\n        string memory _name,\n        address _creator\n    ) public initializer {\n        name = _name;\n        creationTime = now;\n        addMember(_creator);\n        periodDuration = 17280;\n        votingPeriodLength = 35; /// periods\n        gracePeriodLength = 35;\n        processingPeriodLength = votingPeriodLength + gracePeriodLength;\n    }\n    /**\n     * @notice Function to be invoked in order to create a new proposal.\n     *\n     * @param _applicant Address of the user to be added as member. If _proposalType is NewDAO _applicant will be added as the first member.\n     * @param _proposalType Type of the proposal to be voted\n     * @param _description String description about the proposal\n     */\n    function submitProposal(\n        address _applicant,\n        uint8 _proposalType,\n        string memory _description\n    ) public onlyMembers() {\n        ProposalType proposalType = ProposalType(_proposalType);\n        require(_proposalType < 4, 'invalid type');\n        requireProposalTypeIsValid(proposalType);\n\n        if (\n            proposalType == ProposalType.AssignBank ||\n            proposalType == ProposalType.AssignCurator\n        ) {\n            requireIsMember(_applicant);\n        }\n\n        address memberAddress = msg.sender;\n        uint256 startingPeriod = max(\n            getCurrentPeriod(),\n            proposalQueue.length == 0\n                ? 0\n                : proposalQueue[proposalQueue.length.sub(1)].startingPeriod\n        )\n            .add(1);\n        Proposal memory proposal = Proposal({\n            proposer: memberAddress,\n            description: _description,\n            proposalType: proposalType,\n            applicant: _applicant,\n            yesVotes: 0,\n            noVotes: 0,\n            didPass: false,\n            startingPeriod: startingPeriod,\n            processed: false\n        });\n\n        proposalQueue.push(proposal);\n\n        emit SubmitProposal(\n            proposalQueue.length.sub(1),\n            memberAddress,\n            _applicant,\n            proposalType\n        );\n    }\n\n    /**\n     * @notice Used to cast a vote. Keep in mind that only memers can vote, voting twice is not alloed and votes cannot be casted between starting period until expiration.\n     * @param _proposalIndex Proposal to be voted to. It will revert if proposal doesn't exist at _propsoalIndex.\n     * @param _vote The vote, Vote.Yes or Vote.No\n     */\n    function submitVote(uint256 _proposalIndex, uint8 _vote)\n        public\n        onlyMembers()\n    {\n        address memberAddress = msg.sender;\n        require(\n            _proposalIndex < proposalQueue.length,\n            'Moloch::submitVote - proposal does not exist'\n        );\n        Proposal storage proposal = proposalQueue[_proposalIndex];\n        Vote vote = Vote(_vote);\n        require(\n            vote == Vote.Yes || vote == Vote.No,\n            'vote must be either Yes or No'\n        );\n        require(\n            getCurrentPeriod() >= proposal.startingPeriod,\n            'voting period has not started'\n        );\n\n        require(\n            !hasVotingPeriodExpired(proposal.startingPeriod),\n            'proposal voting period has expired'\n        );\n        require(\n            proposal.votesByMember[memberAddress] == Vote.Null,\n            'member has already voted on this proposal'\n        );\n\n        // store user vote\n        proposal.votesByMember[memberAddress] = vote;\n\n        // count the vote in the corresponding proposal vote accumulator\n        Member storage member = members[memberAddress];\n        if (vote == Vote.Yes) {\n            proposal.yesVotes = proposal.yesVotes.add(member.shares);\n        } else if (vote == Vote.No) {\n            proposal.noVotes = proposal.noVotes.add(member.shares);\n        }\n\n        emit SubmitVote(_proposalIndex, memberAddress, _vote);\n    }\n\n    /**\n     * @notice Counts proposal votes and executes corresponding actions if Yes votes > No votes. If it didn't pass does nothing. Proposals can be processed just once.\n     * @param _proposalIndex Proposal to ben processed. Previous proposals (the ones with index less than _proposalIndex) need to be processed first\n     */\n    function processProposal(uint256 _proposalIndex)\n        public\n        canProcess(_proposalIndex)\n    {\n        Proposal storage proposal = proposalQueue[_proposalIndex];\n\n        proposal.processed = true;\n\n        bool didPass = proposal.yesVotes > proposal.noVotes;\n\n        if (didPass) {\n            proposal.didPass = true;\n            // TODO: We might emit event or something to give more feedback to the users\n            bool memberExist = members[proposal.applicant].exists;\n            ProposalType proposalType = proposal.proposalType;\n\n            if (proposalType == ProposalType.NewMember && !memberExist) {\n                addMember(proposal.applicant);\n            } else if (proposalType == ProposalType.AssignBank && memberExist) {\n                members[proposal.applicant].role = Role.Bank;\n            } else if (\n                proposalType == ProposalType.AssignCurator && memberExist\n            ) {\n                members[proposal.applicant].role = Role.Curator;\n            } else if (proposalType == ProposalType.NewDAO) {\n                processNewDaoProposal(proposal.description, proposal.applicant);\n            }\n        }\n\n        emit ProcessProposal(\n            _proposalIndex,\n            proposal.applicant,\n            proposal.proposer,\n            proposal.proposalType,\n            didPass\n        );\n    }\n\n    /**\n     * @notice Returns current period. It can be used to determine the actions that can be performed on a proposal (cast votes or process).\n     */\n    function getCurrentPeriod() public view returns (uint256) {\n        return now.sub(creationTime).div(periodDuration);\n    }\n\n    /**\n     * @notice Returns true if the voting has expired based on the current period\n     * @param startingPeriod Proposal staring period\n     */\n    function hasVotingPeriodExpired(uint256 startingPeriod)\n        public\n        view\n        returns (bool)\n    {\n        return getCurrentPeriod() >= startingPeriod.add(votingPeriodLength);\n    }\n\n    /**\n     * @notice Returns the proposals array length\n     */\n    function getProposalQueueLength() public view returns (uint256) {\n        return proposalQueue.length;\n    }\n\n    /**\n     * @notice Checks if a proposal can be processed or not. Checks to be made: proposal exists, if it's ready to be processed and has not expired and hasn't been yet processed. It also checks if the previoous proposal has been processed already.\n     */\n    modifier canProcess(uint256 proposalIndex) {\n        require(\n            proposalIndex < proposalQueue.length,\n            'proposal does not exist'\n        );\n        Proposal storage proposal = proposalQueue[proposalIndex];\n\n        require(\n            getCurrentPeriod() >=\n                proposal.startingPeriod.add(processingPeriodLength),\n            'proposal is not ready to be processed'\n        );\n        require(\n            proposal.processed == false,\n            'proposal has already been processed'\n        );\n        require(\n            proposalIndex == 0 || proposalQueue[proposalIndex.sub(1)].processed,\n            'previous proposal must be processed'\n        );\n        _;\n    }\n\n    /**\n     * @notice This modifier checks if the `msg.sender` corresponds to a member of the dao with voting power\n     */\n    modifier onlyMembers() {\n        requireIsMember(msg.sender);\n        _;\n    }\n\n    /**\n     * @dev Checks if the given address belongs to a member. It reverts otherwise.\n     * @param _address to be checked\n     */\n    function requireIsMember(address _address) private view {\n        Member storage member = members[_address];\n        require(member.exists == true, 'not a DAO member');\n    }\n\n    function addMember(address memberAddress) private {\n        Member memory member = Member({\n            role: Role.Normal,\n            exists: true,\n            shares: 1\n        });\n        members[memberAddress] = member;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x >= y ? x : y;\n    }\n\n    /**\n     * @dev Checks if the proposal is valid to be processed by this DAO. It must revert if not.\n     * @param _proposalType ProposalType to be checked against to\n     */\n    function requireProposalTypeIsValid(ProposalType _proposalType) internal;\n\n    /**\n     * @dev Processes a new dao proposal. If not supported by the DAO type, it should do nothing\n     * @param _name DAO name\n     * @param _applicant Account to be set as a first member of the dao\n     */\n    function processNewDaoProposal(string memory _name, address _applicant)\n        internal;\n\n    uint256[50] private _gap;\n}\n\n// File: src/contracts/DAO.sol\n\npragma solidity ^0.5.8;\n\n\n/// @title A DAO contract based on MolochDAO ideas\ncontract DAO is AbstractDAO {\n\n    function initialize(string memory _name, address _creator) public initializer {\n        AbstractDAO.initialize(_name, _creator);\n    }\n    \n    function processNewDaoProposal(string memory _name, address applicant)\n        internal\n    {\n        // Do nothing as reverting will mark the proposal as not executed\n        // TODO: Emit an event\n    }\n\n    function requireProposalTypeIsValid(ProposalType _proposalType) internal {\n        require(\n            _proposalType == ProposalType.NewMember ||\n                _proposalType == ProposalType.AssignBank ||\n                _proposalType == ProposalType.AssignCurator,\n            'Invalid Proposal Type'\n        );\n    }\n\n    uint256[50] private _gap;\n}\n\n// File: src/contracts/COA.sol\n\npragma solidity ^0.5.8;\n\n\n\n\n\n\n\n/// @title COA main contract to store projects related information\ncontract COA is Initializable, Ownable {\n    struct Member {\n        string profile;\n    }\n    /// Projects list\n    //Project[] public projects;\n    AdminUpgradeabilityProxy[] public projects;\n    /// COA members\n    mapping(address => Member) public members;\n    /// COA owned daos\n    AdminUpgradeabilityProxy[] public daos;\n    /// FIXME: Where is this used\n    ClaimsRegistry public registry;\n    // Agreements by project address => agreementHash\n    mapping(address => string) public agreements;\n\n    /// Emitted when a new DAO is created\n    event DAOCreated(address addr);\n    /// Emitted when a new Project is created\n    event ProjectCreated(uint256 id, address addr);\n\n    address internal proxyAdmin;\n    address internal implProject;\n    address internal implSuperDao;\n    address internal implDao;\n\n    function coaInitialize(\n        address _registryAddress,\n        address _proxyAdmin,\n        address _implProject,\n        address _implSuperDao,\n        address _implDao\n    ) public initializer {\n        Ownable.initialize(msg.sender);\n        registry = ClaimsRegistry(_registryAddress);\n        proxyAdmin = _proxyAdmin;\n        implProject = _implProject;\n        implSuperDao = _implSuperDao;\n        implDao = _implDao;\n        createSuperDAO();\n    }\n    /**\n     * @notice Adds a new member in COA.\n     * @param _profile - string of the member's profile.\n     *\n     * @dev the profile can be bytes32 but IPFS hashes are 34 bytes long due to multihash. We could strip the first two bytes but for now it seems unnecessary.\n     */\n    function createMember(string memory _profile) public {\n        // role: Role.Activist,\n        Member memory member = Member({profile: _profile});\n        members[msg.sender] = member;\n    }\n\n    /**\n     * @dev Migrates an old member in COA.\n     * @param _profile - string of the member's profile.\n     * @param _existingAddress - address of the old member\n     */\n    function migrateMember(string memory _profile, address _existingAddress)\n        public\n        onlyOwner\n    {\n        // role: Role.Activist,\n        Member memory member = Member({profile: _profile});\n        members[_existingAddress] = member;\n    }\n\n    /**\n     * @dev Create a Project\n     * @param _name - string of the Project's name.\n     */\n    function createProject(uint256 _id, string memory _name)\n        public\n        returns (uint256)\n    {\n        bytes memory payload = abi.encodeWithSignature(\"initialize(string)\", _name);\n        AdminUpgradeabilityProxy proxy = new AdminUpgradeabilityProxy(implProject, owner(), payload);\n        projects.push(proxy);\n        emit ProjectCreated(_id, address(proxy));\n    }\n\n    /**\n     * @dev Create a DAO\n     * @param _name - string of the DAO's name.\n     * @param _creator - address of the first member of the DAO (i.e. its creator)\n     */\n    function createDAO(string memory _name, address _creator) public {\n        require(proxyAdmin != _creator, \"The creator can not be the proxy admin.\");\n        bytes memory payload = abi.encodeWithSignature(\"initialize(string,address)\", _name, _creator);\n        AdminUpgradeabilityProxy proxy = new AdminUpgradeabilityProxy(implDao, proxyAdmin, payload);\n        daos.push(proxy);\n        emit DAOCreated(address(proxy));\n    }\n\n    /**\n     * @dev Create a SuperDAO\n     *      It's the DAO that can be used to create other DAOs.\n     */\n    function createSuperDAO() internal {\n        require(proxyAdmin != owner(), \"The creator can not be the admin proxy.\");\n        bytes memory payload = abi.encodeWithSignature(\"initialize(string,address,address)\", 'Super DAO', owner(), address(this));\n        AdminUpgradeabilityProxy proxy = new AdminUpgradeabilityProxy(implSuperDao, proxyAdmin, payload);\n        daos.push(proxy);\n        emit DAOCreated(address(proxy));\n    }\n\n    // the agreement hash can be bytes32 but IPFS hashes are 34 bytes long due to multihash.\n    // we could strip the first two bytes but for now it seems unnecessary\n    /**\n     * @dev Adds an agreement hash to the agreements map. This can only be run by the admin\n     * @param _project - address of the project the agreement belongs to\n     * @param _agreementHash - string of the agreement's hash.\n     */\n    function addAgreement(address _project, string memory _agreementHash)\n        public\n        onlyOwner()\n    {\n        agreements[_project] = _agreementHash;\n    }\n\n    function getDaosLength() public view returns (uint256) {\n        return daos.length;\n    }\n\n    function getProjectsLength() public view returns (uint256) {\n        return projects.length;\n    }\n\n    uint256[50] private _gap;\n}\n\n// File: src/contracts/SuperDAO.sol\n\npragma solidity ^0.5.8;\n\n\n\n\n\n/// @title This contracts is a DAO but will also process new dao creation proposals\ncontract SuperDAO is AbstractDAO {\n    COA coa;\n\n    function initialize(string memory _name,\n        address _creator,\n        address _coaAddress) public initializer {\n        AbstractDAO.initialize(_name, _creator);\n        coa = COA(_coaAddress);\n    }\n\n    function processNewDaoProposal(string memory _name, address _applicant)\n        internal\n    {\n        coa.createDAO(_name, _applicant);\n    }\n\n    function requireProposalTypeIsValid(ProposalType _proposalType) internal {\n        require(\n            _proposalType == ProposalType.NewMember ||\n                _proposalType == ProposalType.AssignBank ||\n                _proposalType == ProposalType.AssignCurator ||\n                _proposalType == ProposalType.NewDAO,\n            'Invalid Proposal Type'\n        );\n    }\n\n    uint256[50] private _gap;\n}\n",
  "imports": [
    {
      "name": "SuperDAO.sol",
      "contents": "// File: @openzeppelin/upgrades/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.7.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: @openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\n\npragma solidity ^0.5.0;\n\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context is Initializable {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts-ethereum-package/contracts/ownership/Ownable.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Initializable, Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function initialize(address sender) public initializer {\n        _owner = sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    uint256[50] private ______gap;\n}\n\n// File: @openzeppelin/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: @openzeppelin/upgrades/contracts/upgradeability/Proxy.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title Proxy\n * @dev Implements delegation of calls to other contracts, with proper\n * forwarding of return values and bubbling of failures.\n * It defines a fallback function that delegates all calls to the address\n * returned by the abstract _implementation() internal function.\n */\ncontract Proxy {\n  /**\n   * @dev Fallback function.\n   * Implemented entirely in `_fallback`.\n   */\n  function () payable external {\n    _fallback();\n  }\n\n  /**\n   * @return The Address of the implementation.\n   */\n  function _implementation() internal view returns (address);\n\n  /**\n   * @dev Delegates execution to an implementation contract.\n   * This is a low level function that doesn't return to its internal call site.\n   * It will return to the external caller whatever the implementation returns.\n   * @param implementation Address to delegate.\n   */\n  function _delegate(address implementation) internal {\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize)\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize)\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 { revert(0, returndatasize) }\n      default { return(0, returndatasize) }\n    }\n  }\n\n  /**\n   * @dev Function that is run as the first thing in the fallback function.\n   * Can be redefined in derived contracts to add functionality.\n   * Redefinitions must call super._willFallback().\n   */\n  function _willFallback() internal {\n  }\n\n  /**\n   * @dev fallback implementation.\n   * Extracted to enable manual triggering.\n   */\n  function _fallback() internal {\n    _willFallback();\n    _delegate(_implementation());\n  }\n}\n\n// File: @openzeppelin/upgrades/contracts/utils/Address.sol\n\npragma solidity ^0.5.0;\n\n/**\n * Utility library of inline functions on addresses\n *\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/utils/Address.sol\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\n * build/artifacts folder) as well as the vanilla Address implementation from an openzeppelin version.\n */\nlibrary OpenZeppelinUpgradesAddress {\n    /**\n     * Returns whether the target address is a contract\n     * @dev This function will return false if invoked during the constructor of a contract,\n     * as the code is not actually created until after the constructor finishes.\n     * @param account address of the account to check\n     * @return whether the target address is a contract\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // XXX Currently there is no better way to check if there is a contract in an address\n        // than to check the size of the code at that address.\n        // See https://ethereum.stackexchange.com/a/14016/36603\n        // for more details about how this works.\n        // TODO Check this again before the Serenity release, because all addresses will be\n        // contracts then.\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n\n// File: @openzeppelin/upgrades/contracts/upgradeability/BaseUpgradeabilityProxy.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @title BaseUpgradeabilityProxy\n * @dev This contract implements a proxy that allows to change the\n * implementation address to which it will delegate.\n * Such a change is called an implementation upgrade.\n */\ncontract BaseUpgradeabilityProxy is Proxy {\n  /**\n   * @dev Emitted when the implementation is upgraded.\n   * @param implementation Address of the new implementation.\n   */\n  event Upgraded(address indexed implementation);\n\n  /**\n   * @dev Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /**\n   * @dev Returns the current implementation.\n   * @return Address of the current implementation\n   */\n  function _implementation() internal view returns (address impl) {\n    bytes32 slot = IMPLEMENTATION_SLOT;\n    assembly {\n      impl := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Upgrades the proxy to a new implementation.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /**\n   * @dev Sets the implementation address of the proxy.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _setImplementation(address newImplementation) internal {\n    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\n\n    bytes32 slot = IMPLEMENTATION_SLOT;\n\n    assembly {\n      sstore(slot, newImplementation)\n    }\n  }\n}\n\n// File: @openzeppelin/upgrades/contracts/upgradeability/UpgradeabilityProxy.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @title UpgradeabilityProxy\n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\n * implementation and init data.\n */\ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy {\n  /**\n   * @dev Contract constructor.\n   * @param _logic Address of the initial implementation.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(address _logic, bytes memory _data) public payable {\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }  \n}\n\n// File: @openzeppelin/upgrades/contracts/upgradeability/BaseAdminUpgradeabilityProxy.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @title BaseAdminUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n  /**\n   * @dev Emitted when the administration has been transferred.\n   * @param previousAdmin Address of the previous admin.\n   * @param newAdmin Address of the new admin.\n   */\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n\n  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  /**\n   * @dev Modifier to check whether the `msg.sender` is the admin.\n   * If it is, it will run the function. Otherwise, it will delegate the call\n   * to the implementation.\n   */\n  modifier ifAdmin() {\n    if (msg.sender == _admin()) {\n      _;\n    } else {\n      _fallback();\n    }\n  }\n\n  /**\n   * @return The address of the proxy admin.\n   */\n  function admin() external ifAdmin returns (address) {\n    return _admin();\n  }\n\n  /**\n   * @return The address of the implementation.\n   */\n  function implementation() external ifAdmin returns (address) {\n    return _implementation();\n  }\n\n  /**\n   * @dev Changes the admin of the proxy.\n   * Only the current admin can call this function.\n   * @param newAdmin Address to transfer proxy administration to.\n   */\n  function changeAdmin(address newAdmin) external ifAdmin {\n    require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n    emit AdminChanged(_admin(), newAdmin);\n    _setAdmin(newAdmin);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy.\n   * Only the admin can call this function.\n   * @param newImplementation Address of the new implementation.\n   */\n  function upgradeTo(address newImplementation) external ifAdmin {\n    _upgradeTo(newImplementation);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy and call a function\n   * on the new implementation.\n   * This is useful to initialize the proxied contract.\n   * @param newImplementation Address of the new implementation.\n   * @param data Data to send as msg.data in the low level call.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   */\n  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\n    _upgradeTo(newImplementation);\n    (bool success,) = newImplementation.delegatecall(data);\n    require(success);\n  }\n\n  /**\n   * @return The admin slot.\n   */\n  function _admin() internal view returns (address adm) {\n    bytes32 slot = ADMIN_SLOT;\n    assembly {\n      adm := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the address of the proxy admin.\n   * @param newAdmin Address of the new proxy admin.\n   */\n  function _setAdmin(address newAdmin) internal {\n    bytes32 slot = ADMIN_SLOT;\n\n    assembly {\n      sstore(slot, newAdmin)\n    }\n  }\n\n  /**\n   * @dev Only fall back when the sender is not the admin.\n   */\n  function _willFallback() internal {\n    require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\n    super._willFallback();\n  }\n}\n\n// File: @openzeppelin/upgrades/contracts/upgradeability/AdminUpgradeabilityProxy.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @title AdminUpgradeabilityProxy\n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for \n * initializing the implementation, admin, and init data.\n */\ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\n  /**\n   * Contract constructor.\n   * @param _logic address of the initial implementation.\n   * @param _admin Address of the proxy administrator.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(address _logic, address _admin, bytes memory _data) UpgradeabilityProxy(_logic, _data) public payable {\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(_admin);\n  }\n}\n\n// File: src/contracts/Project.sol\n\npragma solidity ^0.5.8;\n\n\n\n\ncontract Project is Initializable, Ownable {\n    using SafeMath for uint256;\n\n    string public name;\n    address public entrepreneurAddress;\n\n    mapping (bytes32 => bool) public isClaimValidated;\n\n    function initialize(string memory _name) public payable initializer {\n        Ownable.initialize(msg.sender);\n        name = _name;\n    }\n\n    uint256[50] private _gap;\n}\n\n// File: src/contracts/ClaimsRegistry.sol\n\npragma solidity ^0.5.8;\n\n\n/**\n * @title This contract holds information about claims made buy COA members\n * @dev loosely based on ERC780 Ethereum Claims Registry https://github.com/ethereum/EIPs/issues/780 now it has been heavily changed.\n */\ncontract ClaimsRegistry is Initializable{\n    struct Claim {\n        bool approved;\n        bytes32 proof;\n    }\n\n    // Claim[] can be used to amend previous verifications\n    // Claim by project address => validator address => claim's hash => claim.\n    mapping(address => mapping(address => mapping(bytes32 => Claim))) public registry;\n\n    // Emitted when a claim is added\n    event ClaimApproved(\n        address indexed project,\n        address indexed validator,\n        bytes32 indexed claim,\n        bool _approved,\n        bytes32 proof,\n        uint256 verifiedAt,\n        uint256 milestone\n    );\n\n    function initialize() public initializer {\n    }\n\n    /**\n     * @notice Adds a claim into the registry.\n     * @param _project - address of a project.\n     * @param _claim - bytes32 of the claim's hash.\n     * @param _proof - bytes32 of the proof's hash.\n     * @param _approved - true if the claim is approved, false otherwise.\n     */\n    function addClaim(\n        address _project,\n        bytes32 _claim,\n        bytes32 _proof,\n        bool _approved,\n        uint256 _milestone\n    ) public {\n        address validator = msg.sender;\n        registry[_project][validator][_claim] = Claim({\n            approved: _approved,\n            proof: _proof\n        });\n\n        emit ClaimApproved(\n            _project,\n            validator,\n            _claim,\n            _approved,\n            _proof,\n            now,\n            _milestone\n        );\n    }\n\n    /**\n     * @notice Checks whether the tasks from a project's milestone are approved).\n     * @param _project - address of a project.\n     * @param _validators - array of addresses of the validators.\n     * @param _claims - array of bytes32 hashes of the claims.\n     */\n    function areApproved(\n        address _project,\n        address[] calldata _validators,\n        bytes32[] calldata _claims\n    ) external view returns (bool) {\n        require(\n            _validators.length == _claims.length,\n            'arrays must be equal size'\n        );\n        for (uint256 i = 0; i < _claims.length; i++) {\n            Claim memory claim = registry[_project][_validators[i]][_claims[i]];\n            if (!claim.approved) return false;\n        }\n        return true;\n    }\n\n    uint256[50] private _gap;\n}\n\n// File: src/contracts/AbstractDAO.sol\n\npragma solidity ^0.5.8;\n\n\n\n\n/// @title A DAO contract based on MolochDAO ideas\ncontract AbstractDAO is Initializable {\n    using SafeMath for uint256;\n\n    /// DAO members\n    mapping(address => Member) public members;\n    /// Array of DAO proposals inlcuding already processed ones\n    Proposal[] public proposalQueue;\n    /// DAO's name.\n    string public name;\n    uint256 public creationTime;\n\n    enum ProposalType {\n        NewMember, /// Adds a new member to the DAO\n        NewDAO, /// Create a new dao\n        AssignBank, /// Assigns bank role to a member\n        AssignCurator /// Assigns curator role to a member\n    }\n\n    enum Role {Normal, Bank, Curator}\n\n    /// TODO: actually define these numbers\n    uint256 public periodDuration; /// seconds\n    uint256 public votingPeriodLength; /// periods\n    uint256 public gracePeriodLength;\n    uint256 public processingPeriodLength;\n\n    /// Emitted then a proposal was successfuly submitted\n    event SubmitProposal(\n        uint256 proposalIndex,\n        address indexed memberAddress,\n        address indexed applicant,\n        ProposalType indexed proposalType\n    );\n    /// Emitted when a vote was succesfuly received\n    event SubmitVote(\n        uint256 indexed proposalIndex,\n        address indexed memberAddress,\n        uint8 vote\n    );\n    /// Emitted when a proposal was successfuly been processed\n    event ProcessProposal(\n        uint256 indexed proposalIndex,\n        address indexed applicant,\n        address indexed memberAddress,\n        ProposalType proposalType,\n        bool didPass\n    );\n\n    enum Vote {Null, Yes, No}\n\n    struct Member {\n        Role role; /// Member current role\n        bool exists; /// To check if it exists in the mapping\n        uint256 shares; /// Amount of shares\n    }\n\n    struct Proposal {\n        address proposer; /// Member that sent the proposal\n        address applicant; ///\n        ProposalType proposalType; /// The type of the proposal being voted\n        uint256 yesVotes; /// Total amount of Yes votes\n        uint256 noVotes; /// Total amount of No votes\n        bool didPass; /// True if the proposal has been approved, no otherwise\n        string description; /// ipfs / rif storage hash\n        mapping(address => Vote) votesByMember; /// All the votes made for this proposal\n        uint256 startingPeriod; /// the period in which voting can start for this proposal\n        bool processed; /// True if it has been processed, false otherwise\n    }\n\n    /**\n     * @param _name DAO name\n     * @param _creator User that will be assigned as the first member\n     */\n    function initialize(\n        string memory _name,\n        address _creator\n    ) public initializer {\n        name = _name;\n        creationTime = now;\n        addMember(_creator);\n        periodDuration = 17280;\n        votingPeriodLength = 35; /// periods\n        gracePeriodLength = 35;\n        processingPeriodLength = votingPeriodLength + gracePeriodLength;\n    }\n    /**\n     * @notice Function to be invoked in order to create a new proposal.\n     *\n     * @param _applicant Address of the user to be added as member. If _proposalType is NewDAO _applicant will be added as the first member.\n     * @param _proposalType Type of the proposal to be voted\n     * @param _description String description about the proposal\n     */\n    function submitProposal(\n        address _applicant,\n        uint8 _proposalType,\n        string memory _description\n    ) public onlyMembers() {\n        ProposalType proposalType = ProposalType(_proposalType);\n        require(_proposalType < 4, 'invalid type');\n        requireProposalTypeIsValid(proposalType);\n\n        if (\n            proposalType == ProposalType.AssignBank ||\n            proposalType == ProposalType.AssignCurator\n        ) {\n            requireIsMember(_applicant);\n        }\n\n        address memberAddress = msg.sender;\n        uint256 startingPeriod = max(\n            getCurrentPeriod(),\n            proposalQueue.length == 0\n                ? 0\n                : proposalQueue[proposalQueue.length.sub(1)].startingPeriod\n        )\n            .add(1);\n        Proposal memory proposal = Proposal({\n            proposer: memberAddress,\n            description: _description,\n            proposalType: proposalType,\n            applicant: _applicant,\n            yesVotes: 0,\n            noVotes: 0,\n            didPass: false,\n            startingPeriod: startingPeriod,\n            processed: false\n        });\n\n        proposalQueue.push(proposal);\n\n        emit SubmitProposal(\n            proposalQueue.length.sub(1),\n            memberAddress,\n            _applicant,\n            proposalType\n        );\n    }\n\n    /**\n     * @notice Used to cast a vote. Keep in mind that only memers can vote, voting twice is not alloed and votes cannot be casted between starting period until expiration.\n     * @param _proposalIndex Proposal to be voted to. It will revert if proposal doesn't exist at _propsoalIndex.\n     * @param _vote The vote, Vote.Yes or Vote.No\n     */\n    function submitVote(uint256 _proposalIndex, uint8 _vote)\n        public\n        onlyMembers()\n    {\n        address memberAddress = msg.sender;\n        require(\n            _proposalIndex < proposalQueue.length,\n            'Moloch::submitVote - proposal does not exist'\n        );\n        Proposal storage proposal = proposalQueue[_proposalIndex];\n        Vote vote = Vote(_vote);\n        require(\n            vote == Vote.Yes || vote == Vote.No,\n            'vote must be either Yes or No'\n        );\n        require(\n            getCurrentPeriod() >= proposal.startingPeriod,\n            'voting period has not started'\n        );\n\n        require(\n            !hasVotingPeriodExpired(proposal.startingPeriod),\n            'proposal voting period has expired'\n        );\n        require(\n            proposal.votesByMember[memberAddress] == Vote.Null,\n            'member has already voted on this proposal'\n        );\n\n        // store user vote\n        proposal.votesByMember[memberAddress] = vote;\n\n        // count the vote in the corresponding proposal vote accumulator\n        Member storage member = members[memberAddress];\n        if (vote == Vote.Yes) {\n            proposal.yesVotes = proposal.yesVotes.add(member.shares);\n        } else if (vote == Vote.No) {\n            proposal.noVotes = proposal.noVotes.add(member.shares);\n        }\n\n        emit SubmitVote(_proposalIndex, memberAddress, _vote);\n    }\n\n    /**\n     * @notice Counts proposal votes and executes corresponding actions if Yes votes > No votes. If it didn't pass does nothing. Proposals can be processed just once.\n     * @param _proposalIndex Proposal to ben processed. Previous proposals (the ones with index less than _proposalIndex) need to be processed first\n     */\n    function processProposal(uint256 _proposalIndex)\n        public\n        canProcess(_proposalIndex)\n    {\n        Proposal storage proposal = proposalQueue[_proposalIndex];\n\n        proposal.processed = true;\n\n        bool didPass = proposal.yesVotes > proposal.noVotes;\n\n        if (didPass) {\n            proposal.didPass = true;\n            // TODO: We might emit event or something to give more feedback to the users\n            bool memberExist = members[proposal.applicant].exists;\n            ProposalType proposalType = proposal.proposalType;\n\n            if (proposalType == ProposalType.NewMember && !memberExist) {\n                addMember(proposal.applicant);\n            } else if (proposalType == ProposalType.AssignBank && memberExist) {\n                members[proposal.applicant].role = Role.Bank;\n            } else if (\n                proposalType == ProposalType.AssignCurator && memberExist\n            ) {\n                members[proposal.applicant].role = Role.Curator;\n            } else if (proposalType == ProposalType.NewDAO) {\n                processNewDaoProposal(proposal.description, proposal.applicant);\n            }\n        }\n\n        emit ProcessProposal(\n            _proposalIndex,\n            proposal.applicant,\n            proposal.proposer,\n            proposal.proposalType,\n            didPass\n        );\n    }\n\n    /**\n     * @notice Returns current period. It can be used to determine the actions that can be performed on a proposal (cast votes or process).\n     */\n    function getCurrentPeriod() public view returns (uint256) {\n        return now.sub(creationTime).div(periodDuration);\n    }\n\n    /**\n     * @notice Returns true if the voting has expired based on the current period\n     * @param startingPeriod Proposal staring period\n     */\n    function hasVotingPeriodExpired(uint256 startingPeriod)\n        public\n        view\n        returns (bool)\n    {\n        return getCurrentPeriod() >= startingPeriod.add(votingPeriodLength);\n    }\n\n    /**\n     * @notice Returns the proposals array length\n     */\n    function getProposalQueueLength() public view returns (uint256) {\n        return proposalQueue.length;\n    }\n\n    /**\n     * @notice Checks if a proposal can be processed or not. Checks to be made: proposal exists, if it's ready to be processed and has not expired and hasn't been yet processed. It also checks if the previoous proposal has been processed already.\n     */\n    modifier canProcess(uint256 proposalIndex) {\n        require(\n            proposalIndex < proposalQueue.length,\n            'proposal does not exist'\n        );\n        Proposal storage proposal = proposalQueue[proposalIndex];\n\n        require(\n            getCurrentPeriod() >=\n                proposal.startingPeriod.add(processingPeriodLength),\n            'proposal is not ready to be processed'\n        );\n        require(\n            proposal.processed == false,\n            'proposal has already been processed'\n        );\n        require(\n            proposalIndex == 0 || proposalQueue[proposalIndex.sub(1)].processed,\n            'previous proposal must be processed'\n        );\n        _;\n    }\n\n    /**\n     * @notice This modifier checks if the `msg.sender` corresponds to a member of the dao with voting power\n     */\n    modifier onlyMembers() {\n        requireIsMember(msg.sender);\n        _;\n    }\n\n    /**\n     * @dev Checks if the given address belongs to a member. It reverts otherwise.\n     * @param _address to be checked\n     */\n    function requireIsMember(address _address) private view {\n        Member storage member = members[_address];\n        require(member.exists == true, 'not a DAO member');\n    }\n\n    function addMember(address memberAddress) private {\n        Member memory member = Member({\n            role: Role.Normal,\n            exists: true,\n            shares: 1\n        });\n        members[memberAddress] = member;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x >= y ? x : y;\n    }\n\n    /**\n     * @dev Checks if the proposal is valid to be processed by this DAO. It must revert if not.\n     * @param _proposalType ProposalType to be checked against to\n     */\n    function requireProposalTypeIsValid(ProposalType _proposalType) internal;\n\n    /**\n     * @dev Processes a new dao proposal. If not supported by the DAO type, it should do nothing\n     * @param _name DAO name\n     * @param _applicant Account to be set as a first member of the dao\n     */\n    function processNewDaoProposal(string memory _name, address _applicant)\n        internal;\n\n    uint256[50] private _gap;\n}\n\n// File: src/contracts/DAO.sol\n\npragma solidity ^0.5.8;\n\n\n/// @title A DAO contract based on MolochDAO ideas\ncontract DAO is AbstractDAO {\n\n    function initialize(string memory _name, address _creator) public initializer {\n        AbstractDAO.initialize(_name, _creator);\n    }\n    \n    function processNewDaoProposal(string memory _name, address applicant)\n        internal\n    {\n        // Do nothing as reverting will mark the proposal as not executed\n        // TODO: Emit an event\n    }\n\n    function requireProposalTypeIsValid(ProposalType _proposalType) internal {\n        require(\n            _proposalType == ProposalType.NewMember ||\n                _proposalType == ProposalType.AssignBank ||\n                _proposalType == ProposalType.AssignCurator,\n            'Invalid Proposal Type'\n        );\n    }\n\n    uint256[50] private _gap;\n}\n\n// File: src/contracts/COA.sol\n\npragma solidity ^0.5.8;\n\n\n\n\n\n\n\n/// @title COA main contract to store projects related information\ncontract COA is Initializable, Ownable {\n    struct Member {\n        string profile;\n    }\n    /// Projects list\n    //Project[] public projects;\n    AdminUpgradeabilityProxy[] public projects;\n    /// COA members\n    mapping(address => Member) public members;\n    /// COA owned daos\n    AdminUpgradeabilityProxy[] public daos;\n    /// FIXME: Where is this used\n    ClaimsRegistry public registry;\n    // Agreements by project address => agreementHash\n    mapping(address => string) public agreements;\n\n    /// Emitted when a new DAO is created\n    event DAOCreated(address addr);\n    /// Emitted when a new Project is created\n    event ProjectCreated(uint256 id, address addr);\n\n    address internal proxyAdmin;\n    address internal implProject;\n    address internal implSuperDao;\n    address internal implDao;\n\n    function coaInitialize(\n        address _registryAddress,\n        address _proxyAdmin,\n        address _implProject,\n        address _implSuperDao,\n        address _implDao\n    ) public initializer {\n        Ownable.initialize(msg.sender);\n        registry = ClaimsRegistry(_registryAddress);\n        proxyAdmin = _proxyAdmin;\n        implProject = _implProject;\n        implSuperDao = _implSuperDao;\n        implDao = _implDao;\n        createSuperDAO();\n    }\n    /**\n     * @notice Adds a new member in COA.\n     * @param _profile - string of the member's profile.\n     *\n     * @dev the profile can be bytes32 but IPFS hashes are 34 bytes long due to multihash. We could strip the first two bytes but for now it seems unnecessary.\n     */\n    function createMember(string memory _profile) public {\n        // role: Role.Activist,\n        Member memory member = Member({profile: _profile});\n        members[msg.sender] = member;\n    }\n\n    /**\n     * @dev Migrates an old member in COA.\n     * @param _profile - string of the member's profile.\n     * @param _existingAddress - address of the old member\n     */\n    function migrateMember(string memory _profile, address _existingAddress)\n        public\n        onlyOwner\n    {\n        // role: Role.Activist,\n        Member memory member = Member({profile: _profile});\n        members[_existingAddress] = member;\n    }\n\n    /**\n     * @dev Create a Project\n     * @param _name - string of the Project's name.\n     */\n    function createProject(uint256 _id, string memory _name)\n        public\n        returns (uint256)\n    {\n        bytes memory payload = abi.encodeWithSignature(\"initialize(string)\", _name);\n        AdminUpgradeabilityProxy proxy = new AdminUpgradeabilityProxy(implProject, owner(), payload);\n        projects.push(proxy);\n        emit ProjectCreated(_id, address(proxy));\n    }\n\n    /**\n     * @dev Create a DAO\n     * @param _name - string of the DAO's name.\n     * @param _creator - address of the first member of the DAO (i.e. its creator)\n     */\n    function createDAO(string memory _name, address _creator) public {\n        require(proxyAdmin != _creator, \"The creator can not be the proxy admin.\");\n        bytes memory payload = abi.encodeWithSignature(\"initialize(string,address)\", _name, _creator);\n        AdminUpgradeabilityProxy proxy = new AdminUpgradeabilityProxy(implDao, proxyAdmin, payload);\n        daos.push(proxy);\n        emit DAOCreated(address(proxy));\n    }\n\n    /**\n     * @dev Create a SuperDAO\n     *      It's the DAO that can be used to create other DAOs.\n     */\n    function createSuperDAO() internal {\n        require(proxyAdmin != owner(), \"The creator can not be the admin proxy.\");\n        bytes memory payload = abi.encodeWithSignature(\"initialize(string,address,address)\", 'Super DAO', owner(), address(this));\n        AdminUpgradeabilityProxy proxy = new AdminUpgradeabilityProxy(implSuperDao, proxyAdmin, payload);\n        daos.push(proxy);\n        emit DAOCreated(address(proxy));\n    }\n\n    // the agreement hash can be bytes32 but IPFS hashes are 34 bytes long due to multihash.\n    // we could strip the first two bytes but for now it seems unnecessary\n    /**\n     * @dev Adds an agreement hash to the agreements map. This can only be run by the admin\n     * @param _project - address of the project the agreement belongs to\n     * @param _agreementHash - string of the agreement's hash.\n     */\n    function addAgreement(address _project, string memory _agreementHash)\n        public\n        onlyOwner()\n    {\n        agreements[_project] = _agreementHash;\n    }\n\n    function getDaosLength() public view returns (uint256) {\n        return daos.length;\n    }\n\n    function getProjectsLength() public view returns (uint256) {\n        return projects.length;\n    }\n\n    uint256[50] private _gap;\n}\n\n// File: src/contracts/SuperDAO.sol\n\npragma solidity ^0.5.8;\n\n\n\n\n\n/// @title This contracts is a DAO but will also process new dao creation proposals\ncontract SuperDAO is AbstractDAO {\n    COA coa;\n\n    function initialize(string memory _name,\n        address _creator,\n        address _coaAddress) public initializer {\n        AbstractDAO.initialize(_name, _creator);\n        coa = COA(_coaAddress);\n    }\n\n    function processNewDaoProposal(string memory _name, address _applicant)\n        internal\n    {\n        coa.createDAO(_name, _applicant);\n    }\n\n    function requireProposalTypeIsValid(ProposalType _proposalType) internal {\n        require(\n            _proposalType == ProposalType.NewMember ||\n                _proposalType == ProposalType.AssignBank ||\n                _proposalType == ProposalType.AssignCurator ||\n                _proposalType == ProposalType.NewDAO,\n            'Invalid Proposal Type'\n        );\n    }\n\n    uint256[50] private _gap;\n}\n",
      "file": "SuperDAO.sol"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x4e785fe94af7491da7b6e2d482e4c5642f4f46aff555ebcd4ddbc7eda30639e6",
    "blockNumber": 2852405,
    "transactionHash": "0xe010d0095af7beadb582355db1f41225b439ba6546d6abc7d4f0e5879f86bc36",
    "timestamp": 1605033759
  }
}