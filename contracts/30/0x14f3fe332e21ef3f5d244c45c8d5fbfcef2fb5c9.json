{
    "address": "0x14f3fe332e21ef3f5d244c45c8d5fbfcef2fb5c9",
    "net": {
        "id": "30",
        "name": "RSK Mainnet"
    },
    "name": "VestingRegistry3",
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        }
    },
    "version": "0.5.17+commit.d19bba13",
    "source": "pragma solidity ^0.5.17;\n\ninterface ITeamVesting {\n\tfunction governanceWithdrawTokens(address receiver) external;\n}\n\n\ninterface IVesting {\n\tfunction duration() external returns (uint256);\n\n\tfunction endDate() external returns (uint256);\n\n\tfunction stakeTokens(uint256 amount) external;\n}\n\n\ninterface IVestingFactory {\n\tfunction deployVesting(\n\t\taddress _SOV,\n\t\taddress _staking,\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration,\n\t\taddress _feeSharing,\n\t\taddress _owner\n\t) external returns (address);\n\n\tfunction deployTeamVesting(\n\t\taddress _SOV,\n\t\taddress _staking,\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration,\n\t\taddress _feeSharing,\n\t\taddress _owner\n\t) external returns (address);\n}\n\n\ninterface IFeeSharingProxy {\n\tfunction withdrawFees(address _token) external;\n\n\tfunction transferTokens(address _token, uint96 _amount) external;\n\n\tfunction withdraw(\n\t\taddress _loanPoolToken,\n\t\tuint32 _maxCheckpoints,\n\t\taddress _receiver\n\t) external;\n}\n\n\ninterface IStaking {\n\tfunction stakesBySchedule(\n\t\tuint256 amount,\n\t\tuint256 cliff,\n\t\tuint256 duration,\n\t\tuint256 intervalLength,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) external;\n\n\tfunction stake(\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) external;\n\n\tfunction getPriorVotes(\n\t\taddress account,\n\t\tuint256 blockNumber,\n\t\tuint256 date\n\t) external view returns (uint96);\n\n\tfunction getPriorTotalVotingPower(uint32 blockNumber, uint256 time) external view returns (uint96);\n\n\tfunction getPriorWeightedStake(\n\t\taddress account,\n\t\tuint256 blockNumber,\n\t\tuint256 date\n\t) external view returns (uint96);\n\n\tfunction timestampToLockDate(uint256 timestamp) external view returns (uint256 lockDate);\n}\n/**\n * Copyright 2017-2021, bZeroX, LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0.\n */\n\n\n\ncontract IERC20 {\n\tstring public name;\n\tuint8 public decimals;\n\tstring public symbol;\n\n\tfunction totalSupply() public view returns (uint256);\n\n\tfunction balanceOf(address _who) public view returns (uint256);\n\n\tfunction allowance(address _owner, address _spender) public view returns (uint256);\n\n\tfunction approve(address _spender, uint256 _value) public returns (bool);\n\n\tfunction transfer(address _to, uint256 _value) public returns (bool);\n\n\tfunction transferFrom(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _value\n\t) public returns (bool);\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\n\n\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n\t// Empty internal constructor, to prevent people from mistakenly deploying\n\t// an instance of this contract, which should be used via inheritance.\n\tconstructor() internal {}\n\n\t// solhint-disable-previous-line no-empty-blocks\n\n\tfunction _msgSender() internal view returns (address payable) {\n\t\treturn msg.sender;\n\t}\n\n\tfunction _msgData() internal view returns (bytes memory) {\n\t\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\t\treturn msg.data;\n\t}\n}\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n\taddress private _owner;\n\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\t/**\n\t * @dev Initializes the contract setting the deployer as the initial owner.\n\t */\n\tconstructor() internal {\n\t\taddress msgSender = _msgSender();\n\t\t_owner = msgSender;\n\t\temit OwnershipTransferred(address(0), msgSender);\n\t}\n\n\t/**\n\t * @dev Returns the address of the current owner.\n\t */\n\tfunction owner() public view returns (address) {\n\t\treturn _owner;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the owner.\n\t */\n\tmodifier onlyOwner() {\n\t\trequire(isOwner(), \"unauthorized\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Returns true if the caller is the current owner.\n\t */\n\tfunction isOwner() public view returns (bool) {\n\t\treturn _msgSender() == _owner;\n\t}\n\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t * Can only be called by the current owner.\n\t */\n\tfunction transferOwnership(address newOwner) public onlyOwner {\n\t\t_transferOwnership(newOwner);\n\t}\n\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t */\n\tfunction _transferOwnership(address newOwner) internal {\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\t\temit OwnershipTransferred(_owner, newOwner);\n\t\t_owner = newOwner;\n\t}\n}\n\n\n\n\n\n\n\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n\t/**\n\t * @dev Returns the addition of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `+` operator.\n\t *\n\t * Requirements:\n\t * - Addition cannot overflow.\n\t */\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\trequire(c >= a, \"SafeMath: addition overflow\");\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t * - Subtraction cannot overflow.\n\t */\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn sub(a, b, \"SafeMath: subtraction overflow\");\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t * - Subtraction cannot overflow.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction sub(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\trequire(b <= a, errorMessage);\n\t\tuint256 c = a - b;\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the multiplication of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `*` operator.\n\t *\n\t * Requirements:\n\t * - Multiplication cannot overflow.\n\t */\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\t\t// benefit is lost if 'b' is also tested.\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 c = a * b;\n\t\trequire(c / a == b, \"SafeMath: multiplication overflow\");\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers. Reverts on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn div(a, b, \"SafeMath: division by zero\");\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction div(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\t// Solidity only automatically asserts when dividing by 0\n\t\trequire(b != 0, errorMessage);\n\t\tuint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Integer division of two numbers, rounding up and truncating the quotient\n\t */\n\tfunction divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn divCeil(a, b, \"SafeMath: division by zero\");\n\t}\n\n\t/**\n\t * @dev Integer division of two numbers, rounding up and truncating the quotient\n\t */\n\tfunction divCeil(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\t// Solidity only automatically asserts when dividing by 0\n\t\trequire(b != 0, errorMessage);\n\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 c = ((a - 1) / b) + 1;\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn mod(a, b, \"SafeMath: modulo by zero\");\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts with custom message when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction mod(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\trequire(b != 0, errorMessage);\n\t\treturn a % b;\n\t}\n\n\tfunction min256(uint256 _a, uint256 _b) internal pure returns (uint256) {\n\t\treturn _a < _b ? _a : _b;\n\t}\n}\n\n\ncontract VestingRegistry3 is Ownable {\n\tusing SafeMath for uint256;\n\n\tIVestingFactory public vestingFactory;\n\n\t///@notice the SOV token contract\n\taddress public SOV;\n\n\t///@notice the staking contract address\n\taddress public staking;\n\t//@notice fee sharing proxy\n\taddress public feeSharingProxy;\n\t//@notice the vesting owner (e.g. governance timelock address)\n\taddress public vestingOwner;\n\n\t//TODO add to the documentation: address can have only one vesting of each type\n\t//user => vesting type => vesting contract\n\tmapping(address => mapping(uint256 => address)) public vestingContracts;\n\n\t//user => flag whether user has admin role\n\tmapping(address => bool) public admins;\n\n\tenum VestingType {\n\t\tTeamVesting, //MultisigVesting\n\t\tVesting //TokenHolderVesting\n\t}\n\n\tevent SOVTransferred(address indexed receiver, uint256 amount);\n\tevent VestingCreated(address indexed tokenOwner, address vesting, uint256 cliff, uint256 duration, uint256 amount);\n\tevent TeamVestingCreated(address indexed tokenOwner, address vesting, uint256 cliff, uint256 duration, uint256 amount);\n\tevent TokensStaked(address indexed vesting, uint256 amount);\n\tevent AdminAdded(address admin);\n\tevent AdminRemoved(address admin);\n\n\tconstructor(\n\t\taddress _vestingFactory,\n\t\taddress _SOV,\n\t\taddress _staking,\n\t\taddress _feeSharingProxy,\n\t\taddress _vestingOwner\n\t) public {\n\t\trequire(_SOV != address(0), \"SOV address invalid\");\n\t\trequire(_staking != address(0), \"staking address invalid\");\n\t\trequire(_feeSharingProxy != address(0), \"feeSharingProxy address invalid\");\n\t\trequire(_vestingOwner != address(0), \"vestingOwner address invalid\");\n\n\t\t_setVestingFactory(_vestingFactory);\n\n\t\tSOV = _SOV;\n\t\tstaking = _staking;\n\t\tfeeSharingProxy = _feeSharingProxy;\n\t\tvestingOwner = _vestingOwner;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the owner or admin.\n\t */\n\tmodifier onlyAuthorized() {\n\t\trequire(isOwner() || admins[msg.sender], \"unauthorized\");\n\t\t_;\n\t}\n\n\tfunction addAdmin(address _admin) public onlyOwner {\n\t\tadmins[_admin] = true;\n\t\temit AdminAdded(_admin);\n\t}\n\n\tfunction removeAdmin(address _admin) public onlyOwner {\n\t\tadmins[_admin] = false;\n\t\temit AdminRemoved(_admin);\n\t}\n\n\t/**\n\t * @notice sets vesting factory address\n\t * @param _vestingFactory the address of vesting factory contract\n\t */\n\tfunction setVestingFactory(address _vestingFactory) public onlyOwner {\n\t\t_setVestingFactory(_vestingFactory);\n\t}\n\n\tfunction _setVestingFactory(address _vestingFactory) internal {\n\t\trequire(_vestingFactory != address(0), \"vestingFactory address invalid\");\n\t\tvestingFactory = IVestingFactory(_vestingFactory);\n\t}\n\n\t/**\n\t * @notice transfers SOV tokens to given address\n\t * @param _receiver the address of the SOV receiver\n\t * @param _amount the amount to be transferred\n\t */\n\tfunction transferSOV(address _receiver, uint256 _amount) public onlyOwner {\n\t\trequire(_receiver != address(0), \"receiver address invalid\");\n\t\trequire(_amount != 0, \"amount invalid\");\n\n\t\tIERC20(SOV).transfer(_receiver, _amount);\n\t\temit SOVTransferred(_receiver, _amount);\n\t}\n\n\t/**\n\t * @notice creates Vesting contract\n\t * @param _tokenOwner the owner of the tokens\n\t * @param _amount the amount to be staked\n\t * @param _cliff the cliff in seconds\n\t * @param _duration the total duration in seconds\n\t */\n\tfunction createVesting(\n\t\taddress _tokenOwner,\n\t\tuint256 _amount,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) public onlyAuthorized {\n\t\taddress vesting = _getOrCreateVesting(_tokenOwner, _cliff, _duration);\n\t\temit VestingCreated(_tokenOwner, vesting, _cliff, _duration, _amount);\n\t}\n\n\t/**\n\t * @notice creates Team Vesting contract\n\t * @param _tokenOwner the owner of the tokens\n\t * @param _amount the amount to be staked\n\t * @param _cliff the cliff in seconds\n\t * @param _duration the total duration in seconds\n\t */\n\tfunction createTeamVesting(\n\t\taddress _tokenOwner,\n\t\tuint256 _amount,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) public onlyAuthorized {\n\t\taddress vesting = _getOrCreateTeamVesting(_tokenOwner, _cliff, _duration);\n\t\temit TeamVestingCreated(_tokenOwner, vesting, _cliff, _duration, _amount);\n\t}\n\n\t/**\n\t * @notice stakes tokens according to the vesting schedule\n\t * @param _vesting the address of Vesting contract\n\t * @param _amount the amount of tokens to stake\n\t */\n\tfunction stakeTokens(address _vesting, uint256 _amount) public onlyAuthorized {\n\t\trequire(_vesting != address(0), \"vesting address invalid\");\n\t\trequire(_amount > 0, \"amount invalid\");\n\n\t\tIERC20(SOV).approve(_vesting, _amount);\n\t\tIVesting(_vesting).stakeTokens(_amount);\n\t\temit TokensStaked(_vesting, _amount);\n\t}\n\n\t/**\n\t * @notice returns vesting contract address for the given token owner\n\t * @param _tokenOwner the owner of the tokens\n\t */\n\tfunction getVesting(address _tokenOwner) public view returns (address) {\n\t\treturn vestingContracts[_tokenOwner][uint256(VestingType.Vesting)];\n\t}\n\n\t/**\n\t * @notice returns team vesting contract address for the given token owner\n\t * @param _tokenOwner the owner of the tokens\n\t */\n\tfunction getTeamVesting(address _tokenOwner) public view returns (address) {\n\t\treturn vestingContracts[_tokenOwner][uint256(VestingType.TeamVesting)];\n\t}\n\n\tfunction _getOrCreateVesting(\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) internal returns (address) {\n\t\tuint256 type_ = uint256(VestingType.Vesting);\n\t\tif (vestingContracts[_tokenOwner][type_] == address(0)) {\n\t\t\t//TODO Owner of OwnerVesting contracts - the same address as tokenOwner\n\t\t\taddress vesting = vestingFactory.deployVesting(SOV, staking, _tokenOwner, _cliff, _duration, feeSharingProxy, _tokenOwner);\n\t\t\tvestingContracts[_tokenOwner][type_] = vesting;\n\t\t}\n\t\treturn vestingContracts[_tokenOwner][type_];\n\t}\n\n\tfunction _getOrCreateTeamVesting(\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) internal returns (address) {\n\t\tuint256 type_ = uint256(VestingType.TeamVesting);\n\t\tif (vestingContracts[_tokenOwner][type_] == address(0)) {\n\t\t\taddress vesting = vestingFactory.deployTeamVesting(SOV, staking, _tokenOwner, _cliff, _duration, feeSharingProxy, vestingOwner);\n\t\t\tvestingContracts[_tokenOwner][type_] = vesting;\n\t\t}\n\t\treturn vestingContracts[_tokenOwner][type_];\n\t}\n}\n\n\n\n",
    "imports": [
        {
            "name": "VestingRegistry3.sol",
            "contents": "pragma solidity ^0.5.17;\n\ninterface ITeamVesting {\n\tfunction governanceWithdrawTokens(address receiver) external;\n}\n\n\ninterface IVesting {\n\tfunction duration() external returns (uint256);\n\n\tfunction endDate() external returns (uint256);\n\n\tfunction stakeTokens(uint256 amount) external;\n}\n\n\ninterface IVestingFactory {\n\tfunction deployVesting(\n\t\taddress _SOV,\n\t\taddress _staking,\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration,\n\t\taddress _feeSharing,\n\t\taddress _owner\n\t) external returns (address);\n\n\tfunction deployTeamVesting(\n\t\taddress _SOV,\n\t\taddress _staking,\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration,\n\t\taddress _feeSharing,\n\t\taddress _owner\n\t) external returns (address);\n}\n\n\ninterface IFeeSharingProxy {\n\tfunction withdrawFees(address _token) external;\n\n\tfunction transferTokens(address _token, uint96 _amount) external;\n\n\tfunction withdraw(\n\t\taddress _loanPoolToken,\n\t\tuint32 _maxCheckpoints,\n\t\taddress _receiver\n\t) external;\n}\n\n\ninterface IStaking {\n\tfunction stakesBySchedule(\n\t\tuint256 amount,\n\t\tuint256 cliff,\n\t\tuint256 duration,\n\t\tuint256 intervalLength,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) external;\n\n\tfunction stake(\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) external;\n\n\tfunction getPriorVotes(\n\t\taddress account,\n\t\tuint256 blockNumber,\n\t\tuint256 date\n\t) external view returns (uint96);\n\n\tfunction getPriorTotalVotingPower(uint32 blockNumber, uint256 time) external view returns (uint96);\n\n\tfunction getPriorWeightedStake(\n\t\taddress account,\n\t\tuint256 blockNumber,\n\t\tuint256 date\n\t) external view returns (uint96);\n\n\tfunction timestampToLockDate(uint256 timestamp) external view returns (uint256 lockDate);\n}\n/**\n * Copyright 2017-2021, bZeroX, LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0.\n */\n\n\n\ncontract IERC20 {\n\tstring public name;\n\tuint8 public decimals;\n\tstring public symbol;\n\n\tfunction totalSupply() public view returns (uint256);\n\n\tfunction balanceOf(address _who) public view returns (uint256);\n\n\tfunction allowance(address _owner, address _spender) public view returns (uint256);\n\n\tfunction approve(address _spender, uint256 _value) public returns (bool);\n\n\tfunction transfer(address _to, uint256 _value) public returns (bool);\n\n\tfunction transferFrom(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _value\n\t) public returns (bool);\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\n\n\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n\t// Empty internal constructor, to prevent people from mistakenly deploying\n\t// an instance of this contract, which should be used via inheritance.\n\tconstructor() internal {}\n\n\t// solhint-disable-previous-line no-empty-blocks\n\n\tfunction _msgSender() internal view returns (address payable) {\n\t\treturn msg.sender;\n\t}\n\n\tfunction _msgData() internal view returns (bytes memory) {\n\t\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\t\treturn msg.data;\n\t}\n}\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n\taddress private _owner;\n\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\t/**\n\t * @dev Initializes the contract setting the deployer as the initial owner.\n\t */\n\tconstructor() internal {\n\t\taddress msgSender = _msgSender();\n\t\t_owner = msgSender;\n\t\temit OwnershipTransferred(address(0), msgSender);\n\t}\n\n\t/**\n\t * @dev Returns the address of the current owner.\n\t */\n\tfunction owner() public view returns (address) {\n\t\treturn _owner;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the owner.\n\t */\n\tmodifier onlyOwner() {\n\t\trequire(isOwner(), \"unauthorized\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Returns true if the caller is the current owner.\n\t */\n\tfunction isOwner() public view returns (bool) {\n\t\treturn _msgSender() == _owner;\n\t}\n\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t * Can only be called by the current owner.\n\t */\n\tfunction transferOwnership(address newOwner) public onlyOwner {\n\t\t_transferOwnership(newOwner);\n\t}\n\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t */\n\tfunction _transferOwnership(address newOwner) internal {\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\t\temit OwnershipTransferred(_owner, newOwner);\n\t\t_owner = newOwner;\n\t}\n}\n\n\n\n\n\n\n\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n\t/**\n\t * @dev Returns the addition of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `+` operator.\n\t *\n\t * Requirements:\n\t * - Addition cannot overflow.\n\t */\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\trequire(c >= a, \"SafeMath: addition overflow\");\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t * - Subtraction cannot overflow.\n\t */\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn sub(a, b, \"SafeMath: subtraction overflow\");\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t * - Subtraction cannot overflow.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction sub(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\trequire(b <= a, errorMessage);\n\t\tuint256 c = a - b;\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the multiplication of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `*` operator.\n\t *\n\t * Requirements:\n\t * - Multiplication cannot overflow.\n\t */\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\t\t// benefit is lost if 'b' is also tested.\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 c = a * b;\n\t\trequire(c / a == b, \"SafeMath: multiplication overflow\");\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers. Reverts on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn div(a, b, \"SafeMath: division by zero\");\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction div(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\t// Solidity only automatically asserts when dividing by 0\n\t\trequire(b != 0, errorMessage);\n\t\tuint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Integer division of two numbers, rounding up and truncating the quotient\n\t */\n\tfunction divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn divCeil(a, b, \"SafeMath: division by zero\");\n\t}\n\n\t/**\n\t * @dev Integer division of two numbers, rounding up and truncating the quotient\n\t */\n\tfunction divCeil(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\t// Solidity only automatically asserts when dividing by 0\n\t\trequire(b != 0, errorMessage);\n\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 c = ((a - 1) / b) + 1;\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn mod(a, b, \"SafeMath: modulo by zero\");\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts with custom message when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction mod(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\trequire(b != 0, errorMessage);\n\t\treturn a % b;\n\t}\n\n\tfunction min256(uint256 _a, uint256 _b) internal pure returns (uint256) {\n\t\treturn _a < _b ? _a : _b;\n\t}\n}\n\n\ncontract VestingRegistry3 is Ownable {\n\tusing SafeMath for uint256;\n\n\tIVestingFactory public vestingFactory;\n\n\t///@notice the SOV token contract\n\taddress public SOV;\n\n\t///@notice the staking contract address\n\taddress public staking;\n\t//@notice fee sharing proxy\n\taddress public feeSharingProxy;\n\t//@notice the vesting owner (e.g. governance timelock address)\n\taddress public vestingOwner;\n\n\t//TODO add to the documentation: address can have only one vesting of each type\n\t//user => vesting type => vesting contract\n\tmapping(address => mapping(uint256 => address)) public vestingContracts;\n\n\t//user => flag whether user has admin role\n\tmapping(address => bool) public admins;\n\n\tenum VestingType {\n\t\tTeamVesting, //MultisigVesting\n\t\tVesting //TokenHolderVesting\n\t}\n\n\tevent SOVTransferred(address indexed receiver, uint256 amount);\n\tevent VestingCreated(address indexed tokenOwner, address vesting, uint256 cliff, uint256 duration, uint256 amount);\n\tevent TeamVestingCreated(address indexed tokenOwner, address vesting, uint256 cliff, uint256 duration, uint256 amount);\n\tevent TokensStaked(address indexed vesting, uint256 amount);\n\tevent AdminAdded(address admin);\n\tevent AdminRemoved(address admin);\n\n\tconstructor(\n\t\taddress _vestingFactory,\n\t\taddress _SOV,\n\t\taddress _staking,\n\t\taddress _feeSharingProxy,\n\t\taddress _vestingOwner\n\t) public {\n\t\trequire(_SOV != address(0), \"SOV address invalid\");\n\t\trequire(_staking != address(0), \"staking address invalid\");\n\t\trequire(_feeSharingProxy != address(0), \"feeSharingProxy address invalid\");\n\t\trequire(_vestingOwner != address(0), \"vestingOwner address invalid\");\n\n\t\t_setVestingFactory(_vestingFactory);\n\n\t\tSOV = _SOV;\n\t\tstaking = _staking;\n\t\tfeeSharingProxy = _feeSharingProxy;\n\t\tvestingOwner = _vestingOwner;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the owner or admin.\n\t */\n\tmodifier onlyAuthorized() {\n\t\trequire(isOwner() || admins[msg.sender], \"unauthorized\");\n\t\t_;\n\t}\n\n\tfunction addAdmin(address _admin) public onlyOwner {\n\t\tadmins[_admin] = true;\n\t\temit AdminAdded(_admin);\n\t}\n\n\tfunction removeAdmin(address _admin) public onlyOwner {\n\t\tadmins[_admin] = false;\n\t\temit AdminRemoved(_admin);\n\t}\n\n\t/**\n\t * @notice sets vesting factory address\n\t * @param _vestingFactory the address of vesting factory contract\n\t */\n\tfunction setVestingFactory(address _vestingFactory) public onlyOwner {\n\t\t_setVestingFactory(_vestingFactory);\n\t}\n\n\tfunction _setVestingFactory(address _vestingFactory) internal {\n\t\trequire(_vestingFactory != address(0), \"vestingFactory address invalid\");\n\t\tvestingFactory = IVestingFactory(_vestingFactory);\n\t}\n\n\t/**\n\t * @notice transfers SOV tokens to given address\n\t * @param _receiver the address of the SOV receiver\n\t * @param _amount the amount to be transferred\n\t */\n\tfunction transferSOV(address _receiver, uint256 _amount) public onlyOwner {\n\t\trequire(_receiver != address(0), \"receiver address invalid\");\n\t\trequire(_amount != 0, \"amount invalid\");\n\n\t\tIERC20(SOV).transfer(_receiver, _amount);\n\t\temit SOVTransferred(_receiver, _amount);\n\t}\n\n\t/**\n\t * @notice creates Vesting contract\n\t * @param _tokenOwner the owner of the tokens\n\t * @param _amount the amount to be staked\n\t * @param _cliff the cliff in seconds\n\t * @param _duration the total duration in seconds\n\t */\n\tfunction createVesting(\n\t\taddress _tokenOwner,\n\t\tuint256 _amount,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) public onlyAuthorized {\n\t\taddress vesting = _getOrCreateVesting(_tokenOwner, _cliff, _duration);\n\t\temit VestingCreated(_tokenOwner, vesting, _cliff, _duration, _amount);\n\t}\n\n\t/**\n\t * @notice creates Team Vesting contract\n\t * @param _tokenOwner the owner of the tokens\n\t * @param _amount the amount to be staked\n\t * @param _cliff the cliff in seconds\n\t * @param _duration the total duration in seconds\n\t */\n\tfunction createTeamVesting(\n\t\taddress _tokenOwner,\n\t\tuint256 _amount,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) public onlyAuthorized {\n\t\taddress vesting = _getOrCreateTeamVesting(_tokenOwner, _cliff, _duration);\n\t\temit TeamVestingCreated(_tokenOwner, vesting, _cliff, _duration, _amount);\n\t}\n\n\t/**\n\t * @notice stakes tokens according to the vesting schedule\n\t * @param _vesting the address of Vesting contract\n\t * @param _amount the amount of tokens to stake\n\t */\n\tfunction stakeTokens(address _vesting, uint256 _amount) public onlyAuthorized {\n\t\trequire(_vesting != address(0), \"vesting address invalid\");\n\t\trequire(_amount > 0, \"amount invalid\");\n\n\t\tIERC20(SOV).approve(_vesting, _amount);\n\t\tIVesting(_vesting).stakeTokens(_amount);\n\t\temit TokensStaked(_vesting, _amount);\n\t}\n\n\t/**\n\t * @notice returns vesting contract address for the given token owner\n\t * @param _tokenOwner the owner of the tokens\n\t */\n\tfunction getVesting(address _tokenOwner) public view returns (address) {\n\t\treturn vestingContracts[_tokenOwner][uint256(VestingType.Vesting)];\n\t}\n\n\t/**\n\t * @notice returns team vesting contract address for the given token owner\n\t * @param _tokenOwner the owner of the tokens\n\t */\n\tfunction getTeamVesting(address _tokenOwner) public view returns (address) {\n\t\treturn vestingContracts[_tokenOwner][uint256(VestingType.TeamVesting)];\n\t}\n\n\tfunction _getOrCreateVesting(\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) internal returns (address) {\n\t\tuint256 type_ = uint256(VestingType.Vesting);\n\t\tif (vestingContracts[_tokenOwner][type_] == address(0)) {\n\t\t\t//TODO Owner of OwnerVesting contracts - the same address as tokenOwner\n\t\t\taddress vesting = vestingFactory.deployVesting(SOV, staking, _tokenOwner, _cliff, _duration, feeSharingProxy, _tokenOwner);\n\t\t\tvestingContracts[_tokenOwner][type_] = vesting;\n\t\t}\n\t\treturn vestingContracts[_tokenOwner][type_];\n\t}\n\n\tfunction _getOrCreateTeamVesting(\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) internal returns (address) {\n\t\tuint256 type_ = uint256(VestingType.TeamVesting);\n\t\tif (vestingContracts[_tokenOwner][type_] == address(0)) {\n\t\t\taddress vesting = vestingFactory.deployTeamVesting(SOV, staking, _tokenOwner, _cliff, _duration, feeSharingProxy, vestingOwner);\n\t\t\tvestingContracts[_tokenOwner][type_] = vesting;\n\t\t}\n\t\treturn vestingContracts[_tokenOwner][type_];\n\t}\n}\n\n\n\n",
            "file": "VestingRegistry3.sol"
        }
    ],
    "libraries": {},
    "constructorArguments": [
        "0x80cec9386a25a60f11f2b9f6cb732c03029bd695",
        "0xefc78fc7d48b64958315949279ba181c2114abbd",
        "0x5684a06cab22db16d901fee2a5c081b4c91ea40e",
        "0x12b1b0c67d9a771eb5db7726d23fdc6848fd93ef",
        "0x924f5ad34698fd20c90fe5d5a8a0abd3b42dc711"
    ],
    "creationData": {
        "blockHash": "0x0b2d97cfd081d9298c9ce7c44a8bad98da877d9b6804564cd63eb2baef0121e2",
        "blockNumber": 3306660,
        "transactionHash": "0x4b5d51d67818b565cefe47ec5924a2d0426acae07fd067805929bc795c2c6458",
        "timestamp": 1619676591
    }
}