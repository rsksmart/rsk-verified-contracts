{
    "address": "0x5684a06cab22db16d901fee2a5c081b4c91ea40e",
    "net": {
        "id": "30",
        "name": "RSK Mainnet"
    },
    "name": "StakingProxy",
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        }
    },
    "version": "0.5.17+commit.d19bba13",
    "source": "pragma solidity ^0.5.17;\n\nimport \"./StakingStorage.sol\";\nimport \"../../proxy/UpgradableProxy.sol\";\n\n/**\n * @dev Staking contract should be upgradable, use UpgradableProxy\n */\ncontract StakingProxy is StakingStorage, UpgradableProxy {\n\t/**\n\t * @notice Construct a new staking contract\n\t * @param SOV The address of the SOV token address\n\t */\n\tconstructor(address SOV) public {\n\t\tSOVToken = IERC20(SOV);\n\t\tkickoffTS = block.timestamp;\n\t}\n}\n",
    "imports": [
        {
            "name": "StakingProxy.sol",
            "contents": "pragma solidity ^0.5.17;\n\nimport \"./StakingStorage.sol\";\nimport \"../../proxy/UpgradableProxy.sol\";\n\n/**\n * @dev Staking contract should be upgradable, use UpgradableProxy\n */\ncontract StakingProxy is StakingStorage, UpgradableProxy {\n\t/**\n\t * @notice Construct a new staking contract\n\t * @param SOV The address of the SOV token address\n\t */\n\tconstructor(address SOV) public {\n\t\tSOVToken = IERC20(SOV);\n\t\tkickoffTS = block.timestamp;\n\t}\n}\n",
            "file": "StakingProxy.sol"
        },
        {
            "name": "StakingStorage.sol",
            "contents": "pragma solidity ^0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"../../openzeppelin/Ownable.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../IFeeSharingProxy.sol\";\n\ncontract StakingStorage is Ownable {\n\t///@notice 2 weeks in seconds\n\tuint256 constant TWO_WEEKS = 1209600;\n\n\t///@notice the maximum possible voting weight before adding +1 (actually 10, but need 9 for computation)\n\tuint96 public constant MAX_VOTING_WEIGHT = 9;\n\n\t///@notice weight is multiplied with this factor (for allowing decimals, like 1.2x)\n\t///@dev MAX_VOTING_WEIGHT * WEIGHT_FACTOR needs to be < 792, because there are 100,000,000 SOV with 18 decimals\n\tuint96 public constant WEIGHT_FACTOR = 10;\n\n\t/// @notice the maximum duration to stake tokens for\n\tuint256 public constant MAX_DURATION = 1092 days;\n\n\t///@notice the maximum duration ^2\n\tuint96 constant MAX_DURATION_POW_2 = 1092 * 1092;\n\n\t///@notice default weight scaling\n\tuint96 constant DEFAULT_WEIGHT_SCALING = 3;\n\n\t///@notice range for weight scaling\n\tuint96 constant MIN_WEIGHT_SCALING = 1;\n\tuint96 constant MAX_WEIGHT_SCALING = 9;\n\n\t///@notice the timestamp of contract creation. base for the staking period calculation\n\tuint256 public kickoffTS;\n\n\tstring name = \"SOVStaking\";\n\n\t/// @notice the token to be staked\n\tIERC20 public SOVToken;\n\n\t/// @notice A record of each accounts delegate\n\tmapping(address => mapping(uint256 => address)) public delegates;\n\n\t/// @notice if this flag is set to true, all tokens are unlocked immediately\n\tbool public allUnlocked = false;\n\n\t/// @notice The EIP-712 typehash for the contract's domain\n\tbytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n\t/// @notice The EIP-712 typehash for the delegation struct used by the contract\n\tbytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 lockDate,uint256 nonce,uint256 expiry)\");\n\n\t/// @notice used for stake migrations to a new staking contract with a different storage structure\n\taddress public newStakingContract;\n\n\t/*************************** Checkpoints *******************************/\n\n\t/// @notice A checkpoint for marking the stakes from a given block\n\tstruct Checkpoint {\n\t\tuint32 fromBlock;\n\t\tuint96 stake;\n\t}\n\n\t/// @notice A record of tokens to be unstaked at a given time in total\n\t/// for total voting power computation. voting weights get adjusted bi-weekly\n\n\tmapping(uint256 => mapping(uint32 => Checkpoint)) public totalStakingCheckpoints;\n\n\t///@notice The number of total staking checkpoints for each date\n\tmapping(uint256 => uint32) public numTotalStakingCheckpoints;\n\n\t/// @notice A record of tokens to be unstaked at a given time which were delegated to a certain address\n\t/// for delegatee voting power computation. voting weights get adjusted bi-weekly\n\tmapping(address => mapping(uint256 => mapping(uint32 => Checkpoint))) public delegateStakingCheckpoints;\n\n\t///@notice The number of total staking checkpoints for each date per delegate\n\tmapping(address => mapping(uint256 => uint32)) public numDelegateStakingCheckpoints;\n\n\t/// @notice A record of tokens to be unstaked at a given time which per user address (address -> lockDate -> stake checkpoint)\n\tmapping(address => mapping(uint256 => mapping(uint32 => Checkpoint))) public userStakingCheckpoints;\n\n\t///@notice The number of total staking checkpoints for each date per user\n\tmapping(address => mapping(uint256 => uint32)) public numUserStakingCheckpoints;\n\n\t/// @notice A record of states for signing / validating signatures\n\tmapping(address => uint256) public nonces;\n\n\t/*************************** Slashing *******************************/\n\n\t/// @notice the address of FeeSharingProxy contract, we need it for unstaking with slashing\n\tIFeeSharingProxy public feeSharing;\n\n\t// @notice used for weight scaling when unstaking with slashing\n\tuint96 public weightScaling = DEFAULT_WEIGHT_SCALING;\n\n\t// @notice list of Vesting contracts, tokens for these contracts won't be slashed if unstaked by governance\n\tmapping(address => bool) public vestingWhitelist;\n}\n"
        },
        {
            "name": "IERC20_.sol",
            "contents": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20_ {\n\t/**\n\t * @dev Returns the amount of tokens in existence.\n\t */\n\tfunction totalSupply() external view returns (uint256);\n\n\t/**\n\t * @dev Returns the amount of tokens owned by `account`.\n\t */\n\tfunction balanceOf(address account) external view returns (uint256);\n\n\t/**\n\t * @dev Moves `amount` tokens from the caller's account to `recipient`.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\n\n\t/**\n\t * @dev Returns the remaining number of tokens that `spender` will be\n\t * allowed to spend on behalf of `owner` through {transferFrom}. This is\n\t * zero by default.\n\t *\n\t * This value changes when {approve} or {transferFrom} are called.\n\t */\n\tfunction allowance(address owner, address spender) external view returns (uint256);\n\n\t/**\n\t * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * IMPORTANT: Beware that changing an allowance with this method brings the risk\n\t * that someone may use both the old and the new allowance by unfortunate\n\t * transaction ordering. One possible solution to mitigate this race\n\t * condition is to first reduce the spender's allowance to 0 and set the\n\t * desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t *\n\t * Emits an {Approval} event.\n\t */\n\tfunction approve(address spender, uint256 amount) external returns (bool);\n\n\t/**\n\t * @dev Moves `amount` tokens from `sender` to `recipient` using the\n\t * allowance mechanism. `amount` is then deducted from the caller's\n\t * allowance.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction transferFrom(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) external returns (bool);\n\n\t/**\n\t * @dev Emitted when `value` tokens are moved from one account (`from`) to\n\t * another (`to`).\n\t *\n\t * Note that `value` may be zero.\n\t */\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n\t * a call to {approve}. `value` is the new allowance.\n\t */\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
        },
        {
            "name": "Ownable.sol",
            "contents": "pragma solidity >=0.5.0 <0.6.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n\taddress private _owner;\n\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\t/**\n\t * @dev Initializes the contract setting the deployer as the initial owner.\n\t */\n\tconstructor() internal {\n\t\taddress msgSender = _msgSender();\n\t\t_owner = msgSender;\n\t\temit OwnershipTransferred(address(0), msgSender);\n\t}\n\n\t/**\n\t * @dev Returns the address of the current owner.\n\t */\n\tfunction owner() public view returns (address) {\n\t\treturn _owner;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the owner.\n\t */\n\tmodifier onlyOwner() {\n\t\trequire(isOwner(), \"unauthorized\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Returns true if the caller is the current owner.\n\t */\n\tfunction isOwner() public view returns (bool) {\n\t\treturn _msgSender() == _owner;\n\t}\n\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t * Can only be called by the current owner.\n\t */\n\tfunction transferOwnership(address newOwner) public onlyOwner {\n\t\t_transferOwnership(newOwner);\n\t}\n\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t */\n\tfunction _transferOwnership(address newOwner) internal {\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\t\temit OwnershipTransferred(_owner, newOwner);\n\t\t_owner = newOwner;\n\t}\n}\n"
        },
        {
            "name": "Proxy.sol",
            "contents": "pragma solidity ^0.5.17;\n\n/**\n * @title Base Proxy Contract\n */\ncontract Proxy {\n\tbytes32 private constant KEY_IMPLEMENTATION = keccak256(\"key.implementation\");\n\tbytes32 private constant KEY_OWNER = keccak256(\"key.proxy.owner\");\n\n\tevent OwnershipTransferred(address indexed _oldOwner, address indexed _newOwner);\n\tevent ImplementationChanged(address indexed _oldImplementation, address indexed _newImplementation);\n\n\t/**\n\t * @notice Sets sender as an owner\n\t */\n\tconstructor() public {\n\t\t_setProxyOwner(msg.sender);\n\t}\n\n\t/**\n\t * @notice Throws error if called not by an owner\n\t */\n\tmodifier onlyProxyOwner() {\n\t\trequire(msg.sender == getProxyOwner(), \"Proxy:: access denied\");\n\t\t_;\n\t}\n\n\tfunction _setImplementation(address _implementation) internal {\n\t\trequire(_implementation != address(0), \"Proxy::setImplementation: invalid address\");\n\t\temit ImplementationChanged(getImplementation(), _implementation);\n\n\t\tbytes32 key = KEY_IMPLEMENTATION;\n\t\tassembly {\n\t\t\tsstore(key, _implementation)\n\t\t}\n\t}\n\n\t/**\n\t * @notice Returns address of the implementation\n\t * @return address of the implementation\n\t */\n\tfunction getImplementation() public view returns (address _implementation) {\n\t\tbytes32 key = KEY_IMPLEMENTATION;\n\t\tassembly {\n\t\t\t_implementation := sload(key)\n\t\t}\n\t}\n\n\tfunction _setProxyOwner(address _owner) internal {\n\t\trequire(_owner != address(0), \"Proxy::setProxyOwner: invalid address\");\n\t\temit OwnershipTransferred(getProxyOwner(), _owner);\n\n\t\tbytes32 key = KEY_OWNER;\n\t\tassembly {\n\t\t\tsstore(key, _owner)\n\t\t}\n\t}\n\n\t/**\n\t * @notice Returns address of the owner\n\t * @return address of the owner\n\t */\n\tfunction getProxyOwner() public view returns (address _owner) {\n\t\tbytes32 key = KEY_OWNER;\n\t\tassembly {\n\t\t\t_owner := sload(key)\n\t\t}\n\t}\n\n\t/**\n\t * @notice Fallback function performs a delegate call\n\t * Returns whatever the implementation call returns\n\t */\n\tfunction() external payable {\n\t\taddress implementation = getImplementation();\n\t\trequire(implementation != address(0), \"Proxy::(): implementation not found\");\n\n\t\tassembly {\n\t\t\tlet pointer := mload(0x40)\n\t\t\tcalldatacopy(pointer, 0, calldatasize)\n\t\t\tlet result := delegatecall(gas, implementation, pointer, calldatasize, 0, 0)\n\t\t\tlet size := returndatasize\n\t\t\treturndatacopy(pointer, 0, size)\n\n\t\t\tswitch result\n\t\t\t\tcase 0 {\n\t\t\t\t\trevert(pointer, size)\n\t\t\t\t}\n\t\t\t\tdefault {\n\t\t\t\t\treturn(pointer, size)\n\t\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
            "name": "UpgradableProxy.sol",
            "contents": "pragma solidity ^0.5.17;\n\nimport \"./Proxy.sol\";\n\n/**\n * @title Upgradable Proxy Contract\n */\ncontract UpgradableProxy is Proxy {\n\t/**\n\t * @notice Sets address of the implementation\n\t * @param _implementation Address of the implementation\n\t */\n\tfunction setImplementation(address _implementation) public onlyProxyOwner {\n\t\t_setImplementation(_implementation);\n\t}\n\n\t/**\n\t * @notice Sets address of the owner\n\t * @param _owner Address of the owner\n\t */\n\tfunction setProxyOwner(address _owner) public onlyProxyOwner {\n\t\t_setProxyOwner(_owner);\n\t}\n}\n"
        },
        {
            "name": "IFeeSharingProxy.sol",
            "contents": "pragma solidity ^0.5.17;\n\ninterface IFeeSharingProxy {\n\tfunction withdrawFees(address _token) external;\n\n\tfunction transferTokens(address _token, uint96 _amount) external;\n\n\tfunction withdraw(\n\t\taddress _loanPoolToken,\n\t\tuint32 _maxCheckpoints,\n\t\taddress _receiver\n\t) external;\n}\n"
        },
        {
            "name": "IERC20.sol",
            "contents": "/**\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0.\n */\n\npragma solidity >=0.5.0 <0.6.0;\n\ncontract IERC20 {\n\tstring public name;\n\tuint8 public decimals;\n\tstring public symbol;\n\n\tfunction totalSupply() public view returns (uint256);\n\n\tfunction balanceOf(address _who) public view returns (uint256);\n\n\tfunction transfer(address _to, uint256 _value) public returns (bool);\n\n\tfunction allowance(address _owner, address _spender) public view returns (uint256);\n\n\tfunction transferFrom(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _value\n\t) public returns (bool);\n\n\tfunction approve(address _spender, uint256 _value) public returns (bool);\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
        },
        {
            "name": "Context.sol",
            "contents": "pragma solidity >=0.5.0 <0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n\t// Empty internal constructor, to prevent people from mistakenly deploying\n\t// an instance of this contract, which should be used via inheritance.\n\tconstructor() internal {}\n\n\t// solhint-disable-previous-line no-empty-blocks\n\n\tfunction _msgSender() internal view returns (address payable) {\n\t\treturn msg.sender;\n\t}\n\n\tfunction _msgData() internal view returns (bytes memory) {\n\t\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\t\treturn msg.data;\n\t}\n}\n"
        }
    ],
    "libraries": {},
    "constructorArguments": [
        "0xEFc78fc7d48b64958315949279Ba181c2114ABBd"
    ],
    "creationData": {
        "blockHash": "0x3b7567411a7e9cd895e6e35e542d57dfe7d8d5f6caef183df030236573344106",
        "blockNumber": 3100263,
        "transactionHash": "0x0e67069806fc52c3682ccc95d341ed31c1a8df4b69975a55f885da1fbc09a83d",
        "timestamp": 1613125695
    }
}