{
    "address": "0xa330a7a3b439a139315f0c90819b04e6716abe12",
    "net": {
        "id": "30",
        "name": "RSK Mainnet"
    },
    "name": "DelayMachine",
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        }
    },
    "version": "0.6.12+commit.27d51765",
    "source": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.12;\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n\n\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n    /**\n      @notice Override this function with a recipe of the changes to be done when this ChangeContract\n      is executed\n     */\n    function execute() external;\n}\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor {\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @dev This function should be protected somehow to only execute changes that\n      benefit the system. This decision process is independent of this architechture\n      therefore is independent of this interface too\n      @param changeContract Address of the contract that will execute the changes\n     */\n    function executeChange(ChangeContract changeContract) external;\n\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @param _changer Address of the contract that will execute the changes\n     */\n    function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed {\n    /**\n      @notice The address of the contract which governs this one\n     */\n    IGovernor public governor;\n\n    string private constant NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n    /**\n      @notice Modifier that protects the function\n      @dev You should use this modifier in any function that should be called through\n      the governance system\n     */\n    modifier onlyAuthorizedChanger() {\n        require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n        _;\n    }\n\n    /**\n      @notice Initialize the contract with the basic settings\n      @dev This initialize replaces the constructor but it is not called automatically.\n      It is necessary because of the upgradeability of the contracts\n      @param _governor Governor address\n     */\n    function _initialize(IGovernor _governor) internal {\n        governor = _governor;\n    }\n\n    /**\n      @notice Change the contract's governor. Should be called through the old governance system\n      @param newIGovernor New governor address\n     */\n    function changeIGovernor(IGovernor newIGovernor) external onlyAuthorizedChanger {\n        governor = newIGovernor;\n    }\n\n    /**\n      @notice This method is used by a change contract to access the storage freely even without a setter.\n      @param data the serialized function arguments\n     */\n    function delegateCallToChanger(bytes calldata data)\n        external\n        onlyAuthorizedChanger\n        returns (bytes memory)\n    {\n        address changerContrat = msg.sender;\n        (bool success, bytes memory result) = changerContrat.delegatecall(\n            abi.encodeWithSignature(\"impersonate(bytes)\", data)\n        );\n        require(success, \"Error in delegate call\");\n        return result;\n    }\n\n    // Leave a gap betweeen inherited contracts variables in order to be\n    // able to add more variables in them later\n    uint256[50] private upgradeGap;\n}\n\n\n\n\n\ninterface IRegistry {\n    // *** Getter Methods ***\n    function getDecimal(bytes32 _key) external view returns (int232 base, int16 exp);\n\n    function getUint(bytes32 _key) external view returns (uint248);\n\n    function getString(bytes32 _key) external view returns (string memory);\n\n    function getAddress(bytes32 _key) external view returns (address);\n\n    function getBytes(bytes32 _key) external view returns (bytes memory);\n\n    function getBool(bytes32 _key) external view returns (bool);\n\n    function getInt(bytes32 _key) external view returns (int248);\n\n    // *** Setter Methods ***\n    function setDecimal(\n        bytes32 _key,\n        int232 _base,\n        int16 _exp\n    ) external;\n\n    function setUint(bytes32 _key, uint248 _value) external;\n\n    function setString(bytes32 _key, string calldata _value) external;\n\n    function setAddress(bytes32 _key, address _value) external;\n\n    function setBytes(bytes32 _key, bytes calldata _value) external;\n\n    function setBool(bytes32 _key, bool _value) external;\n\n    function setInt(bytes32 _key, int248 _value) external;\n\n    // *** Delete Methods ***\n    function deleteDecimal(bytes32 _key) external;\n\n    function deleteUint(bytes32 _key) external;\n\n    function deleteString(bytes32 _key) external;\n\n    function deleteAddress(bytes32 _key) external;\n\n    function deleteBytes(bytes32 _key) external;\n\n    function deleteBool(bytes32 _key) external;\n\n    function deleteInt(bytes32 _key) external;\n\n    // Nov 2020 Upgrade\n    // *** Getter Methods ***\n    function getAddressArrayLength(bytes32 _key) external view returns (uint256);\n\n    function getAddressArrayElementAt(bytes32 _key, uint256 idx) external view returns (address);\n\n    function pushAddressArrayElement(bytes32 _key, address _addr) external;\n\n    function getAddressArray(bytes32 _key) external view returns (address[] memory);\n\n    function addressArrayContains(bytes32 _key, address value) external view returns (bool);\n\n    // *** Setters ***\n    function pushAddressArray(bytes32 _key, address[] memory data) external;\n\n    function clearAddressArray(bytes32 _key) external;\n\n    function removeAddressArrayElement(bytes32 _key, address value) external;\n}\n\n\n/// @title This contract provides an interface for feeding prices from oracles, and\n///        get the current price. One contract must be instanced per supported coin pair,\n///        and registered through OracleManager global contract.\n/// This contract has two lists:\n/// 1) A subscribed list (EnumerableSet.AddressSet) oracles owner addresses, this list has a max size (30).\n/// 2) A selected list, EnumerableSet.AddressSet of oracles owner addresses that are selected to participate in\n/// current publication round (10 entries max size).\n///\n/// Oracles are subscribed by adding them to the subscribed oracle list. When the list is full\n/// the oracle with less stake can be removed by a new oracle that is trying to\n/// subscribe (if its stake is greater than his).\n/// On each round switch the list of selected oracles is populated with the 10 Oracles with more stake. An oracle\n/// can unsubscribe itself from the subscribed list in the middle of the round, in this case, the oracle is still\n/// listed in the selected list until the round ends.\n/// If an oracle withdraw some stake then his participation in the round is put into consideration: If the\n/// oracle ends up having less stake than the next oracle in the subscribed list (but not in the selected list) then\n/// it is removed from the selected list and the point he accumulated during the round are lost (set to zero).\n\ninterface ICoinPairPrice {\n    // getOracleOwnerAddress: Given an Oracle address return the Oracle Owner address.\n    // Used during publication, the servers sign with the oracle address, but the list of selected oracles\n    // is by oracle owner address.\n    // getOracleOwnerStake: Get the stake stored in the supporters smart-contract\n    // prettier-ignore\n    struct CoinPairPriceCallbacks {\n        function (address) external view returns (address) getOracleOwnerAddress;\n        function (address) external view returns (uint256) getOracleOwnerStake;\n    }\n\n    /// @notice subscribe an oracle to this coin pair, allowing it to be selected in the next round.\n    /// If the subscribed list is full and the current oracle has more stake than one with minimum stake in the\n    /// subscribed list, then the one with minimum stake is replaced.\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\n    /// @dev This is designed to be called from OracleManager.\n    function subscribe(address oracleOwnerAddr) external;\n\n    /// @notice Unsubscribe an oracle from this coin pair. The oracle won't be selected in the next round.\n    /// After the round end, the oracle can withdraw stake without having the risk of loosing won points.\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\n    /// @dev This is designed to be called from OracleManager.\n    function unsubscribe(address oracleOwnerAddr) external;\n\n    /// @notice Returns true if an oracle is subscribed to this contract' coin pair\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\n    /// @dev This is designed to be called from OracleManager.\n    function isSubscribed(address oracleOwnerAddr) external view returns (bool);\n\n    /// @notice Publish a price. (The message contain oracleAddresses that must be converted to owner addresses).\n    /// @param _version Version number of message format (3)\n    /// @param _coinpair The coin pair to report (must match this contract)\n    /// @param _price Price to report.\n    /// @param _votedOracle The address of the oracle voted as a publisher by the network.\n    /// @param _blockNumber The block number acting as nonce to prevent replay attacks.\n    /// @param _sigV The array of V-component of Oracle signatures.\n    /// @param _sigR The array of R-component of Oracle signatures.\n    /// @param _sigS The array of S-component of Oracle signatures.\n    function publishPrice(\n        uint256 _version,\n        bytes32 _coinpair,\n        uint256 _price,\n        address _votedOracle,\n        uint256 _blockNumber,\n        uint8[] calldata _sigV,\n        bytes32[] calldata _sigR,\n        bytes32[] calldata _sigS\n    ) external;\n\n    /// @notice Publish a price without signature validation (when there is an emergecy!!!).\n    /// @param _price Price to report.\n    function emergencyPublish(uint256 _price) external;\n\n    /// @notice The oracle owner has withdrawn some stake.\n    /// Must check if the oracle is part of current round and if he lost his place with the\n    /// new stake value (the stake is global and is saved in the supporters contract).\n    /// @param oracleOwnerAddr the oracle owner that is trying to withdraw\n    function onWithdraw(address oracleOwnerAddr) external returns (uint256);\n\n    /// @notice Switch contract context to a new round. With the objective of\n    /// being a decentralized solution, this can be called by *anyone* if current\n    /// round lock period is expired.\n    /// This method search the subscribed list and choose the 10 with more stake.\n    function switchRound() external;\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS\n\n    /// @notice Return the available reward fees\n    ///\n    function getAvailableRewardFees() external view returns (uint256);\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS TO GET CURRENT PRICE\n    // MUST BE WHITELISTED\n    /// @notice Return the current price, compatible with old MOC Oracle\n    function peek() external view returns (bytes32, bool);\n\n    /// @notice Return the current price\n    function getPrice() external view returns (uint256);\n\n    ///////////////////////////////////////////////////////////////////////////////// GETTERS TO GET CURRENT PRICE END\n\n    /// @notice Return current round information\n    function getRoundInfo()\n        external\n        view\n        returns (\n            uint256 round,\n            uint256 startBlock,\n            uint256 lockPeriodTimestamp,\n            uint256 totalPoints,\n            address[] memory selectedOwners,\n            address[] memory selectedOracles\n        );\n\n    /// @notice Return round information for specific oracle\n    function getOracleRoundInfo(address addr)\n        external\n        view\n        returns (uint256 points, bool selectedInCurrentRound);\n\n    // The maximum count of oracles selected to participate each round\n    function maxOraclesPerRound() external view returns (uint256);\n\n    // The round lock period in secs\n    function roundLockPeriodSecs() external view returns (uint256);\n\n    function isOracleInCurrentRound(address oracleAddr) external view returns (bool);\n\n    /// @notice Returns the amount of oracles subscribed to this coin pair.\n    function getSubscribedOraclesLen() external view returns (uint256);\n\n    /// @notice Returns the oracle owner address that is subscribed to this coin pair\n    /// @param idx index to query.\n    function getSubscribedOracleAtIndex(uint256 idx) external view returns (address ownerAddr);\n\n    // Public variable\n    function getMaxSubscribedOraclesPerRound() external view returns (uint256);\n\n    // Public variable\n    function getCoinPair() external view returns (bytes32);\n\n    // Public variable\n    function getLastPublicationBlock() external view returns (uint256);\n\n    // Public variable\n    function getValidPricePeriodInBlocks() external view returns (uint256);\n\n    // Public variable\n    function getEmergencyPublishingPeriodInBlocks() external view returns (uint256);\n\n    // Public variable\n    function getOracleManager() external view returns (IOracleManager);\n\n    // Public variable\n    function getToken() external view returns (IERC20);\n\n    function getRegistry() external view returns (IRegistry);\n\n    // Public value from Registry:\n    //   The minimum count of oracles selected to participate each round\n    function getMinOraclesPerRound() external view returns (uint256);\n}\n\n\n/// This contract manages the Oracle and CoinPair registration info.\n/// The Oracle python server interacts with this contract:\n/// - Coin pair registration\n/// - Oracle registration to coin pairs\n/// - Access Oracle info (oracle address + url) indexed by oracle owner address\n/// - Get the oracle information (url + the specifics of some coin pair rounds) from an oracle address\n/// - Get the oracle address from the owner address.\ninterface IOracleManager {\n    // getOracleOwnerStake: Get the stake stored in the supporters smart-contract\n    // prettier-ignore\n    struct OracleManagerCallbacks {\n        function (address) external view returns (uint256) getOracleOwnerStake;\n    }\n\n    /// @notice Register a new coin pair contract (the contract must be created separately).\n    /// Once created the coin pairs cannot be removed.\n    /// @param coinPair The bytes32-encoded coinpair string (e.g. BTCUSD)\n    /// @param addr The contract address associated to the coin pair.\n    function registerCoinPair(bytes32 coinPair, address addr) external;\n\n    /// Register an oracle in the system must be called by the oracle owner.\n    /// @notice Registers the oracle and transfer the specified caller's MOC token stake.\n    /// @param oracleOwnerAddr The address of the owner of the oracle.\n    /// @param oracleAddr Address of the Oracle to register.\n    /// @param internetName Public Internet name of this Oracle.\n    function registerOracle(\n        address oracleOwnerAddr,\n        address oracleAddr,\n        string calldata internetName\n    ) external;\n\n    /// @notice Change the oracle \"internet\" name (URI), called by the owner.\n    /// @param oracleOwnerAddr The address of the owner of the oracle.\n    /// @param name The new name to set.\n    function setOracleName(address oracleOwnerAddr, string calldata name) external;\n\n    /// @notice Change the oracle address, called by the owner.\n    /// @param oracleOwnerAddr The address of the owner of the oracle.\n    /// @param oracleAddr new value for the address of the oracle\n    function setOracleAddress(address oracleOwnerAddr, address oracleAddr) external;\n\n    /// @notice Removes the oracle registration info. Must be called by the owner\n    /// The oracle must be previously unregistered from all coin pairs.\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\n    function removeOracle(address oracleOwnerAddr) external;\n\n    /// @notice Subscribe a registered oracle to participate in the next round of a registered coin-pair.\n    /// @param oracleOwnerAddr Address of oracle owner\n    function subscribeToCoinPair(address oracleOwnerAddr, bytes32 coinPair) external;\n\n    /// @notice Unsubscribe a registered oracle from participating in rounds of a registered coin-pair.\n    /// The oracle is flagged so it is not selected in the next round.\n    /// @param oracleOwnerAddr Address of oracle owner\n    function unSubscribeFromCoinPair(address oracleOwnerAddr, bytes32 coinPair) external;\n\n    /// @notice The oracle owner did a partial withdrawal of funds\n    /// 1. The oracle address is searched by the owner address.\n    /// 2. Each coin pair to which the oracle is subscribed is consulted to:\n    ///   - Check if the new amount is enough to stay in the current round.\n    ///       If not the oracle is replaced and lost his points.\n    ///   - Get the timestamp for the round end.\n    /// The return value is the maximum timestamp from all the coin pairs.\n    /// @param oracleOwnerAddr Address of oracle owner\n    /// @return the timestamp until which the funds must be locked.\n    function onWithdraw(address oracleOwnerAddr) external returns (uint256);\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS USED BY COINPAIR\n    /// @notice Used by the coin pair to get the oracle address from the oracleOwnerAddress.\n    /// @param  oracleOwnerAddr the address of the owner of the oracle.\n    /// @return oracleAddr Address of oracle\n    function getOracleAddress(address oracleOwnerAddr) external view returns (address oracleAddr);\n\n    /// @notice Returns true if oracle is registered.\n    /// @param ownerAddr The address of the oracle's owner.\n    function isRegistered(address ownerAddr) external view returns (bool);\n\n    /// @notice Used by CoinPair\n    /// @param oracleAddr The oracle address not the owner address.\n    function getOracleOwner(address oracleAddr) external view returns (address);\n\n    /// @notice Returns the amount of owners registered.\n    function getRegisteredOraclesLen() external view returns (uint256);\n\n    /// @notice Returns the oracle name and address at index.\n    /// @param idx index to query.\n    function getRegisteredOracleAtIndex(uint256 idx)\n        external\n        view\n        returns (\n            address ownerAddr,\n            address oracleAddr,\n            string memory url\n        );\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS USED BY COINPAIR END\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS\n\n    // TODO: Check what is the minimum amount of getters the python server needs.\n\n    /// @notice Returns true if an oracle is subscribed to a coin pair\n    function isSubscribed(address oracleAddr, bytes32 coinPair) external view returns (bool);\n\n    /// @notice Return true if the oracle is registered on this coin-pair\n    /// @param oracleAddr addr The address of the Oracle check for.\n    function isOracleRegistered(address oracleAddr) external view returns (bool);\n\n    /// @notice Returns registration information for a registered Oracle.\n    /// @param oracleAddr addr The address of the Oracle to query for.\n    function getOracleRegistrationInfo(address oracleAddr)\n        external\n        view\n        returns (\n            string memory internetName,\n            uint256 stake,\n            address _owner\n        );\n\n    /// @notice Returns round information for a registered oracle in a specific coin-pair.\n    /// @param oracleAddr address of the oracle to query for.\n    /// @param coinpair The coin pair to lookup.\n    function getOracleRoundInfo(address oracleAddr, bytes32 coinpair)\n        external\n        view\n        returns (uint256 points, bool selectedInCurrentRound);\n\n    /// @notice Returns true if an oracle satisfies conditions to be removed from system.\n    /// @param oracleAddr the oracle address to lookup.\n    function canRemoveOracle(address oracleAddr) external view returns (bool);\n\n    /// @notice Get the stake in MOCs that an oracle has.\n    /// @param oracleAddr The address of the oracle.\n    function getStake(address oracleAddr) external view returns (uint256 balance);\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTER TO LIST COIN PAIRS\n\n    /// @notice Returns the count of registered coin pairs.\n    /// Keep in mind that Deleted coin-pairs will contain zeroed addresses.\n    function getCoinPairCount() external view returns (uint256);\n\n    /// @notice Returns the coin pair at index.\n    /// @param i index to query.\n    function getCoinPairAtIndex(uint256 i) external view returns (bytes32);\n\n    /// @notice Return the contract address for a specified registered coin pair.\n    /// @param coinpair Coin-pair string to lookup (e.g: BTCUSD)\n    /// @return address Address of contract or zero if does not exist or was deleted.\n    function getContractAddress(bytes32 coinpair) external view returns (address);\n\n    /// @notice Searches a coinpair in coinPairList\n    /// @param coinPair The bytes32-encoded coinpair string (e.g. BTCUSD)\n    /// @param hint Optional hint to start traversing the coinPairList array, zero is to search all the array.\n    function getCoinPairIndex(bytes32 coinPair, uint256 hint) external view returns (uint256);\n\n    function getMaxStake(address[] calldata addresses) external view returns (address, uint256);\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTER TO LIST COIN PAIRS END\n\n    // Public variable\n    function getStakingContract() external view returns (IStakingMachine);\n\n    // Public variable\n    function getMinCPSubscriptionStake() external view returns (uint256);\n}\n\n\n\ninterface IDelayMachine {\n    /// @notice Accept a deposit from an account.\n    /// @param mocs token quantity\n    /// @param expiration the expiration date for this deposit\n    /// @return id the transaction id\n    function deposit(\n        uint256 mocs,\n        address destination,\n        uint256 expiration\n    ) external returns (uint256 id);\n\n    /// @notice Cancel a transaction returning the funds to the source\n    /// @param id transaction id\n    function cancel(uint256 id) external;\n\n    /// @notice Withdraw stake, send it to the delay machine.\n    /// @param id transaction id\n    function withdraw(uint256 id) external;\n\n    /// @notice Returns the list of transaction for some account\n    /// @return ids transaction ids\n    /// @return amounts token quantity\n    /// @return expirations expiration dates\n    function getTransactions(address account)\n        external\n        view\n        returns (\n            uint256[] memory ids,\n            uint256[] memory amounts,\n            uint256[] memory expirations\n        );\n\n    /// @notice Returns the total balance in MOCs for an account\n    function getBalance(address account) external view returns (uint256);\n\n    // Public variable\n    function getToken() external view returns (IERC20);\n\n    // Public variable\n    function getLastId() external view returns (uint256);\n\n    // Public variable\n    function getSource() external view returns (address);\n}\n\n\ninterface IStakingMachine {\n    /// @notice Used by the voting machine to lock the current balance of MOCs.\n    /// @param mocHolder the moc holder whose mocs will be locked.\n    /// @param untilTimestamp timestamp until which the mocs will be locked.\n    function lockMocs(address mocHolder, uint256 untilTimestamp) external;\n\n    /// @notice Accept a deposit from an account.\n    /// Delegate to the Supporters smart contract.\n    /// @param mocs token quantity\n    /// @param destination the destination account of this deposit.\n    function deposit(uint256 mocs, address destination) external;\n\n    /// @notice Accept a deposit from an account.\n    /// @param mocs token quantity\n    /// @param destination the destination account of this deposit.\n    /// @param source the address that approved the transfer\n    function depositFrom(\n        uint256 mocs,\n        address destination,\n        address source\n    ) external;\n\n    /// @notice Withdraw stake, send it to the delay machine.\n    /// @param mocs token quantity\n    function withdraw(uint256 mocs) external;\n\n    /// @notice Reports the balance of MOCs for a specific user.\n    /// @param user user address\n    function getBalance(address user) external view returns (uint256);\n\n    /// @notice Reports the locked balance of MOCs for a specific user.\n    /// @param user user address\n    function getLockedBalance(address user) external view returns (uint256);\n\n    /// @notice Reports the balance of locked MOCs for a specific user.\n    /// Delegates to the Supporters smart contract.\n    /// @param user user address\n    /// @return amount the amount of mocs locked\n    /// @return untilTimestamp the timestamp that corresponds to the locking date.\n    function getLockingInfo(address user)\n        external\n        view\n        returns (uint256 amount, uint256 untilTimestamp);\n\n    // Public variable\n    function getSupporters() external view returns (address);\n\n    // Public variable\n    function getOracleManager() external view returns (IOracleManager);\n\n    // Public variable\n    function getMocToken() external view returns (IERC20);\n\n    // Public variable\n    function getDelayMachine() external view returns (IDelayMachine);\n\n    // Public variable\n    function getWithdrawLockTime() external view returns (uint256);\n}\n\ninterface IStakingMachineOracles {\n    /// @notice Register an oracle\n    /// @param oracleAddr address of the oracle (from which we publish prices)\n    /// @param url url used by the oracle server\n    function registerOracle(address oracleAddr, string calldata url) external;\n\n    /// @notice Change the oracle \"internet\" name (URI)\n    /// @param url The new url to set.\n    function setOracleName(string calldata url) external;\n\n    /// @notice Change the oracle address\n    /// @param oracleAddr The new oracle address\n    function setOracleAddress(address oracleAddr) external;\n\n    /// @notice Return true if the oracle is registered.\n    /// @param oracleAddr addr The address of the Oracle check for.\n    function isOracleRegistered(address oracleAddr) external view returns (bool);\n\n    /// @notice Returns true if an oracle satisfies conditions to be removed from system.\n    /// @param oracleAddr the oracle address to lookup.\n    function canRemoveOracle(address oracleAddr) external view returns (bool);\n\n    /// @notice Remove an oracle.\n    function removeOracle() external;\n\n    /// @notice Returns the count of registered coin pairs.\n    /// Keep in mind that Deleted coin-pairs will contain zeroed addresses.\n    function getCoinPairCount() external view returns (uint256);\n\n    /// @notice Returns the coin pair at index.\n    /// @param i index to query.\n    function getCoinPairAtIndex(uint256 i) external view returns (bytes32);\n\n    /// @notice Return the contract address for a specified registered coin pair.\n    /// @param coinpair Coin-pair string to lookup (e.g: BTCUSD)\n    /// @return address Address of contract or zero if does not exist or was deleted.\n    function getContractAddress(bytes32 coinpair) external view returns (address);\n\n    /// @notice Searches a coinpair in coinPairList\n    /// @param coinPair The bytes32-encoded coinpair string (e.g. BTCUSD)\n    /// @param hint Optional hint to start traversing the coinPairList array, zero is to search all the array.\n    function getCoinPairIndex(bytes32 coinPair, uint256 hint) external view returns (uint256);\n\n    /// @notice Subscribe an oracle to a coin pair.\n    /// @param coinPair coin pair to subscribe, for example BTCUSD\n    function subscribeToCoinPair(bytes32 coinPair) external;\n\n    /// @notice Unsubscribe an oracle from a coin pair.\n    /// @param coinPair coin pair to unsubscribe, for example BTCUSD\n    function unSubscribeFromCoinPair(bytes32 coinPair) external;\n\n    /// @notice Returns true if an oracle is subscribed to a coin pair\n    /// @param oracleAddr address of the oracle\n    /// @param coinPair coin pair to unsubscribe, for example BTCUSD\n    function isSubscribed(address oracleAddr, bytes32 coinPair) external view returns (bool);\n\n    /// @notice Returns the amount of owners registered.\n    /// Delegates to the Oracle Manager smart contract.\n    function getRegisteredOraclesLen() external view returns (uint256);\n\n    /// @notice Returns the oracle name and address at index.\n    /// Delegates to the Oracle Manager smart contract.\n    /// @param idx index to query.\n    function getRegisteredOracleAtIndex(uint256 idx)\n        external\n        view\n        returns (\n            address ownerAddr,\n            address oracleAddr,\n            string memory url\n        );\n}\n\n\n// prettier-ignore\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\n * (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n\n\ncontract DelayMachineStorage is Initializable, Governed {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    struct Payment {\n        uint256 expiration;\n        uint256 amount;\n    }\n\n    struct Owner {\n        EnumerableSet.UintSet ids;\n    }\n\n    uint256 internal _id;\n    IERC20 internal _token;\n    address internal _source;\n    mapping(address => Owner) internal owners;\n    mapping(uint256 => Payment) internal payments;\n\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    // solhint-disable-next-line no-empty-blocks\n    constructor() internal {}\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n\n\ncontract DelayMachine is DelayMachineStorage, IDelayMachine {\n    using SafeMath for uint256;\n\n    event PaymentDeposit(\n        uint256 indexed id,\n        address source,\n        address destination,\n        uint256 amount,\n        uint256 expiration\n    );\n    event PaymentCancel(uint256 indexed id, address source, address destination, uint256 amount);\n    event PaymentWithdraw(uint256 indexed id, address source, address destination, uint256 amount);\n\n    /// @notice Construct this contract.\n    /// @param governor The minimum amount of tokens required as stake for a coin pair subscription.\n    /// @param token the Supporters contract contract address.\n    function initialize(\n        IGovernor governor,\n        IERC20 token,\n        address source\n    ) external initializer {\n        _token = token;\n        _source = source;\n        Governed._initialize(governor);\n    }\n\n    /// @notice Accept a deposit from an account.\n    /// @param mocs token quantity\n    /// @param destination the destination address which can control the funds.\n    /// @param expiration the expiration date for this deposit\n    /// @return id the transaction id\n    function deposit(\n        uint256 mocs,\n        address destination,\n        uint256 expiration\n    ) external override returns (uint256 id) {\n        require(msg.sender == _source, \"Wrong source\");\n        bool done = _token.transferFrom(_source, address(this), mocs);\n        require(done, \"Token transfer failed.\");\n        _id = _id + 1;\n        payments[_id].expiration = (block.timestamp).add(expiration);\n        // solhint-disable-previous-line not-rely-on-time\n        payments[_id].amount = mocs;\n        owners[destination].ids.add(_id);\n        emit PaymentDeposit(_id, _source, destination, mocs, expiration);\n        return _id;\n    }\n\n    /// @notice Cancel a transaction returning the funds to the source\n    /// @param id transaction id\n    function cancel(uint256 id) external override {\n        require(owners[msg.sender].ids.contains(id), \"Invalid ID\");\n        owners[msg.sender].ids.remove(id);\n        bool done = _token.approve(_source, payments[id].amount);\n        require(done, \"Token approve failed.\");\n        IStakingMachine(_source).depositFrom(payments[id].amount, msg.sender, address(this));\n        uint256 amount = payments[id].amount;\n        delete (payments[id]);\n        emit PaymentCancel(id, _source, msg.sender, amount);\n    }\n\n    /// @notice Withdraw stake, send it to the delay machine.\n    /// @param id transaction id\n    function withdraw(uint256 id) external override {\n        require(owners[msg.sender].ids.contains(id), \"Invalid ID\");\n        owners[msg.sender].ids.remove(id);\n        require(payments[id].expiration < block.timestamp, \"Not expired\");\n        // solhint-disable-previous-line not-rely-on-time\n        bool done = _token.transfer(msg.sender, payments[id].amount);\n        require(done, \"Token transfer failed.\");\n        uint256 amount = payments[id].amount;\n        delete (payments[id]);\n        emit PaymentWithdraw(id, _source, msg.sender, amount);\n    }\n\n    /// @notice Returns the list of transaction for some account\n    /// @param account destination address\n    /// @return ids transaction ids\n    /// @return amounts token quantity\n    /// @return expirations expiration dates\n    function getTransactions(address account)\n        external\n        view\n        override\n        returns (\n            uint256[] memory ids,\n            uint256[] memory amounts,\n            uint256[] memory expirations\n        )\n    {\n        uint256 len = owners[account].ids.length();\n        ids = new uint256[](len);\n        amounts = new uint256[](len);\n        expirations = new uint256[](len);\n        for (uint256 i = 0; i < len; i++) {\n            ids[i] = owners[account].ids.at(i);\n            amounts[i] = payments[owners[account].ids.at(i)].amount;\n            expirations[i] = payments[owners[account].ids.at(i)].expiration;\n        }\n    }\n\n    /// @notice Returns the total balance in MOCs for an account\n    /// @param account destination address\n    /// @return balance token quantity\n    function getBalance(address account) external view override returns (uint256) {\n        uint256 len = owners[account].ids.length();\n        uint256 balance;\n        for (uint256 i = 0; i < len; i++) {\n            balance = balance + payments[owners[account].ids.at(i)].amount;\n        }\n        return balance;\n    }\n\n    // Public variable\n    function getToken() external view override returns (IERC20) {\n        return _token;\n    }\n\n    // Public variable\n    function getLastId() external view override returns (uint256) {\n        return _id;\n    }\n\n    // Public variable\n    function getSource() external view override returns (address) {\n        return _source;\n    }\n}\n\n",
    "imports": [
        {
            "name": "DelayMachineFlat.sol",
            "contents": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.12;\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n\n\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n    /**\n      @notice Override this function with a recipe of the changes to be done when this ChangeContract\n      is executed\n     */\n    function execute() external;\n}\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor {\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @dev This function should be protected somehow to only execute changes that\n      benefit the system. This decision process is independent of this architechture\n      therefore is independent of this interface too\n      @param changeContract Address of the contract that will execute the changes\n     */\n    function executeChange(ChangeContract changeContract) external;\n\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @param _changer Address of the contract that will execute the changes\n     */\n    function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed {\n    /**\n      @notice The address of the contract which governs this one\n     */\n    IGovernor public governor;\n\n    string private constant NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n    /**\n      @notice Modifier that protects the function\n      @dev You should use this modifier in any function that should be called through\n      the governance system\n     */\n    modifier onlyAuthorizedChanger() {\n        require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n        _;\n    }\n\n    /**\n      @notice Initialize the contract with the basic settings\n      @dev This initialize replaces the constructor but it is not called automatically.\n      It is necessary because of the upgradeability of the contracts\n      @param _governor Governor address\n     */\n    function _initialize(IGovernor _governor) internal {\n        governor = _governor;\n    }\n\n    /**\n      @notice Change the contract's governor. Should be called through the old governance system\n      @param newIGovernor New governor address\n     */\n    function changeIGovernor(IGovernor newIGovernor) external onlyAuthorizedChanger {\n        governor = newIGovernor;\n    }\n\n    /**\n      @notice This method is used by a change contract to access the storage freely even without a setter.\n      @param data the serialized function arguments\n     */\n    function delegateCallToChanger(bytes calldata data)\n        external\n        onlyAuthorizedChanger\n        returns (bytes memory)\n    {\n        address changerContrat = msg.sender;\n        (bool success, bytes memory result) = changerContrat.delegatecall(\n            abi.encodeWithSignature(\"impersonate(bytes)\", data)\n        );\n        require(success, \"Error in delegate call\");\n        return result;\n    }\n\n    // Leave a gap betweeen inherited contracts variables in order to be\n    // able to add more variables in them later\n    uint256[50] private upgradeGap;\n}\n\n\n\n\n\ninterface IRegistry {\n    // *** Getter Methods ***\n    function getDecimal(bytes32 _key) external view returns (int232 base, int16 exp);\n\n    function getUint(bytes32 _key) external view returns (uint248);\n\n    function getString(bytes32 _key) external view returns (string memory);\n\n    function getAddress(bytes32 _key) external view returns (address);\n\n    function getBytes(bytes32 _key) external view returns (bytes memory);\n\n    function getBool(bytes32 _key) external view returns (bool);\n\n    function getInt(bytes32 _key) external view returns (int248);\n\n    // *** Setter Methods ***\n    function setDecimal(\n        bytes32 _key,\n        int232 _base,\n        int16 _exp\n    ) external;\n\n    function setUint(bytes32 _key, uint248 _value) external;\n\n    function setString(bytes32 _key, string calldata _value) external;\n\n    function setAddress(bytes32 _key, address _value) external;\n\n    function setBytes(bytes32 _key, bytes calldata _value) external;\n\n    function setBool(bytes32 _key, bool _value) external;\n\n    function setInt(bytes32 _key, int248 _value) external;\n\n    // *** Delete Methods ***\n    function deleteDecimal(bytes32 _key) external;\n\n    function deleteUint(bytes32 _key) external;\n\n    function deleteString(bytes32 _key) external;\n\n    function deleteAddress(bytes32 _key) external;\n\n    function deleteBytes(bytes32 _key) external;\n\n    function deleteBool(bytes32 _key) external;\n\n    function deleteInt(bytes32 _key) external;\n\n    // Nov 2020 Upgrade\n    // *** Getter Methods ***\n    function getAddressArrayLength(bytes32 _key) external view returns (uint256);\n\n    function getAddressArrayElementAt(bytes32 _key, uint256 idx) external view returns (address);\n\n    function pushAddressArrayElement(bytes32 _key, address _addr) external;\n\n    function getAddressArray(bytes32 _key) external view returns (address[] memory);\n\n    function addressArrayContains(bytes32 _key, address value) external view returns (bool);\n\n    // *** Setters ***\n    function pushAddressArray(bytes32 _key, address[] memory data) external;\n\n    function clearAddressArray(bytes32 _key) external;\n\n    function removeAddressArrayElement(bytes32 _key, address value) external;\n}\n\n\n/// @title This contract provides an interface for feeding prices from oracles, and\n///        get the current price. One contract must be instanced per supported coin pair,\n///        and registered through OracleManager global contract.\n/// This contract has two lists:\n/// 1) A subscribed list (EnumerableSet.AddressSet) oracles owner addresses, this list has a max size (30).\n/// 2) A selected list, EnumerableSet.AddressSet of oracles owner addresses that are selected to participate in\n/// current publication round (10 entries max size).\n///\n/// Oracles are subscribed by adding them to the subscribed oracle list. When the list is full\n/// the oracle with less stake can be removed by a new oracle that is trying to\n/// subscribe (if its stake is greater than his).\n/// On each round switch the list of selected oracles is populated with the 10 Oracles with more stake. An oracle\n/// can unsubscribe itself from the subscribed list in the middle of the round, in this case, the oracle is still\n/// listed in the selected list until the round ends.\n/// If an oracle withdraw some stake then his participation in the round is put into consideration: If the\n/// oracle ends up having less stake than the next oracle in the subscribed list (but not in the selected list) then\n/// it is removed from the selected list and the point he accumulated during the round are lost (set to zero).\n\ninterface ICoinPairPrice {\n    // getOracleOwnerAddress: Given an Oracle address return the Oracle Owner address.\n    // Used during publication, the servers sign with the oracle address, but the list of selected oracles\n    // is by oracle owner address.\n    // getOracleOwnerStake: Get the stake stored in the supporters smart-contract\n    // prettier-ignore\n    struct CoinPairPriceCallbacks {\n        function (address) external view returns (address) getOracleOwnerAddress;\n        function (address) external view returns (uint256) getOracleOwnerStake;\n    }\n\n    /// @notice subscribe an oracle to this coin pair, allowing it to be selected in the next round.\n    /// If the subscribed list is full and the current oracle has more stake than one with minimum stake in the\n    /// subscribed list, then the one with minimum stake is replaced.\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\n    /// @dev This is designed to be called from OracleManager.\n    function subscribe(address oracleOwnerAddr) external;\n\n    /// @notice Unsubscribe an oracle from this coin pair. The oracle won't be selected in the next round.\n    /// After the round end, the oracle can withdraw stake without having the risk of loosing won points.\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\n    /// @dev This is designed to be called from OracleManager.\n    function unsubscribe(address oracleOwnerAddr) external;\n\n    /// @notice Returns true if an oracle is subscribed to this contract' coin pair\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\n    /// @dev This is designed to be called from OracleManager.\n    function isSubscribed(address oracleOwnerAddr) external view returns (bool);\n\n    /// @notice Publish a price. (The message contain oracleAddresses that must be converted to owner addresses).\n    /// @param _version Version number of message format (3)\n    /// @param _coinpair The coin pair to report (must match this contract)\n    /// @param _price Price to report.\n    /// @param _votedOracle The address of the oracle voted as a publisher by the network.\n    /// @param _blockNumber The block number acting as nonce to prevent replay attacks.\n    /// @param _sigV The array of V-component of Oracle signatures.\n    /// @param _sigR The array of R-component of Oracle signatures.\n    /// @param _sigS The array of S-component of Oracle signatures.\n    function publishPrice(\n        uint256 _version,\n        bytes32 _coinpair,\n        uint256 _price,\n        address _votedOracle,\n        uint256 _blockNumber,\n        uint8[] calldata _sigV,\n        bytes32[] calldata _sigR,\n        bytes32[] calldata _sigS\n    ) external;\n\n    /// @notice Publish a price without signature validation (when there is an emergecy!!!).\n    /// @param _price Price to report.\n    function emergencyPublish(uint256 _price) external;\n\n    /// @notice The oracle owner has withdrawn some stake.\n    /// Must check if the oracle is part of current round and if he lost his place with the\n    /// new stake value (the stake is global and is saved in the supporters contract).\n    /// @param oracleOwnerAddr the oracle owner that is trying to withdraw\n    function onWithdraw(address oracleOwnerAddr) external returns (uint256);\n\n    /// @notice Switch contract context to a new round. With the objective of\n    /// being a decentralized solution, this can be called by *anyone* if current\n    /// round lock period is expired.\n    /// This method search the subscribed list and choose the 10 with more stake.\n    function switchRound() external;\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS\n\n    /// @notice Return the available reward fees\n    ///\n    function getAvailableRewardFees() external view returns (uint256);\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS TO GET CURRENT PRICE\n    // MUST BE WHITELISTED\n    /// @notice Return the current price, compatible with old MOC Oracle\n    function peek() external view returns (bytes32, bool);\n\n    /// @notice Return the current price\n    function getPrice() external view returns (uint256);\n\n    ///////////////////////////////////////////////////////////////////////////////// GETTERS TO GET CURRENT PRICE END\n\n    /// @notice Return current round information\n    function getRoundInfo()\n        external\n        view\n        returns (\n            uint256 round,\n            uint256 startBlock,\n            uint256 lockPeriodTimestamp,\n            uint256 totalPoints,\n            address[] memory selectedOwners,\n            address[] memory selectedOracles\n        );\n\n    /// @notice Return round information for specific oracle\n    function getOracleRoundInfo(address addr)\n        external\n        view\n        returns (uint256 points, bool selectedInCurrentRound);\n\n    // The maximum count of oracles selected to participate each round\n    function maxOraclesPerRound() external view returns (uint256);\n\n    // The round lock period in secs\n    function roundLockPeriodSecs() external view returns (uint256);\n\n    function isOracleInCurrentRound(address oracleAddr) external view returns (bool);\n\n    /// @notice Returns the amount of oracles subscribed to this coin pair.\n    function getSubscribedOraclesLen() external view returns (uint256);\n\n    /// @notice Returns the oracle owner address that is subscribed to this coin pair\n    /// @param idx index to query.\n    function getSubscribedOracleAtIndex(uint256 idx) external view returns (address ownerAddr);\n\n    // Public variable\n    function getMaxSubscribedOraclesPerRound() external view returns (uint256);\n\n    // Public variable\n    function getCoinPair() external view returns (bytes32);\n\n    // Public variable\n    function getLastPublicationBlock() external view returns (uint256);\n\n    // Public variable\n    function getValidPricePeriodInBlocks() external view returns (uint256);\n\n    // Public variable\n    function getEmergencyPublishingPeriodInBlocks() external view returns (uint256);\n\n    // Public variable\n    function getOracleManager() external view returns (IOracleManager);\n\n    // Public variable\n    function getToken() external view returns (IERC20);\n\n    function getRegistry() external view returns (IRegistry);\n\n    // Public value from Registry:\n    //   The minimum count of oracles selected to participate each round\n    function getMinOraclesPerRound() external view returns (uint256);\n}\n\n\n/// This contract manages the Oracle and CoinPair registration info.\n/// The Oracle python server interacts with this contract:\n/// - Coin pair registration\n/// - Oracle registration to coin pairs\n/// - Access Oracle info (oracle address + url) indexed by oracle owner address\n/// - Get the oracle information (url + the specifics of some coin pair rounds) from an oracle address\n/// - Get the oracle address from the owner address.\ninterface IOracleManager {\n    // getOracleOwnerStake: Get the stake stored in the supporters smart-contract\n    // prettier-ignore\n    struct OracleManagerCallbacks {\n        function (address) external view returns (uint256) getOracleOwnerStake;\n    }\n\n    /// @notice Register a new coin pair contract (the contract must be created separately).\n    /// Once created the coin pairs cannot be removed.\n    /// @param coinPair The bytes32-encoded coinpair string (e.g. BTCUSD)\n    /// @param addr The contract address associated to the coin pair.\n    function registerCoinPair(bytes32 coinPair, address addr) external;\n\n    /// Register an oracle in the system must be called by the oracle owner.\n    /// @notice Registers the oracle and transfer the specified caller's MOC token stake.\n    /// @param oracleOwnerAddr The address of the owner of the oracle.\n    /// @param oracleAddr Address of the Oracle to register.\n    /// @param internetName Public Internet name of this Oracle.\n    function registerOracle(\n        address oracleOwnerAddr,\n        address oracleAddr,\n        string calldata internetName\n    ) external;\n\n    /// @notice Change the oracle \"internet\" name (URI), called by the owner.\n    /// @param oracleOwnerAddr The address of the owner of the oracle.\n    /// @param name The new name to set.\n    function setOracleName(address oracleOwnerAddr, string calldata name) external;\n\n    /// @notice Change the oracle address, called by the owner.\n    /// @param oracleOwnerAddr The address of the owner of the oracle.\n    /// @param oracleAddr new value for the address of the oracle\n    function setOracleAddress(address oracleOwnerAddr, address oracleAddr) external;\n\n    /// @notice Removes the oracle registration info. Must be called by the owner\n    /// The oracle must be previously unregistered from all coin pairs.\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\n    function removeOracle(address oracleOwnerAddr) external;\n\n    /// @notice Subscribe a registered oracle to participate in the next round of a registered coin-pair.\n    /// @param oracleOwnerAddr Address of oracle owner\n    function subscribeToCoinPair(address oracleOwnerAddr, bytes32 coinPair) external;\n\n    /// @notice Unsubscribe a registered oracle from participating in rounds of a registered coin-pair.\n    /// The oracle is flagged so it is not selected in the next round.\n    /// @param oracleOwnerAddr Address of oracle owner\n    function unSubscribeFromCoinPair(address oracleOwnerAddr, bytes32 coinPair) external;\n\n    /// @notice The oracle owner did a partial withdrawal of funds\n    /// 1. The oracle address is searched by the owner address.\n    /// 2. Each coin pair to which the oracle is subscribed is consulted to:\n    ///   - Check if the new amount is enough to stay in the current round.\n    ///       If not the oracle is replaced and lost his points.\n    ///   - Get the timestamp for the round end.\n    /// The return value is the maximum timestamp from all the coin pairs.\n    /// @param oracleOwnerAddr Address of oracle owner\n    /// @return the timestamp until which the funds must be locked.\n    function onWithdraw(address oracleOwnerAddr) external returns (uint256);\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS USED BY COINPAIR\n    /// @notice Used by the coin pair to get the oracle address from the oracleOwnerAddress.\n    /// @param  oracleOwnerAddr the address of the owner of the oracle.\n    /// @return oracleAddr Address of oracle\n    function getOracleAddress(address oracleOwnerAddr) external view returns (address oracleAddr);\n\n    /// @notice Returns true if oracle is registered.\n    /// @param ownerAddr The address of the oracle's owner.\n    function isRegistered(address ownerAddr) external view returns (bool);\n\n    /// @notice Used by CoinPair\n    /// @param oracleAddr The oracle address not the owner address.\n    function getOracleOwner(address oracleAddr) external view returns (address);\n\n    /// @notice Returns the amount of owners registered.\n    function getRegisteredOraclesLen() external view returns (uint256);\n\n    /// @notice Returns the oracle name and address at index.\n    /// @param idx index to query.\n    function getRegisteredOracleAtIndex(uint256 idx)\n        external\n        view\n        returns (\n            address ownerAddr,\n            address oracleAddr,\n            string memory url\n        );\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS USED BY COINPAIR END\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS\n\n    // TODO: Check what is the minimum amount of getters the python server needs.\n\n    /// @notice Returns true if an oracle is subscribed to a coin pair\n    function isSubscribed(address oracleAddr, bytes32 coinPair) external view returns (bool);\n\n    /// @notice Return true if the oracle is registered on this coin-pair\n    /// @param oracleAddr addr The address of the Oracle check for.\n    function isOracleRegistered(address oracleAddr) external view returns (bool);\n\n    /// @notice Returns registration information for a registered Oracle.\n    /// @param oracleAddr addr The address of the Oracle to query for.\n    function getOracleRegistrationInfo(address oracleAddr)\n        external\n        view\n        returns (\n            string memory internetName,\n            uint256 stake,\n            address _owner\n        );\n\n    /// @notice Returns round information for a registered oracle in a specific coin-pair.\n    /// @param oracleAddr address of the oracle to query for.\n    /// @param coinpair The coin pair to lookup.\n    function getOracleRoundInfo(address oracleAddr, bytes32 coinpair)\n        external\n        view\n        returns (uint256 points, bool selectedInCurrentRound);\n\n    /// @notice Returns true if an oracle satisfies conditions to be removed from system.\n    /// @param oracleAddr the oracle address to lookup.\n    function canRemoveOracle(address oracleAddr) external view returns (bool);\n\n    /// @notice Get the stake in MOCs that an oracle has.\n    /// @param oracleAddr The address of the oracle.\n    function getStake(address oracleAddr) external view returns (uint256 balance);\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTER TO LIST COIN PAIRS\n\n    /// @notice Returns the count of registered coin pairs.\n    /// Keep in mind that Deleted coin-pairs will contain zeroed addresses.\n    function getCoinPairCount() external view returns (uint256);\n\n    /// @notice Returns the coin pair at index.\n    /// @param i index to query.\n    function getCoinPairAtIndex(uint256 i) external view returns (bytes32);\n\n    /// @notice Return the contract address for a specified registered coin pair.\n    /// @param coinpair Coin-pair string to lookup (e.g: BTCUSD)\n    /// @return address Address of contract or zero if does not exist or was deleted.\n    function getContractAddress(bytes32 coinpair) external view returns (address);\n\n    /// @notice Searches a coinpair in coinPairList\n    /// @param coinPair The bytes32-encoded coinpair string (e.g. BTCUSD)\n    /// @param hint Optional hint to start traversing the coinPairList array, zero is to search all the array.\n    function getCoinPairIndex(bytes32 coinPair, uint256 hint) external view returns (uint256);\n\n    function getMaxStake(address[] calldata addresses) external view returns (address, uint256);\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTER TO LIST COIN PAIRS END\n\n    // Public variable\n    function getStakingContract() external view returns (IStakingMachine);\n\n    // Public variable\n    function getMinCPSubscriptionStake() external view returns (uint256);\n}\n\n\n\ninterface IDelayMachine {\n    /// @notice Accept a deposit from an account.\n    /// @param mocs token quantity\n    /// @param expiration the expiration date for this deposit\n    /// @return id the transaction id\n    function deposit(\n        uint256 mocs,\n        address destination,\n        uint256 expiration\n    ) external returns (uint256 id);\n\n    /// @notice Cancel a transaction returning the funds to the source\n    /// @param id transaction id\n    function cancel(uint256 id) external;\n\n    /// @notice Withdraw stake, send it to the delay machine.\n    /// @param id transaction id\n    function withdraw(uint256 id) external;\n\n    /// @notice Returns the list of transaction for some account\n    /// @return ids transaction ids\n    /// @return amounts token quantity\n    /// @return expirations expiration dates\n    function getTransactions(address account)\n        external\n        view\n        returns (\n            uint256[] memory ids,\n            uint256[] memory amounts,\n            uint256[] memory expirations\n        );\n\n    /// @notice Returns the total balance in MOCs for an account\n    function getBalance(address account) external view returns (uint256);\n\n    // Public variable\n    function getToken() external view returns (IERC20);\n\n    // Public variable\n    function getLastId() external view returns (uint256);\n\n    // Public variable\n    function getSource() external view returns (address);\n}\n\n\ninterface IStakingMachine {\n    /// @notice Used by the voting machine to lock the current balance of MOCs.\n    /// @param mocHolder the moc holder whose mocs will be locked.\n    /// @param untilTimestamp timestamp until which the mocs will be locked.\n    function lockMocs(address mocHolder, uint256 untilTimestamp) external;\n\n    /// @notice Accept a deposit from an account.\n    /// Delegate to the Supporters smart contract.\n    /// @param mocs token quantity\n    /// @param destination the destination account of this deposit.\n    function deposit(uint256 mocs, address destination) external;\n\n    /// @notice Accept a deposit from an account.\n    /// @param mocs token quantity\n    /// @param destination the destination account of this deposit.\n    /// @param source the address that approved the transfer\n    function depositFrom(\n        uint256 mocs,\n        address destination,\n        address source\n    ) external;\n\n    /// @notice Withdraw stake, send it to the delay machine.\n    /// @param mocs token quantity\n    function withdraw(uint256 mocs) external;\n\n    /// @notice Reports the balance of MOCs for a specific user.\n    /// @param user user address\n    function getBalance(address user) external view returns (uint256);\n\n    /// @notice Reports the locked balance of MOCs for a specific user.\n    /// @param user user address\n    function getLockedBalance(address user) external view returns (uint256);\n\n    /// @notice Reports the balance of locked MOCs for a specific user.\n    /// Delegates to the Supporters smart contract.\n    /// @param user user address\n    /// @return amount the amount of mocs locked\n    /// @return untilTimestamp the timestamp that corresponds to the locking date.\n    function getLockingInfo(address user)\n        external\n        view\n        returns (uint256 amount, uint256 untilTimestamp);\n\n    // Public variable\n    function getSupporters() external view returns (address);\n\n    // Public variable\n    function getOracleManager() external view returns (IOracleManager);\n\n    // Public variable\n    function getMocToken() external view returns (IERC20);\n\n    // Public variable\n    function getDelayMachine() external view returns (IDelayMachine);\n\n    // Public variable\n    function getWithdrawLockTime() external view returns (uint256);\n}\n\ninterface IStakingMachineOracles {\n    /// @notice Register an oracle\n    /// @param oracleAddr address of the oracle (from which we publish prices)\n    /// @param url url used by the oracle server\n    function registerOracle(address oracleAddr, string calldata url) external;\n\n    /// @notice Change the oracle \"internet\" name (URI)\n    /// @param url The new url to set.\n    function setOracleName(string calldata url) external;\n\n    /// @notice Change the oracle address\n    /// @param oracleAddr The new oracle address\n    function setOracleAddress(address oracleAddr) external;\n\n    /// @notice Return true if the oracle is registered.\n    /// @param oracleAddr addr The address of the Oracle check for.\n    function isOracleRegistered(address oracleAddr) external view returns (bool);\n\n    /// @notice Returns true if an oracle satisfies conditions to be removed from system.\n    /// @param oracleAddr the oracle address to lookup.\n    function canRemoveOracle(address oracleAddr) external view returns (bool);\n\n    /// @notice Remove an oracle.\n    function removeOracle() external;\n\n    /// @notice Returns the count of registered coin pairs.\n    /// Keep in mind that Deleted coin-pairs will contain zeroed addresses.\n    function getCoinPairCount() external view returns (uint256);\n\n    /// @notice Returns the coin pair at index.\n    /// @param i index to query.\n    function getCoinPairAtIndex(uint256 i) external view returns (bytes32);\n\n    /// @notice Return the contract address for a specified registered coin pair.\n    /// @param coinpair Coin-pair string to lookup (e.g: BTCUSD)\n    /// @return address Address of contract or zero if does not exist or was deleted.\n    function getContractAddress(bytes32 coinpair) external view returns (address);\n\n    /// @notice Searches a coinpair in coinPairList\n    /// @param coinPair The bytes32-encoded coinpair string (e.g. BTCUSD)\n    /// @param hint Optional hint to start traversing the coinPairList array, zero is to search all the array.\n    function getCoinPairIndex(bytes32 coinPair, uint256 hint) external view returns (uint256);\n\n    /// @notice Subscribe an oracle to a coin pair.\n    /// @param coinPair coin pair to subscribe, for example BTCUSD\n    function subscribeToCoinPair(bytes32 coinPair) external;\n\n    /// @notice Unsubscribe an oracle from a coin pair.\n    /// @param coinPair coin pair to unsubscribe, for example BTCUSD\n    function unSubscribeFromCoinPair(bytes32 coinPair) external;\n\n    /// @notice Returns true if an oracle is subscribed to a coin pair\n    /// @param oracleAddr address of the oracle\n    /// @param coinPair coin pair to unsubscribe, for example BTCUSD\n    function isSubscribed(address oracleAddr, bytes32 coinPair) external view returns (bool);\n\n    /// @notice Returns the amount of owners registered.\n    /// Delegates to the Oracle Manager smart contract.\n    function getRegisteredOraclesLen() external view returns (uint256);\n\n    /// @notice Returns the oracle name and address at index.\n    /// Delegates to the Oracle Manager smart contract.\n    /// @param idx index to query.\n    function getRegisteredOracleAtIndex(uint256 idx)\n        external\n        view\n        returns (\n            address ownerAddr,\n            address oracleAddr,\n            string memory url\n        );\n}\n\n\n// prettier-ignore\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\n * (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n\n\ncontract DelayMachineStorage is Initializable, Governed {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    struct Payment {\n        uint256 expiration;\n        uint256 amount;\n    }\n\n    struct Owner {\n        EnumerableSet.UintSet ids;\n    }\n\n    uint256 internal _id;\n    IERC20 internal _token;\n    address internal _source;\n    mapping(address => Owner) internal owners;\n    mapping(uint256 => Payment) internal payments;\n\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    // solhint-disable-next-line no-empty-blocks\n    constructor() internal {}\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n\n\ncontract DelayMachine is DelayMachineStorage, IDelayMachine {\n    using SafeMath for uint256;\n\n    event PaymentDeposit(\n        uint256 indexed id,\n        address source,\n        address destination,\n        uint256 amount,\n        uint256 expiration\n    );\n    event PaymentCancel(uint256 indexed id, address source, address destination, uint256 amount);\n    event PaymentWithdraw(uint256 indexed id, address source, address destination, uint256 amount);\n\n    /// @notice Construct this contract.\n    /// @param governor The minimum amount of tokens required as stake for a coin pair subscription.\n    /// @param token the Supporters contract contract address.\n    function initialize(\n        IGovernor governor,\n        IERC20 token,\n        address source\n    ) external initializer {\n        _token = token;\n        _source = source;\n        Governed._initialize(governor);\n    }\n\n    /// @notice Accept a deposit from an account.\n    /// @param mocs token quantity\n    /// @param destination the destination address which can control the funds.\n    /// @param expiration the expiration date for this deposit\n    /// @return id the transaction id\n    function deposit(\n        uint256 mocs,\n        address destination,\n        uint256 expiration\n    ) external override returns (uint256 id) {\n        require(msg.sender == _source, \"Wrong source\");\n        bool done = _token.transferFrom(_source, address(this), mocs);\n        require(done, \"Token transfer failed.\");\n        _id = _id + 1;\n        payments[_id].expiration = (block.timestamp).add(expiration);\n        // solhint-disable-previous-line not-rely-on-time\n        payments[_id].amount = mocs;\n        owners[destination].ids.add(_id);\n        emit PaymentDeposit(_id, _source, destination, mocs, expiration);\n        return _id;\n    }\n\n    /// @notice Cancel a transaction returning the funds to the source\n    /// @param id transaction id\n    function cancel(uint256 id) external override {\n        require(owners[msg.sender].ids.contains(id), \"Invalid ID\");\n        owners[msg.sender].ids.remove(id);\n        bool done = _token.approve(_source, payments[id].amount);\n        require(done, \"Token approve failed.\");\n        IStakingMachine(_source).depositFrom(payments[id].amount, msg.sender, address(this));\n        uint256 amount = payments[id].amount;\n        delete (payments[id]);\n        emit PaymentCancel(id, _source, msg.sender, amount);\n    }\n\n    /// @notice Withdraw stake, send it to the delay machine.\n    /// @param id transaction id\n    function withdraw(uint256 id) external override {\n        require(owners[msg.sender].ids.contains(id), \"Invalid ID\");\n        owners[msg.sender].ids.remove(id);\n        require(payments[id].expiration < block.timestamp, \"Not expired\");\n        // solhint-disable-previous-line not-rely-on-time\n        bool done = _token.transfer(msg.sender, payments[id].amount);\n        require(done, \"Token transfer failed.\");\n        uint256 amount = payments[id].amount;\n        delete (payments[id]);\n        emit PaymentWithdraw(id, _source, msg.sender, amount);\n    }\n\n    /// @notice Returns the list of transaction for some account\n    /// @param account destination address\n    /// @return ids transaction ids\n    /// @return amounts token quantity\n    /// @return expirations expiration dates\n    function getTransactions(address account)\n        external\n        view\n        override\n        returns (\n            uint256[] memory ids,\n            uint256[] memory amounts,\n            uint256[] memory expirations\n        )\n    {\n        uint256 len = owners[account].ids.length();\n        ids = new uint256[](len);\n        amounts = new uint256[](len);\n        expirations = new uint256[](len);\n        for (uint256 i = 0; i < len; i++) {\n            ids[i] = owners[account].ids.at(i);\n            amounts[i] = payments[owners[account].ids.at(i)].amount;\n            expirations[i] = payments[owners[account].ids.at(i)].expiration;\n        }\n    }\n\n    /// @notice Returns the total balance in MOCs for an account\n    /// @param account destination address\n    /// @return balance token quantity\n    function getBalance(address account) external view override returns (uint256) {\n        uint256 len = owners[account].ids.length();\n        uint256 balance;\n        for (uint256 i = 0; i < len; i++) {\n            balance = balance + payments[owners[account].ids.at(i)].amount;\n        }\n        return balance;\n    }\n\n    // Public variable\n    function getToken() external view override returns (IERC20) {\n        return _token;\n    }\n\n    // Public variable\n    function getLastId() external view override returns (uint256) {\n        return _id;\n    }\n\n    // Public variable\n    function getSource() external view override returns (address) {\n        return _source;\n    }\n}\n\n",
            "file": "DelayMachineFlat.sol"
        }
    ],
    "libraries": {},
    "creationData": {
        "blockHash": "0xa8e9e3347853c8b01ea697175a431b33d4ebeeee3a2d98fb7a78967c426ff66c",
        "blockNumber": 3092400,
        "transactionHash": "0x06fe90c5f75bc2ad096231d94b6df599b71025d421b37f21329b290621bf32aa",
        "timestamp": 1612879962
    }
}