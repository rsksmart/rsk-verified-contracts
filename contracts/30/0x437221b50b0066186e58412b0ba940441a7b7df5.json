{
  "address": "0x437221b50b0066186e58412b0ba940441a7b7df5",
  "net": {
    "id": "30",
    "name": "RSK Mainnet"
  },
  "name": "MoCConnector",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": "1"
    },
    "evmVersion": "byzantium"
  },
  "version": "0.5.8+commit.23d335f2",
  "source": "pragma solidity 0.5.8;\n\n\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n\n\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCWhitelist {\n  mapping(address => bool) whitelist;\n\n  /**\n   * @dev Check if an account is whitelisted\n   * @return Bool\n   */\n  function isWhitelisted(address account)\n    public\n    view\n    returns (bool)\n  {\n    require(account != address(0), \"Account must not be 0x0\");\n    return whitelist[account];\n  }\n\n  /**\n   * @dev Add account to whitelist\n   */\n  function add(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(!isWhitelisted(account), \"Account not allowed to add accounts into white list\");\n    whitelist[account] = true;\n  }\n\n  /**\n   * @dev Remove account to whitelist\n   */\n  function remove(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(isWhitelisted(account), \"Account is not allowed to remove address from the white list\");\n\n    whitelist[account] = false;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCConnector is MoCWhitelist, Initializable {\n  // References\n  address payable public moc;\n  address public docToken;\n  address public bproToken;\n  address public bproxManager;\n  address public mocState;\n  address public mocConverter;\n  address public mocSettlement;\n  address public mocExchange;\n  address public mocInrate;\n  address public mocBurnout;\n\n  bool internal initialized;\n\n  function initialize(\n    address payable mocAddress,\n    address docAddress,\n    address bproAddress,\n    address bproxAddress,\n    address stateAddress,\n    address settlementAddress,\n    address converterAddress,\n    address exchangeAddress,\n    address inrateAddress,\n    address burnoutBookAddress\n  ) public initializer {\n    moc = mocAddress;\n    docToken = docAddress;\n    bproToken = bproAddress;\n    bproxManager = bproxAddress;\n    mocState = stateAddress;\n    mocSettlement = settlementAddress;\n    mocConverter = converterAddress;\n    mocExchange = exchangeAddress;\n    mocInrate = inrateAddress;\n    mocBurnout = burnoutBookAddress;\n\n    // Add to Whitelist\n    add(mocAddress);\n    add(docAddress);\n    add(bproAddress);\n    add(bproxAddress);\n    add(stateAddress);\n    add(settlementAddress);\n    add(converterAddress);\n    add(exchangeAddress);\n    add(inrateAddress);\n    add(burnoutBookAddress);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}",
  "imports": [
    {
      "name": "MoCConnector_flat.sol",
      "contents": "pragma solidity 0.5.8;\n\n\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n\n\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCWhitelist {\n  mapping(address => bool) whitelist;\n\n  /**\n   * @dev Check if an account is whitelisted\n   * @return Bool\n   */\n  function isWhitelisted(address account)\n    public\n    view\n    returns (bool)\n  {\n    require(account != address(0), \"Account must not be 0x0\");\n    return whitelist[account];\n  }\n\n  /**\n   * @dev Add account to whitelist\n   */\n  function add(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(!isWhitelisted(account), \"Account not allowed to add accounts into white list\");\n    whitelist[account] = true;\n  }\n\n  /**\n   * @dev Remove account to whitelist\n   */\n  function remove(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(isWhitelisted(account), \"Account is not allowed to remove address from the white list\");\n\n    whitelist[account] = false;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCConnector is MoCWhitelist, Initializable {\n  // References\n  address payable public moc;\n  address public docToken;\n  address public bproToken;\n  address public bproxManager;\n  address public mocState;\n  address public mocConverter;\n  address public mocSettlement;\n  address public mocExchange;\n  address public mocInrate;\n  address public mocBurnout;\n\n  bool internal initialized;\n\n  function initialize(\n    address payable mocAddress,\n    address docAddress,\n    address bproAddress,\n    address bproxAddress,\n    address stateAddress,\n    address settlementAddress,\n    address converterAddress,\n    address exchangeAddress,\n    address inrateAddress,\n    address burnoutBookAddress\n  ) public initializer {\n    moc = mocAddress;\n    docToken = docAddress;\n    bproToken = bproAddress;\n    bproxManager = bproxAddress;\n    mocState = stateAddress;\n    mocSettlement = settlementAddress;\n    mocConverter = converterAddress;\n    mocExchange = exchangeAddress;\n    mocInrate = inrateAddress;\n    mocBurnout = burnoutBookAddress;\n\n    // Add to Whitelist\n    add(mocAddress);\n    add(docAddress);\n    add(bproAddress);\n    add(bproxAddress);\n    add(stateAddress);\n    add(settlementAddress);\n    add(converterAddress);\n    add(exchangeAddress);\n    add(inrateAddress);\n    add(burnoutBookAddress);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}",
      "file": "MoCConnector_flat.sol"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0xfd055539cbfae5ef33b462bd3ebb35173a3bdaf5913875356fbedf3c39fc5838",
    "blockNumber": 1764689,
    "transactionHash": "0xe16f7cc86cb5adc50f5a1b1403f9107af93b6cfb75f19768999c91b3d59a407f",
    "timestamp": 1570240189
  }
}