{
  "address": "0x23bf4cd25bed757984b201e7366267a4fb41e0a1",
  "net": {
    "id": "30",
    "name": "RSK Mainnet"
  },
  "name": "RDocStabilizer",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "evmVersion": "byzantium",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "metadata",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ]
      }
    }
  },
  "version": "0.5.8+commit.23d335f2",
  "source": "\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: contracts/base/MoCConnector.sol\n\npragma solidity 0.5.8;\n\n\n/// @dev Interace for MoCConnector with functions used by RDocStabilizer\ncontract MoCConnector {\n  address public riskProToken;\n  address public mocState;\n  address public reserveToken;\n  address public mocInrate;\n}\n\n// File: contracts/MoC.sol\n\npragma solidity 0.5.8;\n\n\n\n/// @dev Interace for MoC with functions used by RDocStabilizer\ncontract MoC {\n  MoCConnector public connector;\n\n  function getMocPrecision() public view returns(uint256);\n  function mintRiskPro(uint256 resTokensToMint) public;\n  function redeemRiskPro(uint256 riskProAmount) public;\n}\n\n// File: contracts/MoCState.sol\n\npragma solidity 0.5.8;\n\n\n/// @dev Interace for MoCState with functions used by RDocStabilizer\ncontract MoCState {\n  function globalCoverage() public view returns(uint256);\n  function cobj() public view returns(uint256);\n  function globalLockedReserveTokens() public view returns(uint256);\n  function riskProTecPrice() public view returns(uint256);\n  function getReserveTokenPrice() public view returns(uint256);\n  function getBcons() public view returns(uint256);\n}\n\n// File: contracts/MoCInrate.sol\n\npragma solidity 0.5.8;\n\n\n/// @dev Interace for MoCInrate with functions used by RDocStabilizer\ncontract MoCInrate {\n  function getCommissionRate() public view returns(uint256);\n}\n\n// File: contracts/IRDocStabilizer.sol\n\npragma solidity 0.5.8;\n\n\ninterface IRDocStabilizer {\n  /**\n    Required actions\n  */\n  enum Action {\n    NoAction,\n    IncreaseCoverage,\n    DecreaseCoverage\n  }\n\n  /**\n    Deposit RIF tokens into MoC contracts to mint RiskPro token\n  */\n  function increaseCoverage() external;\n\n  /**\n    Redeem RiskPro tokens into MoC contracts for RIF tokens\n  */\n  function decreaseCoverage() external;\n\n  /**\n    Determine which action has to be executed client\n    @return Action to be executed by client\n  */\n  function isActionRequired() external view returns (Action);\n\n  /**\n    Withdraw RIF tokens from the contract\n\n    Only the contract owner and a whitelisted address can withdraw tokens\n\n    @param amount Amount of tokens to withdraw\n  */\n  function withdrawRif(uint256 amount) external;\n\n  /**\n    Withdraw RiskPro tokens from the contract\n\n    Only the contract owner and a whitelisted address can withdraw tokens\n\n    @param amount Amount of tokens to withdraw\n  */\n  function withdrawRiskPro(uint256 amount) external;\n\n  /**\n    State of the contract\n  */\n  function getInfo() external view returns (\n    uint256 rifBalance,           // RIF balance\n    uint256 riskProBalance,       // RIF Pro balance\n    uint256 coverage,             // Current coverage\n    uint256 coverageTarget,       // Adjusted target coverage\n    uint256 coverageDeltaBelow,   // Delta below target\n    uint256 coverageDeltaAbove,   // Delta above target\n    uint256 coverageTotal         // Maximum coverage with RIF balance\n  );\n\n  /**\n    Address allowed to withdraw tokens from the contract\n    @return Financial account\n  */\n  function getFinancialAccount() external view returns (address);\n\n  /**\n    Change address allowed to withdraw tokens\n  */\n  function setFinancialAccount(address newAddress) external;\n\n  /**\n    Address allowed to modify the parameters of the contract\n    @return Address whitelisted\n  */\n  function getOperativeAccount() external view returns (address);\n\n  /**\n    Change address allowed to modify the parameters of the contract\n  */\n  function setOperativeAccount(address newAddress) external;\n\n  /**\n    Get coverage params\n  */\n  function getCoverageParams() external view returns (\n    uint256 _incrementCoverage,\n    uint256 _deltaBelowTarget,\n    uint256 _deltaAboveTarget\n  );\n\n  /**\n    Change coverage params\n  */\n  function setCoverageParams(\n    uint256 _incrementCoverage,\n    uint256 _deltaBelowTarget,\n    uint256 _deltaAboveTarget\n  ) external;\n\n  /**\n    Address of contract owner\n  */\n  function owner() external view returns (address);\n\n  /**\n    Change contract ownership\n  */\n  function transferOwnership(address newOwner) external;\n\n  /**\n    Change MoC contract address\n  */\n  function changeMoC(address newAddress) external;\n}\n\n// File: contracts/RDocStabilizer.sol\n\npragma solidity 0.5.8;\n\n\n\n\n\n\n\n\n\ncontract RDocStabilizer is IRDocStabilizer, Ownable {\n  using SafeMath for uint256;\n\n  // Maximum uint256 value\n  uint256 constant UINT256_MAX = ~uint256(0);\n\n  // Minimum possible delta\n  uint256 constant minimumDelta = 1;\n\n  // RIF token\n  IERC20 public rifToken;\n  // RiskPro token\n  IERC20 public riskProToken;\n\n  // Addres allowed to withdraw from contract\n  address private financialAccount;\n\n  // Addres allowed to change the parameters of the contract\n  address private operativeAccount;\n\n  // Percentage increment over adjusted coverage\n  uint256 public incrementCoverage;\n  // Delta below target to buy\n  uint256 public deltaBelowTarget;\n  // Delta above target to sell\n  uint256 public deltaAboveTarget;\n\n  // MoC contract\n  MoC public moc;\n  // MoC State\n  MoCState mocState;\n  // MoC Inrate\n  MoCInrate mocInrate;\n\n  // Event emitted when coverage has increased\n  event IncreaseCoverage(\n    uint256 newCoverage,\n    uint256 targetCoverage,\n    uint256 oldCoverage,\n    uint256 numTokens\n  );\n\n  // Event emitted when coverage has decreased\n  event DecreaseCoverage(\n    uint256 newCoverage,\n    uint256 targetCoverage,\n    uint256 oldCoverage,\n    uint256 numTokens\n  );\n\n  // RIF was withdrawn\n  event WithdrawnRIF(\n    address recipient,\n    uint256 value\n  );\n\n  // RIFPro was withdrawn\n  event WithdrawnRIFPro(\n    address recipient,\n    uint256 value\n  );\n\n  // Coverage params changed\n  event CoverageParamsChanged(\n    uint256 incrementCoverage,\n    uint256 deltaBelowTarget,\n    uint256 deltaAboveTarget\n  );\n\n  // Address allowed to withdraw has changed\n  event FinancialAccountAddressChanged(\n    address newAddress,\n    address oldAddress\n  );\n\n  // Address allowed to change the parameters has changed\n  event OperativeAccountAddressChanged(\n    address newAddress,\n    address oldAddress\n  );\n\n  // MoC contract address has changed\n  event MoCAddressChanged(\n    address newAddress,\n    address oldAddress\n  );\n\n  /**\n    @dev RDoc stabilizer constructor\n\n    @param _moc MoC contract\n    @param _incrementCoverage Percentage increment over adjusted coverage\n    @param _deltaBelowTarget Delta below target\n    @param _deltaAboveTarget Delta above target\n  */\n  constructor(MoC _moc,\n    uint256 _incrementCoverage,\n    uint256 _deltaBelowTarget,\n    uint256 _deltaAboveTarget\n  ) public {\n    _configureMoC(_moc);\n    _setCoverageParams(_incrementCoverage, _deltaBelowTarget, _deltaAboveTarget);\n  }\n\n  /**\n    Increase coverage by minting RIF Pro\n    */\n  function increaseCoverage() external {\n    uint256 maxTokens = rifToken.balanceOf(address(this));\n    require(maxTokens > 0, \"Not enough RIF balance\");\n    uint256 globalCoverage = mocState.globalCoverage();\n    uint256 target = targetCoverage();\n    if (globalCoverage != UINT256_MAX && globalCoverage < target.sub(deltaBelowTarget)) {\n      uint256 commissionRate = mocInrate.getCommissionRate();\n      uint256 globalLockedReserveTokens = mocState.globalLockedReserveTokens();\n      uint256 mocPrecision = moc.getMocPrecision();\n\n      // Coverage variation\n      //\n      //   deltaCoverage = targetCoverage - currentCoverage\n      //\n      // Reserves variation\n      //\n      //   deltaReserves = deposit\n      //\n      // Relation between coverage variation and reserves variation\n      //\n      //   deltaReserves = lockedReserveTokens * deltaCoverage\n      //\n      // Then we have\n      //\n      //   totalDeposit = deposit + deposit * commissionRate\n      //\n      //   totalDeposit = deposit * (1 + commissionRate)\n      //\n      //   totalDeposit = deltaReserves * (1 + commissionRate)\n      //\n      //   totalDeposit = lockedReserveTokens * deltaCoverage * (1 + commissionRate)\n      //\n      //   totalDeposit = lockedReserveTokens * (targetCoverage - currentCoverage) * (1 + commissionRate)\n      //\n      //   deposit = totalDeposit / (1 + commissionRate)\n      //\n\n      uint256 tokensWithCommission = globalLockedReserveTokens.mul(mocPrecision.add(commissionRate)).div(mocPrecision).mul(target.sub(globalCoverage)).div(mocPrecision);\n      if (tokensWithCommission > maxTokens) {\n        tokensWithCommission = maxTokens;\n      }\n      uint256 tokens = tokensWithCommission.mul(mocPrecision).div(mocPrecision.add(commissionRate));\n      rifToken.approve(address(moc), tokensWithCommission);\n      moc.mintRiskPro(tokens);\n      uint256 newCoverage = mocState.globalCoverage();\n      emit IncreaseCoverage(newCoverage, target, globalCoverage, tokens);\n    }\n  }\n\n  /**\n    Decrease coverage by redeeming RIF Pro\n    */\n  function decreaseCoverage() external {\n    uint256 maxTokens = riskProToken.balanceOf(address(this));\n    require(maxTokens > 0, \"Not enough RIF Pro balance\");\n    uint256 globalCoverage = mocState.globalCoverage();\n    uint256 target = targetCoverage();\n    if (globalCoverage != UINT256_MAX && target.add(deltaAboveTarget) < globalCoverage) {\n      uint256 globalLockedReserveTokens = mocState.globalLockedReserveTokens();\n      uint256 mocPrecision = moc.getMocPrecision();\n      uint256 riskProTecPrice = mocState.riskProTecPrice();\n\n      // Coverage variation\n      //\n      //   deltaCoverage = currentCoverage - targetCoverage\n      //\n      // Reserves variation\n      //\n      //   deltaReserves = riskDeposit * riskPrice\n      //\n      // Relation between coverage variation and reserves variation\n      //\n      //   deltaReserves = lockedReserveTokens * deltaCoverage\n      //\n      // Then we have\n      //\n      //   riskDeposit = deltaReserves / riskPrice\n      //   riskDeposit = lockedReserveTokens * deltaCoverage / riskPrice\n      //\n\n      uint256 riskTokens = globalLockedReserveTokens.mul(globalCoverage.sub(target)).div(riskProTecPrice);\n      if (riskTokens > maxTokens) {\n        riskTokens = maxTokens;\n      }\n      uint256 tokens = riskTokens.mul(riskProTecPrice).div(mocPrecision);\n      moc.redeemRiskPro(riskTokens);\n      uint256 newCoverage = mocState.globalCoverage();\n      emit DecreaseCoverage(newCoverage, target, globalCoverage, tokens);\n    }\n  }\n\n  /**\n    Client action required\n\n    @return Client action required to execute\n    */\n  function isActionRequired() external view returns (Action) {\n    uint256 globalCoverage = mocState.globalCoverage();\n    if (globalCoverage == UINT256_MAX) {\n      return IRDocStabilizer.Action.NoAction;\n    }\n    uint256 target = targetCoverage();\n    if (globalCoverage < target.sub(deltaBelowTarget)) {\n      return IRDocStabilizer.Action.IncreaseCoverage;\n    } else if (target.add(deltaAboveTarget) < globalCoverage) {\n      return IRDocStabilizer.Action.DecreaseCoverage;\n    }\n    return IRDocStabilizer.Action.NoAction;\n  }\n\n  /**\n    Withdraw RIF from the contract\n\n    @param amount Amount of RIF to withdraw\n    */\n  function withdrawRif(uint256 amount) external {\n    require(msg.sender == financialAccount, \"Only financialAccount address are allowed to withdraw RIF tokens\");\n    rifToken.transfer(msg.sender, amount);\n    emit WithdrawnRIF(msg.sender, amount);\n  }\n\n  /**\n    Withdraw RIF Pro from the contract\n\n    @param amount Amount of RIF Pro to withdraw\n    */\n  function withdrawRiskPro(uint256 amount) external {\n    require(msg.sender == financialAccount, \"Only financialAccount address are allowed to withdraw RiskPro tokens\");\n    riskProToken.transfer(msg.sender, amount);\n    emit WithdrawnRIFPro(msg.sender, amount);\n  }\n\n  /**\n    State of the contract\n\n    @return Stabilizer and MoC state\n    */\n  function getInfo() external view returns (\n    uint256 rifBalance,\n    uint256 riskProBalance,\n    uint256 coverage,\n    uint256 coverageTarget,\n    uint256 coverageDeltaBelow,\n    uint256 coverageDeltaAbove,\n    uint256 coverageTotal\n  ) {\n    rifBalance = rifToken.balanceOf(address(this));\n    riskProBalance = riskProToken.balanceOf(address(this));\n    coverage = mocState.globalCoverage();\n    coverageTarget = targetCoverage();\n    coverageDeltaBelow = deltaBelowTarget;\n    coverageDeltaAbove = deltaAboveTarget;\n    coverageTotal = calcCoverage(rifBalance);\n  }\n\n  /**\n    Retrieve target coverage params\n\n    @return Coverage params\n    */\n  function getCoverageParams() external view returns (\n    uint256 _incrementCoverage,      // Percentage increment over adjusted coverage\n    uint256 _deltaBelowTarget,    // Points below target to call increase coverage\n    uint256 _deltaAboveTarget     // Points above target to call decrease coverage\n  ) {\n    _incrementCoverage = incrementCoverage;\n    _deltaBelowTarget = deltaBelowTarget;\n    _deltaAboveTarget = deltaAboveTarget;\n  }\n\n  /**\n    Modify target coverage params\n\n    targetCoverage = adjustedCoverage * (1 + _incrementCoverage)\n\n    @param _incrementCoverage Percentage increment above adjusted coverage\n    @param _deltaBelowTarget Points below target to call increase coverage\n    @param _deltaAboveTarget Points above target to call increase coverage\n    */\n  function setCoverageParams(\n    uint256 _incrementCoverage,\n    uint256 _deltaBelowTarget,\n    uint256 _deltaAboveTarget\n  ) external {\n    require(msg.sender == operativeAccount, \"Only operativeAccount address are allowed to change the contract params\");\n    uint256 newDelta = _deltaBelowTarget.add(_deltaAboveTarget);\n    require(newDelta > minimumDelta, \"Total delta required to be above minimum\");\n    _setCoverageParams(_incrementCoverage, _deltaBelowTarget, _deltaAboveTarget);\n  }\n\n  /**\n    @dev Help to change coverage params\n    */\n  function _setCoverageParams(\n    uint256 _incrementCoverage,\n    uint256 _deltaBelowTarget,\n    uint256 _deltaAboveTarget\n  ) private {\n    incrementCoverage = _incrementCoverage;\n    deltaBelowTarget = _deltaBelowTarget;\n    deltaAboveTarget = _deltaAboveTarget;\n    emit CoverageParamsChanged(_incrementCoverage, _deltaBelowTarget, _deltaAboveTarget);\n  }\n\n  /**\n    Retrieve current financialAccount address\n\n    @return Current financialAccount address\n    */\n  function getFinancialAccount() external view returns (address) {\n    return financialAccount;\n  }\n\n  /**\n    Modify financialAccount address\n\n    @param newAddress Address to be assigned to financialAccount\n    */\n  function setFinancialAccount(address newAddress) external onlyOwner {\n    require(newAddress != operativeAccount, \"financial and operative accounts must be different\");\n    address oldAddress = financialAccount;\n    financialAccount = newAddress;\n    emit FinancialAccountAddressChanged(newAddress, oldAddress);\n  }\n\n  /**\n    Address allowed to change the parameters of the contract\n    @return Address whitelisted\n  */\n  function getOperativeAccount() external view returns (address) {\n    return operativeAccount;\n  }\n\n  /**\n    Change address allowed to change the parameters of the contract\n  */\n  function setOperativeAccount(address newAddress) external onlyOwner {\n    require(newAddress != financialAccount, \"financial and operative accounts must be different\");\n    address oldAddress = operativeAccount;\n    operativeAccount = newAddress;\n    emit OperativeAccountAddressChanged(newAddress, oldAddress);\n  }\n\n  /**\n    Change MoC address\n\n    @param newAddress Address of the MoC contract\n    */\n  function changeMoC(address newAddress) external onlyOwner {\n    _configureMoC(MoC(newAddress));\n  }\n\n  /**\n    @dev Helper to change MoC address\n    */\n  function _configureMoC(MoC _moc) private {\n    address oldAddress = address(moc);\n    moc = _moc;\n    MoCConnector connector = moc.connector();\n    rifToken = IERC20(connector.reserveToken());\n    riskProToken = IERC20(connector.riskProToken());\n    mocState = MoCState(connector.mocState());\n    mocInrate = MoCInrate(connector.mocInrate());\n    emit MoCAddressChanged(address(moc), oldAddress);\n  }\n\n  /**\n    @dev Expected coverage when minting RIF\n\n    @param rifBalance Amount of RIF to deposit\n    @return New expected coverage\n    */\n  function calcCoverage(uint256 rifBalance) public view returns (uint256) {\n    uint256 globalLockedReserveTokens = mocState.globalLockedReserveTokens();\n    if (globalLockedReserveTokens == 0) {\n      return UINT256_MAX;\n    }\n    uint256 mocPrecision = moc.getMocPrecision();\n    uint256 globalCoverage = mocState.globalCoverage();\n    return globalCoverage.add(rifBalance.mul(mocPrecision).div(globalLockedReserveTokens));\n  }\n\n  /**\n    @dev Adjusted target coverage\n\n    @return Adjusted coverage\n    */\n  function targetCoverage() public view returns (uint256) {\n    uint256 reservePrice = mocState.getReserveTokenPrice();\n    uint256 bCons = mocState.getBcons();\n    uint256 cobj = mocState.cobj();\n    uint256 adjCobj = cobj.mul(reservePrice).div(bCons);\n    uint256 mocPrecision = moc.getMocPrecision();\n    return adjCobj.mul(mocPrecision.add(incrementCoverage)).div(mocPrecision);\n  }\n}\n",
  "imports": [
    {
      "name": "RDocStabilizer_flat.sol",
      "contents": "\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: contracts/base/MoCConnector.sol\n\npragma solidity 0.5.8;\n\n\n/// @dev Interace for MoCConnector with functions used by RDocStabilizer\ncontract MoCConnector {\n  address public riskProToken;\n  address public mocState;\n  address public reserveToken;\n  address public mocInrate;\n}\n\n// File: contracts/MoC.sol\n\npragma solidity 0.5.8;\n\n\n\n/// @dev Interace for MoC with functions used by RDocStabilizer\ncontract MoC {\n  MoCConnector public connector;\n\n  function getMocPrecision() public view returns(uint256);\n  function mintRiskPro(uint256 resTokensToMint) public;\n  function redeemRiskPro(uint256 riskProAmount) public;\n}\n\n// File: contracts/MoCState.sol\n\npragma solidity 0.5.8;\n\n\n/// @dev Interace for MoCState with functions used by RDocStabilizer\ncontract MoCState {\n  function globalCoverage() public view returns(uint256);\n  function cobj() public view returns(uint256);\n  function globalLockedReserveTokens() public view returns(uint256);\n  function riskProTecPrice() public view returns(uint256);\n  function getReserveTokenPrice() public view returns(uint256);\n  function getBcons() public view returns(uint256);\n}\n\n// File: contracts/MoCInrate.sol\n\npragma solidity 0.5.8;\n\n\n/// @dev Interace for MoCInrate with functions used by RDocStabilizer\ncontract MoCInrate {\n  function getCommissionRate() public view returns(uint256);\n}\n\n// File: contracts/IRDocStabilizer.sol\n\npragma solidity 0.5.8;\n\n\ninterface IRDocStabilizer {\n  /**\n    Required actions\n  */\n  enum Action {\n    NoAction,\n    IncreaseCoverage,\n    DecreaseCoverage\n  }\n\n  /**\n    Deposit RIF tokens into MoC contracts to mint RiskPro token\n  */\n  function increaseCoverage() external;\n\n  /**\n    Redeem RiskPro tokens into MoC contracts for RIF tokens\n  */\n  function decreaseCoverage() external;\n\n  /**\n    Determine which action has to be executed client\n    @return Action to be executed by client\n  */\n  function isActionRequired() external view returns (Action);\n\n  /**\n    Withdraw RIF tokens from the contract\n\n    Only the contract owner and a whitelisted address can withdraw tokens\n\n    @param amount Amount of tokens to withdraw\n  */\n  function withdrawRif(uint256 amount) external;\n\n  /**\n    Withdraw RiskPro tokens from the contract\n\n    Only the contract owner and a whitelisted address can withdraw tokens\n\n    @param amount Amount of tokens to withdraw\n  */\n  function withdrawRiskPro(uint256 amount) external;\n\n  /**\n    State of the contract\n  */\n  function getInfo() external view returns (\n    uint256 rifBalance,           // RIF balance\n    uint256 riskProBalance,       // RIF Pro balance\n    uint256 coverage,             // Current coverage\n    uint256 coverageTarget,       // Adjusted target coverage\n    uint256 coverageDeltaBelow,   // Delta below target\n    uint256 coverageDeltaAbove,   // Delta above target\n    uint256 coverageTotal         // Maximum coverage with RIF balance\n  );\n\n  /**\n    Address allowed to withdraw tokens from the contract\n    @return Financial account\n  */\n  function getFinancialAccount() external view returns (address);\n\n  /**\n    Change address allowed to withdraw tokens\n  */\n  function setFinancialAccount(address newAddress) external;\n\n  /**\n    Address allowed to modify the parameters of the contract\n    @return Address whitelisted\n  */\n  function getOperativeAccount() external view returns (address);\n\n  /**\n    Change address allowed to modify the parameters of the contract\n  */\n  function setOperativeAccount(address newAddress) external;\n\n  /**\n    Get coverage params\n  */\n  function getCoverageParams() external view returns (\n    uint256 _incrementCoverage,\n    uint256 _deltaBelowTarget,\n    uint256 _deltaAboveTarget\n  );\n\n  /**\n    Change coverage params\n  */\n  function setCoverageParams(\n    uint256 _incrementCoverage,\n    uint256 _deltaBelowTarget,\n    uint256 _deltaAboveTarget\n  ) external;\n\n  /**\n    Address of contract owner\n  */\n  function owner() external view returns (address);\n\n  /**\n    Change contract ownership\n  */\n  function transferOwnership(address newOwner) external;\n\n  /**\n    Change MoC contract address\n  */\n  function changeMoC(address newAddress) external;\n}\n\n// File: contracts/RDocStabilizer.sol\n\npragma solidity 0.5.8;\n\n\n\n\n\n\n\n\n\ncontract RDocStabilizer is IRDocStabilizer, Ownable {\n  using SafeMath for uint256;\n\n  // Maximum uint256 value\n  uint256 constant UINT256_MAX = ~uint256(0);\n\n  // Minimum possible delta\n  uint256 constant minimumDelta = 1;\n\n  // RIF token\n  IERC20 public rifToken;\n  // RiskPro token\n  IERC20 public riskProToken;\n\n  // Addres allowed to withdraw from contract\n  address private financialAccount;\n\n  // Addres allowed to change the parameters of the contract\n  address private operativeAccount;\n\n  // Percentage increment over adjusted coverage\n  uint256 public incrementCoverage;\n  // Delta below target to buy\n  uint256 public deltaBelowTarget;\n  // Delta above target to sell\n  uint256 public deltaAboveTarget;\n\n  // MoC contract\n  MoC public moc;\n  // MoC State\n  MoCState mocState;\n  // MoC Inrate\n  MoCInrate mocInrate;\n\n  // Event emitted when coverage has increased\n  event IncreaseCoverage(\n    uint256 newCoverage,\n    uint256 targetCoverage,\n    uint256 oldCoverage,\n    uint256 numTokens\n  );\n\n  // Event emitted when coverage has decreased\n  event DecreaseCoverage(\n    uint256 newCoverage,\n    uint256 targetCoverage,\n    uint256 oldCoverage,\n    uint256 numTokens\n  );\n\n  // RIF was withdrawn\n  event WithdrawnRIF(\n    address recipient,\n    uint256 value\n  );\n\n  // RIFPro was withdrawn\n  event WithdrawnRIFPro(\n    address recipient,\n    uint256 value\n  );\n\n  // Coverage params changed\n  event CoverageParamsChanged(\n    uint256 incrementCoverage,\n    uint256 deltaBelowTarget,\n    uint256 deltaAboveTarget\n  );\n\n  // Address allowed to withdraw has changed\n  event FinancialAccountAddressChanged(\n    address newAddress,\n    address oldAddress\n  );\n\n  // Address allowed to change the parameters has changed\n  event OperativeAccountAddressChanged(\n    address newAddress,\n    address oldAddress\n  );\n\n  // MoC contract address has changed\n  event MoCAddressChanged(\n    address newAddress,\n    address oldAddress\n  );\n\n  /**\n    @dev RDoc stabilizer constructor\n\n    @param _moc MoC contract\n    @param _incrementCoverage Percentage increment over adjusted coverage\n    @param _deltaBelowTarget Delta below target\n    @param _deltaAboveTarget Delta above target\n  */\n  constructor(MoC _moc,\n    uint256 _incrementCoverage,\n    uint256 _deltaBelowTarget,\n    uint256 _deltaAboveTarget\n  ) public {\n    _configureMoC(_moc);\n    _setCoverageParams(_incrementCoverage, _deltaBelowTarget, _deltaAboveTarget);\n  }\n\n  /**\n    Increase coverage by minting RIF Pro\n    */\n  function increaseCoverage() external {\n    uint256 maxTokens = rifToken.balanceOf(address(this));\n    require(maxTokens > 0, \"Not enough RIF balance\");\n    uint256 globalCoverage = mocState.globalCoverage();\n    uint256 target = targetCoverage();\n    if (globalCoverage != UINT256_MAX && globalCoverage < target.sub(deltaBelowTarget)) {\n      uint256 commissionRate = mocInrate.getCommissionRate();\n      uint256 globalLockedReserveTokens = mocState.globalLockedReserveTokens();\n      uint256 mocPrecision = moc.getMocPrecision();\n\n      // Coverage variation\n      //\n      //   deltaCoverage = targetCoverage - currentCoverage\n      //\n      // Reserves variation\n      //\n      //   deltaReserves = deposit\n      //\n      // Relation between coverage variation and reserves variation\n      //\n      //   deltaReserves = lockedReserveTokens * deltaCoverage\n      //\n      // Then we have\n      //\n      //   totalDeposit = deposit + deposit * commissionRate\n      //\n      //   totalDeposit = deposit * (1 + commissionRate)\n      //\n      //   totalDeposit = deltaReserves * (1 + commissionRate)\n      //\n      //   totalDeposit = lockedReserveTokens * deltaCoverage * (1 + commissionRate)\n      //\n      //   totalDeposit = lockedReserveTokens * (targetCoverage - currentCoverage) * (1 + commissionRate)\n      //\n      //   deposit = totalDeposit / (1 + commissionRate)\n      //\n\n      uint256 tokensWithCommission = globalLockedReserveTokens.mul(mocPrecision.add(commissionRate)).div(mocPrecision).mul(target.sub(globalCoverage)).div(mocPrecision);\n      if (tokensWithCommission > maxTokens) {\n        tokensWithCommission = maxTokens;\n      }\n      uint256 tokens = tokensWithCommission.mul(mocPrecision).div(mocPrecision.add(commissionRate));\n      rifToken.approve(address(moc), tokensWithCommission);\n      moc.mintRiskPro(tokens);\n      uint256 newCoverage = mocState.globalCoverage();\n      emit IncreaseCoverage(newCoverage, target, globalCoverage, tokens);\n    }\n  }\n\n  /**\n    Decrease coverage by redeeming RIF Pro\n    */\n  function decreaseCoverage() external {\n    uint256 maxTokens = riskProToken.balanceOf(address(this));\n    require(maxTokens > 0, \"Not enough RIF Pro balance\");\n    uint256 globalCoverage = mocState.globalCoverage();\n    uint256 target = targetCoverage();\n    if (globalCoverage != UINT256_MAX && target.add(deltaAboveTarget) < globalCoverage) {\n      uint256 globalLockedReserveTokens = mocState.globalLockedReserveTokens();\n      uint256 mocPrecision = moc.getMocPrecision();\n      uint256 riskProTecPrice = mocState.riskProTecPrice();\n\n      // Coverage variation\n      //\n      //   deltaCoverage = currentCoverage - targetCoverage\n      //\n      // Reserves variation\n      //\n      //   deltaReserves = riskDeposit * riskPrice\n      //\n      // Relation between coverage variation and reserves variation\n      //\n      //   deltaReserves = lockedReserveTokens * deltaCoverage\n      //\n      // Then we have\n      //\n      //   riskDeposit = deltaReserves / riskPrice\n      //   riskDeposit = lockedReserveTokens * deltaCoverage / riskPrice\n      //\n\n      uint256 riskTokens = globalLockedReserveTokens.mul(globalCoverage.sub(target)).div(riskProTecPrice);\n      if (riskTokens > maxTokens) {\n        riskTokens = maxTokens;\n      }\n      uint256 tokens = riskTokens.mul(riskProTecPrice).div(mocPrecision);\n      moc.redeemRiskPro(riskTokens);\n      uint256 newCoverage = mocState.globalCoverage();\n      emit DecreaseCoverage(newCoverage, target, globalCoverage, tokens);\n    }\n  }\n\n  /**\n    Client action required\n\n    @return Client action required to execute\n    */\n  function isActionRequired() external view returns (Action) {\n    uint256 globalCoverage = mocState.globalCoverage();\n    if (globalCoverage == UINT256_MAX) {\n      return IRDocStabilizer.Action.NoAction;\n    }\n    uint256 target = targetCoverage();\n    if (globalCoverage < target.sub(deltaBelowTarget)) {\n      return IRDocStabilizer.Action.IncreaseCoverage;\n    } else if (target.add(deltaAboveTarget) < globalCoverage) {\n      return IRDocStabilizer.Action.DecreaseCoverage;\n    }\n    return IRDocStabilizer.Action.NoAction;\n  }\n\n  /**\n    Withdraw RIF from the contract\n\n    @param amount Amount of RIF to withdraw\n    */\n  function withdrawRif(uint256 amount) external {\n    require(msg.sender == financialAccount, \"Only financialAccount address are allowed to withdraw RIF tokens\");\n    rifToken.transfer(msg.sender, amount);\n    emit WithdrawnRIF(msg.sender, amount);\n  }\n\n  /**\n    Withdraw RIF Pro from the contract\n\n    @param amount Amount of RIF Pro to withdraw\n    */\n  function withdrawRiskPro(uint256 amount) external {\n    require(msg.sender == financialAccount, \"Only financialAccount address are allowed to withdraw RiskPro tokens\");\n    riskProToken.transfer(msg.sender, amount);\n    emit WithdrawnRIFPro(msg.sender, amount);\n  }\n\n  /**\n    State of the contract\n\n    @return Stabilizer and MoC state\n    */\n  function getInfo() external view returns (\n    uint256 rifBalance,\n    uint256 riskProBalance,\n    uint256 coverage,\n    uint256 coverageTarget,\n    uint256 coverageDeltaBelow,\n    uint256 coverageDeltaAbove,\n    uint256 coverageTotal\n  ) {\n    rifBalance = rifToken.balanceOf(address(this));\n    riskProBalance = riskProToken.balanceOf(address(this));\n    coverage = mocState.globalCoverage();\n    coverageTarget = targetCoverage();\n    coverageDeltaBelow = deltaBelowTarget;\n    coverageDeltaAbove = deltaAboveTarget;\n    coverageTotal = calcCoverage(rifBalance);\n  }\n\n  /**\n    Retrieve target coverage params\n\n    @return Coverage params\n    */\n  function getCoverageParams() external view returns (\n    uint256 _incrementCoverage,      // Percentage increment over adjusted coverage\n    uint256 _deltaBelowTarget,    // Points below target to call increase coverage\n    uint256 _deltaAboveTarget     // Points above target to call decrease coverage\n  ) {\n    _incrementCoverage = incrementCoverage;\n    _deltaBelowTarget = deltaBelowTarget;\n    _deltaAboveTarget = deltaAboveTarget;\n  }\n\n  /**\n    Modify target coverage params\n\n    targetCoverage = adjustedCoverage * (1 + _incrementCoverage)\n\n    @param _incrementCoverage Percentage increment above adjusted coverage\n    @param _deltaBelowTarget Points below target to call increase coverage\n    @param _deltaAboveTarget Points above target to call increase coverage\n    */\n  function setCoverageParams(\n    uint256 _incrementCoverage,\n    uint256 _deltaBelowTarget,\n    uint256 _deltaAboveTarget\n  ) external {\n    require(msg.sender == operativeAccount, \"Only operativeAccount address are allowed to change the contract params\");\n    uint256 newDelta = _deltaBelowTarget.add(_deltaAboveTarget);\n    require(newDelta > minimumDelta, \"Total delta required to be above minimum\");\n    _setCoverageParams(_incrementCoverage, _deltaBelowTarget, _deltaAboveTarget);\n  }\n\n  /**\n    @dev Help to change coverage params\n    */\n  function _setCoverageParams(\n    uint256 _incrementCoverage,\n    uint256 _deltaBelowTarget,\n    uint256 _deltaAboveTarget\n  ) private {\n    incrementCoverage = _incrementCoverage;\n    deltaBelowTarget = _deltaBelowTarget;\n    deltaAboveTarget = _deltaAboveTarget;\n    emit CoverageParamsChanged(_incrementCoverage, _deltaBelowTarget, _deltaAboveTarget);\n  }\n\n  /**\n    Retrieve current financialAccount address\n\n    @return Current financialAccount address\n    */\n  function getFinancialAccount() external view returns (address) {\n    return financialAccount;\n  }\n\n  /**\n    Modify financialAccount address\n\n    @param newAddress Address to be assigned to financialAccount\n    */\n  function setFinancialAccount(address newAddress) external onlyOwner {\n    require(newAddress != operativeAccount, \"financial and operative accounts must be different\");\n    address oldAddress = financialAccount;\n    financialAccount = newAddress;\n    emit FinancialAccountAddressChanged(newAddress, oldAddress);\n  }\n\n  /**\n    Address allowed to change the parameters of the contract\n    @return Address whitelisted\n  */\n  function getOperativeAccount() external view returns (address) {\n    return operativeAccount;\n  }\n\n  /**\n    Change address allowed to change the parameters of the contract\n  */\n  function setOperativeAccount(address newAddress) external onlyOwner {\n    require(newAddress != financialAccount, \"financial and operative accounts must be different\");\n    address oldAddress = operativeAccount;\n    operativeAccount = newAddress;\n    emit OperativeAccountAddressChanged(newAddress, oldAddress);\n  }\n\n  /**\n    Change MoC address\n\n    @param newAddress Address of the MoC contract\n    */\n  function changeMoC(address newAddress) external onlyOwner {\n    _configureMoC(MoC(newAddress));\n  }\n\n  /**\n    @dev Helper to change MoC address\n    */\n  function _configureMoC(MoC _moc) private {\n    address oldAddress = address(moc);\n    moc = _moc;\n    MoCConnector connector = moc.connector();\n    rifToken = IERC20(connector.reserveToken());\n    riskProToken = IERC20(connector.riskProToken());\n    mocState = MoCState(connector.mocState());\n    mocInrate = MoCInrate(connector.mocInrate());\n    emit MoCAddressChanged(address(moc), oldAddress);\n  }\n\n  /**\n    @dev Expected coverage when minting RIF\n\n    @param rifBalance Amount of RIF to deposit\n    @return New expected coverage\n    */\n  function calcCoverage(uint256 rifBalance) public view returns (uint256) {\n    uint256 globalLockedReserveTokens = mocState.globalLockedReserveTokens();\n    if (globalLockedReserveTokens == 0) {\n      return UINT256_MAX;\n    }\n    uint256 mocPrecision = moc.getMocPrecision();\n    uint256 globalCoverage = mocState.globalCoverage();\n    return globalCoverage.add(rifBalance.mul(mocPrecision).div(globalLockedReserveTokens));\n  }\n\n  /**\n    @dev Adjusted target coverage\n\n    @return Adjusted coverage\n    */\n  function targetCoverage() public view returns (uint256) {\n    uint256 reservePrice = mocState.getReserveTokenPrice();\n    uint256 bCons = mocState.getBcons();\n    uint256 cobj = mocState.cobj();\n    uint256 adjCobj = cobj.mul(reservePrice).div(bCons);\n    uint256 mocPrecision = moc.getMocPrecision();\n    return adjCobj.mul(mocPrecision.add(incrementCoverage)).div(mocPrecision);\n  }\n}\n",
      "file": "RDocStabilizer_flat.sol"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x715bd6dfafdac0360ee995e7bd5ca162e01a6fad1abe102c793907e7da676cec",
    "blockNumber": 2298569,
    "transactionHash": "0xc2e86150ca0b17028c5a6a655ff7a34f32d0fd46b82cfaeb15e741acee941650",
    "timestamp": 1587700052
  },
  "constructorArguments": [
    "0xcff3fcaec2352c672c38d77cb1a064b7d50ce7e1",
    "0x16345785d8a0000",
    "0x2386f26fc10000",
    "0x2386f26fc10000"
  ]
}