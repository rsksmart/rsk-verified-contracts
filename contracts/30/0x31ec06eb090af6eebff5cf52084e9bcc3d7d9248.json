{
    "address": "0x31ec06eb090af6eebff5cf52084e9bcc3d7d9248",
    "net": {
        "id": "30",
        "name": "RSK Mainnet"
    },
    "name": "TokenSender",
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        }
    },
    "version": "0.5.17+commit.d19bba13",
    "source": "/**\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0.\n */\n\npragma solidity >=0.5.0 <0.6.0;\n\ncontract IERC20 {\n\tstring public name;\n\tuint8 public decimals;\n\tstring public symbol;\n\n\tfunction totalSupply() public view returns (uint256);\n\n\tfunction balanceOf(address _who) public view returns (uint256);\n\n\tfunction transfer(address _to, uint256 _value) public returns (bool);\n\n\tfunction allowance(address _owner, address _spender) public view returns (uint256);\n\n\tfunction transferFrom(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _value\n\t) public returns (bool);\n\n\tfunction approve(address _spender, uint256 _value) public returns (bool);\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n\t// Empty internal constructor, to prevent people from mistakenly deploying\n\t// an instance of this contract, which should be used via inheritance.\n\tconstructor() internal {}\n\n\t// solhint-disable-previous-line no-empty-blocks\n\n\tfunction _msgSender() internal view returns (address payable) {\n\t\treturn msg.sender;\n\t}\n\n\tfunction _msgData() internal view returns (bytes memory) {\n\t\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\t\treturn msg.data;\n\t}\n}\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n\taddress private _owner;\n\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\t/**\n\t * @dev Initializes the contract setting the deployer as the initial owner.\n\t */\n\tconstructor() internal {\n\t\taddress msgSender = _msgSender();\n\t\t_owner = msgSender;\n\t\temit OwnershipTransferred(address(0), msgSender);\n\t}\n\n\t/**\n\t * @dev Returns the address of the current owner.\n\t */\n\tfunction owner() public view returns (address) {\n\t\treturn _owner;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the owner.\n\t */\n\tmodifier onlyOwner() {\n\t\trequire(isOwner(), \"unauthorized\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Returns true if the caller is the current owner.\n\t */\n\tfunction isOwner() public view returns (bool) {\n\t\treturn _msgSender() == _owner;\n\t}\n\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t * Can only be called by the current owner.\n\t */\n\tfunction transferOwnership(address newOwner) public onlyOwner {\n\t\t_transferOwnership(newOwner);\n\t}\n\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t */\n\tfunction _transferOwnership(address newOwner) internal {\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\t\temit OwnershipTransferred(_owner, newOwner);\n\t\t_owner = newOwner;\n\t}\n}\n\n\n\ncontract TokenSender is Ownable {\n\t///@notice the SOV token contract\n\taddress public SOV;\n\n\t//user => flag whether user has admin role\n\tmapping(address => bool) public admins;\n\n\tevent SOVTransferred(address indexed receiver, uint256 amount);\n\tevent AdminAdded(address admin);\n\tevent AdminRemoved(address admin);\n\n\tconstructor(address _SOV) public {\n\t\trequire(_SOV != address(0), \"SOV address invalid\");\n\n\t\tSOV = _SOV;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the owner or admin.\n\t */\n\tmodifier onlyAuthorized() {\n\t\trequire(isOwner() || admins[msg.sender], \"unauthorized\");\n\t\t_;\n\t}\n\n\tfunction addAdmin(address _admin) public onlyOwner {\n\t\tadmins[_admin] = true;\n\t\temit AdminAdded(_admin);\n\t}\n\n\tfunction removeAdmin(address _admin) public onlyOwner {\n\t\tadmins[_admin] = false;\n\t\temit AdminRemoved(_admin);\n\t}\n\n\t/**\n\t * @notice transfers given amounts of SOV to the given addresses\n\t * @param _receivers the addresses of the SOV receivers\n\t * @param _amounts the amounts to be transferred\n\t */\n\tfunction transferSOVusingList(address[] memory _receivers, uint256[] memory _amounts) public onlyAuthorized {\n\t\trequire(_receivers.length == _amounts.length, \"arrays mismatch\");\n\n\t\tfor (uint256 i = 0; i < _receivers.length; i++) {\n\t\t\t_transferSOV(_receivers[i], _amounts[i]);\n\t\t}\n\t}\n\n\t/**\n\t * @notice transfers SOV tokens to given address\n\t * @param _receiver the address of the SOV receiver\n\t * @param _amount the amount to be transferred\n\t */\n\tfunction transferSOV(address _receiver, uint256 _amount) public onlyAuthorized {\n\t\t_transferSOV(_receiver, _amount);\n\t}\n\n\tfunction _transferSOV(address _receiver, uint256 _amount) internal {\n\t\trequire(_receiver != address(0), \"receiver address invalid\");\n\t\trequire(_amount != 0, \"amount invalid\");\n\n\t\trequire(IERC20(SOV).transfer(_receiver, _amount), \"transfer failed\");\n\t\temit SOVTransferred(_receiver, _amount);\n\t}\n}\n",
    "imports": [
        {
            "name": "TokenSender_flat.sol",
            "contents": "/**\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0.\n */\n\npragma solidity >=0.5.0 <0.6.0;\n\ncontract IERC20 {\n\tstring public name;\n\tuint8 public decimals;\n\tstring public symbol;\n\n\tfunction totalSupply() public view returns (uint256);\n\n\tfunction balanceOf(address _who) public view returns (uint256);\n\n\tfunction transfer(address _to, uint256 _value) public returns (bool);\n\n\tfunction allowance(address _owner, address _spender) public view returns (uint256);\n\n\tfunction transferFrom(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _value\n\t) public returns (bool);\n\n\tfunction approve(address _spender, uint256 _value) public returns (bool);\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n\t// Empty internal constructor, to prevent people from mistakenly deploying\n\t// an instance of this contract, which should be used via inheritance.\n\tconstructor() internal {}\n\n\t// solhint-disable-previous-line no-empty-blocks\n\n\tfunction _msgSender() internal view returns (address payable) {\n\t\treturn msg.sender;\n\t}\n\n\tfunction _msgData() internal view returns (bytes memory) {\n\t\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\t\treturn msg.data;\n\t}\n}\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n\taddress private _owner;\n\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\t/**\n\t * @dev Initializes the contract setting the deployer as the initial owner.\n\t */\n\tconstructor() internal {\n\t\taddress msgSender = _msgSender();\n\t\t_owner = msgSender;\n\t\temit OwnershipTransferred(address(0), msgSender);\n\t}\n\n\t/**\n\t * @dev Returns the address of the current owner.\n\t */\n\tfunction owner() public view returns (address) {\n\t\treturn _owner;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the owner.\n\t */\n\tmodifier onlyOwner() {\n\t\trequire(isOwner(), \"unauthorized\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Returns true if the caller is the current owner.\n\t */\n\tfunction isOwner() public view returns (bool) {\n\t\treturn _msgSender() == _owner;\n\t}\n\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t * Can only be called by the current owner.\n\t */\n\tfunction transferOwnership(address newOwner) public onlyOwner {\n\t\t_transferOwnership(newOwner);\n\t}\n\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t */\n\tfunction _transferOwnership(address newOwner) internal {\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\t\temit OwnershipTransferred(_owner, newOwner);\n\t\t_owner = newOwner;\n\t}\n}\n\n\n\ncontract TokenSender is Ownable {\n\t///@notice the SOV token contract\n\taddress public SOV;\n\n\t//user => flag whether user has admin role\n\tmapping(address => bool) public admins;\n\n\tevent SOVTransferred(address indexed receiver, uint256 amount);\n\tevent AdminAdded(address admin);\n\tevent AdminRemoved(address admin);\n\n\tconstructor(address _SOV) public {\n\t\trequire(_SOV != address(0), \"SOV address invalid\");\n\n\t\tSOV = _SOV;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the owner or admin.\n\t */\n\tmodifier onlyAuthorized() {\n\t\trequire(isOwner() || admins[msg.sender], \"unauthorized\");\n\t\t_;\n\t}\n\n\tfunction addAdmin(address _admin) public onlyOwner {\n\t\tadmins[_admin] = true;\n\t\temit AdminAdded(_admin);\n\t}\n\n\tfunction removeAdmin(address _admin) public onlyOwner {\n\t\tadmins[_admin] = false;\n\t\temit AdminRemoved(_admin);\n\t}\n\n\t/**\n\t * @notice transfers given amounts of SOV to the given addresses\n\t * @param _receivers the addresses of the SOV receivers\n\t * @param _amounts the amounts to be transferred\n\t */\n\tfunction transferSOVusingList(address[] memory _receivers, uint256[] memory _amounts) public onlyAuthorized {\n\t\trequire(_receivers.length == _amounts.length, \"arrays mismatch\");\n\n\t\tfor (uint256 i = 0; i < _receivers.length; i++) {\n\t\t\t_transferSOV(_receivers[i], _amounts[i]);\n\t\t}\n\t}\n\n\t/**\n\t * @notice transfers SOV tokens to given address\n\t * @param _receiver the address of the SOV receiver\n\t * @param _amount the amount to be transferred\n\t */\n\tfunction transferSOV(address _receiver, uint256 _amount) public onlyAuthorized {\n\t\t_transferSOV(_receiver, _amount);\n\t}\n\n\tfunction _transferSOV(address _receiver, uint256 _amount) internal {\n\t\trequire(_receiver != address(0), \"receiver address invalid\");\n\t\trequire(_amount != 0, \"amount invalid\");\n\n\t\trequire(IERC20(SOV).transfer(_receiver, _amount), \"transfer failed\");\n\t\temit SOVTransferred(_receiver, _amount);\n\t}\n}\n",
            "file": "TokenSender_flat.sol"
        }
    ],
    "libraries": {},
    "constructorArguments": [
        "0xefc78fc7d48b64958315949279ba181c2114abbd"
    ],
    "creationData": {
        "blockHash": "0x0b8e3e8d46aa647f18a9bb8ec8044a7756e54ce1d97c1d937fdc503173d17165",
        "blockNumber": 3233830,
        "transactionHash": "0x9b01d9aed061d44c9ab5c7dd8a98cf384a04e72c3d2b60b2ca0cc1bc0d734f4b",
        "timestamp": 1617349346
    }
}