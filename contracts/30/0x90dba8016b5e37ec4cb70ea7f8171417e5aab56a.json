{
    "address": "0x90dba8016b5e37ec4cb70ea7f8171417e5aab56a",
    "net": {
        "id": "30",
        "name": "RSK Mainnet"
    },
    "name": "GovernedRegistry",
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        }
    },
    "version": "0.6.12+commit.27d51765",
    "source": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\n\n\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n    /**\n      @notice Override this function with a recipe of the changes to be done when this ChangeContract\n      is executed\n     */\n    function execute() external;\n}\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor {\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @dev This function should be protected somehow to only execute changes that\n      benefit the system. This decision process is independent of this architechture\n      therefore is independent of this interface too\n      @param changeContract Address of the contract that will execute the changes\n     */\n    function executeChange(ChangeContract changeContract) external;\n\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @param _changer Address of the contract that will execute the changes\n     */\n    function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed {\n    /**\n      @notice The address of the contract which governs this one\n     */\n    IGovernor public governor;\n\n    string private constant NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n    /**\n      @notice Modifier that protects the function\n      @dev You should use this modifier in any function that should be called through\n      the governance system\n     */\n    modifier onlyAuthorizedChanger() {\n        require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n        _;\n    }\n\n    /**\n      @notice Initialize the contract with the basic settings\n      @dev This initialize replaces the constructor but it is not called automatically.\n      It is necessary because of the upgradeability of the contracts\n      @param _governor Governor address\n     */\n    function _initialize(IGovernor _governor) internal {\n        governor = _governor;\n    }\n\n    /**\n      @notice Change the contract's governor. Should be called through the old governance system\n      @param newIGovernor New governor address\n     */\n    function changeIGovernor(IGovernor newIGovernor) external onlyAuthorizedChanger {\n        governor = newIGovernor;\n    }\n\n    /**\n      @notice This method is used by a change contract to access the storage freely even without a setter.\n      @param data the serialized function arguments\n     */\n    function delegateCallToChanger(bytes calldata data)\n        external\n        onlyAuthorizedChanger\n        returns (bytes memory)\n    {\n        address changerContrat = msg.sender;\n        (bool success, bytes memory result) = changerContrat.delegatecall(\n            abi.encodeWithSignature(\"impersonate(bytes)\", data)\n        );\n        require(success, \"Error in delegate call\");\n        return result;\n    }\n\n    // Leave a gap betweeen inherited contracts variables in order to be\n    // able to add more variables in them later\n    uint256[50] private upgradeGap;\n}\n\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n/**\n  @notice Based on heavily on EnumberableSet, but with the ability to clear all the contents.\n */\nlibrary AddressSetLib {\n    using SafeMath for uint256;\n\n    struct AddressSet {\n        // Storage of set values\n        address[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(address => uint256) _indexes;\n    }\n\n    function init() internal pure returns (AddressSet memory) {\n        return AddressSet({_values: new address[](0)});\n    }\n\n    /**\n     * @dev Removes all value from a set. O(N).\n     *\n     */\n    function clear(AddressSet storage set) internal {\n        for (uint256 i = 0; i < set._values.length; i++) {\n            delete set._indexes[set._values[i]];\n        }\n        delete set._values;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        if (!contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            address lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1;\n            // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        require(set._values.length > index, \"index out of bounds\");\n        return set._values[index];\n    }\n\n    /**\n     * @dev Returns the set contents as an array\n     */\n    function asArray(AddressSet storage set)\n        internal\n        view\n        returns (address[] memory selectedOracles)\n    {\n        return set._values;\n    }\n}\n\n\ninterface IRegistry {\n    // *** Getter Methods ***\n    function getDecimal(bytes32 _key) external view returns (int232 base, int16 exp);\n\n    function getUint(bytes32 _key) external view returns (uint248);\n\n    function getString(bytes32 _key) external view returns (string memory);\n\n    function getAddress(bytes32 _key) external view returns (address);\n\n    function getBytes(bytes32 _key) external view returns (bytes memory);\n\n    function getBool(bytes32 _key) external view returns (bool);\n\n    function getInt(bytes32 _key) external view returns (int248);\n\n    // *** Setter Methods ***\n    function setDecimal(\n        bytes32 _key,\n        int232 _base,\n        int16 _exp\n    ) external;\n\n    function setUint(bytes32 _key, uint248 _value) external;\n\n    function setString(bytes32 _key, string calldata _value) external;\n\n    function setAddress(bytes32 _key, address _value) external;\n\n    function setBytes(bytes32 _key, bytes calldata _value) external;\n\n    function setBool(bytes32 _key, bool _value) external;\n\n    function setInt(bytes32 _key, int248 _value) external;\n\n    // *** Delete Methods ***\n    function deleteDecimal(bytes32 _key) external;\n\n    function deleteUint(bytes32 _key) external;\n\n    function deleteString(bytes32 _key) external;\n\n    function deleteAddress(bytes32 _key) external;\n\n    function deleteBytes(bytes32 _key) external;\n\n    function deleteBool(bytes32 _key) external;\n\n    function deleteInt(bytes32 _key) external;\n\n    // Nov 2020 Upgrade\n    // *** Getter Methods ***\n    function getAddressArrayLength(bytes32 _key) external view returns (uint256);\n\n    function getAddressArrayElementAt(bytes32 _key, uint256 idx) external view returns (address);\n\n    function pushAddressArrayElement(bytes32 _key, address _addr) external;\n\n    function getAddressArray(bytes32 _key) external view returns (address[] memory);\n\n    function addressArrayContains(bytes32 _key, address value) external view returns (bool);\n\n    // *** Setters ***\n    function pushAddressArray(bytes32 _key, address[] memory data) external;\n\n    function clearAddressArray(bytes32 _key) external;\n\n    function removeAddressArrayElement(bytes32 _key, address value) external;\n}\n\n\n// Based on https://github.com/fravoll/solidity-patterns EternalStorage\ncontract GovernedRegistry is Initializable, Governed, IRegistry {\n    using AddressSetLib for AddressSetLib.AddressSet;\n\n    struct UIntVal {\n        bool b;\n        uint248 v;\n    }\n\n    struct BoolVal {\n        bool b;\n        bool v;\n    }\n\n    struct IntVal {\n        bool b;\n        int248 v;\n    }\n\n    struct DecimalVal {\n        bool b;\n        int232 base;\n        int16 exp;\n    }\n\n    mapping(bytes32 => DecimalVal) internal decimalStorage;\n    mapping(bytes32 => UIntVal) internal uIntStorage;\n    mapping(bytes32 => string) internal stringStorage;\n    mapping(bytes32 => address) internal addressStorage;\n    mapping(bytes32 => bytes) internal bytesStorage;\n    mapping(bytes32 => BoolVal) internal boolStorage;\n    mapping(bytes32 => IntVal) internal intStorage;\n    /////////// Nov 2020 UPGRADE\n    mapping(bytes32 => AddressSetLib.AddressSet) internal addressArrayStorage;\n\n    /**\n      @notice Initialize the contract with the basic settings\n      @dev This initialize replaces the constructor but it is not called automatically.\n      It is necessary because of the upgradeability of the contracts\n      @param _governor Governor address\n     */\n    function initialize(IGovernor _governor) external initializer {\n        Governed._initialize(_governor);\n    }\n\n    // *** Getter Methods ***\n    function getDecimal(bytes32 _key) external view override returns (int232 base, int16 exp) {\n        require(decimalStorage[_key].b, \"Invalid key\");\n        return (decimalStorage[_key].base, decimalStorage[_key].exp);\n    }\n\n    function getUint(bytes32 _key) external view override returns (uint248) {\n        require(uIntStorage[_key].b, \"Invalid key\");\n        return uIntStorage[_key].v;\n    }\n\n    function getString(bytes32 _key) external view override returns (string memory) {\n        require(bytes(stringStorage[_key]).length != 0, \"Invalid key\");\n        return stringStorage[_key];\n    }\n\n    function getAddress(bytes32 _key) external view override returns (address) {\n        require(addressStorage[_key] != address(0), \"Invalid key\");\n        return addressStorage[_key];\n    }\n\n    function getBytes(bytes32 _key) external view override returns (bytes memory) {\n        require(bytesStorage[_key].length != 0, \"Invalid key\");\n        return bytesStorage[_key];\n    }\n\n    function getBool(bytes32 _key) external view override returns (bool) {\n        require(boolStorage[_key].b, \"Invalid key\");\n        return boolStorage[_key].v;\n    }\n\n    function getInt(bytes32 _key) external view override returns (int248) {\n        require(intStorage[_key].b, \"Invalid key\");\n        return intStorage[_key].v;\n    }\n\n    // *** Setter Methods ***\n    function setDecimal(\n        bytes32 _key,\n        int232 _base,\n        int16 _exp\n    ) external override onlyAuthorizedChanger {\n        decimalStorage[_key] = DecimalVal(true, _base, _exp);\n    }\n\n    function setUint(bytes32 _key, uint248 _value) external override onlyAuthorizedChanger {\n        uIntStorage[_key] = UIntVal(true, _value);\n    }\n\n    function setString(bytes32 _key, string calldata _value)\n        external\n        override\n        onlyAuthorizedChanger\n    {\n        require(bytes(_value).length != 0, \"Invalid value\");\n        stringStorage[_key] = _value;\n    }\n\n    function setAddress(bytes32 _key, address _value) external override onlyAuthorizedChanger {\n        require(_value != address(0), \"Invalid value\");\n        addressStorage[_key] = _value;\n    }\n\n    function setBytes(bytes32 _key, bytes calldata _value) external override onlyAuthorizedChanger {\n        require(_value.length != 0, \"Invalid value\");\n        bytesStorage[_key] = _value;\n    }\n\n    function setBool(bytes32 _key, bool _value) external override onlyAuthorizedChanger {\n        boolStorage[_key] = BoolVal(true, _value);\n    }\n\n    function setInt(bytes32 _key, int248 _value) external override onlyAuthorizedChanger {\n        intStorage[_key] = IntVal(true, _value);\n    }\n\n    // *** Delete Methods ***\n    function deleteDecimal(bytes32 _key) external override onlyAuthorizedChanger {\n        delete decimalStorage[_key];\n    }\n\n    function deleteUint(bytes32 _key) external override onlyAuthorizedChanger {\n        delete uIntStorage[_key];\n    }\n\n    function deleteString(bytes32 _key) external override onlyAuthorizedChanger {\n        delete stringStorage[_key];\n    }\n\n    function deleteAddress(bytes32 _key) external override onlyAuthorizedChanger {\n        delete addressStorage[_key];\n    }\n\n    function deleteBytes(bytes32 _key) external override onlyAuthorizedChanger {\n        delete bytesStorage[_key];\n    }\n\n    function deleteBool(bytes32 _key) external override onlyAuthorizedChanger {\n        delete boolStorage[_key];\n    }\n\n    function deleteInt(bytes32 _key) external override onlyAuthorizedChanger {\n        delete intStorage[_key];\n    }\n\n    /////////// Nov 2020 UPGRADE\n\n    // *** Getter Methods ***\n    function getAddressArray(bytes32 _key) external view override returns (address[] memory) {\n        require(addressArrayStorage[_key].length() != 0, \"Invalid key\");\n        return addressArrayStorage[_key].asArray();\n    }\n\n    function getAddressArrayLength(bytes32 _key) external view override returns (uint256) {\n        return addressArrayStorage[_key].length();\n    }\n\n    function getAddressArrayElementAt(bytes32 _key, uint256 idx)\n        external\n        view\n        override\n        returns (address)\n    {\n        require(addressArrayStorage[_key].length() != 0, \"Invalid key\");\n        return addressArrayStorage[_key].at(idx);\n    }\n\n    function addressArrayContains(bytes32 _key, address value)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return addressArrayStorage[_key].contains(value);\n    }\n\n    // *** Setters ***\n    function pushAddressArrayElement(bytes32 _key, address _addr)\n        external\n        override\n        onlyAuthorizedChanger\n    {\n        addressArrayStorage[_key].add(_addr);\n    }\n\n    function pushAddressArray(bytes32 _key, address[] memory data)\n        external\n        override\n        onlyAuthorizedChanger\n    {\n        for (uint256 i = 0; i < data.length; i++) {\n            addressArrayStorage[_key].add(data[i]);\n        }\n    }\n\n    function clearAddressArray(bytes32 _key) external override onlyAuthorizedChanger {\n        addressArrayStorage[_key].clear();\n    }\n\n    function removeAddressArrayElement(bytes32 _key, address value)\n        external\n        override\n        onlyAuthorizedChanger\n    {\n        addressArrayStorage[_key].remove(value);\n    }\n}\n\n",
    "imports": [
        {
            "name": "RegistryFlat.sol",
            "contents": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\n\n\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n    /**\n      @notice Override this function with a recipe of the changes to be done when this ChangeContract\n      is executed\n     */\n    function execute() external;\n}\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor {\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @dev This function should be protected somehow to only execute changes that\n      benefit the system. This decision process is independent of this architechture\n      therefore is independent of this interface too\n      @param changeContract Address of the contract that will execute the changes\n     */\n    function executeChange(ChangeContract changeContract) external;\n\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @param _changer Address of the contract that will execute the changes\n     */\n    function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed {\n    /**\n      @notice The address of the contract which governs this one\n     */\n    IGovernor public governor;\n\n    string private constant NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n    /**\n      @notice Modifier that protects the function\n      @dev You should use this modifier in any function that should be called through\n      the governance system\n     */\n    modifier onlyAuthorizedChanger() {\n        require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n        _;\n    }\n\n    /**\n      @notice Initialize the contract with the basic settings\n      @dev This initialize replaces the constructor but it is not called automatically.\n      It is necessary because of the upgradeability of the contracts\n      @param _governor Governor address\n     */\n    function _initialize(IGovernor _governor) internal {\n        governor = _governor;\n    }\n\n    /**\n      @notice Change the contract's governor. Should be called through the old governance system\n      @param newIGovernor New governor address\n     */\n    function changeIGovernor(IGovernor newIGovernor) external onlyAuthorizedChanger {\n        governor = newIGovernor;\n    }\n\n    /**\n      @notice This method is used by a change contract to access the storage freely even without a setter.\n      @param data the serialized function arguments\n     */\n    function delegateCallToChanger(bytes calldata data)\n        external\n        onlyAuthorizedChanger\n        returns (bytes memory)\n    {\n        address changerContrat = msg.sender;\n        (bool success, bytes memory result) = changerContrat.delegatecall(\n            abi.encodeWithSignature(\"impersonate(bytes)\", data)\n        );\n        require(success, \"Error in delegate call\");\n        return result;\n    }\n\n    // Leave a gap betweeen inherited contracts variables in order to be\n    // able to add more variables in them later\n    uint256[50] private upgradeGap;\n}\n\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n/**\n  @notice Based on heavily on EnumberableSet, but with the ability to clear all the contents.\n */\nlibrary AddressSetLib {\n    using SafeMath for uint256;\n\n    struct AddressSet {\n        // Storage of set values\n        address[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(address => uint256) _indexes;\n    }\n\n    function init() internal pure returns (AddressSet memory) {\n        return AddressSet({_values: new address[](0)});\n    }\n\n    /**\n     * @dev Removes all value from a set. O(N).\n     *\n     */\n    function clear(AddressSet storage set) internal {\n        for (uint256 i = 0; i < set._values.length; i++) {\n            delete set._indexes[set._values[i]];\n        }\n        delete set._values;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        if (!contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            address lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1;\n            // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        require(set._values.length > index, \"index out of bounds\");\n        return set._values[index];\n    }\n\n    /**\n     * @dev Returns the set contents as an array\n     */\n    function asArray(AddressSet storage set)\n        internal\n        view\n        returns (address[] memory selectedOracles)\n    {\n        return set._values;\n    }\n}\n\n\ninterface IRegistry {\n    // *** Getter Methods ***\n    function getDecimal(bytes32 _key) external view returns (int232 base, int16 exp);\n\n    function getUint(bytes32 _key) external view returns (uint248);\n\n    function getString(bytes32 _key) external view returns (string memory);\n\n    function getAddress(bytes32 _key) external view returns (address);\n\n    function getBytes(bytes32 _key) external view returns (bytes memory);\n\n    function getBool(bytes32 _key) external view returns (bool);\n\n    function getInt(bytes32 _key) external view returns (int248);\n\n    // *** Setter Methods ***\n    function setDecimal(\n        bytes32 _key,\n        int232 _base,\n        int16 _exp\n    ) external;\n\n    function setUint(bytes32 _key, uint248 _value) external;\n\n    function setString(bytes32 _key, string calldata _value) external;\n\n    function setAddress(bytes32 _key, address _value) external;\n\n    function setBytes(bytes32 _key, bytes calldata _value) external;\n\n    function setBool(bytes32 _key, bool _value) external;\n\n    function setInt(bytes32 _key, int248 _value) external;\n\n    // *** Delete Methods ***\n    function deleteDecimal(bytes32 _key) external;\n\n    function deleteUint(bytes32 _key) external;\n\n    function deleteString(bytes32 _key) external;\n\n    function deleteAddress(bytes32 _key) external;\n\n    function deleteBytes(bytes32 _key) external;\n\n    function deleteBool(bytes32 _key) external;\n\n    function deleteInt(bytes32 _key) external;\n\n    // Nov 2020 Upgrade\n    // *** Getter Methods ***\n    function getAddressArrayLength(bytes32 _key) external view returns (uint256);\n\n    function getAddressArrayElementAt(bytes32 _key, uint256 idx) external view returns (address);\n\n    function pushAddressArrayElement(bytes32 _key, address _addr) external;\n\n    function getAddressArray(bytes32 _key) external view returns (address[] memory);\n\n    function addressArrayContains(bytes32 _key, address value) external view returns (bool);\n\n    // *** Setters ***\n    function pushAddressArray(bytes32 _key, address[] memory data) external;\n\n    function clearAddressArray(bytes32 _key) external;\n\n    function removeAddressArrayElement(bytes32 _key, address value) external;\n}\n\n\n// Based on https://github.com/fravoll/solidity-patterns EternalStorage\ncontract GovernedRegistry is Initializable, Governed, IRegistry {\n    using AddressSetLib for AddressSetLib.AddressSet;\n\n    struct UIntVal {\n        bool b;\n        uint248 v;\n    }\n\n    struct BoolVal {\n        bool b;\n        bool v;\n    }\n\n    struct IntVal {\n        bool b;\n        int248 v;\n    }\n\n    struct DecimalVal {\n        bool b;\n        int232 base;\n        int16 exp;\n    }\n\n    mapping(bytes32 => DecimalVal) internal decimalStorage;\n    mapping(bytes32 => UIntVal) internal uIntStorage;\n    mapping(bytes32 => string) internal stringStorage;\n    mapping(bytes32 => address) internal addressStorage;\n    mapping(bytes32 => bytes) internal bytesStorage;\n    mapping(bytes32 => BoolVal) internal boolStorage;\n    mapping(bytes32 => IntVal) internal intStorage;\n    /////////// Nov 2020 UPGRADE\n    mapping(bytes32 => AddressSetLib.AddressSet) internal addressArrayStorage;\n\n    /**\n      @notice Initialize the contract with the basic settings\n      @dev This initialize replaces the constructor but it is not called automatically.\n      It is necessary because of the upgradeability of the contracts\n      @param _governor Governor address\n     */\n    function initialize(IGovernor _governor) external initializer {\n        Governed._initialize(_governor);\n    }\n\n    // *** Getter Methods ***\n    function getDecimal(bytes32 _key) external view override returns (int232 base, int16 exp) {\n        require(decimalStorage[_key].b, \"Invalid key\");\n        return (decimalStorage[_key].base, decimalStorage[_key].exp);\n    }\n\n    function getUint(bytes32 _key) external view override returns (uint248) {\n        require(uIntStorage[_key].b, \"Invalid key\");\n        return uIntStorage[_key].v;\n    }\n\n    function getString(bytes32 _key) external view override returns (string memory) {\n        require(bytes(stringStorage[_key]).length != 0, \"Invalid key\");\n        return stringStorage[_key];\n    }\n\n    function getAddress(bytes32 _key) external view override returns (address) {\n        require(addressStorage[_key] != address(0), \"Invalid key\");\n        return addressStorage[_key];\n    }\n\n    function getBytes(bytes32 _key) external view override returns (bytes memory) {\n        require(bytesStorage[_key].length != 0, \"Invalid key\");\n        return bytesStorage[_key];\n    }\n\n    function getBool(bytes32 _key) external view override returns (bool) {\n        require(boolStorage[_key].b, \"Invalid key\");\n        return boolStorage[_key].v;\n    }\n\n    function getInt(bytes32 _key) external view override returns (int248) {\n        require(intStorage[_key].b, \"Invalid key\");\n        return intStorage[_key].v;\n    }\n\n    // *** Setter Methods ***\n    function setDecimal(\n        bytes32 _key,\n        int232 _base,\n        int16 _exp\n    ) external override onlyAuthorizedChanger {\n        decimalStorage[_key] = DecimalVal(true, _base, _exp);\n    }\n\n    function setUint(bytes32 _key, uint248 _value) external override onlyAuthorizedChanger {\n        uIntStorage[_key] = UIntVal(true, _value);\n    }\n\n    function setString(bytes32 _key, string calldata _value)\n        external\n        override\n        onlyAuthorizedChanger\n    {\n        require(bytes(_value).length != 0, \"Invalid value\");\n        stringStorage[_key] = _value;\n    }\n\n    function setAddress(bytes32 _key, address _value) external override onlyAuthorizedChanger {\n        require(_value != address(0), \"Invalid value\");\n        addressStorage[_key] = _value;\n    }\n\n    function setBytes(bytes32 _key, bytes calldata _value) external override onlyAuthorizedChanger {\n        require(_value.length != 0, \"Invalid value\");\n        bytesStorage[_key] = _value;\n    }\n\n    function setBool(bytes32 _key, bool _value) external override onlyAuthorizedChanger {\n        boolStorage[_key] = BoolVal(true, _value);\n    }\n\n    function setInt(bytes32 _key, int248 _value) external override onlyAuthorizedChanger {\n        intStorage[_key] = IntVal(true, _value);\n    }\n\n    // *** Delete Methods ***\n    function deleteDecimal(bytes32 _key) external override onlyAuthorizedChanger {\n        delete decimalStorage[_key];\n    }\n\n    function deleteUint(bytes32 _key) external override onlyAuthorizedChanger {\n        delete uIntStorage[_key];\n    }\n\n    function deleteString(bytes32 _key) external override onlyAuthorizedChanger {\n        delete stringStorage[_key];\n    }\n\n    function deleteAddress(bytes32 _key) external override onlyAuthorizedChanger {\n        delete addressStorage[_key];\n    }\n\n    function deleteBytes(bytes32 _key) external override onlyAuthorizedChanger {\n        delete bytesStorage[_key];\n    }\n\n    function deleteBool(bytes32 _key) external override onlyAuthorizedChanger {\n        delete boolStorage[_key];\n    }\n\n    function deleteInt(bytes32 _key) external override onlyAuthorizedChanger {\n        delete intStorage[_key];\n    }\n\n    /////////// Nov 2020 UPGRADE\n\n    // *** Getter Methods ***\n    function getAddressArray(bytes32 _key) external view override returns (address[] memory) {\n        require(addressArrayStorage[_key].length() != 0, \"Invalid key\");\n        return addressArrayStorage[_key].asArray();\n    }\n\n    function getAddressArrayLength(bytes32 _key) external view override returns (uint256) {\n        return addressArrayStorage[_key].length();\n    }\n\n    function getAddressArrayElementAt(bytes32 _key, uint256 idx)\n        external\n        view\n        override\n        returns (address)\n    {\n        require(addressArrayStorage[_key].length() != 0, \"Invalid key\");\n        return addressArrayStorage[_key].at(idx);\n    }\n\n    function addressArrayContains(bytes32 _key, address value)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return addressArrayStorage[_key].contains(value);\n    }\n\n    // *** Setters ***\n    function pushAddressArrayElement(bytes32 _key, address _addr)\n        external\n        override\n        onlyAuthorizedChanger\n    {\n        addressArrayStorage[_key].add(_addr);\n    }\n\n    function pushAddressArray(bytes32 _key, address[] memory data)\n        external\n        override\n        onlyAuthorizedChanger\n    {\n        for (uint256 i = 0; i < data.length; i++) {\n            addressArrayStorage[_key].add(data[i]);\n        }\n    }\n\n    function clearAddressArray(bytes32 _key) external override onlyAuthorizedChanger {\n        addressArrayStorage[_key].clear();\n    }\n\n    function removeAddressArrayElement(bytes32 _key, address value)\n        external\n        override\n        onlyAuthorizedChanger\n    {\n        addressArrayStorage[_key].remove(value);\n    }\n}\n\n",
            "file": "RegistryFlat.sol"
        }
    ],
    "libraries": {},
    "creationData": {
        "blockHash": "0xaa19f42fee3f205be4921cc9bb08fc8dd6f0868c2117d19ba8dd1f4c4c4c6e64",
        "blockNumber": 3061939,
        "transactionHash": "0x7eb96175d84fc7c25c90e893f5d04c6e14fd0539c84a802bbc045c23065fe135",
        "timestamp": 1611866131
    }
}