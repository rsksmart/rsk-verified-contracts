{
  "address": "0xd511ff8c64d90bbe277f4426c699f17f3e309ab6",
  "net": {
    "id": "30",
    "name": "RSK Mainnet"
  },
  "name": "MoCBProxManager",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": "1"
    },
    "evmVersion": "byzantium"
  },
  "version": "0.5.8+commit.23d335f2",
  "source": "pragma solidity 0.5.8;\n\n\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n\n  /**\n    @notice Override this function with a recipe of the changes to be done when this ChangeContract\n    is executed\n   */\n  function execute() external;\n}\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor{\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @dev This function should be protected somehow to only execute changes that\n    benefit the system. This decision process is independent of this architechture\n    therefore is independent of this interface too\n    @param changeContract Address of the contract that will execute the changes\n   */\n  function executeChange(ChangeContract changeContract) external;\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @param _changer Address of the contract that will execute the changes\n   */\n  function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n\n/**\n * @dev Defines special constants to use along all the MoC System\n */\ncontract MoCConstants {\n  bytes32 constant public BUCKET_X2 = \"X2\";\n  bytes32 constant public BUCKET_C0 = \"C0\";\n}\n\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n\n\n\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n\n\n\n\n\n\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCWhitelist {\n  mapping(address => bool) whitelist;\n\n  /**\n   * @dev Check if an account is whitelisted\n   * @return Bool\n   */\n  function isWhitelisted(address account)\n    public\n    view\n    returns (bool)\n  {\n    require(account != address(0), \"Account must not be 0x0\");\n    return whitelist[account];\n  }\n\n  /**\n   * @dev Add account to whitelist\n   */\n  function add(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(!isWhitelisted(account), \"Account not allowed to add accounts into white list\");\n    whitelist[account] = true;\n  }\n\n  /**\n   * @dev Remove account to whitelist\n   */\n  function remove(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(isWhitelisted(account), \"Account is not allowed to remove address from the white list\");\n\n    whitelist[account] = false;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCConnector is MoCWhitelist, Initializable {\n  // References\n  address payable public moc;\n  address public docToken;\n  address public bproToken;\n  address public bproxManager;\n  address public mocState;\n  address public mocConverter;\n  address public mocSettlement;\n  address public mocExchange;\n  address public mocInrate;\n  address public mocBurnout;\n\n  bool internal initialized;\n\n  function initialize(\n    address payable mocAddress,\n    address docAddress,\n    address bproAddress,\n    address bproxAddress,\n    address stateAddress,\n    address settlementAddress,\n    address converterAddress,\n    address exchangeAddress,\n    address inrateAddress,\n    address burnoutBookAddress\n  ) public initializer {\n    moc = mocAddress;\n    docToken = docAddress;\n    bproToken = bproAddress;\n    bproxManager = bproxAddress;\n    mocState = stateAddress;\n    mocSettlement = settlementAddress;\n    mocConverter = converterAddress;\n    mocExchange = exchangeAddress;\n    mocInrate = inrateAddress;\n    mocBurnout = burnoutBookAddress;\n\n    // Add to Whitelist\n    add(mocAddress);\n    add(docAddress);\n    add(bproAddress);\n    add(bproxAddress);\n    add(stateAddress);\n    add(settlementAddress);\n    add(converterAddress);\n    add(exchangeAddress);\n    add(inrateAddress);\n    add(burnoutBookAddress);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n\n/**\n  @dev General usefull modifiers and functions\n */\ncontract MoCBase is MoCConstants, Initializable{\n  // Contracts\n  MoCConnector public connector;\n\n  bool internal initialized;\n\n  function initializeBase(address connectorAddress) internal initializer  {\n    connector = MoCConnector(connectorAddress);\n  }\n\n  modifier onlyWhitelisted(address account) {\n    require(connector.isWhitelisted(account), \"Address is not whitelisted\");\n    _;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n\n\n\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n\n\n\n\n\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed is Initializable {\n\n  /**\n    @notice The address of the contract which governs this one\n   */\n  IGovernor public governor;\n\n  string constant private NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n  /**\n    @notice Modifier that protects the function\n    @dev You should use this modifier in any function that should be called through\n    the governance system\n   */\n  modifier onlyAuthorizedChanger() {\n    require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n    _;\n  }\n\n  /**\n    @notice Initialize the contract with the basic settings\n    @dev This initialize replaces the constructor but it is not called automatically.\n    It is necessary because of the upgradeability of the contracts\n    @param _governor Governor address\n   */\n  function initialize(IGovernor _governor) public initializer {\n    governor = _governor;\n  }\n\n  /**\n    @notice Change the contract's governor. Should be called through the old governance system\n    @param newIGovernor New governor address\n   */\n  function changeIGovernor(IGovernor newIGovernor) public onlyAuthorizedChanger {\n    governor = newIGovernor;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n\n\ncontract MoCBucketContainer is MoCBase, Governed{\n  using SafeMath for uint256;\n  using Math for uint256;\n\n  struct BProxBalance {\n    uint256 value;\n    uint index; // Index start in 1, zero is reserved for NULL\n  }\n\n  struct MoCBucket {\n    bytes32 name;\n    bool isBase;\n    uint256 nDoc;\n    uint256 nBPro;\n    uint256 nBTC;\n    uint256 cobj;\n    // Should only be used in L buckets\n    mapping(address => BProxBalance) bproxBalances;\n    address payable[] activeBalances;\n    uint256 activeBalancesLength;\n    // Should only be used in Base buckets (C0)\n    uint256 inrateBag;\n    bool available;\n  }\n\n  event BucketMovement(\n    bytes32 from,\n    bytes32 to,\n    uint256 reserves,\n    uint256 stableTokens\n  );\n\n  event BucketCreation(\n    bytes32 name,\n    uint256 cobj\n  );\n\n  event BucketStateUpdate(\n    bytes32 name,\n    uint256 nReserve,\n    uint256 nStable,\n    uint256 nRiskProx,\n    uint256 inrateBag\n  );\n\n  mapping(bytes32 => MoCBucket) internal mocBuckets;\n  IGovernor internal governor;\n   /**\n   GETTERS\n   */\n  function getBucketNBTC(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].nBTC;\n  }\n\n  function getBucketNBPro(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].nBPro;\n  }\n\n  function getBucketNDoc(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].nDoc;\n  }\n\n  function getBucketCobj(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].cobj;\n  }\n\n  function getInrateBag(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].inrateBag;\n  }\n\n  /**\n   * @dev Sets the objective coverage (cobj) on an specficied bucket.\n   * @param  _bucket - name of the bucket\n   * @param  _cobj - new value of cobj\n   */\n  function setBucketCobj(bytes32 _bucket, uint256 _cobj) public onlyAuthorizedChanger(){\n    //TODO: It is necessary to analyze the impact in the model it has when changing X2. This\n    mocBuckets[_bucket].cobj = _cobj;\n  }\n\n  /**\n    @dev returns true if the bucket is a base bucket\n    @param bucket Name of the bucket\n  **/\n  function isBucketBase(bytes32 bucket) public view returns(bool){\n    return mocBuckets[bucket].isBase;\n  }\n\n  /**\n    @dev returns true if the bucket have docs in it\n    @param bucket Name of the bucket\n  **/\n  function isBucketEmpty(bytes32 bucket) public view returns(bool) {\n    return mocBuckets[bucket].nDoc == 0;\n  }\n\n  /**\n    @dev Returns all the address that currently have bprox position for this bucket\n    @param bucket bucket of the active address\n  */\n  function getActiveAddresses(bytes32 bucket) public view returns(address payable[] memory) {\n    return mocBuckets[bucket].activeBalances;\n  }\n\n  /**\n    @dev Returns all the address that currently have bprox position for this bucket\n    @param bucket bucket of the active address\n  */\n  function getActiveAddressesCount(bytes32 bucket) public view returns(uint256 count) {\n    return mocBuckets[bucket].activeBalancesLength;\n  }\n\n  /**\n    @dev Add values to all variables of the bucket\n    @param bucketName Name of the bucket\n    @param btc BTC amount [using reservePrecision]\n    @param doc Doc amount [using mocPrecision]\n    @param bprox BPro amount [using mocPrecision]\n  **/\n  function addValuesToBucket(bytes32 bucketName, uint256 btc, uint256 doc, uint256 bprox)\n  public onlyWhitelisted(msg.sender) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    bucket.nBTC = bucket.nBTC.add(btc);\n    bucket.nDoc = bucket.nDoc.add(doc);\n    bucket.nBPro = bucket.nBPro.add(bprox);\n  }\n\n  /**\n    @dev Substract values to all variables of the bucket\n    @param bucketName Name of the bucket\n    @param btc BTC amount [using reservePrecision]\n    @param doc Doc amount [using mocPrecision]\n    @param bprox BPro amount [using mocPrecision]\n  **/\n  function substractValuesFromBucket(bytes32 bucketName, uint256 btc, uint256 doc, uint256 bprox)\n  public onlyWhitelisted(msg.sender)  {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    bucket.nBTC = bucket.nBTC.sub(btc);\n    bucket.nDoc = bucket.nDoc.sub(doc);\n    bucket.nBPro = bucket.nBPro.sub(bprox);\n  }\n\n  /**\n    @dev Moves BTC from inrateBag to main BTC bucket bag\n    @param bucketName Name of the bucket to operate\n    @param amount value to move from inrateBag to main bag [using reservePrecision]\n   */\n  function deliverInrate(bytes32 bucketName, uint256 amount) public\n   onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) bucketStateUpdate(bucketName) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    uint256 toMove = Math.min(bucket.inrateBag, amount);\n\n    bucket.inrateBag = bucket.inrateBag.sub(toMove);\n    bucket.nBTC = bucket.nBTC.add(toMove);\n  }\n\n  /**\n    @dev Removes Interests rate from Inrate bag\n    @param bucketName Name of the bucket to operate\n    @param amount value to move from inrateBag to main bag [using reservePrecision]\n    @return Retrieved value\n   */\n  function recoverInrate(bytes32 bucketName, uint256 amount) public\n  onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) bucketStateUpdate(bucketName) returns(uint256) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    uint256 toRetrieve = Math.min(bucket.inrateBag, amount);\n\n    bucket.inrateBag = bucket.inrateBag.sub(toRetrieve);\n\n    return toRetrieve;\n  }\n\n  /**\n    @dev Moves BTC from origin bucket to destination bucket inrateBag\n    @param bucketName name of the bucket to from which takes\n    @param btcAmount value to add to main bag [using reservePrecision]\n  */\n  function payInrate(bytes32 bucketName, uint256 btcAmount) public\n  onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n    bucket.inrateBag = bucket.inrateBag.add(btcAmount);\n  }\n\n  /**\n    @dev Move Btcs and Docs from one bucket to another\n    @param from Name of bucket from where the BTCs will be removed\n    @param to Name of bucket from where the BTCs will be added\n    @param btc BTCs amount [using reservePrecision]\n    @param docs Docs amount [using mocPrecision]\n  **/\n  function moveBtcAndDocs(bytes32 from, bytes32 to, uint256 btc, uint256 docs) public\n  onlyWhitelisted(msg.sender) bucketStateUpdate(from) bucketStateUpdate(to) {\n    MoCBucket storage bucketFrom = mocBuckets[from];\n    MoCBucket storage bucketTo = mocBuckets[to];\n\n    bucketFrom.nBTC = bucketFrom.nBTC.sub(btc);\n    bucketTo.nBTC = bucketTo.nBTC.add(btc);\n\n    bucketFrom.nDoc = bucketFrom.nDoc.sub(docs);\n    bucketTo.nDoc = bucketTo.nDoc.add(docs);\n\n    emit BucketMovement(from, to, btc, docs);\n  }\n\n  /**\n    @dev Clears completely the origin bucket, removing all Docs, RBTCs and bproxs\n    @param toLiquidate Bucket to be cleared out\n    @param destination Bucket that will receive the Docs and RBTCs\n   */\n  function liquidateBucket(bytes32 toLiquidate, bytes32 destination) public onlyWhitelisted(msg.sender) {\n    require(!isBucketBase(toLiquidate), \"Cannot liquidate a base bucket\");\n\n    clearBucketBalances(toLiquidate);\n    emptyBucket(toLiquidate, destination);\n  }\n\n  /**\n    @dev Clears Docs and BTC from bucket origin and sends them to destination bucket\n    @param origin Bucket to clear out\n    @param destination Destination bucket\n  **/\n  function emptyBucket(bytes32 origin, bytes32 destination) public onlyWhitelisted(msg.sender) {\n    moveBtcAndDocs(origin, destination, mocBuckets[origin].nBTC, mocBuckets[origin].nDoc);\n  }\n\n  /**\n   * @dev checks if a bucket exists\n   * @param bucket name of the bucket\n   */\n  function isAvailableBucket(bytes32 bucket) public view returns(bool) {\n    return mocBuckets[bucket].available;\n  }\n\n  /**\n    @dev Put all bucket BProx balances in zero\n    @param bucketName Bucket to clear out\n   */\n  function clearBucketBalances(bytes32 bucketName) public onlyWhitelisted(msg.sender) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n    bucket.nBPro = 0;\n    bucket.activeBalancesLength = 0;\n  }\n\n  /**\n    @dev Creates bucket\n    @param name Name of the bucket\n    @param cobj Target Coverage of the bucket\n  **/\n  function createBucket(bytes32 name, uint256 cobj, bool isBase) internal {\n    mocBuckets[name].name = name;\n    mocBuckets[name].nDoc = 0;\n    mocBuckets[name].nBPro = 0;\n    mocBuckets[name].nBTC = 0;\n    mocBuckets[name].cobj = cobj;\n    mocBuckets[name].isBase = isBase;\n    mocBuckets[name].available = true;\n    emit BucketCreation(name, cobj);\n  }\n\n  modifier onlyBaseBucket(bytes32 bucket) {\n    require(isBucketBase(bucket), \"Bucket should be a base type bucket\");\n    _;\n  }\n\n  modifier bucketStateUpdate(bytes32 bucket) {\n    _;\n    emit BucketStateUpdate(\n      bucket,\n      mocBuckets[bucket].nBTC,\n      mocBuckets[bucket].nDoc,\n      mocBuckets[bucket].nBPro,\n      mocBuckets[bucket].inrateBag\n      );\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n\ncontract MoCBProxManager is MoCBucketContainer {\n  using SafeMath for uint256;\n  uint256 constant MIN_ALLOWED_BALANCE = 0;\n  function initialize(\n    address connectorAddress,\n    address _governor,\n    uint256 _c0Cobj,\n    uint256 _x2Cobj\n  ) public initializer {\n    initializeBase(connectorAddress);\n    initializeValues(_governor);\n    createBucket(BUCKET_C0, _c0Cobj, true);\n    createBucket(BUCKET_X2, _x2Cobj, false);\n  }\n\n  /**\n    @dev returns user balance\n    @param bucket BProx corresponding bucket to get balance from\n    @param userAddress user address to get balance from\n    @return total balance for the userAddress\n  */\n  function bproxBalanceOf(bytes32 bucket, address userAddress) public view returns(uint256) {\n    BProxBalance memory userBalance = mocBuckets[bucket].bproxBalances[userAddress];\n    if (!hasValidBalance(bucket, userAddress, userBalance.index)) return 0;\n    return userBalance.value;\n  }\n\n  /**\n    @dev verifies that this user has assigned balance for the given bucket\n    @param bucket corresponding Leveraged bucket to get balance from\n    @param userAddress user address to verify balance for\n    @param index index, starting from 1, where the address of the user is being kept\n    @return true if the user has assigned balance\n  */\n  function hasValidBalance(bytes32 bucket, address userAddress, uint index) public view returns(bool) {\n    return (index != 0) &&\n      (index <= getActiveAddressesCount(bucket)) &&\n      (mocBuckets[bucket].activeBalances[index - 1] == userAddress);\n  }\n\n  /**\n    @dev  Assigns the amount of BProx\n    @param bucket bucket from which the BProx will be removed\n    @param account user address to redeem for \n    @param bproxAmount bprox amount to redeem [using mocPresicion]\n    @param totalCost btc value of bproxAmount [using reservePrecision]\n  */\n  function assignBProx(bytes32 bucket, address payable account, uint256 bproxAmount, uint256 totalCost)\n  public onlyWhitelisted(msg.sender) {\n    uint256 currentBalance = bproxBalanceOf(bucket, account);\n\n    setBProxBalanceOf(bucket, account, currentBalance.add(bproxAmount));\n    addValuesToBucket(bucket, totalCost, 0, bproxAmount);\n  }\n\n  /**\n    @dev  Removes the amount of BProx and substract BTC cost from bucket\n    @param bucket bucket from which the BProx will be removed\n    @param userAddress user address to redeem for\n    @param bproxAmount bprox amount to redeem [using mocPresicion]\n    @param totalCost btc value of bproxAmount [using reservePrecision]\n  */\n  function removeBProx(bytes32 bucket, address payable userAddress, uint256 bproxAmount, uint256 totalCost)\n  public onlyWhitelisted(msg.sender) {\n    uint256 currentBalance = bproxBalanceOf(bucket, userAddress);\n\n    setBProxBalanceOf(bucket, userAddress, currentBalance.sub(bproxAmount));\n    substractValuesFromBucket(bucket, totalCost, 0, bproxAmount);\n  }\n\n  /**\n    @dev Sets the amount of BProx\n    @param bucket bucket from which the BProx will be setted\n    @param userAddress user address to redeem for\n    @param value bprox amount to redeem [using mocPresicion]\n  */\n  function setBProxBalanceOf(bytes32 bucket, address payable userAddress, uint256 value) public onlyWhitelisted(msg.sender) {\n    mocBuckets[bucket].bproxBalances[userAddress].value = value;\n    uint256 index = mocBuckets[bucket].bproxBalances[userAddress].index;\n    if (!hasValidBalance(bucket, userAddress, index))\n      index = 0;\n\n    bool hasBalance = value > MIN_ALLOWED_BALANCE;\n    // The address is not in the array\n    if (index == 0) {\n      if (hasBalance) {\n        if (mocBuckets[bucket].activeBalances.length == mocBuckets[bucket].activeBalancesLength) {\n          mocBuckets[bucket].activeBalances.length += 1;\n        }\n        uint256 currentIndex = mocBuckets[bucket].activeBalancesLength++;\n        mocBuckets[bucket].activeBalances[currentIndex] = userAddress;\n        mocBuckets[bucket].bproxBalances[userAddress].index = mocBuckets[bucket].activeBalancesLength;\n      }\n    } else {\n      if (!hasBalance) {\n        // We need to delete this address from the tracker\n        uint256 lastActiveIndex = mocBuckets[bucket].activeBalancesLength;\n        address payable keyToMove = mocBuckets[bucket].activeBalances[lastActiveIndex - 1];\n        mocBuckets[bucket].activeBalances[index - 1] = keyToMove;\n        // Alternative index and array decreases lenght to prevent gas limit\n        mocBuckets[bucket].activeBalancesLength--;\n        // Update moved key index\n        mocBuckets[bucket].bproxBalances[keyToMove].index = index;\n        // Disable empty account index (0 == NULL)\n        mocBuckets[bucket].bproxBalances[userAddress].index = 0;\n      }\n    }\n  }\n\n  /**\n   * @dev intializes values of the contract\n   */\n  function initializeValues(address _governor) internal {\n    governor = IGovernor(_governor);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n",
  "imports": [
    {
      "name": "MoCBProxManager_flat.sol",
      "contents": "pragma solidity 0.5.8;\n\n\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n\n  /**\n    @notice Override this function with a recipe of the changes to be done when this ChangeContract\n    is executed\n   */\n  function execute() external;\n}\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor{\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @dev This function should be protected somehow to only execute changes that\n    benefit the system. This decision process is independent of this architechture\n    therefore is independent of this interface too\n    @param changeContract Address of the contract that will execute the changes\n   */\n  function executeChange(ChangeContract changeContract) external;\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @param _changer Address of the contract that will execute the changes\n   */\n  function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n\n/**\n * @dev Defines special constants to use along all the MoC System\n */\ncontract MoCConstants {\n  bytes32 constant public BUCKET_X2 = \"X2\";\n  bytes32 constant public BUCKET_C0 = \"C0\";\n}\n\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n\n\n\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n\n\n\n\n\n\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCWhitelist {\n  mapping(address => bool) whitelist;\n\n  /**\n   * @dev Check if an account is whitelisted\n   * @return Bool\n   */\n  function isWhitelisted(address account)\n    public\n    view\n    returns (bool)\n  {\n    require(account != address(0), \"Account must not be 0x0\");\n    return whitelist[account];\n  }\n\n  /**\n   * @dev Add account to whitelist\n   */\n  function add(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(!isWhitelisted(account), \"Account not allowed to add accounts into white list\");\n    whitelist[account] = true;\n  }\n\n  /**\n   * @dev Remove account to whitelist\n   */\n  function remove(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(isWhitelisted(account), \"Account is not allowed to remove address from the white list\");\n\n    whitelist[account] = false;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCConnector is MoCWhitelist, Initializable {\n  // References\n  address payable public moc;\n  address public docToken;\n  address public bproToken;\n  address public bproxManager;\n  address public mocState;\n  address public mocConverter;\n  address public mocSettlement;\n  address public mocExchange;\n  address public mocInrate;\n  address public mocBurnout;\n\n  bool internal initialized;\n\n  function initialize(\n    address payable mocAddress,\n    address docAddress,\n    address bproAddress,\n    address bproxAddress,\n    address stateAddress,\n    address settlementAddress,\n    address converterAddress,\n    address exchangeAddress,\n    address inrateAddress,\n    address burnoutBookAddress\n  ) public initializer {\n    moc = mocAddress;\n    docToken = docAddress;\n    bproToken = bproAddress;\n    bproxManager = bproxAddress;\n    mocState = stateAddress;\n    mocSettlement = settlementAddress;\n    mocConverter = converterAddress;\n    mocExchange = exchangeAddress;\n    mocInrate = inrateAddress;\n    mocBurnout = burnoutBookAddress;\n\n    // Add to Whitelist\n    add(mocAddress);\n    add(docAddress);\n    add(bproAddress);\n    add(bproxAddress);\n    add(stateAddress);\n    add(settlementAddress);\n    add(converterAddress);\n    add(exchangeAddress);\n    add(inrateAddress);\n    add(burnoutBookAddress);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n\n/**\n  @dev General usefull modifiers and functions\n */\ncontract MoCBase is MoCConstants, Initializable{\n  // Contracts\n  MoCConnector public connector;\n\n  bool internal initialized;\n\n  function initializeBase(address connectorAddress) internal initializer  {\n    connector = MoCConnector(connectorAddress);\n  }\n\n  modifier onlyWhitelisted(address account) {\n    require(connector.isWhitelisted(account), \"Address is not whitelisted\");\n    _;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n\n\n\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n\n\n\n\n\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed is Initializable {\n\n  /**\n    @notice The address of the contract which governs this one\n   */\n  IGovernor public governor;\n\n  string constant private NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n  /**\n    @notice Modifier that protects the function\n    @dev You should use this modifier in any function that should be called through\n    the governance system\n   */\n  modifier onlyAuthorizedChanger() {\n    require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n    _;\n  }\n\n  /**\n    @notice Initialize the contract with the basic settings\n    @dev This initialize replaces the constructor but it is not called automatically.\n    It is necessary because of the upgradeability of the contracts\n    @param _governor Governor address\n   */\n  function initialize(IGovernor _governor) public initializer {\n    governor = _governor;\n  }\n\n  /**\n    @notice Change the contract's governor. Should be called through the old governance system\n    @param newIGovernor New governor address\n   */\n  function changeIGovernor(IGovernor newIGovernor) public onlyAuthorizedChanger {\n    governor = newIGovernor;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n\n\ncontract MoCBucketContainer is MoCBase, Governed{\n  using SafeMath for uint256;\n  using Math for uint256;\n\n  struct BProxBalance {\n    uint256 value;\n    uint index; // Index start in 1, zero is reserved for NULL\n  }\n\n  struct MoCBucket {\n    bytes32 name;\n    bool isBase;\n    uint256 nDoc;\n    uint256 nBPro;\n    uint256 nBTC;\n    uint256 cobj;\n    // Should only be used in L buckets\n    mapping(address => BProxBalance) bproxBalances;\n    address payable[] activeBalances;\n    uint256 activeBalancesLength;\n    // Should only be used in Base buckets (C0)\n    uint256 inrateBag;\n    bool available;\n  }\n\n  event BucketMovement(\n    bytes32 from,\n    bytes32 to,\n    uint256 reserves,\n    uint256 stableTokens\n  );\n\n  event BucketCreation(\n    bytes32 name,\n    uint256 cobj\n  );\n\n  event BucketStateUpdate(\n    bytes32 name,\n    uint256 nReserve,\n    uint256 nStable,\n    uint256 nRiskProx,\n    uint256 inrateBag\n  );\n\n  mapping(bytes32 => MoCBucket) internal mocBuckets;\n  IGovernor internal governor;\n   /**\n   GETTERS\n   */\n  function getBucketNBTC(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].nBTC;\n  }\n\n  function getBucketNBPro(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].nBPro;\n  }\n\n  function getBucketNDoc(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].nDoc;\n  }\n\n  function getBucketCobj(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].cobj;\n  }\n\n  function getInrateBag(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].inrateBag;\n  }\n\n  /**\n   * @dev Sets the objective coverage (cobj) on an specficied bucket.\n   * @param  _bucket - name of the bucket\n   * @param  _cobj - new value of cobj\n   */\n  function setBucketCobj(bytes32 _bucket, uint256 _cobj) public onlyAuthorizedChanger(){\n    //TODO: It is necessary to analyze the impact in the model it has when changing X2. This\n    mocBuckets[_bucket].cobj = _cobj;\n  }\n\n  /**\n    @dev returns true if the bucket is a base bucket\n    @param bucket Name of the bucket\n  **/\n  function isBucketBase(bytes32 bucket) public view returns(bool){\n    return mocBuckets[bucket].isBase;\n  }\n\n  /**\n    @dev returns true if the bucket have docs in it\n    @param bucket Name of the bucket\n  **/\n  function isBucketEmpty(bytes32 bucket) public view returns(bool) {\n    return mocBuckets[bucket].nDoc == 0;\n  }\n\n  /**\n    @dev Returns all the address that currently have bprox position for this bucket\n    @param bucket bucket of the active address\n  */\n  function getActiveAddresses(bytes32 bucket) public view returns(address payable[] memory) {\n    return mocBuckets[bucket].activeBalances;\n  }\n\n  /**\n    @dev Returns all the address that currently have bprox position for this bucket\n    @param bucket bucket of the active address\n  */\n  function getActiveAddressesCount(bytes32 bucket) public view returns(uint256 count) {\n    return mocBuckets[bucket].activeBalancesLength;\n  }\n\n  /**\n    @dev Add values to all variables of the bucket\n    @param bucketName Name of the bucket\n    @param btc BTC amount [using reservePrecision]\n    @param doc Doc amount [using mocPrecision]\n    @param bprox BPro amount [using mocPrecision]\n  **/\n  function addValuesToBucket(bytes32 bucketName, uint256 btc, uint256 doc, uint256 bprox)\n  public onlyWhitelisted(msg.sender) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    bucket.nBTC = bucket.nBTC.add(btc);\n    bucket.nDoc = bucket.nDoc.add(doc);\n    bucket.nBPro = bucket.nBPro.add(bprox);\n  }\n\n  /**\n    @dev Substract values to all variables of the bucket\n    @param bucketName Name of the bucket\n    @param btc BTC amount [using reservePrecision]\n    @param doc Doc amount [using mocPrecision]\n    @param bprox BPro amount [using mocPrecision]\n  **/\n  function substractValuesFromBucket(bytes32 bucketName, uint256 btc, uint256 doc, uint256 bprox)\n  public onlyWhitelisted(msg.sender)  {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    bucket.nBTC = bucket.nBTC.sub(btc);\n    bucket.nDoc = bucket.nDoc.sub(doc);\n    bucket.nBPro = bucket.nBPro.sub(bprox);\n  }\n\n  /**\n    @dev Moves BTC from inrateBag to main BTC bucket bag\n    @param bucketName Name of the bucket to operate\n    @param amount value to move from inrateBag to main bag [using reservePrecision]\n   */\n  function deliverInrate(bytes32 bucketName, uint256 amount) public\n   onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) bucketStateUpdate(bucketName) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    uint256 toMove = Math.min(bucket.inrateBag, amount);\n\n    bucket.inrateBag = bucket.inrateBag.sub(toMove);\n    bucket.nBTC = bucket.nBTC.add(toMove);\n  }\n\n  /**\n    @dev Removes Interests rate from Inrate bag\n    @param bucketName Name of the bucket to operate\n    @param amount value to move from inrateBag to main bag [using reservePrecision]\n    @return Retrieved value\n   */\n  function recoverInrate(bytes32 bucketName, uint256 amount) public\n  onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) bucketStateUpdate(bucketName) returns(uint256) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    uint256 toRetrieve = Math.min(bucket.inrateBag, amount);\n\n    bucket.inrateBag = bucket.inrateBag.sub(toRetrieve);\n\n    return toRetrieve;\n  }\n\n  /**\n    @dev Moves BTC from origin bucket to destination bucket inrateBag\n    @param bucketName name of the bucket to from which takes\n    @param btcAmount value to add to main bag [using reservePrecision]\n  */\n  function payInrate(bytes32 bucketName, uint256 btcAmount) public\n  onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n    bucket.inrateBag = bucket.inrateBag.add(btcAmount);\n  }\n\n  /**\n    @dev Move Btcs and Docs from one bucket to another\n    @param from Name of bucket from where the BTCs will be removed\n    @param to Name of bucket from where the BTCs will be added\n    @param btc BTCs amount [using reservePrecision]\n    @param docs Docs amount [using mocPrecision]\n  **/\n  function moveBtcAndDocs(bytes32 from, bytes32 to, uint256 btc, uint256 docs) public\n  onlyWhitelisted(msg.sender) bucketStateUpdate(from) bucketStateUpdate(to) {\n    MoCBucket storage bucketFrom = mocBuckets[from];\n    MoCBucket storage bucketTo = mocBuckets[to];\n\n    bucketFrom.nBTC = bucketFrom.nBTC.sub(btc);\n    bucketTo.nBTC = bucketTo.nBTC.add(btc);\n\n    bucketFrom.nDoc = bucketFrom.nDoc.sub(docs);\n    bucketTo.nDoc = bucketTo.nDoc.add(docs);\n\n    emit BucketMovement(from, to, btc, docs);\n  }\n\n  /**\n    @dev Clears completely the origin bucket, removing all Docs, RBTCs and bproxs\n    @param toLiquidate Bucket to be cleared out\n    @param destination Bucket that will receive the Docs and RBTCs\n   */\n  function liquidateBucket(bytes32 toLiquidate, bytes32 destination) public onlyWhitelisted(msg.sender) {\n    require(!isBucketBase(toLiquidate), \"Cannot liquidate a base bucket\");\n\n    clearBucketBalances(toLiquidate);\n    emptyBucket(toLiquidate, destination);\n  }\n\n  /**\n    @dev Clears Docs and BTC from bucket origin and sends them to destination bucket\n    @param origin Bucket to clear out\n    @param destination Destination bucket\n  **/\n  function emptyBucket(bytes32 origin, bytes32 destination) public onlyWhitelisted(msg.sender) {\n    moveBtcAndDocs(origin, destination, mocBuckets[origin].nBTC, mocBuckets[origin].nDoc);\n  }\n\n  /**\n   * @dev checks if a bucket exists\n   * @param bucket name of the bucket\n   */\n  function isAvailableBucket(bytes32 bucket) public view returns(bool) {\n    return mocBuckets[bucket].available;\n  }\n\n  /**\n    @dev Put all bucket BProx balances in zero\n    @param bucketName Bucket to clear out\n   */\n  function clearBucketBalances(bytes32 bucketName) public onlyWhitelisted(msg.sender) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n    bucket.nBPro = 0;\n    bucket.activeBalancesLength = 0;\n  }\n\n  /**\n    @dev Creates bucket\n    @param name Name of the bucket\n    @param cobj Target Coverage of the bucket\n  **/\n  function createBucket(bytes32 name, uint256 cobj, bool isBase) internal {\n    mocBuckets[name].name = name;\n    mocBuckets[name].nDoc = 0;\n    mocBuckets[name].nBPro = 0;\n    mocBuckets[name].nBTC = 0;\n    mocBuckets[name].cobj = cobj;\n    mocBuckets[name].isBase = isBase;\n    mocBuckets[name].available = true;\n    emit BucketCreation(name, cobj);\n  }\n\n  modifier onlyBaseBucket(bytes32 bucket) {\n    require(isBucketBase(bucket), \"Bucket should be a base type bucket\");\n    _;\n  }\n\n  modifier bucketStateUpdate(bytes32 bucket) {\n    _;\n    emit BucketStateUpdate(\n      bucket,\n      mocBuckets[bucket].nBTC,\n      mocBuckets[bucket].nDoc,\n      mocBuckets[bucket].nBPro,\n      mocBuckets[bucket].inrateBag\n      );\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n\ncontract MoCBProxManager is MoCBucketContainer {\n  using SafeMath for uint256;\n  uint256 constant MIN_ALLOWED_BALANCE = 0;\n  function initialize(\n    address connectorAddress,\n    address _governor,\n    uint256 _c0Cobj,\n    uint256 _x2Cobj\n  ) public initializer {\n    initializeBase(connectorAddress);\n    initializeValues(_governor);\n    createBucket(BUCKET_C0, _c0Cobj, true);\n    createBucket(BUCKET_X2, _x2Cobj, false);\n  }\n\n  /**\n    @dev returns user balance\n    @param bucket BProx corresponding bucket to get balance from\n    @param userAddress user address to get balance from\n    @return total balance for the userAddress\n  */\n  function bproxBalanceOf(bytes32 bucket, address userAddress) public view returns(uint256) {\n    BProxBalance memory userBalance = mocBuckets[bucket].bproxBalances[userAddress];\n    if (!hasValidBalance(bucket, userAddress, userBalance.index)) return 0;\n    return userBalance.value;\n  }\n\n  /**\n    @dev verifies that this user has assigned balance for the given bucket\n    @param bucket corresponding Leveraged bucket to get balance from\n    @param userAddress user address to verify balance for\n    @param index index, starting from 1, where the address of the user is being kept\n    @return true if the user has assigned balance\n  */\n  function hasValidBalance(bytes32 bucket, address userAddress, uint index) public view returns(bool) {\n    return (index != 0) &&\n      (index <= getActiveAddressesCount(bucket)) &&\n      (mocBuckets[bucket].activeBalances[index - 1] == userAddress);\n  }\n\n  /**\n    @dev  Assigns the amount of BProx\n    @param bucket bucket from which the BProx will be removed\n    @param account user address to redeem for \n    @param bproxAmount bprox amount to redeem [using mocPresicion]\n    @param totalCost btc value of bproxAmount [using reservePrecision]\n  */\n  function assignBProx(bytes32 bucket, address payable account, uint256 bproxAmount, uint256 totalCost)\n  public onlyWhitelisted(msg.sender) {\n    uint256 currentBalance = bproxBalanceOf(bucket, account);\n\n    setBProxBalanceOf(bucket, account, currentBalance.add(bproxAmount));\n    addValuesToBucket(bucket, totalCost, 0, bproxAmount);\n  }\n\n  /**\n    @dev  Removes the amount of BProx and substract BTC cost from bucket\n    @param bucket bucket from which the BProx will be removed\n    @param userAddress user address to redeem for\n    @param bproxAmount bprox amount to redeem [using mocPresicion]\n    @param totalCost btc value of bproxAmount [using reservePrecision]\n  */\n  function removeBProx(bytes32 bucket, address payable userAddress, uint256 bproxAmount, uint256 totalCost)\n  public onlyWhitelisted(msg.sender) {\n    uint256 currentBalance = bproxBalanceOf(bucket, userAddress);\n\n    setBProxBalanceOf(bucket, userAddress, currentBalance.sub(bproxAmount));\n    substractValuesFromBucket(bucket, totalCost, 0, bproxAmount);\n  }\n\n  /**\n    @dev Sets the amount of BProx\n    @param bucket bucket from which the BProx will be setted\n    @param userAddress user address to redeem for\n    @param value bprox amount to redeem [using mocPresicion]\n  */\n  function setBProxBalanceOf(bytes32 bucket, address payable userAddress, uint256 value) public onlyWhitelisted(msg.sender) {\n    mocBuckets[bucket].bproxBalances[userAddress].value = value;\n    uint256 index = mocBuckets[bucket].bproxBalances[userAddress].index;\n    if (!hasValidBalance(bucket, userAddress, index))\n      index = 0;\n\n    bool hasBalance = value > MIN_ALLOWED_BALANCE;\n    // The address is not in the array\n    if (index == 0) {\n      if (hasBalance) {\n        if (mocBuckets[bucket].activeBalances.length == mocBuckets[bucket].activeBalancesLength) {\n          mocBuckets[bucket].activeBalances.length += 1;\n        }\n        uint256 currentIndex = mocBuckets[bucket].activeBalancesLength++;\n        mocBuckets[bucket].activeBalances[currentIndex] = userAddress;\n        mocBuckets[bucket].bproxBalances[userAddress].index = mocBuckets[bucket].activeBalancesLength;\n      }\n    } else {\n      if (!hasBalance) {\n        // We need to delete this address from the tracker\n        uint256 lastActiveIndex = mocBuckets[bucket].activeBalancesLength;\n        address payable keyToMove = mocBuckets[bucket].activeBalances[lastActiveIndex - 1];\n        mocBuckets[bucket].activeBalances[index - 1] = keyToMove;\n        // Alternative index and array decreases lenght to prevent gas limit\n        mocBuckets[bucket].activeBalancesLength--;\n        // Update moved key index\n        mocBuckets[bucket].bproxBalances[keyToMove].index = index;\n        // Disable empty account index (0 == NULL)\n        mocBuckets[bucket].bproxBalances[userAddress].index = 0;\n      }\n    }\n  }\n\n  /**\n   * @dev intializes values of the contract\n   */\n  function initializeValues(address _governor) internal {\n    governor = IGovernor(_governor);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n",
      "file": "MoCBProxManager_flat.sol"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x922b0a0442e3d151f02a63e7a1ba3fde1db60c6bed98da82e62516189470004c",
    "blockNumber": 1764693,
    "transactionHash": "0x94c24dbd532312d5515c50c9cf5337e4c79db70d424449b8655572e9791d2e3c",
    "timestamp": 1570240412
  }
}