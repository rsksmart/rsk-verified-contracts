{
  "address": "0x40993a6609510b5f04a216045d88a24c9635883d",
  "net": {
    "id": "30",
    "name": "RSK Mainnet"
  },
  "name": "Multisig",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "byzantium",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "metadata",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ]
      }
    }
  },
  "version": "0.5.9+commit.e560f70d",
  "source": "pragma solidity ^0.5.4;\n\n\nimport \"./Proxy.sol\";\n\ncontract Multisig {\n\n  mapping(address => bool) public is_owner;\n  uint256 public number_of_owners;\n  // Required signatures apart from the sender's.\n  uint256 public required_extra_signatures;\n  // Unique transaction ids. If the id is already used, the transaction is reverted.\n  mapping(uint256 => bool) public is_used_tx_id;\n\n  event CallSuccessful(bytes data, address destination, uint256 indexed tx_id);\n  event CallUnsuccessful(bytes data, address destination, uint256 indexed tx_id);\n  event AddedOwner(address new_owner);\n  event RemovedOwner(address removed_owner);\n  event ChangedRequiredExtraSignatures(uint256 new_extra_signatures_requirement);\n  event DeployedNewProxy(address newProxy);\n  /**\n   * @param owners Array of addresses that act as signers of the multisig.\n   * @param initial_required_extra_signatures The amount of offline signatures needed apart from the sender.\n   */\n  constructor(address[] memory owners, uint256 initial_required_extra_signatures) public {\n    require(owners.length > 0, \"At least one owner is necessary for the multisig to work.\");\n    require(initial_required_extra_signatures < owners.length, \"Requiring more signatures than owners would deadlock the multisig.\");\n\n    for (uint256 i = 0; i < owners.length; i++) {\n      addOwnerInternal(owners[i]);\n    }\n\n    required_extra_signatures = initial_required_extra_signatures;\n  }\n\n  /**\n   * @notice Call another contract with specific call data. All needed signatures should be provided.\n             The call will be resolved in the same transaction. The message sender is counted as a signer.\n   * @param data Call data that may be interpreted by the destination contract\n   * @param destination Address that will be called by the multisig\n   * @param tx_id An ID that is ensured to be unique among calls made by the multisig. It can be used to avoid repeating certain calls.\n   * @param sig_v Array of one of the components of the payload signatures\n   * @param sig_r Array of one of the components of the payload signatures\n   * @param sig_s Array of one of the components of the payload signatures\n   */\n  function callAddress(bytes memory data, address destination, uint256 tx_id, uint8[] memory sig_v,\n                       bytes32[] memory sig_r, bytes32[] memory sig_s) public {\n    require(!is_used_tx_id[tx_id], \"Transaction ID already used\");\n    verifySignatures(data, destination, tx_id, sig_v, sig_r, sig_s);\n    is_used_tx_id[tx_id] = true;\n\n    (bool success, ) = destination.call(data);\n    if (success) {\n      emit CallSuccessful(data, destination, tx_id);\n    }\n    else {\n      emit CallUnsuccessful(data, destination, tx_id);\n    }\n  }\n\n  function deploy(address implementation, bytes calldata initialize_data) external onlyMultisig {\n    Proxy proxied_contract = new Proxy(implementation, initialize_data);\n    emit DeployedNewProxy(address(proxied_contract));\n  }\n\n  function addOwner(address new_owner) external onlyMultisig {\n    addOwnerInternal(new_owner);\n  }\n\n  function addOwnerInternal(address new_owner) internal {\n    require(new_owner != address(0), \"The new owner should be a non-zero address\");\n    require(!is_owner[new_owner], \"The address is already an owner of the multisig.\");\n\n    is_owner[new_owner] = true;\n    number_of_owners += 1;\n    emit AddedOwner(new_owner);\n  }\n\n  function removeOwner(address owner) external onlyMultisig {\n    require(is_owner[owner], \"The address should be an owner of the multisig.\");\n    require(number_of_owners > required_extra_signatures + 1, \"Cannot reduce owners below the amount of necessary signatures\");\n\n    is_owner[owner] = false;\n    number_of_owners -= 1;\n    emit RemovedOwner(owner);\n  }\n\n  function changeRequiredExtraSignatures(uint256 new_requirement) external onlyMultisig {\n    require(new_requirement < number_of_owners, \"The new signature requirement should be satisfiable by the current owners.\");\n\n    required_extra_signatures = new_requirement;\n    emit ChangedRequiredExtraSignatures(new_requirement);\n  }\n\n  /**\n   * The multisig doesn't currently support operations with ether.\n   * This allows transferral of any ether funds that happen to arrive in the contract.\n   */\n  function transferEther(uint256 value, address payable destination) external onlyMultisig {\n    require(destination != address(0), \"The destination should be a non-zero address\");\n\n    destination.transfer(value);\n  }\n\n  function verifySignatures(bytes memory data, address destination, uint256 tx_id, uint8[] memory v,\n                            bytes32[] memory r, bytes32[] memory s) private view {\n    require(is_owner[msg.sender], \"The sender is not an owner of the multisig\");\n    require(v.length == r.length && r.length == s.length, \"Inconsistent signature data.\");\n    require(v.length >= required_extra_signatures, \"Amount of required signatures is not satisfied by received signatures.\");\n\n    address[] memory verified_signers = new address[](v.length + 1);\n    verified_signers[0] = msg.sender;\n    bytes32 message_hash = keccak256(abi.encodePacked(msg.sender, data, destination, tx_id, address(this)));\n\n    // Valid indices for verified_signers: [0, i]\n    for (uint256 i = 0; i < v.length; i++) {\n      address signer = ecrecover(message_hash, v[i], r[i], s[i]);\n      require(is_owner[signer], \"One signer is not an owner.\");\n\n      // This algorithm doesn't scale well but since the amount of signers isn't typically high\n      //  it shouldn't be a problem.\n      // With Constantinople, it may be viable to use a mapping if it is cleaned at the end of this function\n      //  thanks to lower gas costs for temporal usage of storage.\n      for (uint256 j = 0; j <= i; j++) {\n        require(verified_signers[j] != signer, \"No repeated signatures are allowed.\");\n      }\n      verified_signers[i + 1] = signer;\n    }\n  }\n\n  /**\n   * @notice This modifier restricts functions to be called by the multisig itself.\n   * This means that the function call should be encoded and\n   * passed as argument to the callAddress function as well as the multisig address.\n   */\n  modifier onlyMultisig() {\n    require(msg.sender == address(this), \"Only the multisig can call this function.\");\n    _;\n  }\n\n}",
  "imports": [
    {
      "name": "Multisig.sol",
      "contents": "pragma solidity ^0.5.4;\n\n\nimport \"./Proxy.sol\";\n\ncontract Multisig {\n\n  mapping(address => bool) public is_owner;\n  uint256 public number_of_owners;\n  // Required signatures apart from the sender's.\n  uint256 public required_extra_signatures;\n  // Unique transaction ids. If the id is already used, the transaction is reverted.\n  mapping(uint256 => bool) public is_used_tx_id;\n\n  event CallSuccessful(bytes data, address destination, uint256 indexed tx_id);\n  event CallUnsuccessful(bytes data, address destination, uint256 indexed tx_id);\n  event AddedOwner(address new_owner);\n  event RemovedOwner(address removed_owner);\n  event ChangedRequiredExtraSignatures(uint256 new_extra_signatures_requirement);\n  event DeployedNewProxy(address newProxy);\n  /**\n   * @param owners Array of addresses that act as signers of the multisig.\n   * @param initial_required_extra_signatures The amount of offline signatures needed apart from the sender.\n   */\n  constructor(address[] memory owners, uint256 initial_required_extra_signatures) public {\n    require(owners.length > 0, \"At least one owner is necessary for the multisig to work.\");\n    require(initial_required_extra_signatures < owners.length, \"Requiring more signatures than owners would deadlock the multisig.\");\n\n    for (uint256 i = 0; i < owners.length; i++) {\n      addOwnerInternal(owners[i]);\n    }\n\n    required_extra_signatures = initial_required_extra_signatures;\n  }\n\n  /**\n   * @notice Call another contract with specific call data. All needed signatures should be provided.\n             The call will be resolved in the same transaction. The message sender is counted as a signer.\n   * @param data Call data that may be interpreted by the destination contract\n   * @param destination Address that will be called by the multisig\n   * @param tx_id An ID that is ensured to be unique among calls made by the multisig. It can be used to avoid repeating certain calls.\n   * @param sig_v Array of one of the components of the payload signatures\n   * @param sig_r Array of one of the components of the payload signatures\n   * @param sig_s Array of one of the components of the payload signatures\n   */\n  function callAddress(bytes memory data, address destination, uint256 tx_id, uint8[] memory sig_v,\n                       bytes32[] memory sig_r, bytes32[] memory sig_s) public {\n    require(!is_used_tx_id[tx_id], \"Transaction ID already used\");\n    verifySignatures(data, destination, tx_id, sig_v, sig_r, sig_s);\n    is_used_tx_id[tx_id] = true;\n\n    (bool success, ) = destination.call(data);\n    if (success) {\n      emit CallSuccessful(data, destination, tx_id);\n    }\n    else {\n      emit CallUnsuccessful(data, destination, tx_id);\n    }\n  }\n\n  function deploy(address implementation, bytes calldata initialize_data) external onlyMultisig {\n    Proxy proxied_contract = new Proxy(implementation, initialize_data);\n    emit DeployedNewProxy(address(proxied_contract));\n  }\n\n  function addOwner(address new_owner) external onlyMultisig {\n    addOwnerInternal(new_owner);\n  }\n\n  function addOwnerInternal(address new_owner) internal {\n    require(new_owner != address(0), \"The new owner should be a non-zero address\");\n    require(!is_owner[new_owner], \"The address is already an owner of the multisig.\");\n\n    is_owner[new_owner] = true;\n    number_of_owners += 1;\n    emit AddedOwner(new_owner);\n  }\n\n  function removeOwner(address owner) external onlyMultisig {\n    require(is_owner[owner], \"The address should be an owner of the multisig.\");\n    require(number_of_owners > required_extra_signatures + 1, \"Cannot reduce owners below the amount of necessary signatures\");\n\n    is_owner[owner] = false;\n    number_of_owners -= 1;\n    emit RemovedOwner(owner);\n  }\n\n  function changeRequiredExtraSignatures(uint256 new_requirement) external onlyMultisig {\n    require(new_requirement < number_of_owners, \"The new signature requirement should be satisfiable by the current owners.\");\n\n    required_extra_signatures = new_requirement;\n    emit ChangedRequiredExtraSignatures(new_requirement);\n  }\n\n  /**\n   * The multisig doesn't currently support operations with ether.\n   * This allows transferral of any ether funds that happen to arrive in the contract.\n   */\n  function transferEther(uint256 value, address payable destination) external onlyMultisig {\n    require(destination != address(0), \"The destination should be a non-zero address\");\n\n    destination.transfer(value);\n  }\n\n  function verifySignatures(bytes memory data, address destination, uint256 tx_id, uint8[] memory v,\n                            bytes32[] memory r, bytes32[] memory s) private view {\n    require(is_owner[msg.sender], \"The sender is not an owner of the multisig\");\n    require(v.length == r.length && r.length == s.length, \"Inconsistent signature data.\");\n    require(v.length >= required_extra_signatures, \"Amount of required signatures is not satisfied by received signatures.\");\n\n    address[] memory verified_signers = new address[](v.length + 1);\n    verified_signers[0] = msg.sender;\n    bytes32 message_hash = keccak256(abi.encodePacked(msg.sender, data, destination, tx_id, address(this)));\n\n    // Valid indices for verified_signers: [0, i]\n    for (uint256 i = 0; i < v.length; i++) {\n      address signer = ecrecover(message_hash, v[i], r[i], s[i]);\n      require(is_owner[signer], \"One signer is not an owner.\");\n\n      // This algorithm doesn't scale well but since the amount of signers isn't typically high\n      //  it shouldn't be a problem.\n      // With Constantinople, it may be viable to use a mapping if it is cleaned at the end of this function\n      //  thanks to lower gas costs for temporal usage of storage.\n      for (uint256 j = 0; j <= i; j++) {\n        require(verified_signers[j] != signer, \"No repeated signatures are allowed.\");\n      }\n      verified_signers[i + 1] = signer;\n    }\n  }\n\n  /**\n   * @notice This modifier restricts functions to be called by the multisig itself.\n   * This means that the function call should be encoded and\n   * passed as argument to the callAddress function as well as the multisig address.\n   */\n  modifier onlyMultisig() {\n    require(msg.sender == address(this), \"Only the multisig can call this function.\");\n    _;\n  }\n\n}",
      "file": "Multisig.sol"
    },
    {
      "name": "Proxy.sol",
      "contents": "pragma solidity ^0.5.4;\n\n/* Flattened from https://github.com/zeppelinos/zos/tree/v2.0.1/packages/lib/contracts/upgradeability\n   With slight simplifications.\n\n/**\n * @title Proxy\n * @dev Implements delegation of calls to other contracts, with proper\n * forwarding of return values and bubbling of failures.\n * It defines a fallback function that delegates all calls to the address\n * returned by the getImplementation() internal function.\n * An admin can change the implementation address to which it will delegate.\n * Such a change is called an implementation upgrade.\n * Calls by accounts other than the admin will always be proxied.\n * This is ensured as long as the `proxyIfNotAdmin` modifier is on all external functions.\n * See ethereum/solidity#3864 for a Solidity feature proposal that would\n * enable this to be done automatically.\n */\ncontract Proxy {\n\n  /**\n   * @dev Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"org.zeppelinos.proxy.implementation\", and is\n   * validated in the constructor.\n   */\n  bytes32 private constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"org.zeppelinos.proxy.admin\", and is\n   * validated in the constructor.\n   */\n  bytes32 private constant ADMIN_SLOT = 0x10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b;\n\n  /**\n   * @dev Emitted when the implementation is upgraded.\n   * @param implementation Address of the new implementation.\n   */\n  event Upgraded(address indexed implementation);\n\n  /**\n   * @dev Emitted when the administration has been transferred.\n   * @param previousAdmin Address of the previous admin.\n   * @param newAdmin Address of the new admin.\n   */\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n  /**\n   * @dev Contract constructor.\n   * It sets the `msg.sender` as the proxy administrator.\n   * @param implementation Address of the initial implementation.\n   * @param data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(address implementation, bytes memory data) public payable {\n    assert(IMPLEMENTATION_SLOT == keccak256(\"org.zeppelinos.proxy.implementation\"));\n    assert(ADMIN_SLOT == keccak256(\"org.zeppelinos.proxy.admin\"));\n\n    setAdmin(msg.sender);\n    setImplementation(implementation);\n    if (data.length > 0) {\n      (bool success, ) = implementation.delegatecall(data);\n      require(success);\n    }\n  }\n\n  /**\n   * @dev Fallback function.\n   * Implemented entirely in `fallback`.\n   */\n  function () payable external {\n    fallback();\n  }\n\n  /**\n   * @dev Delegates execution to an implementation contract.\n   * This is a low level function that doesn't return to its internal call site.\n   * It will return to the external caller whatever the implementation returns.\n   * @param implementation Address to delegate.\n   */\n  function delegate(address implementation) internal {\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize)\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize)\n\n      switch result\n      // TODO: check if the Solidity compiler 0.5.3 allows perfect forwarding using the require function\n      // This would make unnecessary the use of inline assembly.\n      // delegatecall returns 0 on error.\n      case 0 { revert(0, returndatasize) }\n      default { return(0, returndatasize) }\n    }\n  }\n\n  /**\n   * @dev fallback implementation. Only fall back when the sender is not the admin.\n   * Extracted to enable manual triggering.\n   */\n  function fallback() internal {\n    require(msg.sender != getAdmin(), \"Cannot call fallback function from the proxy admin\");\n    delegate(getImplementation());\n  }\n\n  /**\n   * @dev Returns the current implementation.\n   * @return Address of the current implementation\n   */\n  function getImplementation() internal view returns (address impl) {\n    bytes32 slot = IMPLEMENTATION_SLOT;\n    assembly {\n      impl := sload(slot)\n    }\n  }\n\n  /**\n   * @return The administrator account.\n   */\n  function getAdmin() internal view returns (address adm) {\n    bytes32 slot = ADMIN_SLOT;\n    assembly {\n      adm := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the implementation address of the proxy.\n   * @param newImplementation Address of the new implementation.\n   */\n  function setImplementation(address newImplementation) private {\n    require(isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\n\n    bytes32 slot = IMPLEMENTATION_SLOT;\n\n    assembly {\n      sstore(slot, newImplementation)\n    }\n    emit Upgraded(newImplementation);\n  }\n\n  /**\n   * @dev Sets the address of the proxy admin.\n   * @param newAdmin Address of the new proxy admin.\n   */\n  function setAdmin(address newAdmin) internal {\n    bytes32 slot = ADMIN_SLOT;\n\n    assembly {\n      sstore(slot, newAdmin)\n    }\n  }\n\n  /**\n   * @return The address of the proxy admin.\n   */\n  function admin() external proxyIfNotAdmin returns (address) {\n    return getAdmin();\n  }\n\n  /**\n   * @return The address of the implementation.\n   */\n  function implementation() external proxyIfNotAdmin returns (address) {\n    return getImplementation();\n  }\n\n  /**\n   * @dev Changes the admin of the proxy.\n   * Only the current admin can call this function.\n   * @param newAdmin Address to transfer proxy administration to.\n   */\n  function changeAdmin(address newAdmin) external proxyIfNotAdmin {\n    require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n    emit AdminChanged(getAdmin(), newAdmin);\n    setAdmin(newAdmin);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy.\n   * Only the admin can call this function.\n   * @param newImplementation Address of the new implementation.\n   */\n  function upgradeTo(address newImplementation) external proxyIfNotAdmin {\n    setImplementation(newImplementation);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy and call a function\n   * on the new implementation.\n   * This is useful to initialize the proxied contract.\n   * @param newImplementation Address of the new implementation.\n   * @param data Data to send as msg.data in the low level call.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.5.4/abi-spec.html#function-selector-and-argument-encoding.\n   */\n  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external proxyIfNotAdmin {\n    setImplementation(newImplementation);\n    (bool success, ) = newImplementation.delegatecall(data);\n    require(success);\n  }\n\n  /**\n   * @dev Modifier to check whether the `msg.sender` is the admin.\n   * If it is, it will run the function. Otherwise, it will delegate the call\n   * to the implementation.\n   */\n  modifier proxyIfNotAdmin() {\n    if (msg.sender == getAdmin()) {\n      _;\n    } else {\n      fallback();\n    }\n  }\n\n  /**\n   * Returns whether the target address is a contract\n   * @dev This function will return false if invoked during the constructor of a contract,\n   * as the code is not actually created until after the constructor finishes.\n   *\n   * IMPORTANT: DO NOT USE THIS FUNCTION AS A SECURITY CHECK\n   *\n   * @param account address of the account to check\n   * @return whether the target address is a contract\n   */\n  function isContract(address account) internal view returns (bool) {\n    uint256 size;\n    // XXX Currently there is no better way to check if there is a contract in an address\n    // than to check the size of the code at that address.\n    // See https://ethereum.stackexchange.com/a/14016/36603\n    // for more details about how this works.\n    // TODO Check this again before the Serenity release, because all addresses will be\n    // contracts then.\n    // solium-disable-next-line security/no-inline-assembly\n    assembly { size := extcodesize(account) }\n    return size > 0;\n  }\n}"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x9764541f08377a1f47528d1618985638dda664eaf06abe5ed004d54fee565222",
    "blockNumber": 1964437,
    "transactionHash": "0x975e3a39453bfc25044a93a21e50d930c5eb4b287c0bab69bad3e888738b947e",
    "timestamp": 1576698341
  },
  "constructorArguments": [
    [
      "0xa6b720b6cbbfe2f55151d31b4f119fd291222905",
      "0x9f9c5f6f1e12e3bbfc787203cf6045868ce3ba2a",
      "0x6f93af0a459ff07830b0e9437f30499571f02f48"
    ],
    "0x1"
  ]
}