{
  "address": "0xd33771b35fcf81a6919ab0790baa77a694c036a9",
  "net": {
    "id": "30",
    "name": "RSK Mainnet"
  },
  "name": "DAO",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": "1"
    },
    "evmVersion": "byzantium"
  },
  "version": "0.5.8+commit.23d335f2",
  "source": "// File: @openzeppelin/upgrades/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.7.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: @openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\n\npragma solidity ^0.5.0;\n\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context is Initializable {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts-ethereum-package/contracts/ownership/Ownable.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Initializable, Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function initialize(address sender) public initializer {\n        _owner = sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    uint256[50] private ______gap;\n}\n\n// File: @openzeppelin/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: src/contracts/AbstractDAO.sol\n\npragma solidity ^0.5.8;\n\n\n\n\n/// @title A DAO contract based on MolochDAO ideas\ncontract AbstractDAO is Initializable {\n    using SafeMath for uint256;\n\n    /// DAO members\n    mapping(address => Member) public members;\n    /// Array of DAO proposals inlcuding already processed ones\n    Proposal[] public proposalQueue;\n    /// DAO's name.\n    string public name;\n    uint256 public creationTime;\n\n    enum ProposalType {\n        NewMember, /// Adds a new member to the DAO\n        NewDAO, /// Create a new dao\n        AssignBank, /// Assigns bank role to a member\n        AssignCurator /// Assigns curator role to a member\n    }\n\n    enum Role {Normal, Bank, Curator}\n\n    /// TODO: actually define these numbers\n    uint256 public periodDuration; /// seconds\n    uint256 public votingPeriodLength; /// periods\n    uint256 public gracePeriodLength;\n    uint256 public processingPeriodLength;\n\n    /// Emitted then a proposal was successfuly submitted\n    event SubmitProposal(\n        uint256 proposalIndex,\n        address indexed memberAddress,\n        address indexed applicant,\n        ProposalType indexed proposalType\n    );\n    /// Emitted when a vote was succesfuly received\n    event SubmitVote(\n        uint256 indexed proposalIndex,\n        address indexed memberAddress,\n        uint8 vote\n    );\n    /// Emitted when a proposal was successfuly been processed\n    event ProcessProposal(\n        uint256 indexed proposalIndex,\n        address indexed applicant,\n        address indexed memberAddress,\n        ProposalType proposalType,\n        bool didPass\n    );\n\n    enum Vote {Null, Yes, No}\n\n    struct Member {\n        Role role; /// Member current role\n        bool exists; /// To check if it exists in the mapping\n        uint256 shares; /// Amount of shares\n    }\n\n    struct Proposal {\n        address proposer; /// Member that sent the proposal\n        address applicant; ///\n        ProposalType proposalType; /// The type of the proposal being voted\n        uint256 yesVotes; /// Total amount of Yes votes\n        uint256 noVotes; /// Total amount of No votes\n        bool didPass; /// True if the proposal has been approved, no otherwise\n        string description; /// ipfs / rif storage hash\n        mapping(address => Vote) votesByMember; /// All the votes made for this proposal\n        uint256 startingPeriod; /// the period in which voting can start for this proposal\n        bool processed; /// True if it has been processed, false otherwise\n    }\n\n    /**\n     * @param _name DAO name\n     * @param _creator User that will be assigned as the first member\n     */\n    function initialize(\n        string memory _name,\n        address _creator\n    ) public initializer {\n        name = _name;\n        creationTime = now;\n        addMember(_creator);\n        periodDuration = 17280;\n        votingPeriodLength = 35; /// periods\n        gracePeriodLength = 35;\n        processingPeriodLength = votingPeriodLength + gracePeriodLength;\n    }\n    /**\n     * @notice Function to be invoked in order to create a new proposal.\n     *\n     * @param _applicant Address of the user to be added as member. If _proposalType is NewDAO _applicant will be added as the first member.\n     * @param _proposalType Type of the proposal to be voted\n     * @param _description String description about the proposal\n     */\n    function submitProposal(\n        address _applicant,\n        uint8 _proposalType,\n        string memory _description\n    ) public onlyMembers() {\n        ProposalType proposalType = ProposalType(_proposalType);\n        require(_proposalType < 4, 'invalid type');\n        requireProposalTypeIsValid(proposalType);\n\n        if (\n            proposalType == ProposalType.AssignBank ||\n            proposalType == ProposalType.AssignCurator\n        ) {\n            requireIsMember(_applicant);\n        }\n\n        address memberAddress = msg.sender;\n        uint256 startingPeriod = max(\n            getCurrentPeriod(),\n            proposalQueue.length == 0\n                ? 0\n                : proposalQueue[proposalQueue.length.sub(1)].startingPeriod\n        )\n            .add(1);\n        Proposal memory proposal = Proposal({\n            proposer: memberAddress,\n            description: _description,\n            proposalType: proposalType,\n            applicant: _applicant,\n            yesVotes: 0,\n            noVotes: 0,\n            didPass: false,\n            startingPeriod: startingPeriod,\n            processed: false\n        });\n\n        proposalQueue.push(proposal);\n\n        emit SubmitProposal(\n            proposalQueue.length.sub(1),\n            memberAddress,\n            _applicant,\n            proposalType\n        );\n    }\n\n    /**\n     * @notice Used to cast a vote. Keep in mind that only memers can vote, voting twice is not alloed and votes cannot be casted between starting period until expiration.\n     * @param _proposalIndex Proposal to be voted to. It will revert if proposal doesn't exist at _propsoalIndex.\n     * @param _vote The vote, Vote.Yes or Vote.No\n     */\n    function submitVote(uint256 _proposalIndex, uint8 _vote)\n        public\n        onlyMembers()\n    {\n        address memberAddress = msg.sender;\n        require(\n            _proposalIndex < proposalQueue.length,\n            'Moloch::submitVote - proposal does not exist'\n        );\n        Proposal storage proposal = proposalQueue[_proposalIndex];\n        Vote vote = Vote(_vote);\n        require(\n            vote == Vote.Yes || vote == Vote.No,\n            'vote must be either Yes or No'\n        );\n        require(\n            getCurrentPeriod() >= proposal.startingPeriod,\n            'voting period has not started'\n        );\n\n        require(\n            !hasVotingPeriodExpired(proposal.startingPeriod),\n            'proposal voting period has expired'\n        );\n        require(\n            proposal.votesByMember[memberAddress] == Vote.Null,\n            'member has already voted on this proposal'\n        );\n\n        // store user vote\n        proposal.votesByMember[memberAddress] = vote;\n\n        // count the vote in the corresponding proposal vote accumulator\n        Member storage member = members[memberAddress];\n        if (vote == Vote.Yes) {\n            proposal.yesVotes = proposal.yesVotes.add(member.shares);\n        } else if (vote == Vote.No) {\n            proposal.noVotes = proposal.noVotes.add(member.shares);\n        }\n\n        emit SubmitVote(_proposalIndex, memberAddress, _vote);\n    }\n\n    /**\n     * @notice Counts proposal votes and executes corresponding actions if Yes votes > No votes. If it didn't pass does nothing. Proposals can be processed just once.\n     * @param _proposalIndex Proposal to ben processed. Previous proposals (the ones with index less than _proposalIndex) need to be processed first\n     */\n    function processProposal(uint256 _proposalIndex)\n        public\n        canProcess(_proposalIndex)\n    {\n        Proposal storage proposal = proposalQueue[_proposalIndex];\n\n        proposal.processed = true;\n\n        bool didPass = proposal.yesVotes > proposal.noVotes;\n\n        if (didPass) {\n            proposal.didPass = true;\n            // TODO: We might emit event or something to give more feedback to the users\n            bool memberExist = members[proposal.applicant].exists;\n            ProposalType proposalType = proposal.proposalType;\n\n            if (proposalType == ProposalType.NewMember && !memberExist) {\n                addMember(proposal.applicant);\n            } else if (proposalType == ProposalType.AssignBank && memberExist) {\n                members[proposal.applicant].role = Role.Bank;\n            } else if (\n                proposalType == ProposalType.AssignCurator && memberExist\n            ) {\n                members[proposal.applicant].role = Role.Curator;\n            } else if (proposalType == ProposalType.NewDAO) {\n                processNewDaoProposal(proposal.description, proposal.applicant);\n            }\n        }\n\n        emit ProcessProposal(\n            _proposalIndex,\n            proposal.applicant,\n            proposal.proposer,\n            proposal.proposalType,\n            didPass\n        );\n    }\n\n    /**\n     * @notice Returns current period. It can be used to determine the actions that can be performed on a proposal (cast votes or process).\n     */\n    function getCurrentPeriod() public view returns (uint256) {\n        return now.sub(creationTime).div(periodDuration);\n    }\n\n    /**\n     * @notice Returns true if the voting has expired based on the current period\n     * @param startingPeriod Proposal staring period\n     */\n    function hasVotingPeriodExpired(uint256 startingPeriod)\n        public\n        view\n        returns (bool)\n    {\n        return getCurrentPeriod() >= startingPeriod.add(votingPeriodLength);\n    }\n\n    /**\n     * @notice Returns the proposals array length\n     */\n    function getProposalQueueLength() public view returns (uint256) {\n        return proposalQueue.length;\n    }\n\n    /**\n     * @notice Checks if a proposal can be processed or not. Checks to be made: proposal exists, if it's ready to be processed and has not expired and hasn't been yet processed. It also checks if the previoous proposal has been processed already.\n     */\n    modifier canProcess(uint256 proposalIndex) {\n        require(\n            proposalIndex < proposalQueue.length,\n            'proposal does not exist'\n        );\n        Proposal storage proposal = proposalQueue[proposalIndex];\n\n        require(\n            getCurrentPeriod() >=\n                proposal.startingPeriod.add(processingPeriodLength),\n            'proposal is not ready to be processed'\n        );\n        require(\n            proposal.processed == false,\n            'proposal has already been processed'\n        );\n        require(\n            proposalIndex == 0 || proposalQueue[proposalIndex.sub(1)].processed,\n            'previous proposal must be processed'\n        );\n        _;\n    }\n\n    /**\n     * @notice This modifier checks if the `msg.sender` corresponds to a member of the dao with voting power\n     */\n    modifier onlyMembers() {\n        requireIsMember(msg.sender);\n        _;\n    }\n\n    /**\n     * @dev Checks if the given address belongs to a member. It reverts otherwise.\n     * @param _address to be checked\n     */\n    function requireIsMember(address _address) private view {\n        Member storage member = members[_address];\n        require(member.exists == true, 'not a DAO member');\n    }\n\n    function addMember(address memberAddress) private {\n        Member memory member = Member({\n            role: Role.Normal,\n            exists: true,\n            shares: 1\n        });\n        members[memberAddress] = member;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x >= y ? x : y;\n    }\n\n    /**\n     * @dev Checks if the proposal is valid to be processed by this DAO. It must revert if not.\n     * @param _proposalType ProposalType to be checked against to\n     */\n    function requireProposalTypeIsValid(ProposalType _proposalType) internal;\n\n    /**\n     * @dev Processes a new dao proposal. If not supported by the DAO type, it should do nothing\n     * @param _name DAO name\n     * @param _applicant Account to be set as a first member of the dao\n     */\n    function processNewDaoProposal(string memory _name, address _applicant)\n        internal;\n\n    uint256[50] private _gap;\n}\n\n// File: src/contracts/DAO.sol\n\npragma solidity ^0.5.8;\n\n\n/// @title A DAO contract based on MolochDAO ideas\ncontract DAO is AbstractDAO {\n\n    function initialize(string memory _name, address _creator) public initializer {\n        AbstractDAO.initialize(_name, _creator);\n    }\n    \n    function processNewDaoProposal(string memory _name, address applicant)\n        internal\n    {\n        // Do nothing as reverting will mark the proposal as not executed\n        // TODO: Emit an event\n    }\n\n    function requireProposalTypeIsValid(ProposalType _proposalType) internal {\n        require(\n            _proposalType == ProposalType.NewMember ||\n                _proposalType == ProposalType.AssignBank ||\n                _proposalType == ProposalType.AssignCurator,\n            'Invalid Proposal Type'\n        );\n    }\n\n    uint256[50] private _gap;\n}\n",
  "imports": [
    {
      "name": "DAO.sol",
      "contents": "// File: @openzeppelin/upgrades/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.7.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: @openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\n\npragma solidity ^0.5.0;\n\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context is Initializable {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts-ethereum-package/contracts/ownership/Ownable.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Initializable, Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function initialize(address sender) public initializer {\n        _owner = sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    uint256[50] private ______gap;\n}\n\n// File: @openzeppelin/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: src/contracts/AbstractDAO.sol\n\npragma solidity ^0.5.8;\n\n\n\n\n/// @title A DAO contract based on MolochDAO ideas\ncontract AbstractDAO is Initializable {\n    using SafeMath for uint256;\n\n    /// DAO members\n    mapping(address => Member) public members;\n    /// Array of DAO proposals inlcuding already processed ones\n    Proposal[] public proposalQueue;\n    /// DAO's name.\n    string public name;\n    uint256 public creationTime;\n\n    enum ProposalType {\n        NewMember, /// Adds a new member to the DAO\n        NewDAO, /// Create a new dao\n        AssignBank, /// Assigns bank role to a member\n        AssignCurator /// Assigns curator role to a member\n    }\n\n    enum Role {Normal, Bank, Curator}\n\n    /// TODO: actually define these numbers\n    uint256 public periodDuration; /// seconds\n    uint256 public votingPeriodLength; /// periods\n    uint256 public gracePeriodLength;\n    uint256 public processingPeriodLength;\n\n    /// Emitted then a proposal was successfuly submitted\n    event SubmitProposal(\n        uint256 proposalIndex,\n        address indexed memberAddress,\n        address indexed applicant,\n        ProposalType indexed proposalType\n    );\n    /// Emitted when a vote was succesfuly received\n    event SubmitVote(\n        uint256 indexed proposalIndex,\n        address indexed memberAddress,\n        uint8 vote\n    );\n    /// Emitted when a proposal was successfuly been processed\n    event ProcessProposal(\n        uint256 indexed proposalIndex,\n        address indexed applicant,\n        address indexed memberAddress,\n        ProposalType proposalType,\n        bool didPass\n    );\n\n    enum Vote {Null, Yes, No}\n\n    struct Member {\n        Role role; /// Member current role\n        bool exists; /// To check if it exists in the mapping\n        uint256 shares; /// Amount of shares\n    }\n\n    struct Proposal {\n        address proposer; /// Member that sent the proposal\n        address applicant; ///\n        ProposalType proposalType; /// The type of the proposal being voted\n        uint256 yesVotes; /// Total amount of Yes votes\n        uint256 noVotes; /// Total amount of No votes\n        bool didPass; /// True if the proposal has been approved, no otherwise\n        string description; /// ipfs / rif storage hash\n        mapping(address => Vote) votesByMember; /// All the votes made for this proposal\n        uint256 startingPeriod; /// the period in which voting can start for this proposal\n        bool processed; /// True if it has been processed, false otherwise\n    }\n\n    /**\n     * @param _name DAO name\n     * @param _creator User that will be assigned as the first member\n     */\n    function initialize(\n        string memory _name,\n        address _creator\n    ) public initializer {\n        name = _name;\n        creationTime = now;\n        addMember(_creator);\n        periodDuration = 17280;\n        votingPeriodLength = 35; /// periods\n        gracePeriodLength = 35;\n        processingPeriodLength = votingPeriodLength + gracePeriodLength;\n    }\n    /**\n     * @notice Function to be invoked in order to create a new proposal.\n     *\n     * @param _applicant Address of the user to be added as member. If _proposalType is NewDAO _applicant will be added as the first member.\n     * @param _proposalType Type of the proposal to be voted\n     * @param _description String description about the proposal\n     */\n    function submitProposal(\n        address _applicant,\n        uint8 _proposalType,\n        string memory _description\n    ) public onlyMembers() {\n        ProposalType proposalType = ProposalType(_proposalType);\n        require(_proposalType < 4, 'invalid type');\n        requireProposalTypeIsValid(proposalType);\n\n        if (\n            proposalType == ProposalType.AssignBank ||\n            proposalType == ProposalType.AssignCurator\n        ) {\n            requireIsMember(_applicant);\n        }\n\n        address memberAddress = msg.sender;\n        uint256 startingPeriod = max(\n            getCurrentPeriod(),\n            proposalQueue.length == 0\n                ? 0\n                : proposalQueue[proposalQueue.length.sub(1)].startingPeriod\n        )\n            .add(1);\n        Proposal memory proposal = Proposal({\n            proposer: memberAddress,\n            description: _description,\n            proposalType: proposalType,\n            applicant: _applicant,\n            yesVotes: 0,\n            noVotes: 0,\n            didPass: false,\n            startingPeriod: startingPeriod,\n            processed: false\n        });\n\n        proposalQueue.push(proposal);\n\n        emit SubmitProposal(\n            proposalQueue.length.sub(1),\n            memberAddress,\n            _applicant,\n            proposalType\n        );\n    }\n\n    /**\n     * @notice Used to cast a vote. Keep in mind that only memers can vote, voting twice is not alloed and votes cannot be casted between starting period until expiration.\n     * @param _proposalIndex Proposal to be voted to. It will revert if proposal doesn't exist at _propsoalIndex.\n     * @param _vote The vote, Vote.Yes or Vote.No\n     */\n    function submitVote(uint256 _proposalIndex, uint8 _vote)\n        public\n        onlyMembers()\n    {\n        address memberAddress = msg.sender;\n        require(\n            _proposalIndex < proposalQueue.length,\n            'Moloch::submitVote - proposal does not exist'\n        );\n        Proposal storage proposal = proposalQueue[_proposalIndex];\n        Vote vote = Vote(_vote);\n        require(\n            vote == Vote.Yes || vote == Vote.No,\n            'vote must be either Yes or No'\n        );\n        require(\n            getCurrentPeriod() >= proposal.startingPeriod,\n            'voting period has not started'\n        );\n\n        require(\n            !hasVotingPeriodExpired(proposal.startingPeriod),\n            'proposal voting period has expired'\n        );\n        require(\n            proposal.votesByMember[memberAddress] == Vote.Null,\n            'member has already voted on this proposal'\n        );\n\n        // store user vote\n        proposal.votesByMember[memberAddress] = vote;\n\n        // count the vote in the corresponding proposal vote accumulator\n        Member storage member = members[memberAddress];\n        if (vote == Vote.Yes) {\n            proposal.yesVotes = proposal.yesVotes.add(member.shares);\n        } else if (vote == Vote.No) {\n            proposal.noVotes = proposal.noVotes.add(member.shares);\n        }\n\n        emit SubmitVote(_proposalIndex, memberAddress, _vote);\n    }\n\n    /**\n     * @notice Counts proposal votes and executes corresponding actions if Yes votes > No votes. If it didn't pass does nothing. Proposals can be processed just once.\n     * @param _proposalIndex Proposal to ben processed. Previous proposals (the ones with index less than _proposalIndex) need to be processed first\n     */\n    function processProposal(uint256 _proposalIndex)\n        public\n        canProcess(_proposalIndex)\n    {\n        Proposal storage proposal = proposalQueue[_proposalIndex];\n\n        proposal.processed = true;\n\n        bool didPass = proposal.yesVotes > proposal.noVotes;\n\n        if (didPass) {\n            proposal.didPass = true;\n            // TODO: We might emit event or something to give more feedback to the users\n            bool memberExist = members[proposal.applicant].exists;\n            ProposalType proposalType = proposal.proposalType;\n\n            if (proposalType == ProposalType.NewMember && !memberExist) {\n                addMember(proposal.applicant);\n            } else if (proposalType == ProposalType.AssignBank && memberExist) {\n                members[proposal.applicant].role = Role.Bank;\n            } else if (\n                proposalType == ProposalType.AssignCurator && memberExist\n            ) {\n                members[proposal.applicant].role = Role.Curator;\n            } else if (proposalType == ProposalType.NewDAO) {\n                processNewDaoProposal(proposal.description, proposal.applicant);\n            }\n        }\n\n        emit ProcessProposal(\n            _proposalIndex,\n            proposal.applicant,\n            proposal.proposer,\n            proposal.proposalType,\n            didPass\n        );\n    }\n\n    /**\n     * @notice Returns current period. It can be used to determine the actions that can be performed on a proposal (cast votes or process).\n     */\n    function getCurrentPeriod() public view returns (uint256) {\n        return now.sub(creationTime).div(periodDuration);\n    }\n\n    /**\n     * @notice Returns true if the voting has expired based on the current period\n     * @param startingPeriod Proposal staring period\n     */\n    function hasVotingPeriodExpired(uint256 startingPeriod)\n        public\n        view\n        returns (bool)\n    {\n        return getCurrentPeriod() >= startingPeriod.add(votingPeriodLength);\n    }\n\n    /**\n     * @notice Returns the proposals array length\n     */\n    function getProposalQueueLength() public view returns (uint256) {\n        return proposalQueue.length;\n    }\n\n    /**\n     * @notice Checks if a proposal can be processed or not. Checks to be made: proposal exists, if it's ready to be processed and has not expired and hasn't been yet processed. It also checks if the previoous proposal has been processed already.\n     */\n    modifier canProcess(uint256 proposalIndex) {\n        require(\n            proposalIndex < proposalQueue.length,\n            'proposal does not exist'\n        );\n        Proposal storage proposal = proposalQueue[proposalIndex];\n\n        require(\n            getCurrentPeriod() >=\n                proposal.startingPeriod.add(processingPeriodLength),\n            'proposal is not ready to be processed'\n        );\n        require(\n            proposal.processed == false,\n            'proposal has already been processed'\n        );\n        require(\n            proposalIndex == 0 || proposalQueue[proposalIndex.sub(1)].processed,\n            'previous proposal must be processed'\n        );\n        _;\n    }\n\n    /**\n     * @notice This modifier checks if the `msg.sender` corresponds to a member of the dao with voting power\n     */\n    modifier onlyMembers() {\n        requireIsMember(msg.sender);\n        _;\n    }\n\n    /**\n     * @dev Checks if the given address belongs to a member. It reverts otherwise.\n     * @param _address to be checked\n     */\n    function requireIsMember(address _address) private view {\n        Member storage member = members[_address];\n        require(member.exists == true, 'not a DAO member');\n    }\n\n    function addMember(address memberAddress) private {\n        Member memory member = Member({\n            role: Role.Normal,\n            exists: true,\n            shares: 1\n        });\n        members[memberAddress] = member;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x >= y ? x : y;\n    }\n\n    /**\n     * @dev Checks if the proposal is valid to be processed by this DAO. It must revert if not.\n     * @param _proposalType ProposalType to be checked against to\n     */\n    function requireProposalTypeIsValid(ProposalType _proposalType) internal;\n\n    /**\n     * @dev Processes a new dao proposal. If not supported by the DAO type, it should do nothing\n     * @param _name DAO name\n     * @param _applicant Account to be set as a first member of the dao\n     */\n    function processNewDaoProposal(string memory _name, address _applicant)\n        internal;\n\n    uint256[50] private _gap;\n}\n\n// File: src/contracts/DAO.sol\n\npragma solidity ^0.5.8;\n\n\n/// @title A DAO contract based on MolochDAO ideas\ncontract DAO is AbstractDAO {\n\n    function initialize(string memory _name, address _creator) public initializer {\n        AbstractDAO.initialize(_name, _creator);\n    }\n    \n    function processNewDaoProposal(string memory _name, address applicant)\n        internal\n    {\n        // Do nothing as reverting will mark the proposal as not executed\n        // TODO: Emit an event\n    }\n\n    function requireProposalTypeIsValid(ProposalType _proposalType) internal {\n        require(\n            _proposalType == ProposalType.NewMember ||\n                _proposalType == ProposalType.AssignBank ||\n                _proposalType == ProposalType.AssignCurator,\n            'Invalid Proposal Type'\n        );\n    }\n\n    uint256[50] private _gap;\n}\n",
      "file": "DAO.sol"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x3bdda531e360e960164a08cb3e0d0ea470f4b4c0a4619f6f98255d5882f80e95",
    "blockNumber": 2852407,
    "transactionHash": "0xfd0b5f5b44366339d38dd8e169d8d232bd3d377217f06fd8bf0bc03bcff43dfc",
    "timestamp": 1605033845
  }
}