{
  "address": "0x75f80e50181597f87fad3a81dd9acc2aa35c32b3",
  "net": {
    "id": "30",
    "name": "RSK Mainnet"
  },
  "name": "MoCBurnout",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": "1"
    },
    "evmVersion": "byzantium"
  },
  "version": "0.5.8+commit.23d335f2",
  "source": "pragma solidity 0.5.8;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCWhitelist {\n  mapping(address => bool) whitelist;\n\n  /**\n   * @dev Check if an account is whitelisted\n   * @return Bool\n   */\n  function isWhitelisted(address account)\n    public\n    view\n    returns (bool)\n  {\n    require(account != address(0), \"Account must not be 0x0\");\n    return whitelist[account];\n  }\n\n  /**\n   * @dev Add account to whitelist\n   */\n  function add(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(!isWhitelisted(account), \"Account not allowed to add accounts into white list\");\n    whitelist[account] = true;\n  }\n\n  /**\n   * @dev Remove account to whitelist\n   */\n  function remove(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(isWhitelisted(account), \"Account is not allowed to remove address from the white list\");\n\n    whitelist[account] = false;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCConnector is MoCWhitelist, Initializable {\n  // References\n  address payable public moc;\n  address public stableToken;\n  address public riskProToken;\n  address public riskProxManager;\n  address public mocState;\n  address public mocConverter;\n  address public mocSettlement;\n  address public mocExchange;\n  address public mocInrate;\n  address public mocBurnout;\n  address public reserveToken;\n\n  bool internal initialized;\n\n  function initialize(\n    address payable mocAddress,\n    address stableTokenAddress,\n    address riskProAddress,\n    address riskProxAddress,\n    address stateAddress,\n    address settlementAddress,\n    address converterAddress,\n    address exchangeAddress,\n    address inrateAddress,\n    address burnoutBookAddress,\n    address reserveTokenAddress\n  ) public initializer {\n    moc = mocAddress;\n    stableToken = stableTokenAddress;\n    riskProToken = riskProAddress;\n    riskProxManager = riskProxAddress;\n    mocState = stateAddress;\n    mocSettlement = settlementAddress;\n    mocConverter = converterAddress;\n    mocExchange = exchangeAddress;\n    mocInrate = inrateAddress;\n    mocBurnout = burnoutBookAddress;\n    reserveToken = reserveTokenAddress;\n\n    // Add to Whitelist\n    add(mocAddress);\n    add(stableTokenAddress);\n    add(riskProAddress);\n    add(riskProxAddress);\n    add(stateAddress);\n    add(settlementAddress);\n    add(converterAddress);\n    add(exchangeAddress);\n    add(inrateAddress);\n    add(burnoutBookAddress);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n/**\n * @dev Defines special constants to use along all the MoC System\n */\ncontract MoCConstants {\n  bytes32 constant public BUCKET_X2 = \"X2\";\n  bytes32 constant public BUCKET_C0 = \"C0\";\n}\n\n/**\n  @dev General usefull modifiers and functions\n */\ncontract MoCBase is MoCConstants, Initializable {\n  // Contracts\n  MoCConnector public connector;\n\n  bool internal initialized;\n\n  function initializeBase(address connectorAddress) internal initializer {\n    connector = MoCConnector(connectorAddress);\n  }\n\n  modifier onlyWhitelisted(address account) {\n    require(connector.isWhitelisted(account), \"Address is not whitelisted\");\n    _;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\ncontract PartialExecutionData {\n  enum ExecutionState {\n    Ready,\n    Running,\n    Finished\n  }\n\n  struct TaskGroup {\n    bytes32 id;\n    ExecutionState state;\n    bytes32[] subTasks;\n    function() internal onStart;\n    function() internal onFinish;\n    bool autoRestart;\n  }\n\n  struct Task {\n    bytes32 id;\n    function() internal returns(uint256) getStepCount;\n    function(uint256) internal stepFunction;\n    function() internal onStart;\n    function() internal onFinish;\n    uint256 currentStep;\n    uint256 stepCount;\n    ExecutionState state;\n  }\n}\n\n/**\n  @dev Brings basic data structures and functions for partial execution.\n  The main data structures are:\n    Task: Represents a function that needs to be executed by steps.\n    TaskGroup: Represents a function that contains several functions that needs to be executed by steps.\n  Tasks and Tasks groups can be executed specifying the amount of steps to run.\n*/\ncontract PartialExecution is PartialExecutionData {\n  using SafeMath for uint256;\n  using Math for uint256;\n  mapping(bytes32 => Task) internal tasks;\n  mapping(bytes32 => TaskGroup) internal taskGroups;\n  /**\n     @dev Auxiliar function for tasks with no onFinish function\n   */\n  function noFunction() internal {\n\n  }\n\n  /**\n     @dev Creates a task group\n     @param _groupId Id of the task group\n     @param _subtasks Tasks to execute when executing the task group\n     @param _onFinish Function to execute when all tasks of the group are completed\n   */\n  function createTaskGroup(bytes32 _groupId, bytes32[] memory _subtasks, function() _onStart, function() _onFinish, bool _autoRestart) internal{\n    taskGroups[_groupId].id = _groupId;\n    taskGroups[_groupId].subTasks = _subtasks;\n    taskGroups[_groupId].onStart = _onStart;\n    taskGroups[_groupId].onFinish = _onFinish;\n    taskGroups[_groupId].state = ExecutionState.Ready;\n    taskGroups[_groupId].autoRestart = _autoRestart;\n  }\n\n  /**\n     @dev Creates a task\n     @param taskId Id of the task\n     @param _getStepCount Function executed before starting the task\n     Should return the step count of the execution\n     @param _stepFunction Function to execute at each step\n     @param _onStart Function to execute before task execution\n     @param _onFinish Function to execute when all steps are completed\n   */\n  function createTask(\n    bytes32 taskId,\n    function() internal returns(uint256) _getStepCount,\n    function(uint256) internal _stepFunction,\n    function() internal _onStart,\n    function() internal _onFinish\n  ) internal {\n    tasks[taskId].id = taskId;\n    tasks[taskId].getStepCount = _getStepCount;\n    tasks[taskId].stepFunction = _stepFunction;\n    tasks[taskId].onStart = _onStart;\n    tasks[taskId].onFinish = _onFinish;\n    tasks[taskId].state = ExecutionState.Ready;\n  }\n\n  /**\n     @dev Executes all tasks of the group in order using the step count passed as parameter\n     @param groupId Id of the task group\n     @param stepCount Step count to execute\n   */\n  function executeGroup(bytes32 groupId, uint256 stepCount) internal {\n    TaskGroup storage group = taskGroups[groupId];\n\n    if (group.state == ExecutionState.Ready) {\n      group.onStart();\n      group.state = ExecutionState.Running;\n    }\n\n    uint256 leftSteps = stepCount;\n\n    for (uint256 i = 0; i < group.subTasks.length; i++) {\n      uint256 consumed = executeTask(group.subTasks[i], leftSteps);\n      leftSteps = leftSteps.sub(consumed);\n    }\n\n    if (groupFinished(groupId)) {\n      group.state = ExecutionState.Finished;\n      group.onFinish();\n      if (group.autoRestart) {\n        resetGroup(groupId);\n      }\n    }\n  }\n\n  /**\n     @dev Creates a task\n     @param taskId Id of the task\n     @param steps Step count to execute\n     @return The amount of steps consumed in the execution\n   */\n  function executeTask(bytes32 taskId, uint256 steps) internal returns(uint256){\n    Task storage task = tasks[taskId];\n    uint256 initialStep = task.currentStep;\n\n    if (task.state == ExecutionState.Finished) {\n      // No execution\n      return 0;\n    }\n    if (task.state == ExecutionState.Ready) {\n      task.stepCount = task.getStepCount();\n      task.onStart();\n      task.state = ExecutionState.Running;\n    }\n    if (task.state == ExecutionState.Running) {\n      uint256 endStep = Math.min(task.currentStep.add(steps), task.stepCount);\n\n      for (task.currentStep; task.currentStep < endStep; task.currentStep++) {\n        task.stepFunction(task.currentStep);\n      }\n\n      if (task.currentStep == task.stepCount) {\n        task.state = ExecutionState.Finished;\n        task.onFinish();\n      }\n    }\n\n    return task.currentStep.sub(initialStep);\n  }\n\n  /**\n     @dev Put task in Ready to run state and reset currentStep value\n     @param taskId Id of the task\n   */\n  function resetTask(bytes32 taskId) internal {\n    tasks[taskId].state = ExecutionState.Ready;\n    tasks[taskId].currentStep = 0;\n  }\n\n  /**\n    @dev Reset all tasks in a group. Used at the completion of a task group execution\n    @param groupId Id of the task group\n  */\n  function resetTasks(bytes32 groupId) internal {\n    TaskGroup storage group = taskGroups[groupId];\n\n    for (uint256 i = 0; i < group.subTasks.length; i++) {\n      resetTask(group.subTasks[i]);\n    }\n  }\n\n  /**\n    @dev Set if a Group should be automatically set to Ready state\n    after Finnished State is reached\n    @param groupId Id of the task group\n  */\n  function setAutoRestart(bytes32 groupId, bool _autoRestart) internal {\n    taskGroups[groupId].autoRestart = _autoRestart;\n  }\n\n  /**\n    @dev Set Group in Ready state. Reset all sub-task.\n    @param groupId Id of the task group\n  */\n  function resetGroup(bytes32 groupId) internal {\n    TaskGroup storage group = taskGroups[groupId];\n    group.state = ExecutionState.Ready;\n\n    resetTasks(groupId);\n  }\n\n  /**\n     @dev Returns true if the last task of the group was completed\n     @param groupId Id of the task group\n     @return boolean\n   */\n  function groupFinished(bytes32 groupId) internal view returns(bool){\n    TaskGroup storage group = taskGroups[groupId];\n    bytes32 taskId = group.subTasks[group.subTasks.length.sub(1)];\n    Task storage lastTask = tasks[taskId];\n\n    return lastTask.state == ExecutionState.Finished;\n  }\n\n  /**\n     @dev Returns true if the group is currently un Running state\n     @param groupId Id of the task group\n     @return boolean\n   */\n  function isGroupRunning(bytes32 groupId) internal view returns(bool) {\n    return taskGroups[groupId].state == ExecutionState.Running;\n  }\n\n  /**\n     @dev Returns true if the group is currently in Ready state\n     @param groupId Id of the task group\n     @return boolean\n   */\n  function isGroupReady(bytes32 groupId) internal view returns(bool) {\n    return taskGroups[groupId].state == ExecutionState.Ready;\n  }\n\n  /**\n     @dev Returns true if the task is currently un Running state\n     @param taskId Id of the task\n     @return boolean\n   */\n  function isTaskRunning(bytes32 taskId) internal view returns(bool) {\n    return tasks[taskId].state == ExecutionState.Running;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * > Note that this information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * `IERC20.balanceOf` and `IERC20.transfer`.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See `IERC20.approve`.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destoys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See `_burn` and `_approve`.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\ncontract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(msg.sender), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n\n/**\n * @dev Extension of `ERC20` that adds a set of accounts with the `MinterRole`,\n * which have permission to mint (create) new tokens as they see fit.\n *\n * At construction, the deployer of the contract is the only minter.\n */\ncontract ERC20Mintable is ERC20, MinterRole {\n    /**\n     * @dev See `ERC20._mint`.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MinterRole`.\n     */\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n/**\n * @title Owner Burnable Token\n * @dev Token that allows the owner to irreversibly burned (destroyed) any token.\n */\ncontract OwnerBurnableToken is Ownable, ERC20Mintable {\n  /**\n   * @dev Burns a specific amount of tokens for the address.\n   * @param who who's tokens are gona be burned\n   * @param value The amount of token to be burned.\n   */\n  function burn(address who, uint256 value) public onlyOwner {\n    _burn(who, value);\n  }\n}\n\ncontract StableToken is ERC20Detailed, OwnerBurnableToken {\n\n  string private _name = \"Stable Token\";\n  string private _symbol = \"STABLE\";\n  uint8 private _decimals = 18;\n\n  constructor() Ownable() ERC20Detailed(_name, _symbol, _decimals) public {\n\n  }\n\n  //Fallback\n  function() external {\n  }\n}\n\ninterface PriceProvider {\n  function peek() external view returns (bytes32, bool);\n}\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n\n  /**\n    @notice Override this function with a recipe of the changes to be done when this ChangeContract\n    is executed\n   */\n  function execute() external;\n}\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor{\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @dev This function should be protected somehow to only execute changes that\n    benefit the system. This decision process is independent of this architechture\n    therefore is independent of this interface too\n    @param changeContract Address of the contract that will execute the changes\n   */\n  function executeChange(ChangeContract changeContract) external;\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @param _changer Address of the contract that will execute the changes\n   */\n  function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed is Initializable {\n\n  /**\n    @notice The address of the contract which governs this one\n   */\n  IGovernor public governor;\n\n  string constant private NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n  /**\n    @notice Modifier that protects the function\n    @dev You should use this modifier in any function that should be called through\n    the governance system\n   */\n  modifier onlyAuthorizedChanger() {\n    require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n    _;\n  }\n\n  /**\n    @notice Initialize the contract with the basic settings\n    @dev This initialize replaces the constructor but it is not called automatically.\n    It is necessary because of the upgradeability of the contracts\n    @param _governor Governor address\n   */\n  function initialize(IGovernor _governor) public initializer {\n    governor = _governor;\n  }\n\n  /**\n    @notice Change the contract's governor. Should be called through the old governance system\n    @param newIGovernor New governor address\n   */\n  function changeIGovernor(IGovernor newIGovernor) public onlyAuthorizedChanger {\n    governor = newIGovernor;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n/** @title ReserveToken Price Provider. */\ncontract MoCEMACalculator is Governed {\n  using SafeMath for uint256;\n\n  event MovingAverageCalculation (\n    uint256 price,\n    uint256 movingAverage\n  );\n\n  uint256 internal exponentialMovingAverage;\n  uint256 public smoothingFactor;\n  uint256 public lastEmaCalculation;\n  uint256 public emaCalculationBlockSpan;\n\n  uint256 constant public PRICE_PRECISION =  10 ** 18;\n  uint256 constant public FACTOR_PRECISION = 10 ** 18;\n\n  function getExponentalMovingAverage() public view returns(uint256) {\n    return exponentialMovingAverage;\n  }\n\n  function getSmoothingFactor() public view returns(uint256) {\n    return smoothingFactor;\n  }\n\n  function setSmoothingFactor(uint256 factor) public onlyAuthorizedChanger() {\n    _doSetSmoothingFactor(factor);\n  }\n\n  function getGovernorAddress() public view returns(address){\n    return address(governor);\n  }\n\n  function getEmaCalculationBlockSpan() public view returns(uint256){\n    return emaCalculationBlockSpan;\n  }\n  /**\n  * @param blockSpan Defines how many blocks should pass between BMA calculations\n  **/\n  function setEmaCalculationBlockSpan(uint256 blockSpan) public onlyAuthorizedChanger() {\n    emaCalculationBlockSpan = blockSpan;\n  }\n\n  function shouldCalculateEma() public view returns(bool) {\n    return block.number >= lastEmaCalculation.add(emaCalculationBlockSpan);\n  }\n\n  function getLastEmaCalculation() public view returns(uint256) {\n    return lastEmaCalculation;\n  }\n\n    /** @dev Provides ResToken's Price and Moving average.\n    * More information of EMA calculation https://en.wikipedia.org/wiki/Exponential_smoothing\n    * @param initialEma Initial ema value\n    * @param smoothFactor Weight coefficient for EMA calculation.\n    * @param emaBlockSpan Block count in a period for EMA calculation\n    */\n  function initializeMovingAverage(uint256 initialEma, uint256 smoothFactor, uint256 emaBlockSpan) internal {\n    _doSetSmoothingFactor(smoothFactor);\n    lastEmaCalculation = block.number;\n    exponentialMovingAverage = initialEma;\n    emaCalculationBlockSpan = emaBlockSpan;\n  }\n\n  /** @dev Calculates a EMA of the price.\n    * More information of EMA calculation https://en.wikipedia.org/wiki/Exponential_smoothing\n    * @param reservePrice Current price.\n    */\n  function setExponentalMovingAverage(uint256 reservePrice) internal {\n    if (shouldCalculateEma()) {\n      uint256 weightedPrice = reservePrice.mul(smoothingFactor);\n      uint256 currentEma = exponentialMovingAverage.mul(coefficientComp()).add(weightedPrice)\n        .div(FACTOR_PRECISION);\n\n      lastEmaCalculation = block.number;\n      exponentialMovingAverage = currentEma;\n\n      emit MovingAverageCalculation(reservePrice, currentEma);\n    }\n  }\n\n  /** @dev Calculates the smoothing factor complement\n    */\n  function coefficientComp() internal view returns(uint256) {\n    return FACTOR_PRECISION.sub(smoothingFactor);\n  }\n\n  function initializeGovernor(address _governor) internal {\n    governor = IGovernor(_governor);\n  }\n\n  function _doSetSmoothingFactor(uint256 factor) private {\n    require(factor <= FACTOR_PRECISION, \"Invalid smoothing factor\");\n    smoothingFactor = factor;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\nlibrary MoCHelperLib {\n\n  struct MocLibConfig {\n    uint256 reservePrecision;\n    uint256 dayPrecision;\n    uint256 mocPrecision;\n  }\n\n  using SafeMath for uint256;\n\n  uint256 constant UINT256_MAX = ~uint256(0);\n\n  /**\n    Calculates average interest using integral function\n\n    @dev T =  Rate = a * (x ** b) + c\n    @param tMax maxInterestRate [using mocPrecision]\n    @param power factor [using noPrecision]\n    @param tMin minInterestRate C0 stableToken amount [using mocPrecision]\n    @param abRat1 initial abundance ratio [using mocPrecision]\n    @param abRat2 final abundance ratio [using mocPrecision]\n    @return average interest rate [using mocPrecision]\n  */\n  function inrateAvg(MocLibConfig storage config, uint256 tMax, uint256 power, uint256 tMin, uint256 abRat1, uint256 abRat2)\n  public view returns(uint256) {\n    require(tMax > tMin, \"Max inrate should be bigger than Min inrate\");\n    uint256 abRat1Comp = config.mocPrecision.sub(abRat1);\n    uint256 abRat2Comp = config.mocPrecision.sub(abRat2);\n\n    if (abRat1 == abRat2) {\n      return potential(config, tMax, power, tMin, abRat1Comp);\n    }\n    else if (abRat2 < abRat1) {\n      return avgInt(config, tMax, power, tMin, abRat1Comp, abRat2Comp);\n    }\n    else {\n      return avgInt(config, tMax, power, tMin, abRat2Comp, abRat1Comp);\n    }\n  }\n\n  /**\n    Calculates spot interest rate that RiskProx owners should pay to RiskPro owners\n\n    @dev Rate = tMax * (abRatio ** power) + tMin\n    @param tMin min interest rate [using mocPrecision]\n    @param power power to use in the formula [using NoPrecision]\n    @param tMax max interest rate [using mocPrecision]\n    @param abRatio bucket C0  abundance Ratio [using mocPrecision]\n\n   */\n  function spotInrate(\n    MocLibConfig storage config, uint256 tMax, uint256 power, uint256 tMin, uint256 abRatio\n  ) public view returns(uint256) {\n    uint256 abRatioComp = config.mocPrecision.sub(abRatio);\n\n    return potential(config, tMax, power, tMin, abRatioComp);\n  }\n\n  /**\n    Calculates potential interests function with given parameters\n\n    @dev Rate = a * (x ** b) + c\n    @param a maxInterestRate [using mocPrecision]\n    @param b factor [using NoPrecision]\n    @param c minInterestRate C0 stableToken amount [using mocPrecision]\n    @param value global stableToken amount [using mocPrecision]\n  */\n  function potential(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value)\n  public view returns(uint256) {\n    // value ** b\n    // [MOC] ** [] = [MOC]\n    uint256 aux1 = pow(value, b, config.mocPrecision);\n    // (a * aux1) + c\n    // [MOC] [MOC] / [MOC] + [MOC] = [MOC]\n    return a.mul(aux1).div(config.mocPrecision).add(c);\n  }\n\n  /**\n    Calculates average of the integral function\n\n    @dev T = (\n              (c * xf + ((a * (xf ** (b + 1))) / (b + 1))) -\n              (c * xi + ((a * (xi ** (b + 1))) / (b + 1)))\n             ) / (xf - xi)\n    @param a maxInterestRate [using mocPrecision]\n    @param b factor [using NoPrecision]\n    @param c minInterestRate C0 stableToken amount [using mocPrecision]\n    @param value1 value to put in the function [using mocPrecision]\n    @param value2 value to put in the function [using mocPrecision]\n    @return average interest rate [using mocPrecision]\n   */\n  function avgInt(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value1, uint256 value2)\n  public view returns(uint256) {\n    // value2 - value1\n    // [MOC]\n    uint256 diff = value2.sub(value1);\n    // ((c * (1 - value1) + ((a * ((1 - value1) ** (b + 1))) / (b + 1)))\n    uint256 intV1 = integral(config, a, b, c, value1);\n    // ((c * (1 - value2) + ((a * ((1 - value2) ** (b + 1))) / (b + 1)))\n    uint256 intV2 = integral(config,  a, b, c, value2);\n    // (secOp - first) / diff\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\n    return intV2.sub(intV1).div(diff);\n  }\n\n  /**\n    Calculates integral of the exponential function\n\n    @dev T = c * (value) + (a * value ** (b + 1)) / (b + 1))\n    @param a maxInterestRate [using mocPrecision]\n    @param b factor [using NoPrecision]\n    @param c minInterestRate C0 stableToken amount [using mocPrecision]\n    @param value value to put in the function [using mocPrecision]\n    @return integration result [using mocPrecision]\n\n   */\n  function integral(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value)\n  public view returns(uint256) {\n    // b + 1\n    // [NONE]\n    uint256 b2 = b.add(1);\n    // c * value\n    // [MOC][MOC]\n    uint256 firstOp = c.mul(value);\n    // [MOC]\n    uint256 pow = pow(value, b2, config.mocPrecision);\n    // (a * value ** b2) / b2)\n    // [MOC][MOC]\n    uint256 secOp = a.mul(pow).div(b2);\n    // (firstOp + secOp)\n    // [MOC][MOC] + [MOC][MOC] = [MOC][MOC]\n    return firstOp.add(secOp);\n  }\n\n  /**\n  * @dev Relation between stableTokens in bucket 0 and StableToken total supply\n  * @param stableToken0 stableToken count in bucket 0 [using mocPrecision]\n  * @param stableTokent total stableToken supply [using mocPrecision]\n  * @return abundance ratio [using mocPrecision]\n  */\n  function abundanceRatio(MocLibConfig storage config, uint256 stableToken0, uint256 stableTokent)\n  public view returns(uint256) {\n    if (stableTokent == 0) {\n      return config.mocPrecision;\n    }\n    // [StableToken] [MOC] / [StableToken] = [MOC]\n    return stableToken0.mul(config.mocPrecision).div(stableTokent);\n  }\n\n  /**\n    SpotDiscountRate = TPD * (utpdu - cob) / (uptdu -liq)\n\n    @dev Returns the Ratio to apply to RiskPro Price in discount situations\n    @param riskProLiqDiscountRate Discount rate applied at Liquidation level coverage [using mocPrecision]\n    @param liq Liquidation coverage threshold [using mocPrecision]\n    @param utpdu Discount coverage threshold [using mocPrecision]\n    @param cov Actual global Coverage threshold [using mocPrecision]\n    @return Spot discount rate [using mocPrecision]\n  **/\n  function riskProSpotDiscountRate(\n    MocLibConfig storage libConfig, uint256 riskProLiqDiscountRate,\n    uint256 liq, uint256 utpdu, uint256 cov\n  ) public view returns(uint256) {\n    require(riskProLiqDiscountRate < libConfig.mocPrecision, \"Discount rate should be lower than 1\");\n\n    if (cov >= utpdu) {\n      return 0;\n    }\n\n    // utpdu - liq\n    // [MOC] - [MOC] = [MOC]\n    uint256 utpduLiqDiff = utpdu.sub(liq);\n\n    // utpdu - cov\n    // [MOC] - [MOC] = [MOC]\n    uint256 utpduCovDiff = utpdu.sub(cov);\n\n    // TPD * utpduCovDiff / utpduLiqDiff\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    return riskProLiqDiscountRate.mul(utpduCovDiff).div(utpduLiqDiff);\n  }\n\n  /**\n    MaxRiskProWithDiscount = (uTPDU * nStableToken * PEG - (nReserve * B)) / (TPusd * TPD)\n\n    @dev Max amount of RiskPro to available with discount\n    @param nReserve Total ReserveTokens amount [using reservePrecision]\n    @param nStableToken StableToken amount [using mocPrecision]\n    @param utpdu Discount coverage threshold [using mocPrecision]\n    @param peg peg value\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @param riskProUsdPrice riskProUsdPrice [using mocPrecision]\n    @param spotDiscount spot discount [using mocPrecision]\n    @return Total RiskPro amount [using mocPrecision]\n  **/\n  function maxRiskProWithDiscount(\n    MocLibConfig storage libConfig, uint256 nReserve, uint256 nStableToken, uint256 utpdu,\n    uint256 peg, uint256 reservePrice, uint256 riskProUsdPrice, uint256 spotDiscount\n  ) public view returns(uint256)  {\n    require(spotDiscount < libConfig.mocPrecision, \"Discount Rate should be lower than 1\");\n\n    if (spotDiscount == 0) {\n      return 0;\n    }\n\n    // nReserve * B\n    // [RES] * [MOC] / [RES] = [MOC]\n    uint256 nbUsdValue = nReserve.mul(reservePrice).div(libConfig.reservePrecision);\n\n    // (TPusd * (1 - TPD))\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 riskProDiscountPrice = riskProUsdPrice.mul(libConfig.mocPrecision.sub(spotDiscount))\n      .div(libConfig.mocPrecision);\n\n    return maxRiskProWithDiscountAux(libConfig, nbUsdValue, nStableToken, utpdu, peg, riskProDiscountPrice);\n  }\n\n  /**\n    MaxRiskProWithDiscount = (uTPDU * nStableToken * PEG - (nReserve * B)) / (TPusd * TPD)\n\n    @dev Max amount of RiskPro to available with discount\n    @param nbUsdValue Total amount of ReserveTokens in USD [using mocPrecision]\n    @param nStableToken StableToken amount [using mocPrecision]\n    @param utpdu Discount coverage threshold [using mocPrecision]\n    @param riskProDiscountPrice riskProUsdPrice with discount applied [using mocPrecision]\n    @param peg peg value\n    @return Total RiskPro amount [using reservePrecision]\n  **/\n  function maxRiskProWithDiscountAux(\n    MocLibConfig storage libConfig, uint256 nbUsdValue, uint256 nStableToken,\n    uint256 utpdu, uint256 peg, uint256 riskProDiscountPrice\n  ) internal view returns(uint256) {\n\n    // uTPDU * nStableToken * PEG\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 coverageUSDAmount = utpdu.mul(nStableToken).mul(peg).div(libConfig.mocPrecision);\n\n    // This case only occurs with Coverage below 1\n    if (coverageUSDAmount <= nbUsdValue) {\n      return 0;\n    }\n\n    // ([MOC] - [MOC]) * [RES] / [MOC] = [RES]\n    return coverageUSDAmount.sub(nbUsdValue).mul(libConfig.reservePrecision).div(riskProDiscountPrice);\n  }\n\n  /**\n\n    @dev Calculates Locked ReserveTokens\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @param nStableToken StableTokens amount [using mocPrecision]\n    @param peg peg value\n    @return Locked ReserveTokens [using reservePrecision]\n  **/\n  function lockedReserveTokens(\n    MocLibConfig storage libConfig, uint256 reservePrice, uint256 nStableToken, uint256 peg\n  ) public view returns(uint256) {\n    return nStableToken.mul(peg).mul(libConfig.reservePrecision).div(reservePrice);\n  }\n\n  /**\n    @dev Calculates price at liquidation event as a relation between the stableToken total supply\n    and the amount of ReserveTokens available to distribute\n    @param resTokenAmount ReserveTokens to distribute [using reservePrecision]\n    @param nStableToken StableTokens amount [using mocPrecision]\n    @return Price at liquidation event [using mocPrecision]\n  **/\n  function liquidationPrice(MocLibConfig storage libConfig, uint256 resTokenAmount, uint256 nStableToken)\n  public view returns(uint256) {\n    // [MOC] * [RES] / [RES]\n    return nStableToken.mul(libConfig.reservePrecision).div(resTokenAmount);\n  }\n\n  /**\n    (nReserve-LB) / nTP\n\n    @dev Calculates RiskPro ReserveTokens price\n    @param nReserve Total ReserveTokens amount [using reservePrecision]\n    @param lb Locked ReserveTokens amount [using reservePrecision]\n    @param nTP RiskPro amount [using mocPrecision]\n    @return RiskPro ReserveTokens price [using reservePrecision]\n  **/\n  function riskProTecPrice(MocLibConfig storage libConfig, uint256 nReserve, uint256 lb, uint256 nTP)\n    public view returns(uint256) {\n    // Liquidation happens before this condition turns true\n    if (nReserve < lb) {\n      return 0;\n    }\n\n    if (nTP == 0) {\n      return libConfig.mocPrecision;\n    }\n    // ([RES] - [RES]) * [MOC] / [MOC]\n    return nReserve.sub(lb).mul(libConfig.mocPrecision).div(nTP);\n  }\n\n  /**\n   RiskProxInRiskPro = riskProxTecPrice / riskProPrice\n\n    @dev Calculates RiskPro ReserveTokens price\n    @param riskProxTecPrice RiskProx ReserveTokens price [using reservePrecision]\n    @param riskProPrice Trog ReserveTokens price [using reservePrecision]\n    @return RiskProx price in RiskPro [using mocPrecision]\n  **/\n  function riskProxRiskProPrice(\n    MocLibConfig storage libConfig, uint256 riskProxTecPrice, uint256 riskProPrice\n  ) public view returns(uint256) {\n    // [RES] * [MOC] / [RES] = [MOC]\n    return riskProxTecPrice.mul(libConfig.mocPrecision).div(riskProPrice);\n  }\n\n  /**\n    (price)* (1 - discountRate)\n\n    @dev Returns a new value with the discountRate applied\n    @param price Price [using SomePrecision]\n    @param discountRate Discount rate to apply [using mocPrecision]\n    @return Price with discount applied [using SomePrecision]\n  **/\n  function applyDiscountRate(MocLibConfig storage libConfig, uint256 price, uint256 discountRate)\n    public view returns(uint256) {\n\n    uint256 discountCoeff = libConfig.mocPrecision.sub(discountRate);\n\n    return price.mul(discountCoeff).div(libConfig.mocPrecision);\n  }\n\n  /**\n   price * interestRate\n\n    @dev Returns the amount of interest to pay\n    @param value Cost to apply interest [using SomePrecision]\n    @param interestRate Interest rate to apply [using mocPrecision]\n    @return Interest cost based on the value and interestRate [using SomePrecision]\n  **/\n  function getInterestCost(MocLibConfig storage libConfig, uint256 value, uint256 interestRate)\n    public view returns(uint256) {\n    // [ORIGIN] * [MOC] / [MOC] = [ORIGIN]\n    return value.mul(interestRate).div(libConfig.mocPrecision);\n  }\n\n  /**\n    Coverage = nReserve / LB\n\n    @dev Calculates Coverage\n    @param nReserve Total ReserveTokens amount [using reservePrecision]\n    @param lB Locked ReserveTokens amount [using reservePrecision]\n    @return Coverage [using mocPrecision]\n  **/\n  function coverage(MocLibConfig storage libConfig, uint256 nReserve, uint256 lB) public view\n    returns(uint256) {\n    if (lB == 0) {\n      return UINT256_MAX;\n    }\n\n    return nReserve.mul(libConfig.mocPrecision).div(lB);\n  }\n\n /**\n  Leverage = C / (C - 1)\n\n    @dev Calculates Leverage\n    @param cov Coverage [using mocPrecision]\n    @return Leverage [using mocPrecision]\n  **/\n  function leverageFromCoverage(MocLibConfig storage libConfig, uint256 cov)\n  public view returns(uint256) {\n    if (cov == UINT256_MAX) {\n      return libConfig.mocPrecision;\n    }\n\n    if (cov <= libConfig.mocPrecision) {\n      return UINT256_MAX;\n    }\n\n    return cov.mul(libConfig.mocPrecision).div(cov.sub(libConfig.mocPrecision));\n  }\n\n /**\n  Leverage = nReserve / (nReserve - lB)\n\n    @dev Calculates Leverage\n    @param nReserve Total ReserveTokens amount [using reservePrecision]\n    @param lB Locked ReserveTokens amount [using reservePrecision]\n    @return Leverage [using mocPrecision]\n  **/\n  function leverage(MocLibConfig storage libConfig, uint256 nReserve,uint256 lB)\n  public view returns(uint256) {\n    if (lB == 0) {\n      return libConfig.mocPrecision;\n    }\n\n    if (nReserve <= lB) {\n      return UINT256_MAX;\n    }\n\n    return nReserve.mul(libConfig.mocPrecision).div(nReserve.sub(lB));\n  }\n\n  /**\n    @dev Price in ReserveTokens of the amount of StableTokens\n    @param amount Total ReserveTokens amount [using reservePrecision]\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @return Total value [using reservePrecision]\n  **/\n  function stableTokensResTokensValue(\n    MocLibConfig storage libConfig, uint256 amount,uint256 peg, uint256 reservePrice\n  ) public view returns(uint256) {\n    require(reservePrice > 0,\"Price should be more than zero\");\n    require(libConfig.reservePrecision > 0, \"Precision should be more than zero\");\n    //Total = amount / satoshi price\n    //Total = amount / (reservePrice / precision)\n    // [RES] * [MOC] / [MOC]\n    uint256 stableTokenResTokenTotal = amount.mul(libConfig.mocPrecision).mul(peg).div(reservePrice);\n\n    return stableTokenResTokenTotal;\n  }\n\n /**\n    @dev Price in ReserveTokens of the amount of RiskPros\n    @param riskProAmount amount of RiskPro [using mocPrecision]\n    @param riskProResTokenPrice RiskPro price in ReserveTokens [using reservePrecision]\n    @return Total value [using reservePrecision]\n  **/\n  function riskProResTokensValuet(MocLibConfig storage libConfig, uint256 riskProAmount, uint256 riskProResTokenPrice)\n    public view returns(uint256) {\n    require(libConfig.reservePrecision > 0, \"Precision should be more than zero\");\n\n    // [MOC] * [RES] / [MOC] =  [RES]\n    uint256 riskProResTokenTotal = riskProAmount.mul(riskProResTokenPrice).div(libConfig.mocPrecision);\n\n    return riskProResTokenTotal;\n  }\n\n  /**\n   MaxStableToken = ((nReserve*B)-(Cobj*B/Bcons*nStableToken*PEG))/(PEG*(Cobj*B/BCons-1))\n\n    @dev Max amount of StableTokens to issue\n    @param nReserve Total ReserveTokens amount [using reservePrecision]\n    @param cobj Target Coverage [using mocPrecision]\n    @param nStableToken StableToken amount [using mocPrecision]\n    @param peg peg value\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @param bCons ReserveTokens conservative price [using mocPrecision]\n    @return Total StableTokens amount [using mocPrecision]\n  **/\n  function maxStableToken(\n    MocLibConfig storage libConfig, uint256 nReserve,\n    uint256 cobj, uint256 nStableToken, uint256 peg, uint256 reservePrice, uint256 bCons\n  ) public view returns(uint256) {\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\n\n    // If cobj is less than 1, just return zero\n    if (cobj < libConfig.mocPrecision)\n      return 0;\n\n    // Cobj * B / BCons\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 adjCobj = cobj.mul(reservePrice).div(bCons);\n\n    return maxStableTokenAux(libConfig, nReserve, adjCobj, nStableToken, peg, reservePrice);\n  }\n\n  function maxStableTokenAux(\n    MocLibConfig storage libConfig, uint256 nReserve,\n    uint256 adjCobj, uint256 nStableToken, uint256 peg, uint256 reservePrice\n  ) internal view returns(uint256) {\n    // (nReserve*B)\n    // [RES] [MOC] [MOC] / [RES] = [MOC] [MOC]\n    uint256 firstOperand = nReserve.mul(reservePrice).mul(libConfig.mocPrecision).div(libConfig.reservePrecision);\n    // (adjCobj*nStableToken*PEG)\n    // [MOC] [MOC]\n    uint256 secOperand = adjCobj.mul(nStableToken).mul(peg);\n    // (PEG*(adjCobj-1)\n    // [MOC]\n    uint256 denom = adjCobj.sub(libConfig.mocPrecision).mul(peg);\n\n    if (firstOperand <= secOperand)\n      return 0;\n\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\n    return (firstOperand.sub(secOperand)).div(denom);\n  }\n\n  /**\n   MaxRiskPro = ((nReserve*B)-(Cobj*nStableToken*PEG))/TPusd\n\n    @dev Max amount of RiskPro to redeem\n    @param nReserve Total ReserveTokens amount [using reservePrecision]\n    @param cobj Target Coverage [using mocPrecision]\n    @param nStableToken Target Coverage [using mocPrecision]\n    @param peg peg value\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @param bCons ReserveTokens conservative price [using mocPrecision]\n    @param riskProUsdPrice riskProUsdPrice [using mocPrecision]\n    @return Total RiskPro amount [using mocPrecision]\n  **/\n  function maxRiskPro(\n    MocLibConfig storage libConfig, uint256 nReserve, uint256 cobj,\n    uint256 nStableToken, uint256 peg, uint256 reservePrice, uint256 bCons, uint256 riskProUsdPrice\n  ) public view returns(uint256) {\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\n\n    // Cobj * reservePrice / BCons\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 adjCobj = cobj.mul(reservePrice).div(bCons);\n    // (nReserve * reservePrice)\n    // [RES] * [MOC] * [MOC] / [RES] = [MOC] [MOC]\n    uint256 firstOperand = nReserve.mul(reservePrice)\n      .mul(libConfig.mocPrecision)\n      .div(libConfig.reservePrecision);\n    // (adjCobj * nStableToken * PEG)\n    // [MOC] * [MOC]\n    uint256 secOperand = adjCobj.mul(nStableToken).mul(peg);\n\n    if (firstOperand <= secOperand)\n      return 0;\n\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\n    return (firstOperand.sub(secOperand)).div(riskProUsdPrice);\n  }\n\n  /**\n    @dev Calculates the total ReserveTokens price of the amount of RiskPros\n    @param amount Amount of RiskPro [using mocPrecision]\n    @param riskProPrice RiskPro ReserveTokens Price [using reservePrecision]\n    @return RiskPro total value in ReserveTokens [using reservePrecision]\n  **/\n  function totalRiskProInResTokens(\n    MocLibConfig storage libConfig, uint256 amount, uint256 riskProPrice\n  ) public view returns(uint256) {\n    // [RES] * [MOC] / [MOC] = [RES]\n    return riskProPrice.mul(amount).div(libConfig.mocPrecision);\n  }\n\n  /**\n    @dev Calculates the equivalent in StableTokens of the resTokensAmount\n    @param resTokensAmount ReserveTokens  amount [using reservePrecision]\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @return Equivalent StableToken amount [using mocPrecision]\n  **/\n  function maxStableTokensWithResTokens(\n    MocLibConfig storage libConfig, uint256 resTokensAmount, uint256 reservePrice\n  ) public view returns(uint256) {\n    // [RES] * [MOC] / [RES] = [MOC]\n    return resTokensAmount.mul(reservePrice).div(libConfig.reservePrecision);\n  }\n\n  /**\n    @dev Calculates the equivalent in RiskPro of the resTokensAmount\n    @param resTokensAmount ReserveTokens amount [using reservePrecision]\n    @param riskProPrice RiskPro ReserveTokens price [using reservePrecision]\n    @return Equivalent RiskPro amount [using mocPrecision]\n  **/\n  function maxRiskProWithResTokens(\n    MocLibConfig storage libConfig, uint256 resTokensAmount, uint256 riskProPrice\n  ) public view returns(uint256) {\n    if (riskProPrice == 0) {\n      return 0;\n    }\n\n    // [RES] * [MOC] / [RES]\n    return resTokensAmount.mul(libConfig.mocPrecision).div(riskProPrice);\n  }\n\n  /**\n    toMove = resTokensAmount * (lev - 1)\n\n    @dev Calculates the ResToken amount to move from C0 bucket to\n    an L bucket when a RiskProx minting occurs\n    @param resTokensAmount Total ReserveTokens amount [using reservePrecision]\n    @param lev L bucket leverage [using mocPrecision]\n    @return resTokens to move [using reservePrecision]\n    **/\n  function bucketTransferAmount(\n    MocLibConfig storage libConfig, uint256 resTokensAmount, uint256 lev\n  ) public view returns(uint256) {\n    require(lev > libConfig.mocPrecision, \"Leverage should be more than 1\");\n\n    if (lev == UINT256_MAX || resTokensAmount == 0) {\n      return 0;\n    }\n\n    // (lev-1)\n    uint256 levSubOne = lev.sub(libConfig.mocPrecision);\n\n    // Intentionally avaoid SafeMath\n    // [RES] * [MOC]\n    uint256 transferAmount = resTokensAmount * levSubOne;\n    if (transferAmount / resTokensAmount != levSubOne)\n      return 0;\n\n    // [RES] * [MOC] / [MOC] = [RES]\n    return transferAmount.div(libConfig.mocPrecision);\n  }\n\n   /**\n    MaxriskProx = nStableToken/ (PEG*B*(lev-1))\n\n    @dev Max amount of ReserveTokens allowed to be used to mint riskProx\n    @param nStableToken number of StableToken [using mocPrecision]\n    @param peg peg value\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @param lev leverage [using mocPrecision]\n    @return Max riskProx ReserveTokens value [using reservePrecision]\n  **/\n  function maxRiskProxResTokenValue(\n    MocLibConfig storage libConfig, uint256 nStableToken, uint256 peg, uint256 reservePrice, uint256 lev\n  ) public view returns(uint256)  {\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\n\n    if (lev <= libConfig.mocPrecision) {\n      return 0;\n    }\n    // (lev-1)\n    // [MOC]\n    uint256 levSubOne = lev.sub(libConfig.mocPrecision);\n\n    // PEG * ResTokenPrice\n    // [MOC]\n    uint256 pegTimesPrice = peg.mul(reservePrice);\n\n    // This intentionally avoid using safeMath to handle overflow case\n    // PEG * ResTokenPrice * (lev - 1)\n    // [MOC] * [MOC]\n    uint256 dividend = pegTimesPrice * levSubOne;\n\n    if (dividend / pegTimesPrice != levSubOne)\n      return 0; // INFINIT dividend means 0\n\n    // nStableToken adjusted with precisions\n    // [MOC] [RES]\n    uint256 divider = nStableToken.mul(libConfig.reservePrecision);\n\n    // [MOC] [RES] [MOC] / [MOC] [MOC]\n    return divider.mul(libConfig.mocPrecision).div(dividend);\n  }\n\n  /**\n    @dev Rounding product adapted from DSMath but with custom precision\n    @param x Multiplicand\n    @param y Multiplier\n    @return Product\n  **/\n  function mulr(uint x, uint y, uint256 precision) internal pure returns (uint z) {\n    return x.mul(y).add(precision.div(2)).div(precision);\n  }\n\n  /**\n    @dev Potentiation by squaring adapted from DSMath but with custom precision\n    @param x Base\n    @param n Exponent\n    @return power\n  **/\n  function pow(uint256 x, uint256 n, uint256 precision) internal pure returns (uint z) {\n    uint256 x2 = x;\n    z = n % 2 != 0 ? x : precision;\n\n    for (n /= 2; n != 0; n /= 2) {\n      x2 = mulr(x2, x2, precision);\n\n      if (n % 2 != 0) {\n        z = mulr(z, x2, precision);\n      }\n    }\n  }\n}\n\n/**\n  @dev Interface with MocHelperLib\n */\ncontract MoCLibConnection {\n  using MoCHelperLib for MoCHelperLib.MocLibConfig;\n  MoCHelperLib.MocLibConfig internal mocLibConfig;\n\n  /*\n  * Precision getters\n  */\n  function getMocPrecision() public view returns(uint256) {\n    return mocLibConfig.mocPrecision;\n  }\n\n  function getReservePrecision() public view returns(uint256) {\n    return mocLibConfig.reservePrecision;\n  }\n\n  function getDayPrecision() public view returns(uint256) {\n    return mocLibConfig.dayPrecision;\n  }\n\n  function initializePrecisions() internal {\n    mocLibConfig = MoCHelperLib.MocLibConfig({\n      reservePrecision: 10 ** 18,\n      mocPrecision: 10 ** 18,\n      dayPrecision: 1\n    });\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\ncontract MoCBucketContainer is MoCBase, Governed{\n  using SafeMath for uint256;\n  using Math for uint256;\n\n  struct RiskProxBalance {\n    uint256 value;\n    uint index; // Index start in 1, zero is reserved for NULL\n  }\n\n  struct MoCBucket {\n    bytes32 name;\n    bool isBase;\n    uint256 nStable;\n    uint256 nRiskPro;\n    uint256 nReserve;\n    uint256 cobj;\n    // Should only be used in X buckets\n    mapping(address => RiskProxBalance) riskProxBalances;\n    address payable[] activeBalances;\n    uint256 activeBalancesLength;\n    // Should only be used in Base buckets (C0)\n    uint256 inrateBag;\n    bool available;\n  }\n\n  event BucketMovement(\n    bytes32 from,\n    bytes32 to,\n    uint256 reserves,\n    uint256 stableTokens\n  );\n\n  event BucketCreation(\n    bytes32 name,\n    uint256 cobj\n  );\n\n  event BucketStateUpdate(\n    bytes32 name,\n    uint256 nReserve,\n    uint256 nStable,\n    uint256 nRiskProx,\n    uint256 inrateBag\n  );\n\n  mapping(bytes32 => MoCBucket) internal mocBuckets;\n  IGovernor internal governor;\n   /**\n   GETTERS\n   */\n  function getBucketNReserve(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].nReserve;\n  }\n\n  function getBucketNRiskPro(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].nRiskPro;\n  }\n\n  function getBucketNStableToken(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].nStable;\n  }\n\n  function getBucketCobj(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].cobj;\n  }\n\n  function getInrateBag(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].inrateBag;\n  }\n\n  /**\n   * @dev Sets the objective coverage (cobj) on an specficied bucket.\n   * @param  _bucket - name of the bucket\n   * @param  _cobj - new value of cobj\n   */\n  function setBucketCobj(bytes32 _bucket, uint256 _cobj) public onlyAuthorizedChanger(){\n    //TODO: It is necessary to analyze the impact in the model it has when changing X2. This\n    mocBuckets[_bucket].cobj = _cobj;\n  }\n\n  /**\n    @dev returns true if the bucket is a base bucket\n    @param bucket Name of the bucket\n  **/\n  function isBucketBase(bytes32 bucket) public view returns(bool){\n    return mocBuckets[bucket].isBase;\n  }\n\n  /**\n    @dev returns true if the bucket have stableTokens in it\n    @param bucket Name of the bucket\n  **/\n  function isBucketEmpty(bytes32 bucket) public view returns(bool) {\n    return mocBuckets[bucket].nStable == 0;\n  }\n\n  /**\n    @dev Returns all the address that currently have riskProx position for this bucket\n    @param bucket bucket of the active address\n  */\n  function getActiveAddresses(bytes32 bucket) public view returns(address payable[] memory) {\n    return mocBuckets[bucket].activeBalances;\n  }\n\n  /**\n    @dev Returns all the address that currently have riskProx position for this bucket\n    @param bucket bucket of the active address\n  */\n  function getActiveAddressesCount(bytes32 bucket) public view returns(uint256 count) {\n    return mocBuckets[bucket].activeBalancesLength;\n  }\n\n  /**\n    @dev Add values to all variables of the bucket\n    @param bucketName Name of the bucket\n    @param reserveTokens ReserveToken amount [using reservePrecision]\n    @param stableToken StableToken amount [using mocPrecision]\n    @param riskProx RiskProx amount [using mocPrecision]\n  **/\n  function addValuesToBucket(bytes32 bucketName, uint256 reserveTokens, uint256 stableToken, uint256 riskProx)\n  public onlyWhitelisted(msg.sender) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    bucket.nReserve = bucket.nReserve.add(reserveTokens);\n    bucket.nStable = bucket.nStable.add(stableToken);\n    bucket.nRiskPro = bucket.nRiskPro.add(riskProx);\n  }\n\n  /**\n    @dev Substract values to all variables of the bucket\n    @param bucketName Name of the bucket\n    @param reserve ReserveToken amount [using reservePrecision]\n    @param stableToken StableToken amount [using mocPrecision]\n    @param riskProx RiskProx amount [using mocPrecision]\n  **/\n  function substractValuesFromBucket(bytes32 bucketName, uint256 reserve, uint256 stableToken, uint256 riskProx)\n  public onlyWhitelisted(msg.sender)  {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    bucket.nReserve = bucket.nReserve.sub(reserve);\n    bucket.nStable = bucket.nStable.sub(stableToken);\n    bucket.nRiskPro = bucket.nRiskPro.sub(riskProx);\n  }\n\n  /**\n    @dev Moves ReserveTokens from inrateBag to main ReserveTokens bucket bag\n    @param bucketName Name of the bucket to operate\n    @param amount value to move from inrateBag to main bag [using reservePrecision]\n   */\n  function deliverInrate(bytes32 bucketName, uint256 amount) public\n   onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) bucketStateUpdate(bucketName) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    uint256 toMove = Math.min(bucket.inrateBag, amount);\n\n    bucket.inrateBag = bucket.inrateBag.sub(toMove);\n    bucket.nReserve = bucket.nReserve.add(toMove);\n  }\n\n  /**\n    @dev Removes Interests rate from Inrate bag\n    @param bucketName Name of the bucket to operate\n    @param amount value to move from inrateBag to main bag [using reservePrecision]\n    @return Retrieved value\n   */\n  function recoverInrate(bytes32 bucketName, uint256 amount) public\n  onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) bucketStateUpdate(bucketName) returns(uint256) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    uint256 toRetrieve = Math.min(bucket.inrateBag, amount);\n\n    bucket.inrateBag = bucket.inrateBag.sub(toRetrieve);\n\n    return toRetrieve;\n  }\n\n  /**\n    @dev Moves ReserveTokens from origin bucket to destination bucket inrateBag\n    @param bucketName name of the bucket to from which takes\n    @param reserveAmount value to add to main bag [using reservePrecision]\n  */\n  function payInrate(bytes32 bucketName, uint256 reserveAmount) public\n  onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n    bucket.inrateBag = bucket.inrateBag.add(reserveAmount);\n  }\n\n  /**\n    @dev Move ReserveTokens and StableTokens from one bucket to another\n    @param from Name of bucket from where the ReserveTokens will be removed\n    @param to Name of bucket from where the ReserveTokens will be added\n    @param reserve ReserveTokens amount [using reservePrecision]\n    @param stableTokens StableTokens amount [using mocPrecision]\n  **/\n  function moveResTokensAndStableTokens(bytes32 from, bytes32 to, uint256 reserve, uint256 stableTokens) public\n  onlyWhitelisted(msg.sender) bucketStateUpdate(from) bucketStateUpdate(to) {\n    MoCBucket storage bucketFrom = mocBuckets[from];\n    MoCBucket storage bucketTo = mocBuckets[to];\n\n    bucketFrom.nReserve = bucketFrom.nReserve.sub(reserve);\n    bucketTo.nReserve = bucketTo.nReserve.add(reserve);\n\n    bucketFrom.nStable = bucketFrom.nStable.sub(stableTokens);\n    bucketTo.nStable = bucketTo.nStable.add(stableTokens);\n\n    emit BucketMovement(from, to, reserve, stableTokens);\n  }\n\n  /**\n    @dev Clears completely the origin bucket, removing all StableTokens, ReserveTokens and riskProxs\n    @param toLiquidate Bucket to be cleared out\n    @param destination Bucket that will receive the StableTokens and ReserveTokens\n   */\n  function liquidateBucket(bytes32 toLiquidate, bytes32 destination) public onlyWhitelisted(msg.sender) {\n    require(!isBucketBase(toLiquidate), \"Cannot liquidate a base bucket\");\n\n    clearBucketBalances(toLiquidate);\n    emptyBucket(toLiquidate, destination);\n  }\n\n  /**\n    @dev Clears StableTokens and ReserveTokens from bucket origin and sends them to destination bucket\n    @param origin Bucket to clear out\n    @param destination Destination bucket\n  **/\n  function emptyBucket(bytes32 origin, bytes32 destination) public onlyWhitelisted(msg.sender) {\n    moveResTokensAndStableTokens(origin, destination, mocBuckets[origin].nReserve, mocBuckets[origin].nStable);\n  }\n\n  /**\n   * @dev checks if a bucket exists\n   * @param bucket name of the bucket\n   */\n  function isAvailableBucket(bytes32 bucket) public view returns(bool) {\n    return mocBuckets[bucket].available;\n  }\n\n  /**\n    @dev Put all bucket RiskProx balances in zero\n    @param bucketName Bucket to clear out\n   */\n  function clearBucketBalances(bytes32 bucketName) public onlyWhitelisted(msg.sender) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n    bucket.nRiskPro = 0;\n    bucket.activeBalancesLength = 0;\n  }\n\n  /**\n    @dev Creates bucket\n    @param name Name of the bucket\n    @param cobj Target Coverage of the bucket\n  **/\n  function createBucket(bytes32 name, uint256 cobj, bool isBase) internal {\n    mocBuckets[name].name = name;\n    mocBuckets[name].nStable = 0;\n    mocBuckets[name].nRiskPro = 0;\n    mocBuckets[name].nReserve = 0;\n    mocBuckets[name].cobj = cobj;\n    mocBuckets[name].isBase = isBase;\n    mocBuckets[name].available = true;\n    emit BucketCreation(name, cobj);\n  }\n\n  modifier onlyBaseBucket(bytes32 bucket) {\n    require(isBucketBase(bucket), \"Bucket should be a base type bucket\");\n    _;\n  }\n\n  modifier bucketStateUpdate(bytes32 bucket) {\n    _;\n    emit BucketStateUpdate(\n      bucket,\n      mocBuckets[bucket].nReserve,\n      mocBuckets[bucket].nStable,\n      mocBuckets[bucket].nRiskPro,\n      mocBuckets[bucket].inrateBag\n      );\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\ncontract MoCRiskProxManager is MoCBucketContainer {\n  using SafeMath for uint256;\n  uint256 constant MIN_ALLOWED_BALANCE = 0;\n\n  function initialize(\n    address connectorAddress,\n    address _governor,\n    uint256 _c0Cobj,\n    uint256 _x2Cobj\n  ) public initializer {\n    initializeBase(connectorAddress);\n    initializeValues(_governor);\n    createBucket(BUCKET_C0, _c0Cobj, true);\n    createBucket(BUCKET_X2, _x2Cobj, false);\n  }\n\n  /**\n    @dev returns user balance\n    @param bucket RiskProx corresponding bucket to get balance from\n    @param userAddress user address to get balance from\n    @return total balance for the userAddress\n  */\n  function riskProxBalanceOf(bytes32 bucket, address userAddress) public view returns(uint256) {\n    RiskProxBalance memory userBalance = mocBuckets[bucket].riskProxBalances[userAddress];\n    if (!hasValidBalance(bucket, userAddress, userBalance.index)) return 0;\n    return userBalance.value;\n  }\n\n  /**\n    @dev verifies that this user has assigned balance for the given bucket\n    @param bucket corresponding Leveraged bucket to get balance from\n    @param userAddress user address to verify balance for\n    @param index index, starting from 1, where the address of the user is being kept\n    @return true if the user has assigned balance\n  */\n  function hasValidBalance(bytes32 bucket, address userAddress, uint index) public view returns(bool) {\n    return (index != 0) &&\n      (index <= getActiveAddressesCount(bucket)) &&\n      (mocBuckets[bucket].activeBalances[index - 1] == userAddress);\n  }\n\n  /**\n    @dev  Assigns the amount of BProx\n    @param bucket bucket from which the BProx will be removed\n    @param account user address to redeem for\n    @param riskProxAmount riskProx amount to redeem [using mocPresicion]\n    @param totalCost btc value of bproxAmount [using reservePrecision]\n  */\n  function assignRiskProx(bytes32 bucket, address payable account, uint256 riskProxAmount, uint256 totalCost)\n  public onlyWhitelisted(msg.sender) {\n    uint256 currentBalance = riskProxBalanceOf(bucket, account);\n\n    setRiskProxBalanceOf(bucket, account, currentBalance.add(riskProxAmount));\n    addValuesToBucket(bucket, totalCost, 0, riskProxAmount);\n  }\n\n  /**\n    @dev  Removes the amount of RiskProx and substract ReserveTokens from bucket\n    @param bucket bucket from which the RiskProx will be removed\n    @param userAddress user address to redeem for\n    @param riskProxAmount riskProx amount to redeem [using mocPresicion]\n    @param totalCost reserveToken value of riskProxAmount [using reservePrecision]\n  */\n  function removeRiskProx(bytes32 bucket, address payable userAddress, uint256 riskProxAmount, uint256 totalCost)\n  public onlyWhitelisted(msg.sender) {\n    uint256 currentBalance = riskProxBalanceOf(bucket, userAddress);\n\n    setRiskProxBalanceOf(bucket, userAddress, currentBalance.sub(riskProxAmount));\n    substractValuesFromBucket(bucket, totalCost, 0, riskProxAmount);\n  }\n\n  /**\n    @dev Sets the amount of RiskProx\n    @param bucket bucket from which the RiskProx will be setted\n    @param userAddress user address to redeem for\n    @param value riskProx amount to redeem [using mocPresicion]\n  */\n  function setRiskProxBalanceOf(bytes32 bucket, address payable userAddress, uint256 value) public onlyWhitelisted(msg.sender) {\n    mocBuckets[bucket].riskProxBalances[userAddress].value = value;\n\n    uint256 index = mocBuckets[bucket].riskProxBalances[userAddress].index;\n    if (!hasValidBalance(bucket, userAddress, index))\n      index = 0;\n\n    bool hasBalance = value > MIN_ALLOWED_BALANCE;\n    // The address is not in the array\n    if (index == 0) {\n      if (hasBalance) {\n        if (mocBuckets[bucket].activeBalances.length == mocBuckets[bucket].activeBalancesLength) {\n          mocBuckets[bucket].activeBalances.length += 1;\n        }\n        uint256 currentIndex = mocBuckets[bucket].activeBalancesLength++;\n        mocBuckets[bucket].activeBalances[currentIndex] = userAddress;\n        mocBuckets[bucket].riskProxBalances[userAddress].index = mocBuckets[bucket].activeBalancesLength;\n      }\n    } else {\n      if (!hasBalance) {\n        // We need to delete this address from the tracker\n        uint256 lastActiveIndex = mocBuckets[bucket].activeBalancesLength;\n        address payable keyToMove = mocBuckets[bucket].activeBalances[lastActiveIndex - 1];\n        mocBuckets[bucket].activeBalances[index - 1] = keyToMove;\n        // Alternative index and array decreases lenght to prevent gas limit\n        mocBuckets[bucket].activeBalancesLength--;\n        // Update moved key index\n        mocBuckets[bucket].riskProxBalances[keyToMove].index = index;\n        // Disable empty account index (0 == NULL)\n        mocBuckets[bucket].riskProxBalances[userAddress].index = 0;\n      }\n    }\n  }\n\n  /**\n   * @dev intializes values of the contract\n   */\n  function initializeValues(address _governor) internal {\n    governor = IGovernor(_governor);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\ncontract MoCConverter {\n\n\n  function riskProxToResToken(uint256 riskProxAmount, bytes32 bucket) public view returns(uint256);\n\n}\n\ncontract PauserRole {\n    using Roles for Roles.Role;\n\n    event PauserAdded(address indexed account);\n    event PauserRemoved(address indexed account);\n\n    Roles.Role private _pausers;\n\n    constructor () internal {\n        _addPauser(msg.sender);\n    }\n\n    modifier onlyPauser() {\n        require(isPauser(msg.sender), \"PauserRole: caller does not have the Pauser role\");\n        _;\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return _pausers.has(account);\n    }\n\n    function addPauser(address account) public onlyPauser {\n        _addPauser(account);\n    }\n\n    function renouncePauser() public {\n        _removePauser(msg.sender);\n    }\n\n    function _addPauser(address account) internal {\n        _pausers.add(account);\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) internal {\n        _pausers.remove(account);\n        emit PauserRemoved(account);\n    }\n}\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract Pausable is PauserRole {\n    /**\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\n     * to the deployer.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Called by a pauser to pause, triggers stopped state.\n     */\n    function pause() public onlyPauser whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @dev Called by a pauser to unpause, returns to normal state.\n     */\n    function unpause() public onlyPauser whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n}\n\n /**\n * @title Pausable token\n * @dev ERC20 modified with pausable transfers.\n */\ncontract ERC20Pausable is ERC20, Pausable {\n    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {\n        return super.transfer(to, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {\n        return super.transferFrom(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {\n        return super.approve(spender, value);\n    }\n\n    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool) {\n        return super.increaseAllowance(spender, addedValue);\n    }\n\n    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool) {\n        return super.decreaseAllowance(spender, subtractedValue);\n    }\n}\n\ncontract RiskProToken is ERC20Detailed, ERC20Pausable, OwnerBurnableToken {\n\n  string private _name = \"Risk Pro\";\n  string private _symbol = \"RPRO\";\n  uint8 private _decimals = 18;\n\n  constructor() Ownable() ERC20Detailed(_name, _symbol, _decimals) public {\n  }\n\n  //Fallback\n  function() external {\n  }\n}\n\ncontract MoCSettlement {\n  /**\n    @dev Returns the next block from which settlement is possible\n   */\n  function nextSettlementBlock() public view returns(uint256);\n}\n\ncontract MoCState is MoCLibConnection, MoCBase, MoCEMACalculator {\n  using Math for uint256;\n  using SafeMath for uint256;\n\n  // This is the current state.\n  States public state;\n\n  event StateTransition(States newState);\n  event PriceProviderUpdated(address oldAddress, address newAddress);\n  // Contracts\n  PriceProvider internal priceProvider;\n  MoCSettlement internal mocSettlement;\n  MoCConverter internal mocConverter;\n  StableToken internal stableToken;\n  RiskProToken internal riskProToken;\n  MoCRiskProxManager internal riskProxManager;\n\n  // One Day based on 15 seconds blocks\n  uint256 public dayBlockSpan;\n  // Relation between StableToken and dollar\n  uint256 public peg;\n  // RiskPro max discount rate\n  // Reflects the discount spot rate at Liquidation level\n  uint256 public riskProMaxDiscountRate;\n  // Liquidation limit\n  // [using mocPrecision]\n  uint256 public liq;\n  // RiskPro with discount limit\n  // [using mocPrecision]\n  uint256 public utpdu;\n  // Complete amount reserves in the system\n  uint256 public reserves;\n  // Price to use at stableToken redemption at\n  // liquidation event\n  uint256 public liquidationPrice;\n\n  function initialize(\n    address connectorAddress,\n    address _governor,\n    address _priceProvider,\n    uint256 _liq,\n    uint256 _utpdu,\n    uint256 _maxDiscRate,\n    uint256 _dayBlockSpan,\n    uint256 _ema,\n    uint256 _smoothFactor,\n    uint256 _emaBlockSpan\n  ) public initializer {\n    initializePrecisions();\n    initializeBase(connectorAddress);\n    initializeContracts();\n    initializeValues(_governor, _priceProvider,_liq, _utpdu, _maxDiscRate, _dayBlockSpan);\n    initializeMovingAverage(_ema, _smoothFactor, _emaBlockSpan);\n  }\n\n  /**\n  * @param rate Discount rate at liquidation level [using mocPrecision]\n  **/\n  function setMaxDiscountRate(uint256 rate) public onlyAuthorizedChanger() {\n    require(rate < mocLibConfig.mocPrecision, \"rate is lower than mocPrecision\");\n\n    riskProMaxDiscountRate = rate;\n  }\n\n    /**\n   * @dev return the value of the RiskPro max discount rate configuration param\n   * @return riskProMaxDiscountRate RiskPro max discount rate\n   */\n  function getMaxDiscountRate() public view returns(uint256) {\n    return riskProMaxDiscountRate;\n  }\n\n  /**\n  * @dev Defines how many blocks there are in a day\n  * @param blockSpan blocks there are in a day\n  **/\n  function setDayBlockSpan(uint256 blockSpan) public onlyAuthorizedChanger() {\n    dayBlockSpan = blockSpan;\n  }\n\n  /**\n  * @dev Sets a new PriceProvider contract\n  * @param priceProviderAddress blocks there are in a day\n  **/\n  function setPriceProvider(address priceProviderAddress) public onlyAuthorizedChanger() {\n    address oldPriceProviderAddress = address(priceProvider);\n    priceProvider = PriceProvider(priceProviderAddress);\n    emit PriceProviderUpdated(oldPriceProviderAddress, address(priceProvider));\n  }\n\n  /**\n  * @dev Gets the PriceProviderAddress\n  * @return priceProvider blocks there are in a day\n  **/\n  function getPriceProvider() public view returns(address) {\n    return address(priceProvider);\n  }\n  /**\n   * @dev Gets how many blocks there are in a day\n   * @return blocks there are in a day\n   */\n  function getDayBlockSpan() public view returns(uint256) {\n    return dayBlockSpan;\n  }\n  /******STATE MACHINE*********/\n\n  enum States {\n    // State 0\n    Liquidated,\n    // State 1\n    RiskProDiscount,\n    // State 2\n    BelowCobj,\n    // State 3\n    AboveCobj\n  }\n\n/**\n  * @dev Subtract the reserve amount passed by parameter to the reserves total\n  * @param amount Amount that will be subtract to reserves\n  */\n  function substractFromReserves(uint256 amount) public onlyWhitelisted(msg.sender) {\n    reserves = reserves.sub(amount);\n  }\n\n  /**\n  * @dev Add the reserve amount passed by parameter to the reserves total\n  * @param amount Amount that will be added to reserves\n  */\n  function addToReserves(uint256 amount) public onlyWhitelisted(msg.sender) {\n    reserves = reserves.add(amount);\n  }\n\n  /**\n    @dev All RiskPros in circulation\n   */\n  function riskProTotalSupply() public view returns(uint256) {\n    return riskProToken.totalSupply();\n  }\n\n  /**\n    @dev All stableTokens in circulation\n   */\n  function stableTokenTotalSupply() public view returns(uint256) {\n    return stableToken.totalSupply();\n  }\n\n  /**\n    @dev Target coverage for complete system\n   */\n  function cobj() public view returns(uint256) {\n    return riskProxManager.getBucketCobj(BUCKET_C0);\n  }\n\n  /**\n    * @dev Amount of ReserveTokens in the system excluding\n    * RiskProx values and interests holdings\n    */\n  function collateralReserves() public view returns(uint256) {\n    uint256 resTokensInRiskProx = mocConverter.riskProxToResToken(riskProxManager.getBucketNRiskPro(BUCKET_X2),BUCKET_X2);\n    uint256 resTokensInBag = riskProxManager.getInrateBag(BUCKET_C0);\n\n    return reserves.sub(resTokensInRiskProx).sub(resTokensInBag);\n  }\n\n  /** @dev GLOBAL Coverage\n    * @return coverage [using mocPrecision].\n    */\n  function globalCoverage() public view returns(uint256) {\n    uint256 lB = globalLockedReserveTokens();\n\n    return mocLibConfig.coverage(collateralReserves(), lB);\n  }\n\n  /**\n  * @dev BUCKET lockedReserveTokens\n  * @param bucket Name of the bucket used\n  * @return lockedReserveTokens amount [using reservePrecision].\n  */\n  function lockedReserveTokens(bytes32 bucket) public view returns(uint256) {\n    uint256 nStableToken = riskProxManager.getBucketNStableToken(bucket);\n\n    return mocLibConfig.lockedReserveTokens(getReserveTokenPrice(), nStableToken, peg);\n  }\n\n  /**\n  * @dev Gets ReserveTokens in RiskPro within specified bucket\n  * @param bucket Name of the bucket used\n  * @return ReserveToken amount of RiskPro in Bucket [using reservePrecision].\n  */\n  function getResTokensInRiskPro(bytes32 bucket) public view returns(uint256) {\n    uint256 nReserve = riskProxManager.getBucketNReserve(bucket);\n    uint256 lB = lockedReserveTokens(bucket);\n\n    if ( lB >= nReserve ){\n      return 0;\n    }\n\n    return nReserve.sub(lB);\n  }\n\n  /**\n  * @dev Gets the ReserveTokens in the contract that not corresponds\n    to StableToken collateral\n  * @return ReserveTokens remainder [using reservePrecision].\n  */\n  function getReservesRemainder() public view returns(uint256) {\n    uint256 lB = globalLockedReserveTokens();\n\n    if ( lB >= reserves ){\n      return 0;\n    }\n\n    return reserves.sub(lB);\n  }\n\n  /**\n  * @dev BUCKET Coverage\n  * @param bucket Name of the bucket used\n  * @return coverage [using mocPrecision]\n  */\n  function coverage(bytes32 bucket) public view returns(uint256) {\n    if (!riskProxManager.isBucketBase(bucket) && riskProxManager.isBucketEmpty(bucket)) {\n      return riskProxManager.getBucketCobj(bucket);\n    }\n\n    uint256 nReserve = riskProxManager.getBucketNReserve(bucket);\n    uint256 lB = lockedReserveTokens(bucket);\n\n    return mocLibConfig.coverage(nReserve, lB);\n  }\n\n    /**\n  * @dev Abundance ratio, receives tha amount of stableToken to use the value of stableToken0 and StableToken total supply\n  * @return abundance ratio [using mocPrecision]\n  */\n  function abundanceRatio(uint256 stableToken0) public view returns(uint256) {\n    return mocLibConfig.abundanceRatio(stableToken0, stableTokenTotalSupply());\n  }\n\n  /**\n  * @dev Relation between stableTokens in bucket 0 and StableToken total supply\n  * @return abundance ratio [using mocPrecision]\n  */\n  function currentAbundanceRatio() public view returns(uint256) {\n    return abundanceRatio(getBucketNStableToken(BUCKET_C0));\n  }\n\n  /**\n  * @dev BUCKET Leverage\n  * @param bucket Name of the bucket used\n  * @return leverage [using mocPrecision]\n  */\n  function leverage(bytes32 bucket) public view returns(uint256) {\n    uint256 cov = coverage(bucket);\n\n    return mocLibConfig.leverageFromCoverage(cov);\n  }\n\n  /**\n  * @dev GLOBAL maxStableToken\n  * @return maxStableToken to issue [using mocPrecision]\n  */\n  function globalMaxStableToken() public view returns(uint256) {\n    return mocLibConfig.maxStableToken(collateralReserves(), cobj(), stableTokenTotalSupply(), peg, getReserveTokenPrice(), getBcons());\n  }\n\n  /**\n  * @return amount of stableTokens in bucket 0, that can be redeemed outside of settlement [using mocPrecision]\n  */\n  function freeStableToken() public view returns(uint256) {\n    return riskProxManager.getBucketNStableToken(BUCKET_C0);\n  }\n\n  /**\n  * @dev BUCKET maxStableToken\n  * @return maxStableToken to issue [using mocPrecision]\n  */\n  function maxStableToken(bytes32 bucket) public view returns(uint256) {\n    uint256 nReserve = riskProxManager.getBucketNReserve(bucket);\n    uint256 nStableToken = riskProxManager.getBucketNStableToken(bucket);\n    uint256 bktCobj = riskProxManager.getBucketCobj(bucket);\n\n    return mocLibConfig.maxStableToken(nReserve, bktCobj, nStableToken, peg, getReserveTokenPrice(), getBcons());\n  }\n\n  /**\n  * @dev GLOBAL maxRiskPro\n  * @return maxRiskPro for redeem [using mocPrecision].\n  */\n  function globalMaxRiskPro() public view returns(uint256) {\n    uint256 riskProPrice = riskProUsdPrice();\n\n    return mocLibConfig.maxRiskPro(\n      collateralReserves(), cobj(), stableTokenTotalSupply(), peg, getReserveTokenPrice(), getBcons(), riskProPrice\n    );\n  }\n\n  /**\n  * @dev ABSOLUTE maxStableToken\n  * @return maxStableToken to issue [using mocPrecision]\n  */\n  function absoluteMaxStableToken() public view returns(uint256) {\n    return Math.min(globalMaxStableToken(), maxStableToken(BUCKET_C0));\n  }\n\n  /** @dev BUCKET maxRiskPro to redeem / mint\n      @param bucket Name of the bucket used\n    * @return maxRiskPro for redeem [using mocPrecision].\n    */\n  function maxRiskPro(bytes32 bucket) public view returns(uint256) {\n    uint256 nReserve = riskProxManager.getBucketNReserve(bucket);\n    uint256 nStableToken = riskProxManager.getBucketNStableToken(bucket);\n    uint256 riskProPrice = riskProUsdPrice();\n    uint256 bktCobj = riskProxManager.getBucketCobj(bucket);\n\n    return mocLibConfig.maxRiskPro(\n      nReserve, bktCobj, nStableToken, peg, getReserveTokenPrice(), getBcons(), riskProPrice\n    );\n  }\n\n /**\n  * @dev GLOBAL max riskProx to mint\n  * @param bucket Name of the bucket used\n  * @return maxRiskProx [using mocPrecision]\n  */\n  function maxRiskProx(bytes32 bucket) public view returns(uint256) {\n    uint256 maxResTokens = maxRiskProxResTokenValue(bucket);\n\n    return mocLibConfig.maxRiskProWithResTokens(maxResTokens, bucketRiskProTecPrice(bucket));\n  }\n\n  /**\n  * @dev GLOBAL max riskProx to mint\n  * @param bucket Name of the bucket used\n  * @return maxRiskProx ReserveTokens value to mint [using reservePrecision]\n  */\n  function maxRiskProxResTokenValue(bytes32 bucket) public view returns(uint256) {\n    uint256 nStableToken0 = riskProxManager.getBucketNStableToken(BUCKET_C0);\n    uint256 bucketLev = leverage(bucket);\n\n    return mocLibConfig.maxRiskProxResTokenValue(nStableToken0, peg, getReserveTokenPrice(), bucketLev);\n  }\n\n  /** @dev ABSOLUTE maxRiskPro\n  * @return maxStableToken to issue [using mocPrecision].\n  */\n  function absoluteMaxRiskPro() public view returns(uint256) {\n    return Math.min(globalMaxRiskPro(), maxRiskPro(BUCKET_C0));\n  }\n\n  /**\n  * @dev DISCOUNT maxRiskPro\n  * @return maxRiskPro for mint with discount [using mocPrecision]\n  */\n  function maxRiskProWithDiscount() public view returns(uint256) {\n    uint256 nStableToken = stableTokenTotalSupply();\n    uint256 riskProSpotDiscount = riskProSpotDiscountRate();\n    uint256 riskProPrice = riskProUsdPrice();\n    uint256 reservePrice = getReserveTokenPrice();\n\n    return mocLibConfig.maxRiskProWithDiscount(collateralReserves(), nStableToken, utpdu, peg, reservePrice, riskProPrice,\n      riskProSpotDiscount);\n  }\n\n  /**\n  * @dev GLOBAL lockedReserveTokens\n  * @return lockedReserveTokens amount [using reservePrecision].\n  */\n  function globalLockedReserveTokens() public view returns(uint256) {\n    return mocLibConfig.lockedReserveTokens(getReserveTokenPrice(), stableTokenTotalSupply(), peg);\n  }\n\n  /**\n  * @dev ReserveTokens price of RiskPro\n  * @return the RiskPro Tec Price [using reservePrecision].\n  */\n  function riskProTecPrice() public view returns(uint256) {\n    return bucketRiskProTecPrice(BUCKET_C0);\n  }\n\n  /**\n  * @dev BUCKET ReserveTokens price of RiskPro\n  * @param bucket Name of the bucket used\n  * @return the RiskPro Tec Price [using reservePrecision].\n  */\n  function bucketRiskProTecPrice(bytes32 bucket) public view returns(uint256) {\n    uint256 nRiskPro = riskProxManager.getBucketNRiskPro(bucket);\n    uint256 lb = lockedReserveTokens(bucket);\n    uint256 nReserve = riskProxManager.getBucketNReserve(bucket);\n\n    return mocLibConfig.riskProTecPrice(nReserve, lb, nRiskPro);\n  }\n\n  /**\n  * @dev ReserveTokens price of RiskPro with spot discount applied\n  * @return the RiskPro Tec Price [using reservePrecision].\n  */\n  function riskProDiscountPrice() public view returns(uint256) {\n    uint256 riskProTecprice = riskProTecPrice();\n    uint256 discountRate = riskProSpotDiscountRate();\n\n    return mocLibConfig.applyDiscountRate(riskProTecprice, discountRate);\n  }\n\n  /**\n  * @dev RiskPro USD PRICE\n  * @return the RiskPro USD Price [using mocPrecision]\n  */\n  function riskProUsdPrice() public view returns(uint256) {\n    uint256 riskProResTokenPrice = riskProTecPrice();\n    uint256 reservePrice = getReserveTokenPrice();\n\n    return reservePrice.mul(riskProResTokenPrice).div(mocLibConfig.reservePrecision);\n  }\n\n /**\n  * @dev GLOBAL max riskProx to mint\n  * @param bucket Name of the bucket used\n  * @return max RiskPro allowed to be spent to mint RiskProx [using reservePrecision]\n  **/\n  function maxRiskProxRiskProValue(bytes32 bucket) public view returns(uint256) {\n    uint256 resTokensValue = maxRiskProxResTokenValue(bucket);\n\n    return mocLibConfig.maxRiskProWithResTokens(resTokensValue, riskProTecPrice());\n  }\n\n  /**\n  * @dev BUCKET RiskProx price in RiskPro\n  * @param bucket Name of the bucket used\n  * @return RiskPro RiskPro Price [[using mocPrecision]Precision].\n  */\n  function riskProxRiskProPrice(bytes32 bucket) public view returns(uint256) {\n    // Otherwise, it reverts.\n    if (state == States.Liquidated) {\n      return 0;\n    }\n\n    uint256 riskProxResTokenPrice = bucketRiskProTecPrice(bucket);\n    uint256 riskProResTokenPrice = riskProTecPrice();\n\n    return mocLibConfig.riskProxRiskProPrice(riskProxResTokenPrice, riskProResTokenPrice);\n  }\n\n  /**\n  * @dev GLOBAL ReserveTokens Discount rate to apply to RiskProPrice.\n  * @return RiskPro discount rate [using DISCOUNT_PRECISION].\n   */\n  function riskProSpotDiscountRate() public view returns(uint256) {\n    uint256 cov = globalCoverage();\n\n    return mocLibConfig.riskProSpotDiscountRate(riskProMaxDiscountRate, liq, utpdu, cov);\n  }\n\n  /**\n    @dev Calculates the number of days to next settlement based dayBlockSpan\n   */\n  function daysToSettlement() public view returns(uint256) {\n    return blocksToSettlement().mul(mocLibConfig.dayPrecision).div(dayBlockSpan);\n  }\n\n  /**\n    @dev Number of blocks to settlement\n   */\n  function blocksToSettlement() public view returns(uint256) {\n    if (mocSettlement.nextSettlementBlock() <= block.number) {\n      return 0;\n    }\n\n    return mocSettlement.nextSettlementBlock().sub(block.number);\n  }\n\n  /**\n   * @dev Verifies if forced liquidation is reached checking if globalCoverage <= liquidation (currently 1.04)\n   * @return true if liquidation state is reached, false otherwise\n   */\n  function isLiquidationReached() public view returns(bool) {\n    uint256 cov = globalCoverage();\n    if (state != States.Liquidated && cov <= liq)\n      return true;\n    return false;\n  }\n\n  /**\n    @dev Returns the price to use for stableToken redeem in a liquidation event\n   */\n  function getLiquidationPrice() public view returns(uint256) {\n    return liquidationPrice;\n  }\n\n  function getBucketNReserve(bytes32 bucket) public view returns(uint256) {\n    return riskProxManager.getBucketNReserve(bucket);\n  }\n\n  function getBucketNRiskPro(bytes32 bucket) public view returns(uint256) {\n    return riskProxManager.getBucketNRiskPro(bucket);\n  }\n\n  function getBucketNStableToken(bytes32 bucket) public view returns(uint256) {\n    return riskProxManager.getBucketNStableToken(bucket);\n  }\n\n  function getBucketCobj(bytes32 bucket) public view returns(uint256) {\n    return riskProxManager.getBucketCobj(bucket);\n  }\n\n  function getInrateBag(bytes32 bucket) public view returns(uint256) {\n    return riskProxManager.getInrateBag(bucket);\n  }\n\n  /**********************\n    ReserveTokens PRICE PROVIDER\n   *********************/\n\n  function getBcons() public view returns(uint256) {\n    return Math.min(getReserveTokenPrice(), getExponentalMovingAverage());\n  }\n\n  function getReserveTokenPrice() public view returns(uint256) {\n    (bytes32 price, bool has) = priceProvider.peek();\n    require(has, \"Oracle have no Price\");\n\n    return uint256(price);\n  }\n\n\n  function calculateReserveTokenMovingAverage() public {\n    setExponentalMovingAverage(getReserveTokenPrice());\n  }\n\n\n\n  /**\n   * @dev return the value of the liq threshold configuration param\n   * @return liq threshold, currently 1.04\n   */\n  function getLiq() public view returns(uint256) {\n    return liq;\n  }\n\n  /**\n   * @dev sets the value of the liq threshold configuration param\n   * @param _liq liquidation threshold\n   */\n  function setLiq(uint _liq) public onlyAuthorizedChanger(){\n    liq = _liq;\n  }\n\n  /**\n   * @dev return the value of the utpdu threshold configuration param\n   * @return utpdu Universal TPro discount sales coverage threshold\n   */\n  function getUtpdu() public view returns(uint256) {\n    return utpdu;\n  }\n\n  /**\n   * @dev sets the value of the utpdu threshold configuration param\n   * @param _utpdu Universal TPro discount sales coverage threshold\n   */\n  function setUtpdu(uint _utpdu) public onlyAuthorizedChanger(){\n    utpdu = _utpdu;\n  }\n\n  /**\n   * @dev returns the relation between StableToken and dollar. By default it is 1.\n   * @return peg relation between StableToken and dollar\n   */\n  function getPeg() public view returns(uint256) {\n    return peg;\n  }\n\n  /**\n   * @dev sets the relation between StableToken and dollar. By default it is 1.\n   * @param _peg relation between StableToken and dollar\n   */\n  function setPeg(uint _peg) public onlyAuthorizedChanger(){\n    peg = _peg;\n  }\n\n  function nextState() public {\n    // There is no coming back from Liquidation\n    if (state == States.Liquidated)\n      return;\n\n    States prevState = state;\n    calculateReserveTokenMovingAverage();\n    uint256 cov = globalCoverage();\n    if (cov <= liq) {\n      setLiquidationPrice();\n      state = States.Liquidated;\n    } else if (cov > liq && cov <= utpdu) {\n      state = States.RiskProDiscount;\n    } else if (cov > utpdu && cov <= cobj()) {\n      state = States.BelowCobj;\n    } else {\n      state = States.AboveCobj;\n    }\n\n    if (prevState != state)\n      emit StateTransition(state);\n  }\n\n\n  /**\n    @dev Calculates price at liquidation event as the relation between\n    the stableToken total supply and the amount of ReserveTokens available to distribute\n   */\n  function setLiquidationPrice() internal {\n    // When coverage is below 1, the amount to\n    // distribute is all the ReserveTokens in the contract\n    uint256 resTokenscAvailable = Math.min(globalLockedReserveTokens(), reserves);\n\n    liquidationPrice = mocLibConfig.liquidationPrice(resTokenscAvailable, stableTokenTotalSupply());\n  }\n\n  function initializeValues(\n    address _governor,\n    address _priceProvider,\n    uint256 _liq,\n    uint256 _utpdu,\n    uint256 _maxDiscRate,\n    uint256 _dayBlockSpan) internal {\n    liq = _liq;\n    utpdu = _utpdu;\n    riskProMaxDiscountRate = _maxDiscRate;\n    dayBlockSpan = _dayBlockSpan;\n    governor = IGovernor(_governor);\n    priceProvider = PriceProvider(_priceProvider);\n    // Default values\n    state = States.AboveCobj;\n    peg = 1;\n  }\n\n  function initializeContracts() internal  {\n    mocSettlement = MoCSettlement(connector.mocSettlement());\n    stableToken = StableToken(connector.stableToken());\n    riskProToken = RiskProToken(connector.riskProToken());\n    riskProxManager = MoCRiskProxManager(connector.riskProxManager());\n    mocConverter = MoCConverter(connector.mocConverter());\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\ncontract MoCExchange {\n    function redeemAllStableToken(address origin, address payable destination) public returns(uint256);\n}\n\ncontract MoCBurnoutEvents {\n  event BurnoutAddressSet(address indexed account, address burnoutAddress);\n  event BurnoutExecuted(uint256 addressCount);\n  event BurnoutAddressProcessed(address indexed account, address burnoutAddress, uint256 amount);\n}\n\n/**\n * @title Burnout Queue for liquidation event\n * @dev Track all Burnout addresses that will be used in liquidation event. When liquidation happens\n * all StableTokens of the holders in the queue will be sent to the corresponding burnout address.\n */\ncontract MoCBurnout is MoCBase, MoCBurnoutEvents, PartialExecution {\n  using SafeMath for uint256;\n\n  // Contracts\n  StableToken internal stableToken;\n  MoCExchange internal mocExchange;\n  MoCState internal mocState;\n\n  bytes32 internal constant BURNOUT_TASK = keccak256(\"Burnout\");\n\n  // Burnout addresses\n  mapping(address => address payable) burnoutBook;\n  // Used to iterate in liquidation event\n  address[] private burnoutQueue;\n  uint256 private numElements;\n\n  function initialize(\n    address connectorAddress\n    ) public initializer {\n    initializeBase(connectorAddress);\n    initializeContracts();\n    initializeTasks();\n  }\n\n  function isBurnoutRunning() public view returns(bool) {\n    return isTaskRunning(BURNOUT_TASK);\n  }\n\n  /**\n    @dev Return current burnout queue size\n   */\n  function burnoutQueueSize() public view returns(uint256) {\n    return numElements;\n  }\n\n  /**\n    @dev Returns the burnout address for _who address\n    @param _who Address to find burnout address\n    @return Burnout address\n   */\n  function getBurnoutAddress(address _who) public view returns(address) {\n    return burnoutBook[_who];\n  }\n\n  /**\n    @dev push a new burnout address to the queue for _who\n    @param _who address for which set the burnout address\n    @param _burnout address to send stableTokens in liquidation event\n  */\n  function pushBurnoutAddress(address _who, address payable _burnout) public onlyWhitelisted(msg.sender) {\n    require(_burnout != address(0x0), \"Burnout address can't be 0x0\");\n\n    if (burnoutBook[_who] == address(0x0)) {\n      pushAddressToQueue(_who);\n    }\n\n    burnoutBook[_who] = _burnout;\n    emit BurnoutAddressSet(_who, _burnout);\n  }\n\n  /**\n    @dev Iterate over the burnout address book and redeem stableTokens\n  **/\n  function executeBurnout(uint256 steps) public onlyWhitelisted(msg.sender) {\n    executeTask(BURNOUT_TASK, steps);\n  }\n\n  function burnoutStep(uint256 index) internal {\n    address account = burnoutQueue[index];\n    address payable burnout = burnoutBook[account];\n    uint256 reserveTotal = mocExchange.redeemAllStableToken(account, burnout);\n\n    emit BurnoutAddressProcessed(account, burnout, reserveTotal);\n  }\n\n  function finishBurnout() internal {\n    emit BurnoutExecuted(numElements);\n    clearBook();\n  }\n\n  function burnoutStepCount() internal view returns(uint256) {\n    return numElements;\n  }\n\n  function pushAddressToQueue(address _who) internal {\n    if (numElements == burnoutQueue.length) {\n      burnoutQueue.length += 1;\n    }\n\n    burnoutQueue[numElements++] = _who;\n  }\n\n  /**\n    @dev empty the queue\n   */\n  function clearBook() internal {\n    numElements = 0;\n  }\n\n  function initializeContracts() internal {\n    stableToken = StableToken(connector.stableToken());\n    mocExchange = MoCExchange(connector.mocExchange());\n    mocState = MoCState(connector.mocState());\n  }\n\n  /**\n    @dev Create Task structures for Settlement execution\n  */\n  function initializeTasks() internal {\n    createTask(BURNOUT_TASK, burnoutStepCount, burnoutStep, noFunction, finishBurnout);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n",
  "imports": [
    {
      "name": "MoCBurnout_flat.sol",
      "contents": "pragma solidity 0.5.8;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCWhitelist {\n  mapping(address => bool) whitelist;\n\n  /**\n   * @dev Check if an account is whitelisted\n   * @return Bool\n   */\n  function isWhitelisted(address account)\n    public\n    view\n    returns (bool)\n  {\n    require(account != address(0), \"Account must not be 0x0\");\n    return whitelist[account];\n  }\n\n  /**\n   * @dev Add account to whitelist\n   */\n  function add(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(!isWhitelisted(account), \"Account not allowed to add accounts into white list\");\n    whitelist[account] = true;\n  }\n\n  /**\n   * @dev Remove account to whitelist\n   */\n  function remove(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(isWhitelisted(account), \"Account is not allowed to remove address from the white list\");\n\n    whitelist[account] = false;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCConnector is MoCWhitelist, Initializable {\n  // References\n  address payable public moc;\n  address public stableToken;\n  address public riskProToken;\n  address public riskProxManager;\n  address public mocState;\n  address public mocConverter;\n  address public mocSettlement;\n  address public mocExchange;\n  address public mocInrate;\n  address public mocBurnout;\n  address public reserveToken;\n\n  bool internal initialized;\n\n  function initialize(\n    address payable mocAddress,\n    address stableTokenAddress,\n    address riskProAddress,\n    address riskProxAddress,\n    address stateAddress,\n    address settlementAddress,\n    address converterAddress,\n    address exchangeAddress,\n    address inrateAddress,\n    address burnoutBookAddress,\n    address reserveTokenAddress\n  ) public initializer {\n    moc = mocAddress;\n    stableToken = stableTokenAddress;\n    riskProToken = riskProAddress;\n    riskProxManager = riskProxAddress;\n    mocState = stateAddress;\n    mocSettlement = settlementAddress;\n    mocConverter = converterAddress;\n    mocExchange = exchangeAddress;\n    mocInrate = inrateAddress;\n    mocBurnout = burnoutBookAddress;\n    reserveToken = reserveTokenAddress;\n\n    // Add to Whitelist\n    add(mocAddress);\n    add(stableTokenAddress);\n    add(riskProAddress);\n    add(riskProxAddress);\n    add(stateAddress);\n    add(settlementAddress);\n    add(converterAddress);\n    add(exchangeAddress);\n    add(inrateAddress);\n    add(burnoutBookAddress);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n/**\n * @dev Defines special constants to use along all the MoC System\n */\ncontract MoCConstants {\n  bytes32 constant public BUCKET_X2 = \"X2\";\n  bytes32 constant public BUCKET_C0 = \"C0\";\n}\n\n/**\n  @dev General usefull modifiers and functions\n */\ncontract MoCBase is MoCConstants, Initializable {\n  // Contracts\n  MoCConnector public connector;\n\n  bool internal initialized;\n\n  function initializeBase(address connectorAddress) internal initializer {\n    connector = MoCConnector(connectorAddress);\n  }\n\n  modifier onlyWhitelisted(address account) {\n    require(connector.isWhitelisted(account), \"Address is not whitelisted\");\n    _;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\ncontract PartialExecutionData {\n  enum ExecutionState {\n    Ready,\n    Running,\n    Finished\n  }\n\n  struct TaskGroup {\n    bytes32 id;\n    ExecutionState state;\n    bytes32[] subTasks;\n    function() internal onStart;\n    function() internal onFinish;\n    bool autoRestart;\n  }\n\n  struct Task {\n    bytes32 id;\n    function() internal returns(uint256) getStepCount;\n    function(uint256) internal stepFunction;\n    function() internal onStart;\n    function() internal onFinish;\n    uint256 currentStep;\n    uint256 stepCount;\n    ExecutionState state;\n  }\n}\n\n/**\n  @dev Brings basic data structures and functions for partial execution.\n  The main data structures are:\n    Task: Represents a function that needs to be executed by steps.\n    TaskGroup: Represents a function that contains several functions that needs to be executed by steps.\n  Tasks and Tasks groups can be executed specifying the amount of steps to run.\n*/\ncontract PartialExecution is PartialExecutionData {\n  using SafeMath for uint256;\n  using Math for uint256;\n  mapping(bytes32 => Task) internal tasks;\n  mapping(bytes32 => TaskGroup) internal taskGroups;\n  /**\n     @dev Auxiliar function for tasks with no onFinish function\n   */\n  function noFunction() internal {\n\n  }\n\n  /**\n     @dev Creates a task group\n     @param _groupId Id of the task group\n     @param _subtasks Tasks to execute when executing the task group\n     @param _onFinish Function to execute when all tasks of the group are completed\n   */\n  function createTaskGroup(bytes32 _groupId, bytes32[] memory _subtasks, function() _onStart, function() _onFinish, bool _autoRestart) internal{\n    taskGroups[_groupId].id = _groupId;\n    taskGroups[_groupId].subTasks = _subtasks;\n    taskGroups[_groupId].onStart = _onStart;\n    taskGroups[_groupId].onFinish = _onFinish;\n    taskGroups[_groupId].state = ExecutionState.Ready;\n    taskGroups[_groupId].autoRestart = _autoRestart;\n  }\n\n  /**\n     @dev Creates a task\n     @param taskId Id of the task\n     @param _getStepCount Function executed before starting the task\n     Should return the step count of the execution\n     @param _stepFunction Function to execute at each step\n     @param _onStart Function to execute before task execution\n     @param _onFinish Function to execute when all steps are completed\n   */\n  function createTask(\n    bytes32 taskId,\n    function() internal returns(uint256) _getStepCount,\n    function(uint256) internal _stepFunction,\n    function() internal _onStart,\n    function() internal _onFinish\n  ) internal {\n    tasks[taskId].id = taskId;\n    tasks[taskId].getStepCount = _getStepCount;\n    tasks[taskId].stepFunction = _stepFunction;\n    tasks[taskId].onStart = _onStart;\n    tasks[taskId].onFinish = _onFinish;\n    tasks[taskId].state = ExecutionState.Ready;\n  }\n\n  /**\n     @dev Executes all tasks of the group in order using the step count passed as parameter\n     @param groupId Id of the task group\n     @param stepCount Step count to execute\n   */\n  function executeGroup(bytes32 groupId, uint256 stepCount) internal {\n    TaskGroup storage group = taskGroups[groupId];\n\n    if (group.state == ExecutionState.Ready) {\n      group.onStart();\n      group.state = ExecutionState.Running;\n    }\n\n    uint256 leftSteps = stepCount;\n\n    for (uint256 i = 0; i < group.subTasks.length; i++) {\n      uint256 consumed = executeTask(group.subTasks[i], leftSteps);\n      leftSteps = leftSteps.sub(consumed);\n    }\n\n    if (groupFinished(groupId)) {\n      group.state = ExecutionState.Finished;\n      group.onFinish();\n      if (group.autoRestart) {\n        resetGroup(groupId);\n      }\n    }\n  }\n\n  /**\n     @dev Creates a task\n     @param taskId Id of the task\n     @param steps Step count to execute\n     @return The amount of steps consumed in the execution\n   */\n  function executeTask(bytes32 taskId, uint256 steps) internal returns(uint256){\n    Task storage task = tasks[taskId];\n    uint256 initialStep = task.currentStep;\n\n    if (task.state == ExecutionState.Finished) {\n      // No execution\n      return 0;\n    }\n    if (task.state == ExecutionState.Ready) {\n      task.stepCount = task.getStepCount();\n      task.onStart();\n      task.state = ExecutionState.Running;\n    }\n    if (task.state == ExecutionState.Running) {\n      uint256 endStep = Math.min(task.currentStep.add(steps), task.stepCount);\n\n      for (task.currentStep; task.currentStep < endStep; task.currentStep++) {\n        task.stepFunction(task.currentStep);\n      }\n\n      if (task.currentStep == task.stepCount) {\n        task.state = ExecutionState.Finished;\n        task.onFinish();\n      }\n    }\n\n    return task.currentStep.sub(initialStep);\n  }\n\n  /**\n     @dev Put task in Ready to run state and reset currentStep value\n     @param taskId Id of the task\n   */\n  function resetTask(bytes32 taskId) internal {\n    tasks[taskId].state = ExecutionState.Ready;\n    tasks[taskId].currentStep = 0;\n  }\n\n  /**\n    @dev Reset all tasks in a group. Used at the completion of a task group execution\n    @param groupId Id of the task group\n  */\n  function resetTasks(bytes32 groupId) internal {\n    TaskGroup storage group = taskGroups[groupId];\n\n    for (uint256 i = 0; i < group.subTasks.length; i++) {\n      resetTask(group.subTasks[i]);\n    }\n  }\n\n  /**\n    @dev Set if a Group should be automatically set to Ready state\n    after Finnished State is reached\n    @param groupId Id of the task group\n  */\n  function setAutoRestart(bytes32 groupId, bool _autoRestart) internal {\n    taskGroups[groupId].autoRestart = _autoRestart;\n  }\n\n  /**\n    @dev Set Group in Ready state. Reset all sub-task.\n    @param groupId Id of the task group\n  */\n  function resetGroup(bytes32 groupId) internal {\n    TaskGroup storage group = taskGroups[groupId];\n    group.state = ExecutionState.Ready;\n\n    resetTasks(groupId);\n  }\n\n  /**\n     @dev Returns true if the last task of the group was completed\n     @param groupId Id of the task group\n     @return boolean\n   */\n  function groupFinished(bytes32 groupId) internal view returns(bool){\n    TaskGroup storage group = taskGroups[groupId];\n    bytes32 taskId = group.subTasks[group.subTasks.length.sub(1)];\n    Task storage lastTask = tasks[taskId];\n\n    return lastTask.state == ExecutionState.Finished;\n  }\n\n  /**\n     @dev Returns true if the group is currently un Running state\n     @param groupId Id of the task group\n     @return boolean\n   */\n  function isGroupRunning(bytes32 groupId) internal view returns(bool) {\n    return taskGroups[groupId].state == ExecutionState.Running;\n  }\n\n  /**\n     @dev Returns true if the group is currently in Ready state\n     @param groupId Id of the task group\n     @return boolean\n   */\n  function isGroupReady(bytes32 groupId) internal view returns(bool) {\n    return taskGroups[groupId].state == ExecutionState.Ready;\n  }\n\n  /**\n     @dev Returns true if the task is currently un Running state\n     @param taskId Id of the task\n     @return boolean\n   */\n  function isTaskRunning(bytes32 taskId) internal view returns(bool) {\n    return tasks[taskId].state == ExecutionState.Running;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * > Note that this information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * `IERC20.balanceOf` and `IERC20.transfer`.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See `IERC20.approve`.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destoys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See `_burn` and `_approve`.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\ncontract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(msg.sender), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n\n/**\n * @dev Extension of `ERC20` that adds a set of accounts with the `MinterRole`,\n * which have permission to mint (create) new tokens as they see fit.\n *\n * At construction, the deployer of the contract is the only minter.\n */\ncontract ERC20Mintable is ERC20, MinterRole {\n    /**\n     * @dev See `ERC20._mint`.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MinterRole`.\n     */\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n/**\n * @title Owner Burnable Token\n * @dev Token that allows the owner to irreversibly burned (destroyed) any token.\n */\ncontract OwnerBurnableToken is Ownable, ERC20Mintable {\n  /**\n   * @dev Burns a specific amount of tokens for the address.\n   * @param who who's tokens are gona be burned\n   * @param value The amount of token to be burned.\n   */\n  function burn(address who, uint256 value) public onlyOwner {\n    _burn(who, value);\n  }\n}\n\ncontract StableToken is ERC20Detailed, OwnerBurnableToken {\n\n  string private _name = \"Stable Token\";\n  string private _symbol = \"STABLE\";\n  uint8 private _decimals = 18;\n\n  constructor() Ownable() ERC20Detailed(_name, _symbol, _decimals) public {\n\n  }\n\n  //Fallback\n  function() external {\n  }\n}\n\ninterface PriceProvider {\n  function peek() external view returns (bytes32, bool);\n}\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n\n  /**\n    @notice Override this function with a recipe of the changes to be done when this ChangeContract\n    is executed\n   */\n  function execute() external;\n}\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor{\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @dev This function should be protected somehow to only execute changes that\n    benefit the system. This decision process is independent of this architechture\n    therefore is independent of this interface too\n    @param changeContract Address of the contract that will execute the changes\n   */\n  function executeChange(ChangeContract changeContract) external;\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @param _changer Address of the contract that will execute the changes\n   */\n  function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed is Initializable {\n\n  /**\n    @notice The address of the contract which governs this one\n   */\n  IGovernor public governor;\n\n  string constant private NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n  /**\n    @notice Modifier that protects the function\n    @dev You should use this modifier in any function that should be called through\n    the governance system\n   */\n  modifier onlyAuthorizedChanger() {\n    require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n    _;\n  }\n\n  /**\n    @notice Initialize the contract with the basic settings\n    @dev This initialize replaces the constructor but it is not called automatically.\n    It is necessary because of the upgradeability of the contracts\n    @param _governor Governor address\n   */\n  function initialize(IGovernor _governor) public initializer {\n    governor = _governor;\n  }\n\n  /**\n    @notice Change the contract's governor. Should be called through the old governance system\n    @param newIGovernor New governor address\n   */\n  function changeIGovernor(IGovernor newIGovernor) public onlyAuthorizedChanger {\n    governor = newIGovernor;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n/** @title ReserveToken Price Provider. */\ncontract MoCEMACalculator is Governed {\n  using SafeMath for uint256;\n\n  event MovingAverageCalculation (\n    uint256 price,\n    uint256 movingAverage\n  );\n\n  uint256 internal exponentialMovingAverage;\n  uint256 public smoothingFactor;\n  uint256 public lastEmaCalculation;\n  uint256 public emaCalculationBlockSpan;\n\n  uint256 constant public PRICE_PRECISION =  10 ** 18;\n  uint256 constant public FACTOR_PRECISION = 10 ** 18;\n\n  function getExponentalMovingAverage() public view returns(uint256) {\n    return exponentialMovingAverage;\n  }\n\n  function getSmoothingFactor() public view returns(uint256) {\n    return smoothingFactor;\n  }\n\n  function setSmoothingFactor(uint256 factor) public onlyAuthorizedChanger() {\n    _doSetSmoothingFactor(factor);\n  }\n\n  function getGovernorAddress() public view returns(address){\n    return address(governor);\n  }\n\n  function getEmaCalculationBlockSpan() public view returns(uint256){\n    return emaCalculationBlockSpan;\n  }\n  /**\n  * @param blockSpan Defines how many blocks should pass between BMA calculations\n  **/\n  function setEmaCalculationBlockSpan(uint256 blockSpan) public onlyAuthorizedChanger() {\n    emaCalculationBlockSpan = blockSpan;\n  }\n\n  function shouldCalculateEma() public view returns(bool) {\n    return block.number >= lastEmaCalculation.add(emaCalculationBlockSpan);\n  }\n\n  function getLastEmaCalculation() public view returns(uint256) {\n    return lastEmaCalculation;\n  }\n\n    /** @dev Provides ResToken's Price and Moving average.\n    * More information of EMA calculation https://en.wikipedia.org/wiki/Exponential_smoothing\n    * @param initialEma Initial ema value\n    * @param smoothFactor Weight coefficient for EMA calculation.\n    * @param emaBlockSpan Block count in a period for EMA calculation\n    */\n  function initializeMovingAverage(uint256 initialEma, uint256 smoothFactor, uint256 emaBlockSpan) internal {\n    _doSetSmoothingFactor(smoothFactor);\n    lastEmaCalculation = block.number;\n    exponentialMovingAverage = initialEma;\n    emaCalculationBlockSpan = emaBlockSpan;\n  }\n\n  /** @dev Calculates a EMA of the price.\n    * More information of EMA calculation https://en.wikipedia.org/wiki/Exponential_smoothing\n    * @param reservePrice Current price.\n    */\n  function setExponentalMovingAverage(uint256 reservePrice) internal {\n    if (shouldCalculateEma()) {\n      uint256 weightedPrice = reservePrice.mul(smoothingFactor);\n      uint256 currentEma = exponentialMovingAverage.mul(coefficientComp()).add(weightedPrice)\n        .div(FACTOR_PRECISION);\n\n      lastEmaCalculation = block.number;\n      exponentialMovingAverage = currentEma;\n\n      emit MovingAverageCalculation(reservePrice, currentEma);\n    }\n  }\n\n  /** @dev Calculates the smoothing factor complement\n    */\n  function coefficientComp() internal view returns(uint256) {\n    return FACTOR_PRECISION.sub(smoothingFactor);\n  }\n\n  function initializeGovernor(address _governor) internal {\n    governor = IGovernor(_governor);\n  }\n\n  function _doSetSmoothingFactor(uint256 factor) private {\n    require(factor <= FACTOR_PRECISION, \"Invalid smoothing factor\");\n    smoothingFactor = factor;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\nlibrary MoCHelperLib {\n\n  struct MocLibConfig {\n    uint256 reservePrecision;\n    uint256 dayPrecision;\n    uint256 mocPrecision;\n  }\n\n  using SafeMath for uint256;\n\n  uint256 constant UINT256_MAX = ~uint256(0);\n\n  /**\n    Calculates average interest using integral function\n\n    @dev T =  Rate = a * (x ** b) + c\n    @param tMax maxInterestRate [using mocPrecision]\n    @param power factor [using noPrecision]\n    @param tMin minInterestRate C0 stableToken amount [using mocPrecision]\n    @param abRat1 initial abundance ratio [using mocPrecision]\n    @param abRat2 final abundance ratio [using mocPrecision]\n    @return average interest rate [using mocPrecision]\n  */\n  function inrateAvg(MocLibConfig storage config, uint256 tMax, uint256 power, uint256 tMin, uint256 abRat1, uint256 abRat2)\n  public view returns(uint256) {\n    require(tMax > tMin, \"Max inrate should be bigger than Min inrate\");\n    uint256 abRat1Comp = config.mocPrecision.sub(abRat1);\n    uint256 abRat2Comp = config.mocPrecision.sub(abRat2);\n\n    if (abRat1 == abRat2) {\n      return potential(config, tMax, power, tMin, abRat1Comp);\n    }\n    else if (abRat2 < abRat1) {\n      return avgInt(config, tMax, power, tMin, abRat1Comp, abRat2Comp);\n    }\n    else {\n      return avgInt(config, tMax, power, tMin, abRat2Comp, abRat1Comp);\n    }\n  }\n\n  /**\n    Calculates spot interest rate that RiskProx owners should pay to RiskPro owners\n\n    @dev Rate = tMax * (abRatio ** power) + tMin\n    @param tMin min interest rate [using mocPrecision]\n    @param power power to use in the formula [using NoPrecision]\n    @param tMax max interest rate [using mocPrecision]\n    @param abRatio bucket C0  abundance Ratio [using mocPrecision]\n\n   */\n  function spotInrate(\n    MocLibConfig storage config, uint256 tMax, uint256 power, uint256 tMin, uint256 abRatio\n  ) public view returns(uint256) {\n    uint256 abRatioComp = config.mocPrecision.sub(abRatio);\n\n    return potential(config, tMax, power, tMin, abRatioComp);\n  }\n\n  /**\n    Calculates potential interests function with given parameters\n\n    @dev Rate = a * (x ** b) + c\n    @param a maxInterestRate [using mocPrecision]\n    @param b factor [using NoPrecision]\n    @param c minInterestRate C0 stableToken amount [using mocPrecision]\n    @param value global stableToken amount [using mocPrecision]\n  */\n  function potential(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value)\n  public view returns(uint256) {\n    // value ** b\n    // [MOC] ** [] = [MOC]\n    uint256 aux1 = pow(value, b, config.mocPrecision);\n    // (a * aux1) + c\n    // [MOC] [MOC] / [MOC] + [MOC] = [MOC]\n    return a.mul(aux1).div(config.mocPrecision).add(c);\n  }\n\n  /**\n    Calculates average of the integral function\n\n    @dev T = (\n              (c * xf + ((a * (xf ** (b + 1))) / (b + 1))) -\n              (c * xi + ((a * (xi ** (b + 1))) / (b + 1)))\n             ) / (xf - xi)\n    @param a maxInterestRate [using mocPrecision]\n    @param b factor [using NoPrecision]\n    @param c minInterestRate C0 stableToken amount [using mocPrecision]\n    @param value1 value to put in the function [using mocPrecision]\n    @param value2 value to put in the function [using mocPrecision]\n    @return average interest rate [using mocPrecision]\n   */\n  function avgInt(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value1, uint256 value2)\n  public view returns(uint256) {\n    // value2 - value1\n    // [MOC]\n    uint256 diff = value2.sub(value1);\n    // ((c * (1 - value1) + ((a * ((1 - value1) ** (b + 1))) / (b + 1)))\n    uint256 intV1 = integral(config, a, b, c, value1);\n    // ((c * (1 - value2) + ((a * ((1 - value2) ** (b + 1))) / (b + 1)))\n    uint256 intV2 = integral(config,  a, b, c, value2);\n    // (secOp - first) / diff\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\n    return intV2.sub(intV1).div(diff);\n  }\n\n  /**\n    Calculates integral of the exponential function\n\n    @dev T = c * (value) + (a * value ** (b + 1)) / (b + 1))\n    @param a maxInterestRate [using mocPrecision]\n    @param b factor [using NoPrecision]\n    @param c minInterestRate C0 stableToken amount [using mocPrecision]\n    @param value value to put in the function [using mocPrecision]\n    @return integration result [using mocPrecision]\n\n   */\n  function integral(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value)\n  public view returns(uint256) {\n    // b + 1\n    // [NONE]\n    uint256 b2 = b.add(1);\n    // c * value\n    // [MOC][MOC]\n    uint256 firstOp = c.mul(value);\n    // [MOC]\n    uint256 pow = pow(value, b2, config.mocPrecision);\n    // (a * value ** b2) / b2)\n    // [MOC][MOC]\n    uint256 secOp = a.mul(pow).div(b2);\n    // (firstOp + secOp)\n    // [MOC][MOC] + [MOC][MOC] = [MOC][MOC]\n    return firstOp.add(secOp);\n  }\n\n  /**\n  * @dev Relation between stableTokens in bucket 0 and StableToken total supply\n  * @param stableToken0 stableToken count in bucket 0 [using mocPrecision]\n  * @param stableTokent total stableToken supply [using mocPrecision]\n  * @return abundance ratio [using mocPrecision]\n  */\n  function abundanceRatio(MocLibConfig storage config, uint256 stableToken0, uint256 stableTokent)\n  public view returns(uint256) {\n    if (stableTokent == 0) {\n      return config.mocPrecision;\n    }\n    // [StableToken] [MOC] / [StableToken] = [MOC]\n    return stableToken0.mul(config.mocPrecision).div(stableTokent);\n  }\n\n  /**\n    SpotDiscountRate = TPD * (utpdu - cob) / (uptdu -liq)\n\n    @dev Returns the Ratio to apply to RiskPro Price in discount situations\n    @param riskProLiqDiscountRate Discount rate applied at Liquidation level coverage [using mocPrecision]\n    @param liq Liquidation coverage threshold [using mocPrecision]\n    @param utpdu Discount coverage threshold [using mocPrecision]\n    @param cov Actual global Coverage threshold [using mocPrecision]\n    @return Spot discount rate [using mocPrecision]\n  **/\n  function riskProSpotDiscountRate(\n    MocLibConfig storage libConfig, uint256 riskProLiqDiscountRate,\n    uint256 liq, uint256 utpdu, uint256 cov\n  ) public view returns(uint256) {\n    require(riskProLiqDiscountRate < libConfig.mocPrecision, \"Discount rate should be lower than 1\");\n\n    if (cov >= utpdu) {\n      return 0;\n    }\n\n    // utpdu - liq\n    // [MOC] - [MOC] = [MOC]\n    uint256 utpduLiqDiff = utpdu.sub(liq);\n\n    // utpdu - cov\n    // [MOC] - [MOC] = [MOC]\n    uint256 utpduCovDiff = utpdu.sub(cov);\n\n    // TPD * utpduCovDiff / utpduLiqDiff\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    return riskProLiqDiscountRate.mul(utpduCovDiff).div(utpduLiqDiff);\n  }\n\n  /**\n    MaxRiskProWithDiscount = (uTPDU * nStableToken * PEG - (nReserve * B)) / (TPusd * TPD)\n\n    @dev Max amount of RiskPro to available with discount\n    @param nReserve Total ReserveTokens amount [using reservePrecision]\n    @param nStableToken StableToken amount [using mocPrecision]\n    @param utpdu Discount coverage threshold [using mocPrecision]\n    @param peg peg value\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @param riskProUsdPrice riskProUsdPrice [using mocPrecision]\n    @param spotDiscount spot discount [using mocPrecision]\n    @return Total RiskPro amount [using mocPrecision]\n  **/\n  function maxRiskProWithDiscount(\n    MocLibConfig storage libConfig, uint256 nReserve, uint256 nStableToken, uint256 utpdu,\n    uint256 peg, uint256 reservePrice, uint256 riskProUsdPrice, uint256 spotDiscount\n  ) public view returns(uint256)  {\n    require(spotDiscount < libConfig.mocPrecision, \"Discount Rate should be lower than 1\");\n\n    if (spotDiscount == 0) {\n      return 0;\n    }\n\n    // nReserve * B\n    // [RES] * [MOC] / [RES] = [MOC]\n    uint256 nbUsdValue = nReserve.mul(reservePrice).div(libConfig.reservePrecision);\n\n    // (TPusd * (1 - TPD))\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 riskProDiscountPrice = riskProUsdPrice.mul(libConfig.mocPrecision.sub(spotDiscount))\n      .div(libConfig.mocPrecision);\n\n    return maxRiskProWithDiscountAux(libConfig, nbUsdValue, nStableToken, utpdu, peg, riskProDiscountPrice);\n  }\n\n  /**\n    MaxRiskProWithDiscount = (uTPDU * nStableToken * PEG - (nReserve * B)) / (TPusd * TPD)\n\n    @dev Max amount of RiskPro to available with discount\n    @param nbUsdValue Total amount of ReserveTokens in USD [using mocPrecision]\n    @param nStableToken StableToken amount [using mocPrecision]\n    @param utpdu Discount coverage threshold [using mocPrecision]\n    @param riskProDiscountPrice riskProUsdPrice with discount applied [using mocPrecision]\n    @param peg peg value\n    @return Total RiskPro amount [using reservePrecision]\n  **/\n  function maxRiskProWithDiscountAux(\n    MocLibConfig storage libConfig, uint256 nbUsdValue, uint256 nStableToken,\n    uint256 utpdu, uint256 peg, uint256 riskProDiscountPrice\n  ) internal view returns(uint256) {\n\n    // uTPDU * nStableToken * PEG\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 coverageUSDAmount = utpdu.mul(nStableToken).mul(peg).div(libConfig.mocPrecision);\n\n    // This case only occurs with Coverage below 1\n    if (coverageUSDAmount <= nbUsdValue) {\n      return 0;\n    }\n\n    // ([MOC] - [MOC]) * [RES] / [MOC] = [RES]\n    return coverageUSDAmount.sub(nbUsdValue).mul(libConfig.reservePrecision).div(riskProDiscountPrice);\n  }\n\n  /**\n\n    @dev Calculates Locked ReserveTokens\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @param nStableToken StableTokens amount [using mocPrecision]\n    @param peg peg value\n    @return Locked ReserveTokens [using reservePrecision]\n  **/\n  function lockedReserveTokens(\n    MocLibConfig storage libConfig, uint256 reservePrice, uint256 nStableToken, uint256 peg\n  ) public view returns(uint256) {\n    return nStableToken.mul(peg).mul(libConfig.reservePrecision).div(reservePrice);\n  }\n\n  /**\n    @dev Calculates price at liquidation event as a relation between the stableToken total supply\n    and the amount of ReserveTokens available to distribute\n    @param resTokenAmount ReserveTokens to distribute [using reservePrecision]\n    @param nStableToken StableTokens amount [using mocPrecision]\n    @return Price at liquidation event [using mocPrecision]\n  **/\n  function liquidationPrice(MocLibConfig storage libConfig, uint256 resTokenAmount, uint256 nStableToken)\n  public view returns(uint256) {\n    // [MOC] * [RES] / [RES]\n    return nStableToken.mul(libConfig.reservePrecision).div(resTokenAmount);\n  }\n\n  /**\n    (nReserve-LB) / nTP\n\n    @dev Calculates RiskPro ReserveTokens price\n    @param nReserve Total ReserveTokens amount [using reservePrecision]\n    @param lb Locked ReserveTokens amount [using reservePrecision]\n    @param nTP RiskPro amount [using mocPrecision]\n    @return RiskPro ReserveTokens price [using reservePrecision]\n  **/\n  function riskProTecPrice(MocLibConfig storage libConfig, uint256 nReserve, uint256 lb, uint256 nTP)\n    public view returns(uint256) {\n    // Liquidation happens before this condition turns true\n    if (nReserve < lb) {\n      return 0;\n    }\n\n    if (nTP == 0) {\n      return libConfig.mocPrecision;\n    }\n    // ([RES] - [RES]) * [MOC] / [MOC]\n    return nReserve.sub(lb).mul(libConfig.mocPrecision).div(nTP);\n  }\n\n  /**\n   RiskProxInRiskPro = riskProxTecPrice / riskProPrice\n\n    @dev Calculates RiskPro ReserveTokens price\n    @param riskProxTecPrice RiskProx ReserveTokens price [using reservePrecision]\n    @param riskProPrice Trog ReserveTokens price [using reservePrecision]\n    @return RiskProx price in RiskPro [using mocPrecision]\n  **/\n  function riskProxRiskProPrice(\n    MocLibConfig storage libConfig, uint256 riskProxTecPrice, uint256 riskProPrice\n  ) public view returns(uint256) {\n    // [RES] * [MOC] / [RES] = [MOC]\n    return riskProxTecPrice.mul(libConfig.mocPrecision).div(riskProPrice);\n  }\n\n  /**\n    (price)* (1 - discountRate)\n\n    @dev Returns a new value with the discountRate applied\n    @param price Price [using SomePrecision]\n    @param discountRate Discount rate to apply [using mocPrecision]\n    @return Price with discount applied [using SomePrecision]\n  **/\n  function applyDiscountRate(MocLibConfig storage libConfig, uint256 price, uint256 discountRate)\n    public view returns(uint256) {\n\n    uint256 discountCoeff = libConfig.mocPrecision.sub(discountRate);\n\n    return price.mul(discountCoeff).div(libConfig.mocPrecision);\n  }\n\n  /**\n   price * interestRate\n\n    @dev Returns the amount of interest to pay\n    @param value Cost to apply interest [using SomePrecision]\n    @param interestRate Interest rate to apply [using mocPrecision]\n    @return Interest cost based on the value and interestRate [using SomePrecision]\n  **/\n  function getInterestCost(MocLibConfig storage libConfig, uint256 value, uint256 interestRate)\n    public view returns(uint256) {\n    // [ORIGIN] * [MOC] / [MOC] = [ORIGIN]\n    return value.mul(interestRate).div(libConfig.mocPrecision);\n  }\n\n  /**\n    Coverage = nReserve / LB\n\n    @dev Calculates Coverage\n    @param nReserve Total ReserveTokens amount [using reservePrecision]\n    @param lB Locked ReserveTokens amount [using reservePrecision]\n    @return Coverage [using mocPrecision]\n  **/\n  function coverage(MocLibConfig storage libConfig, uint256 nReserve, uint256 lB) public view\n    returns(uint256) {\n    if (lB == 0) {\n      return UINT256_MAX;\n    }\n\n    return nReserve.mul(libConfig.mocPrecision).div(lB);\n  }\n\n /**\n  Leverage = C / (C - 1)\n\n    @dev Calculates Leverage\n    @param cov Coverage [using mocPrecision]\n    @return Leverage [using mocPrecision]\n  **/\n  function leverageFromCoverage(MocLibConfig storage libConfig, uint256 cov)\n  public view returns(uint256) {\n    if (cov == UINT256_MAX) {\n      return libConfig.mocPrecision;\n    }\n\n    if (cov <= libConfig.mocPrecision) {\n      return UINT256_MAX;\n    }\n\n    return cov.mul(libConfig.mocPrecision).div(cov.sub(libConfig.mocPrecision));\n  }\n\n /**\n  Leverage = nReserve / (nReserve - lB)\n\n    @dev Calculates Leverage\n    @param nReserve Total ReserveTokens amount [using reservePrecision]\n    @param lB Locked ReserveTokens amount [using reservePrecision]\n    @return Leverage [using mocPrecision]\n  **/\n  function leverage(MocLibConfig storage libConfig, uint256 nReserve,uint256 lB)\n  public view returns(uint256) {\n    if (lB == 0) {\n      return libConfig.mocPrecision;\n    }\n\n    if (nReserve <= lB) {\n      return UINT256_MAX;\n    }\n\n    return nReserve.mul(libConfig.mocPrecision).div(nReserve.sub(lB));\n  }\n\n  /**\n    @dev Price in ReserveTokens of the amount of StableTokens\n    @param amount Total ReserveTokens amount [using reservePrecision]\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @return Total value [using reservePrecision]\n  **/\n  function stableTokensResTokensValue(\n    MocLibConfig storage libConfig, uint256 amount,uint256 peg, uint256 reservePrice\n  ) public view returns(uint256) {\n    require(reservePrice > 0,\"Price should be more than zero\");\n    require(libConfig.reservePrecision > 0, \"Precision should be more than zero\");\n    //Total = amount / satoshi price\n    //Total = amount / (reservePrice / precision)\n    // [RES] * [MOC] / [MOC]\n    uint256 stableTokenResTokenTotal = amount.mul(libConfig.mocPrecision).mul(peg).div(reservePrice);\n\n    return stableTokenResTokenTotal;\n  }\n\n /**\n    @dev Price in ReserveTokens of the amount of RiskPros\n    @param riskProAmount amount of RiskPro [using mocPrecision]\n    @param riskProResTokenPrice RiskPro price in ReserveTokens [using reservePrecision]\n    @return Total value [using reservePrecision]\n  **/\n  function riskProResTokensValuet(MocLibConfig storage libConfig, uint256 riskProAmount, uint256 riskProResTokenPrice)\n    public view returns(uint256) {\n    require(libConfig.reservePrecision > 0, \"Precision should be more than zero\");\n\n    // [MOC] * [RES] / [MOC] =  [RES]\n    uint256 riskProResTokenTotal = riskProAmount.mul(riskProResTokenPrice).div(libConfig.mocPrecision);\n\n    return riskProResTokenTotal;\n  }\n\n  /**\n   MaxStableToken = ((nReserve*B)-(Cobj*B/Bcons*nStableToken*PEG))/(PEG*(Cobj*B/BCons-1))\n\n    @dev Max amount of StableTokens to issue\n    @param nReserve Total ReserveTokens amount [using reservePrecision]\n    @param cobj Target Coverage [using mocPrecision]\n    @param nStableToken StableToken amount [using mocPrecision]\n    @param peg peg value\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @param bCons ReserveTokens conservative price [using mocPrecision]\n    @return Total StableTokens amount [using mocPrecision]\n  **/\n  function maxStableToken(\n    MocLibConfig storage libConfig, uint256 nReserve,\n    uint256 cobj, uint256 nStableToken, uint256 peg, uint256 reservePrice, uint256 bCons\n  ) public view returns(uint256) {\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\n\n    // If cobj is less than 1, just return zero\n    if (cobj < libConfig.mocPrecision)\n      return 0;\n\n    // Cobj * B / BCons\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 adjCobj = cobj.mul(reservePrice).div(bCons);\n\n    return maxStableTokenAux(libConfig, nReserve, adjCobj, nStableToken, peg, reservePrice);\n  }\n\n  function maxStableTokenAux(\n    MocLibConfig storage libConfig, uint256 nReserve,\n    uint256 adjCobj, uint256 nStableToken, uint256 peg, uint256 reservePrice\n  ) internal view returns(uint256) {\n    // (nReserve*B)\n    // [RES] [MOC] [MOC] / [RES] = [MOC] [MOC]\n    uint256 firstOperand = nReserve.mul(reservePrice).mul(libConfig.mocPrecision).div(libConfig.reservePrecision);\n    // (adjCobj*nStableToken*PEG)\n    // [MOC] [MOC]\n    uint256 secOperand = adjCobj.mul(nStableToken).mul(peg);\n    // (PEG*(adjCobj-1)\n    // [MOC]\n    uint256 denom = adjCobj.sub(libConfig.mocPrecision).mul(peg);\n\n    if (firstOperand <= secOperand)\n      return 0;\n\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\n    return (firstOperand.sub(secOperand)).div(denom);\n  }\n\n  /**\n   MaxRiskPro = ((nReserve*B)-(Cobj*nStableToken*PEG))/TPusd\n\n    @dev Max amount of RiskPro to redeem\n    @param nReserve Total ReserveTokens amount [using reservePrecision]\n    @param cobj Target Coverage [using mocPrecision]\n    @param nStableToken Target Coverage [using mocPrecision]\n    @param peg peg value\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @param bCons ReserveTokens conservative price [using mocPrecision]\n    @param riskProUsdPrice riskProUsdPrice [using mocPrecision]\n    @return Total RiskPro amount [using mocPrecision]\n  **/\n  function maxRiskPro(\n    MocLibConfig storage libConfig, uint256 nReserve, uint256 cobj,\n    uint256 nStableToken, uint256 peg, uint256 reservePrice, uint256 bCons, uint256 riskProUsdPrice\n  ) public view returns(uint256) {\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\n\n    // Cobj * reservePrice / BCons\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 adjCobj = cobj.mul(reservePrice).div(bCons);\n    // (nReserve * reservePrice)\n    // [RES] * [MOC] * [MOC] / [RES] = [MOC] [MOC]\n    uint256 firstOperand = nReserve.mul(reservePrice)\n      .mul(libConfig.mocPrecision)\n      .div(libConfig.reservePrecision);\n    // (adjCobj * nStableToken * PEG)\n    // [MOC] * [MOC]\n    uint256 secOperand = adjCobj.mul(nStableToken).mul(peg);\n\n    if (firstOperand <= secOperand)\n      return 0;\n\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\n    return (firstOperand.sub(secOperand)).div(riskProUsdPrice);\n  }\n\n  /**\n    @dev Calculates the total ReserveTokens price of the amount of RiskPros\n    @param amount Amount of RiskPro [using mocPrecision]\n    @param riskProPrice RiskPro ReserveTokens Price [using reservePrecision]\n    @return RiskPro total value in ReserveTokens [using reservePrecision]\n  **/\n  function totalRiskProInResTokens(\n    MocLibConfig storage libConfig, uint256 amount, uint256 riskProPrice\n  ) public view returns(uint256) {\n    // [RES] * [MOC] / [MOC] = [RES]\n    return riskProPrice.mul(amount).div(libConfig.mocPrecision);\n  }\n\n  /**\n    @dev Calculates the equivalent in StableTokens of the resTokensAmount\n    @param resTokensAmount ReserveTokens  amount [using reservePrecision]\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @return Equivalent StableToken amount [using mocPrecision]\n  **/\n  function maxStableTokensWithResTokens(\n    MocLibConfig storage libConfig, uint256 resTokensAmount, uint256 reservePrice\n  ) public view returns(uint256) {\n    // [RES] * [MOC] / [RES] = [MOC]\n    return resTokensAmount.mul(reservePrice).div(libConfig.reservePrecision);\n  }\n\n  /**\n    @dev Calculates the equivalent in RiskPro of the resTokensAmount\n    @param resTokensAmount ReserveTokens amount [using reservePrecision]\n    @param riskProPrice RiskPro ReserveTokens price [using reservePrecision]\n    @return Equivalent RiskPro amount [using mocPrecision]\n  **/\n  function maxRiskProWithResTokens(\n    MocLibConfig storage libConfig, uint256 resTokensAmount, uint256 riskProPrice\n  ) public view returns(uint256) {\n    if (riskProPrice == 0) {\n      return 0;\n    }\n\n    // [RES] * [MOC] / [RES]\n    return resTokensAmount.mul(libConfig.mocPrecision).div(riskProPrice);\n  }\n\n  /**\n    toMove = resTokensAmount * (lev - 1)\n\n    @dev Calculates the ResToken amount to move from C0 bucket to\n    an L bucket when a RiskProx minting occurs\n    @param resTokensAmount Total ReserveTokens amount [using reservePrecision]\n    @param lev L bucket leverage [using mocPrecision]\n    @return resTokens to move [using reservePrecision]\n    **/\n  function bucketTransferAmount(\n    MocLibConfig storage libConfig, uint256 resTokensAmount, uint256 lev\n  ) public view returns(uint256) {\n    require(lev > libConfig.mocPrecision, \"Leverage should be more than 1\");\n\n    if (lev == UINT256_MAX || resTokensAmount == 0) {\n      return 0;\n    }\n\n    // (lev-1)\n    uint256 levSubOne = lev.sub(libConfig.mocPrecision);\n\n    // Intentionally avaoid SafeMath\n    // [RES] * [MOC]\n    uint256 transferAmount = resTokensAmount * levSubOne;\n    if (transferAmount / resTokensAmount != levSubOne)\n      return 0;\n\n    // [RES] * [MOC] / [MOC] = [RES]\n    return transferAmount.div(libConfig.mocPrecision);\n  }\n\n   /**\n    MaxriskProx = nStableToken/ (PEG*B*(lev-1))\n\n    @dev Max amount of ReserveTokens allowed to be used to mint riskProx\n    @param nStableToken number of StableToken [using mocPrecision]\n    @param peg peg value\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @param lev leverage [using mocPrecision]\n    @return Max riskProx ReserveTokens value [using reservePrecision]\n  **/\n  function maxRiskProxResTokenValue(\n    MocLibConfig storage libConfig, uint256 nStableToken, uint256 peg, uint256 reservePrice, uint256 lev\n  ) public view returns(uint256)  {\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\n\n    if (lev <= libConfig.mocPrecision) {\n      return 0;\n    }\n    // (lev-1)\n    // [MOC]\n    uint256 levSubOne = lev.sub(libConfig.mocPrecision);\n\n    // PEG * ResTokenPrice\n    // [MOC]\n    uint256 pegTimesPrice = peg.mul(reservePrice);\n\n    // This intentionally avoid using safeMath to handle overflow case\n    // PEG * ResTokenPrice * (lev - 1)\n    // [MOC] * [MOC]\n    uint256 dividend = pegTimesPrice * levSubOne;\n\n    if (dividend / pegTimesPrice != levSubOne)\n      return 0; // INFINIT dividend means 0\n\n    // nStableToken adjusted with precisions\n    // [MOC] [RES]\n    uint256 divider = nStableToken.mul(libConfig.reservePrecision);\n\n    // [MOC] [RES] [MOC] / [MOC] [MOC]\n    return divider.mul(libConfig.mocPrecision).div(dividend);\n  }\n\n  /**\n    @dev Rounding product adapted from DSMath but with custom precision\n    @param x Multiplicand\n    @param y Multiplier\n    @return Product\n  **/\n  function mulr(uint x, uint y, uint256 precision) internal pure returns (uint z) {\n    return x.mul(y).add(precision.div(2)).div(precision);\n  }\n\n  /**\n    @dev Potentiation by squaring adapted from DSMath but with custom precision\n    @param x Base\n    @param n Exponent\n    @return power\n  **/\n  function pow(uint256 x, uint256 n, uint256 precision) internal pure returns (uint z) {\n    uint256 x2 = x;\n    z = n % 2 != 0 ? x : precision;\n\n    for (n /= 2; n != 0; n /= 2) {\n      x2 = mulr(x2, x2, precision);\n\n      if (n % 2 != 0) {\n        z = mulr(z, x2, precision);\n      }\n    }\n  }\n}\n\n/**\n  @dev Interface with MocHelperLib\n */\ncontract MoCLibConnection {\n  using MoCHelperLib for MoCHelperLib.MocLibConfig;\n  MoCHelperLib.MocLibConfig internal mocLibConfig;\n\n  /*\n  * Precision getters\n  */\n  function getMocPrecision() public view returns(uint256) {\n    return mocLibConfig.mocPrecision;\n  }\n\n  function getReservePrecision() public view returns(uint256) {\n    return mocLibConfig.reservePrecision;\n  }\n\n  function getDayPrecision() public view returns(uint256) {\n    return mocLibConfig.dayPrecision;\n  }\n\n  function initializePrecisions() internal {\n    mocLibConfig = MoCHelperLib.MocLibConfig({\n      reservePrecision: 10 ** 18,\n      mocPrecision: 10 ** 18,\n      dayPrecision: 1\n    });\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\ncontract MoCBucketContainer is MoCBase, Governed{\n  using SafeMath for uint256;\n  using Math for uint256;\n\n  struct RiskProxBalance {\n    uint256 value;\n    uint index; // Index start in 1, zero is reserved for NULL\n  }\n\n  struct MoCBucket {\n    bytes32 name;\n    bool isBase;\n    uint256 nStable;\n    uint256 nRiskPro;\n    uint256 nReserve;\n    uint256 cobj;\n    // Should only be used in X buckets\n    mapping(address => RiskProxBalance) riskProxBalances;\n    address payable[] activeBalances;\n    uint256 activeBalancesLength;\n    // Should only be used in Base buckets (C0)\n    uint256 inrateBag;\n    bool available;\n  }\n\n  event BucketMovement(\n    bytes32 from,\n    bytes32 to,\n    uint256 reserves,\n    uint256 stableTokens\n  );\n\n  event BucketCreation(\n    bytes32 name,\n    uint256 cobj\n  );\n\n  event BucketStateUpdate(\n    bytes32 name,\n    uint256 nReserve,\n    uint256 nStable,\n    uint256 nRiskProx,\n    uint256 inrateBag\n  );\n\n  mapping(bytes32 => MoCBucket) internal mocBuckets;\n  IGovernor internal governor;\n   /**\n   GETTERS\n   */\n  function getBucketNReserve(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].nReserve;\n  }\n\n  function getBucketNRiskPro(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].nRiskPro;\n  }\n\n  function getBucketNStableToken(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].nStable;\n  }\n\n  function getBucketCobj(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].cobj;\n  }\n\n  function getInrateBag(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].inrateBag;\n  }\n\n  /**\n   * @dev Sets the objective coverage (cobj) on an specficied bucket.\n   * @param  _bucket - name of the bucket\n   * @param  _cobj - new value of cobj\n   */\n  function setBucketCobj(bytes32 _bucket, uint256 _cobj) public onlyAuthorizedChanger(){\n    //TODO: It is necessary to analyze the impact in the model it has when changing X2. This\n    mocBuckets[_bucket].cobj = _cobj;\n  }\n\n  /**\n    @dev returns true if the bucket is a base bucket\n    @param bucket Name of the bucket\n  **/\n  function isBucketBase(bytes32 bucket) public view returns(bool){\n    return mocBuckets[bucket].isBase;\n  }\n\n  /**\n    @dev returns true if the bucket have stableTokens in it\n    @param bucket Name of the bucket\n  **/\n  function isBucketEmpty(bytes32 bucket) public view returns(bool) {\n    return mocBuckets[bucket].nStable == 0;\n  }\n\n  /**\n    @dev Returns all the address that currently have riskProx position for this bucket\n    @param bucket bucket of the active address\n  */\n  function getActiveAddresses(bytes32 bucket) public view returns(address payable[] memory) {\n    return mocBuckets[bucket].activeBalances;\n  }\n\n  /**\n    @dev Returns all the address that currently have riskProx position for this bucket\n    @param bucket bucket of the active address\n  */\n  function getActiveAddressesCount(bytes32 bucket) public view returns(uint256 count) {\n    return mocBuckets[bucket].activeBalancesLength;\n  }\n\n  /**\n    @dev Add values to all variables of the bucket\n    @param bucketName Name of the bucket\n    @param reserveTokens ReserveToken amount [using reservePrecision]\n    @param stableToken StableToken amount [using mocPrecision]\n    @param riskProx RiskProx amount [using mocPrecision]\n  **/\n  function addValuesToBucket(bytes32 bucketName, uint256 reserveTokens, uint256 stableToken, uint256 riskProx)\n  public onlyWhitelisted(msg.sender) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    bucket.nReserve = bucket.nReserve.add(reserveTokens);\n    bucket.nStable = bucket.nStable.add(stableToken);\n    bucket.nRiskPro = bucket.nRiskPro.add(riskProx);\n  }\n\n  /**\n    @dev Substract values to all variables of the bucket\n    @param bucketName Name of the bucket\n    @param reserve ReserveToken amount [using reservePrecision]\n    @param stableToken StableToken amount [using mocPrecision]\n    @param riskProx RiskProx amount [using mocPrecision]\n  **/\n  function substractValuesFromBucket(bytes32 bucketName, uint256 reserve, uint256 stableToken, uint256 riskProx)\n  public onlyWhitelisted(msg.sender)  {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    bucket.nReserve = bucket.nReserve.sub(reserve);\n    bucket.nStable = bucket.nStable.sub(stableToken);\n    bucket.nRiskPro = bucket.nRiskPro.sub(riskProx);\n  }\n\n  /**\n    @dev Moves ReserveTokens from inrateBag to main ReserveTokens bucket bag\n    @param bucketName Name of the bucket to operate\n    @param amount value to move from inrateBag to main bag [using reservePrecision]\n   */\n  function deliverInrate(bytes32 bucketName, uint256 amount) public\n   onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) bucketStateUpdate(bucketName) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    uint256 toMove = Math.min(bucket.inrateBag, amount);\n\n    bucket.inrateBag = bucket.inrateBag.sub(toMove);\n    bucket.nReserve = bucket.nReserve.add(toMove);\n  }\n\n  /**\n    @dev Removes Interests rate from Inrate bag\n    @param bucketName Name of the bucket to operate\n    @param amount value to move from inrateBag to main bag [using reservePrecision]\n    @return Retrieved value\n   */\n  function recoverInrate(bytes32 bucketName, uint256 amount) public\n  onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) bucketStateUpdate(bucketName) returns(uint256) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    uint256 toRetrieve = Math.min(bucket.inrateBag, amount);\n\n    bucket.inrateBag = bucket.inrateBag.sub(toRetrieve);\n\n    return toRetrieve;\n  }\n\n  /**\n    @dev Moves ReserveTokens from origin bucket to destination bucket inrateBag\n    @param bucketName name of the bucket to from which takes\n    @param reserveAmount value to add to main bag [using reservePrecision]\n  */\n  function payInrate(bytes32 bucketName, uint256 reserveAmount) public\n  onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n    bucket.inrateBag = bucket.inrateBag.add(reserveAmount);\n  }\n\n  /**\n    @dev Move ReserveTokens and StableTokens from one bucket to another\n    @param from Name of bucket from where the ReserveTokens will be removed\n    @param to Name of bucket from where the ReserveTokens will be added\n    @param reserve ReserveTokens amount [using reservePrecision]\n    @param stableTokens StableTokens amount [using mocPrecision]\n  **/\n  function moveResTokensAndStableTokens(bytes32 from, bytes32 to, uint256 reserve, uint256 stableTokens) public\n  onlyWhitelisted(msg.sender) bucketStateUpdate(from) bucketStateUpdate(to) {\n    MoCBucket storage bucketFrom = mocBuckets[from];\n    MoCBucket storage bucketTo = mocBuckets[to];\n\n    bucketFrom.nReserve = bucketFrom.nReserve.sub(reserve);\n    bucketTo.nReserve = bucketTo.nReserve.add(reserve);\n\n    bucketFrom.nStable = bucketFrom.nStable.sub(stableTokens);\n    bucketTo.nStable = bucketTo.nStable.add(stableTokens);\n\n    emit BucketMovement(from, to, reserve, stableTokens);\n  }\n\n  /**\n    @dev Clears completely the origin bucket, removing all StableTokens, ReserveTokens and riskProxs\n    @param toLiquidate Bucket to be cleared out\n    @param destination Bucket that will receive the StableTokens and ReserveTokens\n   */\n  function liquidateBucket(bytes32 toLiquidate, bytes32 destination) public onlyWhitelisted(msg.sender) {\n    require(!isBucketBase(toLiquidate), \"Cannot liquidate a base bucket\");\n\n    clearBucketBalances(toLiquidate);\n    emptyBucket(toLiquidate, destination);\n  }\n\n  /**\n    @dev Clears StableTokens and ReserveTokens from bucket origin and sends them to destination bucket\n    @param origin Bucket to clear out\n    @param destination Destination bucket\n  **/\n  function emptyBucket(bytes32 origin, bytes32 destination) public onlyWhitelisted(msg.sender) {\n    moveResTokensAndStableTokens(origin, destination, mocBuckets[origin].nReserve, mocBuckets[origin].nStable);\n  }\n\n  /**\n   * @dev checks if a bucket exists\n   * @param bucket name of the bucket\n   */\n  function isAvailableBucket(bytes32 bucket) public view returns(bool) {\n    return mocBuckets[bucket].available;\n  }\n\n  /**\n    @dev Put all bucket RiskProx balances in zero\n    @param bucketName Bucket to clear out\n   */\n  function clearBucketBalances(bytes32 bucketName) public onlyWhitelisted(msg.sender) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n    bucket.nRiskPro = 0;\n    bucket.activeBalancesLength = 0;\n  }\n\n  /**\n    @dev Creates bucket\n    @param name Name of the bucket\n    @param cobj Target Coverage of the bucket\n  **/\n  function createBucket(bytes32 name, uint256 cobj, bool isBase) internal {\n    mocBuckets[name].name = name;\n    mocBuckets[name].nStable = 0;\n    mocBuckets[name].nRiskPro = 0;\n    mocBuckets[name].nReserve = 0;\n    mocBuckets[name].cobj = cobj;\n    mocBuckets[name].isBase = isBase;\n    mocBuckets[name].available = true;\n    emit BucketCreation(name, cobj);\n  }\n\n  modifier onlyBaseBucket(bytes32 bucket) {\n    require(isBucketBase(bucket), \"Bucket should be a base type bucket\");\n    _;\n  }\n\n  modifier bucketStateUpdate(bytes32 bucket) {\n    _;\n    emit BucketStateUpdate(\n      bucket,\n      mocBuckets[bucket].nReserve,\n      mocBuckets[bucket].nStable,\n      mocBuckets[bucket].nRiskPro,\n      mocBuckets[bucket].inrateBag\n      );\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\ncontract MoCRiskProxManager is MoCBucketContainer {\n  using SafeMath for uint256;\n  uint256 constant MIN_ALLOWED_BALANCE = 0;\n\n  function initialize(\n    address connectorAddress,\n    address _governor,\n    uint256 _c0Cobj,\n    uint256 _x2Cobj\n  ) public initializer {\n    initializeBase(connectorAddress);\n    initializeValues(_governor);\n    createBucket(BUCKET_C0, _c0Cobj, true);\n    createBucket(BUCKET_X2, _x2Cobj, false);\n  }\n\n  /**\n    @dev returns user balance\n    @param bucket RiskProx corresponding bucket to get balance from\n    @param userAddress user address to get balance from\n    @return total balance for the userAddress\n  */\n  function riskProxBalanceOf(bytes32 bucket, address userAddress) public view returns(uint256) {\n    RiskProxBalance memory userBalance = mocBuckets[bucket].riskProxBalances[userAddress];\n    if (!hasValidBalance(bucket, userAddress, userBalance.index)) return 0;\n    return userBalance.value;\n  }\n\n  /**\n    @dev verifies that this user has assigned balance for the given bucket\n    @param bucket corresponding Leveraged bucket to get balance from\n    @param userAddress user address to verify balance for\n    @param index index, starting from 1, where the address of the user is being kept\n    @return true if the user has assigned balance\n  */\n  function hasValidBalance(bytes32 bucket, address userAddress, uint index) public view returns(bool) {\n    return (index != 0) &&\n      (index <= getActiveAddressesCount(bucket)) &&\n      (mocBuckets[bucket].activeBalances[index - 1] == userAddress);\n  }\n\n  /**\n    @dev  Assigns the amount of BProx\n    @param bucket bucket from which the BProx will be removed\n    @param account user address to redeem for\n    @param riskProxAmount riskProx amount to redeem [using mocPresicion]\n    @param totalCost btc value of bproxAmount [using reservePrecision]\n  */\n  function assignRiskProx(bytes32 bucket, address payable account, uint256 riskProxAmount, uint256 totalCost)\n  public onlyWhitelisted(msg.sender) {\n    uint256 currentBalance = riskProxBalanceOf(bucket, account);\n\n    setRiskProxBalanceOf(bucket, account, currentBalance.add(riskProxAmount));\n    addValuesToBucket(bucket, totalCost, 0, riskProxAmount);\n  }\n\n  /**\n    @dev  Removes the amount of RiskProx and substract ReserveTokens from bucket\n    @param bucket bucket from which the RiskProx will be removed\n    @param userAddress user address to redeem for\n    @param riskProxAmount riskProx amount to redeem [using mocPresicion]\n    @param totalCost reserveToken value of riskProxAmount [using reservePrecision]\n  */\n  function removeRiskProx(bytes32 bucket, address payable userAddress, uint256 riskProxAmount, uint256 totalCost)\n  public onlyWhitelisted(msg.sender) {\n    uint256 currentBalance = riskProxBalanceOf(bucket, userAddress);\n\n    setRiskProxBalanceOf(bucket, userAddress, currentBalance.sub(riskProxAmount));\n    substractValuesFromBucket(bucket, totalCost, 0, riskProxAmount);\n  }\n\n  /**\n    @dev Sets the amount of RiskProx\n    @param bucket bucket from which the RiskProx will be setted\n    @param userAddress user address to redeem for\n    @param value riskProx amount to redeem [using mocPresicion]\n  */\n  function setRiskProxBalanceOf(bytes32 bucket, address payable userAddress, uint256 value) public onlyWhitelisted(msg.sender) {\n    mocBuckets[bucket].riskProxBalances[userAddress].value = value;\n\n    uint256 index = mocBuckets[bucket].riskProxBalances[userAddress].index;\n    if (!hasValidBalance(bucket, userAddress, index))\n      index = 0;\n\n    bool hasBalance = value > MIN_ALLOWED_BALANCE;\n    // The address is not in the array\n    if (index == 0) {\n      if (hasBalance) {\n        if (mocBuckets[bucket].activeBalances.length == mocBuckets[bucket].activeBalancesLength) {\n          mocBuckets[bucket].activeBalances.length += 1;\n        }\n        uint256 currentIndex = mocBuckets[bucket].activeBalancesLength++;\n        mocBuckets[bucket].activeBalances[currentIndex] = userAddress;\n        mocBuckets[bucket].riskProxBalances[userAddress].index = mocBuckets[bucket].activeBalancesLength;\n      }\n    } else {\n      if (!hasBalance) {\n        // We need to delete this address from the tracker\n        uint256 lastActiveIndex = mocBuckets[bucket].activeBalancesLength;\n        address payable keyToMove = mocBuckets[bucket].activeBalances[lastActiveIndex - 1];\n        mocBuckets[bucket].activeBalances[index - 1] = keyToMove;\n        // Alternative index and array decreases lenght to prevent gas limit\n        mocBuckets[bucket].activeBalancesLength--;\n        // Update moved key index\n        mocBuckets[bucket].riskProxBalances[keyToMove].index = index;\n        // Disable empty account index (0 == NULL)\n        mocBuckets[bucket].riskProxBalances[userAddress].index = 0;\n      }\n    }\n  }\n\n  /**\n   * @dev intializes values of the contract\n   */\n  function initializeValues(address _governor) internal {\n    governor = IGovernor(_governor);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\ncontract MoCConverter {\n\n\n  function riskProxToResToken(uint256 riskProxAmount, bytes32 bucket) public view returns(uint256);\n\n}\n\ncontract PauserRole {\n    using Roles for Roles.Role;\n\n    event PauserAdded(address indexed account);\n    event PauserRemoved(address indexed account);\n\n    Roles.Role private _pausers;\n\n    constructor () internal {\n        _addPauser(msg.sender);\n    }\n\n    modifier onlyPauser() {\n        require(isPauser(msg.sender), \"PauserRole: caller does not have the Pauser role\");\n        _;\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return _pausers.has(account);\n    }\n\n    function addPauser(address account) public onlyPauser {\n        _addPauser(account);\n    }\n\n    function renouncePauser() public {\n        _removePauser(msg.sender);\n    }\n\n    function _addPauser(address account) internal {\n        _pausers.add(account);\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) internal {\n        _pausers.remove(account);\n        emit PauserRemoved(account);\n    }\n}\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract Pausable is PauserRole {\n    /**\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\n     * to the deployer.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Called by a pauser to pause, triggers stopped state.\n     */\n    function pause() public onlyPauser whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @dev Called by a pauser to unpause, returns to normal state.\n     */\n    function unpause() public onlyPauser whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n}\n\n /**\n * @title Pausable token\n * @dev ERC20 modified with pausable transfers.\n */\ncontract ERC20Pausable is ERC20, Pausable {\n    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {\n        return super.transfer(to, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {\n        return super.transferFrom(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {\n        return super.approve(spender, value);\n    }\n\n    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool) {\n        return super.increaseAllowance(spender, addedValue);\n    }\n\n    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool) {\n        return super.decreaseAllowance(spender, subtractedValue);\n    }\n}\n\ncontract RiskProToken is ERC20Detailed, ERC20Pausable, OwnerBurnableToken {\n\n  string private _name = \"Risk Pro\";\n  string private _symbol = \"RPRO\";\n  uint8 private _decimals = 18;\n\n  constructor() Ownable() ERC20Detailed(_name, _symbol, _decimals) public {\n  }\n\n  //Fallback\n  function() external {\n  }\n}\n\ncontract MoCSettlement {\n  /**\n    @dev Returns the next block from which settlement is possible\n   */\n  function nextSettlementBlock() public view returns(uint256);\n}\n\ncontract MoCState is MoCLibConnection, MoCBase, MoCEMACalculator {\n  using Math for uint256;\n  using SafeMath for uint256;\n\n  // This is the current state.\n  States public state;\n\n  event StateTransition(States newState);\n  event PriceProviderUpdated(address oldAddress, address newAddress);\n  // Contracts\n  PriceProvider internal priceProvider;\n  MoCSettlement internal mocSettlement;\n  MoCConverter internal mocConverter;\n  StableToken internal stableToken;\n  RiskProToken internal riskProToken;\n  MoCRiskProxManager internal riskProxManager;\n\n  // One Day based on 15 seconds blocks\n  uint256 public dayBlockSpan;\n  // Relation between StableToken and dollar\n  uint256 public peg;\n  // RiskPro max discount rate\n  // Reflects the discount spot rate at Liquidation level\n  uint256 public riskProMaxDiscountRate;\n  // Liquidation limit\n  // [using mocPrecision]\n  uint256 public liq;\n  // RiskPro with discount limit\n  // [using mocPrecision]\n  uint256 public utpdu;\n  // Complete amount reserves in the system\n  uint256 public reserves;\n  // Price to use at stableToken redemption at\n  // liquidation event\n  uint256 public liquidationPrice;\n\n  function initialize(\n    address connectorAddress,\n    address _governor,\n    address _priceProvider,\n    uint256 _liq,\n    uint256 _utpdu,\n    uint256 _maxDiscRate,\n    uint256 _dayBlockSpan,\n    uint256 _ema,\n    uint256 _smoothFactor,\n    uint256 _emaBlockSpan\n  ) public initializer {\n    initializePrecisions();\n    initializeBase(connectorAddress);\n    initializeContracts();\n    initializeValues(_governor, _priceProvider,_liq, _utpdu, _maxDiscRate, _dayBlockSpan);\n    initializeMovingAverage(_ema, _smoothFactor, _emaBlockSpan);\n  }\n\n  /**\n  * @param rate Discount rate at liquidation level [using mocPrecision]\n  **/\n  function setMaxDiscountRate(uint256 rate) public onlyAuthorizedChanger() {\n    require(rate < mocLibConfig.mocPrecision, \"rate is lower than mocPrecision\");\n\n    riskProMaxDiscountRate = rate;\n  }\n\n    /**\n   * @dev return the value of the RiskPro max discount rate configuration param\n   * @return riskProMaxDiscountRate RiskPro max discount rate\n   */\n  function getMaxDiscountRate() public view returns(uint256) {\n    return riskProMaxDiscountRate;\n  }\n\n  /**\n  * @dev Defines how many blocks there are in a day\n  * @param blockSpan blocks there are in a day\n  **/\n  function setDayBlockSpan(uint256 blockSpan) public onlyAuthorizedChanger() {\n    dayBlockSpan = blockSpan;\n  }\n\n  /**\n  * @dev Sets a new PriceProvider contract\n  * @param priceProviderAddress blocks there are in a day\n  **/\n  function setPriceProvider(address priceProviderAddress) public onlyAuthorizedChanger() {\n    address oldPriceProviderAddress = address(priceProvider);\n    priceProvider = PriceProvider(priceProviderAddress);\n    emit PriceProviderUpdated(oldPriceProviderAddress, address(priceProvider));\n  }\n\n  /**\n  * @dev Gets the PriceProviderAddress\n  * @return priceProvider blocks there are in a day\n  **/\n  function getPriceProvider() public view returns(address) {\n    return address(priceProvider);\n  }\n  /**\n   * @dev Gets how many blocks there are in a day\n   * @return blocks there are in a day\n   */\n  function getDayBlockSpan() public view returns(uint256) {\n    return dayBlockSpan;\n  }\n  /******STATE MACHINE*********/\n\n  enum States {\n    // State 0\n    Liquidated,\n    // State 1\n    RiskProDiscount,\n    // State 2\n    BelowCobj,\n    // State 3\n    AboveCobj\n  }\n\n/**\n  * @dev Subtract the reserve amount passed by parameter to the reserves total\n  * @param amount Amount that will be subtract to reserves\n  */\n  function substractFromReserves(uint256 amount) public onlyWhitelisted(msg.sender) {\n    reserves = reserves.sub(amount);\n  }\n\n  /**\n  * @dev Add the reserve amount passed by parameter to the reserves total\n  * @param amount Amount that will be added to reserves\n  */\n  function addToReserves(uint256 amount) public onlyWhitelisted(msg.sender) {\n    reserves = reserves.add(amount);\n  }\n\n  /**\n    @dev All RiskPros in circulation\n   */\n  function riskProTotalSupply() public view returns(uint256) {\n    return riskProToken.totalSupply();\n  }\n\n  /**\n    @dev All stableTokens in circulation\n   */\n  function stableTokenTotalSupply() public view returns(uint256) {\n    return stableToken.totalSupply();\n  }\n\n  /**\n    @dev Target coverage for complete system\n   */\n  function cobj() public view returns(uint256) {\n    return riskProxManager.getBucketCobj(BUCKET_C0);\n  }\n\n  /**\n    * @dev Amount of ReserveTokens in the system excluding\n    * RiskProx values and interests holdings\n    */\n  function collateralReserves() public view returns(uint256) {\n    uint256 resTokensInRiskProx = mocConverter.riskProxToResToken(riskProxManager.getBucketNRiskPro(BUCKET_X2),BUCKET_X2);\n    uint256 resTokensInBag = riskProxManager.getInrateBag(BUCKET_C0);\n\n    return reserves.sub(resTokensInRiskProx).sub(resTokensInBag);\n  }\n\n  /** @dev GLOBAL Coverage\n    * @return coverage [using mocPrecision].\n    */\n  function globalCoverage() public view returns(uint256) {\n    uint256 lB = globalLockedReserveTokens();\n\n    return mocLibConfig.coverage(collateralReserves(), lB);\n  }\n\n  /**\n  * @dev BUCKET lockedReserveTokens\n  * @param bucket Name of the bucket used\n  * @return lockedReserveTokens amount [using reservePrecision].\n  */\n  function lockedReserveTokens(bytes32 bucket) public view returns(uint256) {\n    uint256 nStableToken = riskProxManager.getBucketNStableToken(bucket);\n\n    return mocLibConfig.lockedReserveTokens(getReserveTokenPrice(), nStableToken, peg);\n  }\n\n  /**\n  * @dev Gets ReserveTokens in RiskPro within specified bucket\n  * @param bucket Name of the bucket used\n  * @return ReserveToken amount of RiskPro in Bucket [using reservePrecision].\n  */\n  function getResTokensInRiskPro(bytes32 bucket) public view returns(uint256) {\n    uint256 nReserve = riskProxManager.getBucketNReserve(bucket);\n    uint256 lB = lockedReserveTokens(bucket);\n\n    if ( lB >= nReserve ){\n      return 0;\n    }\n\n    return nReserve.sub(lB);\n  }\n\n  /**\n  * @dev Gets the ReserveTokens in the contract that not corresponds\n    to StableToken collateral\n  * @return ReserveTokens remainder [using reservePrecision].\n  */\n  function getReservesRemainder() public view returns(uint256) {\n    uint256 lB = globalLockedReserveTokens();\n\n    if ( lB >= reserves ){\n      return 0;\n    }\n\n    return reserves.sub(lB);\n  }\n\n  /**\n  * @dev BUCKET Coverage\n  * @param bucket Name of the bucket used\n  * @return coverage [using mocPrecision]\n  */\n  function coverage(bytes32 bucket) public view returns(uint256) {\n    if (!riskProxManager.isBucketBase(bucket) && riskProxManager.isBucketEmpty(bucket)) {\n      return riskProxManager.getBucketCobj(bucket);\n    }\n\n    uint256 nReserve = riskProxManager.getBucketNReserve(bucket);\n    uint256 lB = lockedReserveTokens(bucket);\n\n    return mocLibConfig.coverage(nReserve, lB);\n  }\n\n    /**\n  * @dev Abundance ratio, receives tha amount of stableToken to use the value of stableToken0 and StableToken total supply\n  * @return abundance ratio [using mocPrecision]\n  */\n  function abundanceRatio(uint256 stableToken0) public view returns(uint256) {\n    return mocLibConfig.abundanceRatio(stableToken0, stableTokenTotalSupply());\n  }\n\n  /**\n  * @dev Relation between stableTokens in bucket 0 and StableToken total supply\n  * @return abundance ratio [using mocPrecision]\n  */\n  function currentAbundanceRatio() public view returns(uint256) {\n    return abundanceRatio(getBucketNStableToken(BUCKET_C0));\n  }\n\n  /**\n  * @dev BUCKET Leverage\n  * @param bucket Name of the bucket used\n  * @return leverage [using mocPrecision]\n  */\n  function leverage(bytes32 bucket) public view returns(uint256) {\n    uint256 cov = coverage(bucket);\n\n    return mocLibConfig.leverageFromCoverage(cov);\n  }\n\n  /**\n  * @dev GLOBAL maxStableToken\n  * @return maxStableToken to issue [using mocPrecision]\n  */\n  function globalMaxStableToken() public view returns(uint256) {\n    return mocLibConfig.maxStableToken(collateralReserves(), cobj(), stableTokenTotalSupply(), peg, getReserveTokenPrice(), getBcons());\n  }\n\n  /**\n  * @return amount of stableTokens in bucket 0, that can be redeemed outside of settlement [using mocPrecision]\n  */\n  function freeStableToken() public view returns(uint256) {\n    return riskProxManager.getBucketNStableToken(BUCKET_C0);\n  }\n\n  /**\n  * @dev BUCKET maxStableToken\n  * @return maxStableToken to issue [using mocPrecision]\n  */\n  function maxStableToken(bytes32 bucket) public view returns(uint256) {\n    uint256 nReserve = riskProxManager.getBucketNReserve(bucket);\n    uint256 nStableToken = riskProxManager.getBucketNStableToken(bucket);\n    uint256 bktCobj = riskProxManager.getBucketCobj(bucket);\n\n    return mocLibConfig.maxStableToken(nReserve, bktCobj, nStableToken, peg, getReserveTokenPrice(), getBcons());\n  }\n\n  /**\n  * @dev GLOBAL maxRiskPro\n  * @return maxRiskPro for redeem [using mocPrecision].\n  */\n  function globalMaxRiskPro() public view returns(uint256) {\n    uint256 riskProPrice = riskProUsdPrice();\n\n    return mocLibConfig.maxRiskPro(\n      collateralReserves(), cobj(), stableTokenTotalSupply(), peg, getReserveTokenPrice(), getBcons(), riskProPrice\n    );\n  }\n\n  /**\n  * @dev ABSOLUTE maxStableToken\n  * @return maxStableToken to issue [using mocPrecision]\n  */\n  function absoluteMaxStableToken() public view returns(uint256) {\n    return Math.min(globalMaxStableToken(), maxStableToken(BUCKET_C0));\n  }\n\n  /** @dev BUCKET maxRiskPro to redeem / mint\n      @param bucket Name of the bucket used\n    * @return maxRiskPro for redeem [using mocPrecision].\n    */\n  function maxRiskPro(bytes32 bucket) public view returns(uint256) {\n    uint256 nReserve = riskProxManager.getBucketNReserve(bucket);\n    uint256 nStableToken = riskProxManager.getBucketNStableToken(bucket);\n    uint256 riskProPrice = riskProUsdPrice();\n    uint256 bktCobj = riskProxManager.getBucketCobj(bucket);\n\n    return mocLibConfig.maxRiskPro(\n      nReserve, bktCobj, nStableToken, peg, getReserveTokenPrice(), getBcons(), riskProPrice\n    );\n  }\n\n /**\n  * @dev GLOBAL max riskProx to mint\n  * @param bucket Name of the bucket used\n  * @return maxRiskProx [using mocPrecision]\n  */\n  function maxRiskProx(bytes32 bucket) public view returns(uint256) {\n    uint256 maxResTokens = maxRiskProxResTokenValue(bucket);\n\n    return mocLibConfig.maxRiskProWithResTokens(maxResTokens, bucketRiskProTecPrice(bucket));\n  }\n\n  /**\n  * @dev GLOBAL max riskProx to mint\n  * @param bucket Name of the bucket used\n  * @return maxRiskProx ReserveTokens value to mint [using reservePrecision]\n  */\n  function maxRiskProxResTokenValue(bytes32 bucket) public view returns(uint256) {\n    uint256 nStableToken0 = riskProxManager.getBucketNStableToken(BUCKET_C0);\n    uint256 bucketLev = leverage(bucket);\n\n    return mocLibConfig.maxRiskProxResTokenValue(nStableToken0, peg, getReserveTokenPrice(), bucketLev);\n  }\n\n  /** @dev ABSOLUTE maxRiskPro\n  * @return maxStableToken to issue [using mocPrecision].\n  */\n  function absoluteMaxRiskPro() public view returns(uint256) {\n    return Math.min(globalMaxRiskPro(), maxRiskPro(BUCKET_C0));\n  }\n\n  /**\n  * @dev DISCOUNT maxRiskPro\n  * @return maxRiskPro for mint with discount [using mocPrecision]\n  */\n  function maxRiskProWithDiscount() public view returns(uint256) {\n    uint256 nStableToken = stableTokenTotalSupply();\n    uint256 riskProSpotDiscount = riskProSpotDiscountRate();\n    uint256 riskProPrice = riskProUsdPrice();\n    uint256 reservePrice = getReserveTokenPrice();\n\n    return mocLibConfig.maxRiskProWithDiscount(collateralReserves(), nStableToken, utpdu, peg, reservePrice, riskProPrice,\n      riskProSpotDiscount);\n  }\n\n  /**\n  * @dev GLOBAL lockedReserveTokens\n  * @return lockedReserveTokens amount [using reservePrecision].\n  */\n  function globalLockedReserveTokens() public view returns(uint256) {\n    return mocLibConfig.lockedReserveTokens(getReserveTokenPrice(), stableTokenTotalSupply(), peg);\n  }\n\n  /**\n  * @dev ReserveTokens price of RiskPro\n  * @return the RiskPro Tec Price [using reservePrecision].\n  */\n  function riskProTecPrice() public view returns(uint256) {\n    return bucketRiskProTecPrice(BUCKET_C0);\n  }\n\n  /**\n  * @dev BUCKET ReserveTokens price of RiskPro\n  * @param bucket Name of the bucket used\n  * @return the RiskPro Tec Price [using reservePrecision].\n  */\n  function bucketRiskProTecPrice(bytes32 bucket) public view returns(uint256) {\n    uint256 nRiskPro = riskProxManager.getBucketNRiskPro(bucket);\n    uint256 lb = lockedReserveTokens(bucket);\n    uint256 nReserve = riskProxManager.getBucketNReserve(bucket);\n\n    return mocLibConfig.riskProTecPrice(nReserve, lb, nRiskPro);\n  }\n\n  /**\n  * @dev ReserveTokens price of RiskPro with spot discount applied\n  * @return the RiskPro Tec Price [using reservePrecision].\n  */\n  function riskProDiscountPrice() public view returns(uint256) {\n    uint256 riskProTecprice = riskProTecPrice();\n    uint256 discountRate = riskProSpotDiscountRate();\n\n    return mocLibConfig.applyDiscountRate(riskProTecprice, discountRate);\n  }\n\n  /**\n  * @dev RiskPro USD PRICE\n  * @return the RiskPro USD Price [using mocPrecision]\n  */\n  function riskProUsdPrice() public view returns(uint256) {\n    uint256 riskProResTokenPrice = riskProTecPrice();\n    uint256 reservePrice = getReserveTokenPrice();\n\n    return reservePrice.mul(riskProResTokenPrice).div(mocLibConfig.reservePrecision);\n  }\n\n /**\n  * @dev GLOBAL max riskProx to mint\n  * @param bucket Name of the bucket used\n  * @return max RiskPro allowed to be spent to mint RiskProx [using reservePrecision]\n  **/\n  function maxRiskProxRiskProValue(bytes32 bucket) public view returns(uint256) {\n    uint256 resTokensValue = maxRiskProxResTokenValue(bucket);\n\n    return mocLibConfig.maxRiskProWithResTokens(resTokensValue, riskProTecPrice());\n  }\n\n  /**\n  * @dev BUCKET RiskProx price in RiskPro\n  * @param bucket Name of the bucket used\n  * @return RiskPro RiskPro Price [[using mocPrecision]Precision].\n  */\n  function riskProxRiskProPrice(bytes32 bucket) public view returns(uint256) {\n    // Otherwise, it reverts.\n    if (state == States.Liquidated) {\n      return 0;\n    }\n\n    uint256 riskProxResTokenPrice = bucketRiskProTecPrice(bucket);\n    uint256 riskProResTokenPrice = riskProTecPrice();\n\n    return mocLibConfig.riskProxRiskProPrice(riskProxResTokenPrice, riskProResTokenPrice);\n  }\n\n  /**\n  * @dev GLOBAL ReserveTokens Discount rate to apply to RiskProPrice.\n  * @return RiskPro discount rate [using DISCOUNT_PRECISION].\n   */\n  function riskProSpotDiscountRate() public view returns(uint256) {\n    uint256 cov = globalCoverage();\n\n    return mocLibConfig.riskProSpotDiscountRate(riskProMaxDiscountRate, liq, utpdu, cov);\n  }\n\n  /**\n    @dev Calculates the number of days to next settlement based dayBlockSpan\n   */\n  function daysToSettlement() public view returns(uint256) {\n    return blocksToSettlement().mul(mocLibConfig.dayPrecision).div(dayBlockSpan);\n  }\n\n  /**\n    @dev Number of blocks to settlement\n   */\n  function blocksToSettlement() public view returns(uint256) {\n    if (mocSettlement.nextSettlementBlock() <= block.number) {\n      return 0;\n    }\n\n    return mocSettlement.nextSettlementBlock().sub(block.number);\n  }\n\n  /**\n   * @dev Verifies if forced liquidation is reached checking if globalCoverage <= liquidation (currently 1.04)\n   * @return true if liquidation state is reached, false otherwise\n   */\n  function isLiquidationReached() public view returns(bool) {\n    uint256 cov = globalCoverage();\n    if (state != States.Liquidated && cov <= liq)\n      return true;\n    return false;\n  }\n\n  /**\n    @dev Returns the price to use for stableToken redeem in a liquidation event\n   */\n  function getLiquidationPrice() public view returns(uint256) {\n    return liquidationPrice;\n  }\n\n  function getBucketNReserve(bytes32 bucket) public view returns(uint256) {\n    return riskProxManager.getBucketNReserve(bucket);\n  }\n\n  function getBucketNRiskPro(bytes32 bucket) public view returns(uint256) {\n    return riskProxManager.getBucketNRiskPro(bucket);\n  }\n\n  function getBucketNStableToken(bytes32 bucket) public view returns(uint256) {\n    return riskProxManager.getBucketNStableToken(bucket);\n  }\n\n  function getBucketCobj(bytes32 bucket) public view returns(uint256) {\n    return riskProxManager.getBucketCobj(bucket);\n  }\n\n  function getInrateBag(bytes32 bucket) public view returns(uint256) {\n    return riskProxManager.getInrateBag(bucket);\n  }\n\n  /**********************\n    ReserveTokens PRICE PROVIDER\n   *********************/\n\n  function getBcons() public view returns(uint256) {\n    return Math.min(getReserveTokenPrice(), getExponentalMovingAverage());\n  }\n\n  function getReserveTokenPrice() public view returns(uint256) {\n    (bytes32 price, bool has) = priceProvider.peek();\n    require(has, \"Oracle have no Price\");\n\n    return uint256(price);\n  }\n\n\n  function calculateReserveTokenMovingAverage() public {\n    setExponentalMovingAverage(getReserveTokenPrice());\n  }\n\n\n\n  /**\n   * @dev return the value of the liq threshold configuration param\n   * @return liq threshold, currently 1.04\n   */\n  function getLiq() public view returns(uint256) {\n    return liq;\n  }\n\n  /**\n   * @dev sets the value of the liq threshold configuration param\n   * @param _liq liquidation threshold\n   */\n  function setLiq(uint _liq) public onlyAuthorizedChanger(){\n    liq = _liq;\n  }\n\n  /**\n   * @dev return the value of the utpdu threshold configuration param\n   * @return utpdu Universal TPro discount sales coverage threshold\n   */\n  function getUtpdu() public view returns(uint256) {\n    return utpdu;\n  }\n\n  /**\n   * @dev sets the value of the utpdu threshold configuration param\n   * @param _utpdu Universal TPro discount sales coverage threshold\n   */\n  function setUtpdu(uint _utpdu) public onlyAuthorizedChanger(){\n    utpdu = _utpdu;\n  }\n\n  /**\n   * @dev returns the relation between StableToken and dollar. By default it is 1.\n   * @return peg relation between StableToken and dollar\n   */\n  function getPeg() public view returns(uint256) {\n    return peg;\n  }\n\n  /**\n   * @dev sets the relation between StableToken and dollar. By default it is 1.\n   * @param _peg relation between StableToken and dollar\n   */\n  function setPeg(uint _peg) public onlyAuthorizedChanger(){\n    peg = _peg;\n  }\n\n  function nextState() public {\n    // There is no coming back from Liquidation\n    if (state == States.Liquidated)\n      return;\n\n    States prevState = state;\n    calculateReserveTokenMovingAverage();\n    uint256 cov = globalCoverage();\n    if (cov <= liq) {\n      setLiquidationPrice();\n      state = States.Liquidated;\n    } else if (cov > liq && cov <= utpdu) {\n      state = States.RiskProDiscount;\n    } else if (cov > utpdu && cov <= cobj()) {\n      state = States.BelowCobj;\n    } else {\n      state = States.AboveCobj;\n    }\n\n    if (prevState != state)\n      emit StateTransition(state);\n  }\n\n\n  /**\n    @dev Calculates price at liquidation event as the relation between\n    the stableToken total supply and the amount of ReserveTokens available to distribute\n   */\n  function setLiquidationPrice() internal {\n    // When coverage is below 1, the amount to\n    // distribute is all the ReserveTokens in the contract\n    uint256 resTokenscAvailable = Math.min(globalLockedReserveTokens(), reserves);\n\n    liquidationPrice = mocLibConfig.liquidationPrice(resTokenscAvailable, stableTokenTotalSupply());\n  }\n\n  function initializeValues(\n    address _governor,\n    address _priceProvider,\n    uint256 _liq,\n    uint256 _utpdu,\n    uint256 _maxDiscRate,\n    uint256 _dayBlockSpan) internal {\n    liq = _liq;\n    utpdu = _utpdu;\n    riskProMaxDiscountRate = _maxDiscRate;\n    dayBlockSpan = _dayBlockSpan;\n    governor = IGovernor(_governor);\n    priceProvider = PriceProvider(_priceProvider);\n    // Default values\n    state = States.AboveCobj;\n    peg = 1;\n  }\n\n  function initializeContracts() internal  {\n    mocSettlement = MoCSettlement(connector.mocSettlement());\n    stableToken = StableToken(connector.stableToken());\n    riskProToken = RiskProToken(connector.riskProToken());\n    riskProxManager = MoCRiskProxManager(connector.riskProxManager());\n    mocConverter = MoCConverter(connector.mocConverter());\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\ncontract MoCExchange {\n    function redeemAllStableToken(address origin, address payable destination) public returns(uint256);\n}\n\ncontract MoCBurnoutEvents {\n  event BurnoutAddressSet(address indexed account, address burnoutAddress);\n  event BurnoutExecuted(uint256 addressCount);\n  event BurnoutAddressProcessed(address indexed account, address burnoutAddress, uint256 amount);\n}\n\n/**\n * @title Burnout Queue for liquidation event\n * @dev Track all Burnout addresses that will be used in liquidation event. When liquidation happens\n * all StableTokens of the holders in the queue will be sent to the corresponding burnout address.\n */\ncontract MoCBurnout is MoCBase, MoCBurnoutEvents, PartialExecution {\n  using SafeMath for uint256;\n\n  // Contracts\n  StableToken internal stableToken;\n  MoCExchange internal mocExchange;\n  MoCState internal mocState;\n\n  bytes32 internal constant BURNOUT_TASK = keccak256(\"Burnout\");\n\n  // Burnout addresses\n  mapping(address => address payable) burnoutBook;\n  // Used to iterate in liquidation event\n  address[] private burnoutQueue;\n  uint256 private numElements;\n\n  function initialize(\n    address connectorAddress\n    ) public initializer {\n    initializeBase(connectorAddress);\n    initializeContracts();\n    initializeTasks();\n  }\n\n  function isBurnoutRunning() public view returns(bool) {\n    return isTaskRunning(BURNOUT_TASK);\n  }\n\n  /**\n    @dev Return current burnout queue size\n   */\n  function burnoutQueueSize() public view returns(uint256) {\n    return numElements;\n  }\n\n  /**\n    @dev Returns the burnout address for _who address\n    @param _who Address to find burnout address\n    @return Burnout address\n   */\n  function getBurnoutAddress(address _who) public view returns(address) {\n    return burnoutBook[_who];\n  }\n\n  /**\n    @dev push a new burnout address to the queue for _who\n    @param _who address for which set the burnout address\n    @param _burnout address to send stableTokens in liquidation event\n  */\n  function pushBurnoutAddress(address _who, address payable _burnout) public onlyWhitelisted(msg.sender) {\n    require(_burnout != address(0x0), \"Burnout address can't be 0x0\");\n\n    if (burnoutBook[_who] == address(0x0)) {\n      pushAddressToQueue(_who);\n    }\n\n    burnoutBook[_who] = _burnout;\n    emit BurnoutAddressSet(_who, _burnout);\n  }\n\n  /**\n    @dev Iterate over the burnout address book and redeem stableTokens\n  **/\n  function executeBurnout(uint256 steps) public onlyWhitelisted(msg.sender) {\n    executeTask(BURNOUT_TASK, steps);\n  }\n\n  function burnoutStep(uint256 index) internal {\n    address account = burnoutQueue[index];\n    address payable burnout = burnoutBook[account];\n    uint256 reserveTotal = mocExchange.redeemAllStableToken(account, burnout);\n\n    emit BurnoutAddressProcessed(account, burnout, reserveTotal);\n  }\n\n  function finishBurnout() internal {\n    emit BurnoutExecuted(numElements);\n    clearBook();\n  }\n\n  function burnoutStepCount() internal view returns(uint256) {\n    return numElements;\n  }\n\n  function pushAddressToQueue(address _who) internal {\n    if (numElements == burnoutQueue.length) {\n      burnoutQueue.length += 1;\n    }\n\n    burnoutQueue[numElements++] = _who;\n  }\n\n  /**\n    @dev empty the queue\n   */\n  function clearBook() internal {\n    numElements = 0;\n  }\n\n  function initializeContracts() internal {\n    stableToken = StableToken(connector.stableToken());\n    mocExchange = MoCExchange(connector.mocExchange());\n    mocState = MoCState(connector.mocState());\n  }\n\n  /**\n    @dev Create Task structures for Settlement execution\n  */\n  function initializeTasks() internal {\n    createTask(BURNOUT_TASK, burnoutStepCount, burnoutStep, noFunction, finishBurnout);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n",
      "file": "MoCBurnout_flat.sol"
    }
  ],
  "libraries": {
    "MoCHelperLib": "0xBBa730F602584ca91ca26334510c00ad6e35f71e"
  },
  "creationData": {
    "blockHash": "0x3871eee7763eb053a2a334913ead979940b92038a31286932484f75d466c71e7",
    "blockNumber": 1765123,
    "transactionHash": "0x76c5edcc7984a3a5c62c23a7697c52786d26d82b8df544ef787164ae556ecbe3",
    "timestamp": 1570254179
  }
}