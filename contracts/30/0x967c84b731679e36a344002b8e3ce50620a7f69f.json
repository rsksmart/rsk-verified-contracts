{
    "address": "0x967c84b731679e36a344002b8e3ce50620a7f69f",
    "net": {
        "id": "30",
        "name": "RSK Mainnet"
    },
    "name": "Timelock",
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        }
    },
    "version": "0.5.17+commit.d19bba13",
    "source": "pragma solidity ^0.5.17;\n\nimport \"../openzeppelin/SafeMath.sol\";\nimport \"./ErrorDecoder.sol\";\n\ninterface ITimelock {\n\tfunction delay() external view returns (uint256);\n\n\tfunction GRACE_PERIOD() external view returns (uint256);\n\n\tfunction acceptAdmin() external;\n\n\tfunction queuedTransactions(bytes32 hash) external view returns (bool);\n\n\tfunction queueTransaction(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring calldata signature,\n\t\tbytes calldata data,\n\t\tuint256 eta\n\t) external returns (bytes32);\n\n\tfunction cancelTransaction(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring calldata signature,\n\t\tbytes calldata data,\n\t\tuint256 eta\n\t) external;\n\n\tfunction executeTransaction(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring calldata signature,\n\t\tbytes calldata data,\n\t\tuint256 eta\n\t) external payable returns (bytes memory);\n}\n\ncontract Timelock is ErrorDecoder, ITimelock {\n\tusing SafeMath for uint256;\n\n\tuint256 public constant GRACE_PERIOD = 14 days;\n\tuint256 public constant MINIMUM_DELAY = 3 hours;\n\tuint256 public constant MAXIMUM_DELAY = 30 days;\n\n\taddress public admin;\n\taddress public pendingAdmin;\n\tuint256 public delay;\n\n\tmapping(bytes32 => bool) public queuedTransactions;\n\n\tevent NewAdmin(address indexed newAdmin);\n\tevent NewPendingAdmin(address indexed newPendingAdmin);\n\tevent NewDelay(uint256 indexed newDelay);\n\tevent CancelTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n\tevent ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n\tevent QueueTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n\n\tconstructor(address admin_, uint256 delay_) public {\n\t\trequire(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n\t\trequire(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\n\t\tadmin = admin_;\n\t\tdelay = delay_;\n\t}\n\n\tfunction() external payable {}\n\n\tfunction setDelay(uint256 delay_) public {\n\t\trequire(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n\t\trequire(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n\t\trequire(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\t\tdelay = delay_;\n\n\t\temit NewDelay(delay);\n\t}\n\n\tfunction acceptAdmin() public {\n\t\trequire(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n\t\tadmin = msg.sender;\n\t\tpendingAdmin = address(0);\n\n\t\temit NewAdmin(admin);\n\t}\n\n\tfunction setPendingAdmin(address pendingAdmin_) public {\n\t\trequire(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n\t\tpendingAdmin = pendingAdmin_;\n\n\t\temit NewPendingAdmin(pendingAdmin);\n\t}\n\n\tfunction queueTransaction(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring memory signature,\n\t\tbytes memory data,\n\t\tuint256 eta\n\t) public returns (bytes32) {\n\t\trequire(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n\t\trequire(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n\t\tbytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n\t\tqueuedTransactions[txHash] = true;\n\n\t\temit QueueTransaction(txHash, target, value, signature, data, eta);\n\t\treturn txHash;\n\t}\n\n\tfunction cancelTransaction(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring memory signature,\n\t\tbytes memory data,\n\t\tuint256 eta\n\t) public {\n\t\trequire(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n\t\tbytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n\t\tqueuedTransactions[txHash] = false;\n\n\t\temit CancelTransaction(txHash, target, value, signature, data, eta);\n\t}\n\n\tfunction executeTransaction(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring memory signature,\n\t\tbytes memory data,\n\t\tuint256 eta\n\t) public payable returns (bytes memory) {\n\t\trequire(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n\t\tbytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n\t\trequire(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n\t\trequire(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n\t\trequire(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n\t\tqueuedTransactions[txHash] = false;\n\n\t\tbytes memory callData;\n\n\t\tif (bytes(signature).length == 0) {\n\t\t\tcallData = data;\n\t\t} else {\n\t\t\tcallData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n\t\t}\n\n\t\t// solium-disable-next-line security/no-call-value\n\t\t(bool success, bytes memory returnData) = target.call.value(value)(callData);\n\t\tif (!success) {\n\t\t\tif (returnData.length <= ERROR_MESSAGE_SHIFT) {\n\t\t\t\trevert(\"Timelock::executeTransaction: Transaction execution reverted.\");\n\t\t\t} else {\n\t\t\t\trevert(_addErrorMessage(\"Timelock::executeTransaction: \", string(returnData)));\n\t\t\t}\n\t\t}\n\n\t\temit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n\t\treturn returnData;\n\t}\n\n\tfunction getBlockTimestamp() internal view returns (uint256) {\n\t\t// solium-disable-next-line security/no-block-members\n\t\treturn block.timestamp;\n\t}\n}\n",
    "imports": [
        {
            "name": "Timelock.sol",
            "contents": "pragma solidity ^0.5.17;\n\nimport \"../openzeppelin/SafeMath.sol\";\nimport \"./ErrorDecoder.sol\";\n\ninterface ITimelock {\n\tfunction delay() external view returns (uint256);\n\n\tfunction GRACE_PERIOD() external view returns (uint256);\n\n\tfunction acceptAdmin() external;\n\n\tfunction queuedTransactions(bytes32 hash) external view returns (bool);\n\n\tfunction queueTransaction(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring calldata signature,\n\t\tbytes calldata data,\n\t\tuint256 eta\n\t) external returns (bytes32);\n\n\tfunction cancelTransaction(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring calldata signature,\n\t\tbytes calldata data,\n\t\tuint256 eta\n\t) external;\n\n\tfunction executeTransaction(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring calldata signature,\n\t\tbytes calldata data,\n\t\tuint256 eta\n\t) external payable returns (bytes memory);\n}\n\ncontract Timelock is ErrorDecoder, ITimelock {\n\tusing SafeMath for uint256;\n\n\tuint256 public constant GRACE_PERIOD = 14 days;\n\tuint256 public constant MINIMUM_DELAY = 3 hours;\n\tuint256 public constant MAXIMUM_DELAY = 30 days;\n\n\taddress public admin;\n\taddress public pendingAdmin;\n\tuint256 public delay;\n\n\tmapping(bytes32 => bool) public queuedTransactions;\n\n\tevent NewAdmin(address indexed newAdmin);\n\tevent NewPendingAdmin(address indexed newPendingAdmin);\n\tevent NewDelay(uint256 indexed newDelay);\n\tevent CancelTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n\tevent ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n\tevent QueueTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n\n\tconstructor(address admin_, uint256 delay_) public {\n\t\trequire(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n\t\trequire(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\n\t\tadmin = admin_;\n\t\tdelay = delay_;\n\t}\n\n\tfunction() external payable {}\n\n\tfunction setDelay(uint256 delay_) public {\n\t\trequire(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n\t\trequire(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n\t\trequire(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\t\tdelay = delay_;\n\n\t\temit NewDelay(delay);\n\t}\n\n\tfunction acceptAdmin() public {\n\t\trequire(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n\t\tadmin = msg.sender;\n\t\tpendingAdmin = address(0);\n\n\t\temit NewAdmin(admin);\n\t}\n\n\tfunction setPendingAdmin(address pendingAdmin_) public {\n\t\trequire(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n\t\tpendingAdmin = pendingAdmin_;\n\n\t\temit NewPendingAdmin(pendingAdmin);\n\t}\n\n\tfunction queueTransaction(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring memory signature,\n\t\tbytes memory data,\n\t\tuint256 eta\n\t) public returns (bytes32) {\n\t\trequire(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n\t\trequire(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n\t\tbytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n\t\tqueuedTransactions[txHash] = true;\n\n\t\temit QueueTransaction(txHash, target, value, signature, data, eta);\n\t\treturn txHash;\n\t}\n\n\tfunction cancelTransaction(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring memory signature,\n\t\tbytes memory data,\n\t\tuint256 eta\n\t) public {\n\t\trequire(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n\t\tbytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n\t\tqueuedTransactions[txHash] = false;\n\n\t\temit CancelTransaction(txHash, target, value, signature, data, eta);\n\t}\n\n\tfunction executeTransaction(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring memory signature,\n\t\tbytes memory data,\n\t\tuint256 eta\n\t) public payable returns (bytes memory) {\n\t\trequire(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n\t\tbytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n\t\trequire(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n\t\trequire(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n\t\trequire(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n\t\tqueuedTransactions[txHash] = false;\n\n\t\tbytes memory callData;\n\n\t\tif (bytes(signature).length == 0) {\n\t\t\tcallData = data;\n\t\t} else {\n\t\t\tcallData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n\t\t}\n\n\t\t// solium-disable-next-line security/no-call-value\n\t\t(bool success, bytes memory returnData) = target.call.value(value)(callData);\n\t\tif (!success) {\n\t\t\tif (returnData.length <= ERROR_MESSAGE_SHIFT) {\n\t\t\t\trevert(\"Timelock::executeTransaction: Transaction execution reverted.\");\n\t\t\t} else {\n\t\t\t\trevert(_addErrorMessage(\"Timelock::executeTransaction: \", string(returnData)));\n\t\t\t}\n\t\t}\n\n\t\temit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n\t\treturn returnData;\n\t}\n\n\tfunction getBlockTimestamp() internal view returns (uint256) {\n\t\t// solium-disable-next-line security/no-block-members\n\t\treturn block.timestamp;\n\t}\n}\n",
            "file": "Timelock.sol"
        },
        {
            "name": "ErrorDecoder.sol",
            "contents": "pragma solidity ^0.5.17;\n\ncontract ErrorDecoder {\n\t//4 bytes - 0x08c379a0 - method id\n\t//32 bytes - 2 parameters\n\t//32 bytes - bool, result\n\t//32 ... bytes - string, error message\n\tuint256 constant ERROR_MESSAGE_SHIFT = 68;\n\n\tfunction _addErrorMessage(string memory str1, string memory str2) internal pure returns (string memory) {\n\t\tbytes memory bytesStr1 = bytes(str1);\n\t\tbytes memory bytesStr2 = bytes(str2);\n\t\tstring memory str12 = new string(bytesStr1.length + bytesStr2.length - ERROR_MESSAGE_SHIFT);\n\t\tbytes memory bytesStr12 = bytes(str12);\n\t\tuint256 j = 0;\n\t\tfor (uint256 i = 0; i < bytesStr1.length; i++) {\n\t\t\tbytesStr12[j++] = bytesStr1[i];\n\t\t}\n\t\tfor (uint256 i = ERROR_MESSAGE_SHIFT; i < bytesStr2.length; i++) {\n\t\t\tbytesStr12[j++] = bytesStr2[i];\n\t\t}\n\t\treturn string(bytesStr12);\n\t}\n}\n"
        },
        {
            "name": "SafeMath.sol",
            "contents": "pragma solidity >=0.5.0 <0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n\t/**\n\t * @dev Returns the addition of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `+` operator.\n\t *\n\t * Requirements:\n\t * - Addition cannot overflow.\n\t */\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\trequire(c >= a, \"SafeMath: addition overflow\");\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t * - Subtraction cannot overflow.\n\t */\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn sub(a, b, \"SafeMath: subtraction overflow\");\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t * - Subtraction cannot overflow.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction sub(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\trequire(b <= a, errorMessage);\n\t\tuint256 c = a - b;\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the multiplication of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `*` operator.\n\t *\n\t * Requirements:\n\t * - Multiplication cannot overflow.\n\t */\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\t\t// benefit is lost if 'b' is also tested.\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 c = a * b;\n\t\trequire(c / a == b, \"SafeMath: multiplication overflow\");\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers. Reverts on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn div(a, b, \"SafeMath: division by zero\");\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction div(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\t// Solidity only automatically asserts when dividing by 0\n\t\trequire(b > 0, errorMessage);\n\t\tuint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn mod(a, b, \"SafeMath: modulo by zero\");\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts with custom message when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction mod(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\trequire(b != 0, errorMessage);\n\t\treturn a % b;\n\t}\n\n\tfunction min256(uint256 _a, uint256 _b) internal pure returns (uint256) {\n\t\treturn _a < _b ? _a : _b;\n\t}\n}\n"
        }
    ],
    "libraries": {},
    "constructorArguments": [
        "0x27d55f5668ef4438635bdce0adca083507e77752",
        "172800"
    ],
    "creationData": {
        "blockHash": "0x518f2b744b88b1ac55b324b9924c54220763dc9191bc507708ccf02a42f03b58",
        "blockNumber": 3100268,
        "transactionHash": "0xbb39c10f7b2dfe4a8254f0cb712cf231c6a7d01c4b1ba593b3e2daf10ac32daa",
        "timestamp": 1613125855
    }
}