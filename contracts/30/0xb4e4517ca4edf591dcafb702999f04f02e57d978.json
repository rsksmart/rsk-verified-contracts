{
    "address": "0xb4e4517ca4edf591dcafb702999f04f02e57d978",
    "net": {
        "id": "30",
        "name": "RSK Mainnet"
    },
    "name": "LockedSOV",
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        }
    },
    "version": "0.5.17+commit.d19bba13",
    "source": "// File: contracts/openzeppelin/SafeMath.sol\n\npragma solidity >=0.5.0 <0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n\t/**\n\t * @dev Returns the addition of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `+` operator.\n\t *\n\t * Requirements:\n\t * - Addition cannot overflow.\n\t */\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\trequire(c >= a, \"SafeMath: addition overflow\");\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t * - Subtraction cannot overflow.\n\t */\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn sub(a, b, \"SafeMath: subtraction overflow\");\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t * - Subtraction cannot overflow.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction sub(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\trequire(b <= a, errorMessage);\n\t\tuint256 c = a - b;\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the multiplication of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `*` operator.\n\t *\n\t * Requirements:\n\t * - Multiplication cannot overflow.\n\t */\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\t\t// benefit is lost if 'b' is also tested.\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 c = a * b;\n\t\trequire(c / a == b, \"SafeMath: multiplication overflow\");\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers. Reverts on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn div(a, b, \"SafeMath: division by zero\");\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction div(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\t// Solidity only automatically asserts when dividing by 0\n\t\trequire(b != 0, errorMessage);\n\t\tuint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Integer division of two numbers, rounding up and truncating the quotient\n\t */\n\tfunction divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn divCeil(a, b, \"SafeMath: division by zero\");\n\t}\n\n\t/**\n\t * @dev Integer division of two numbers, rounding up and truncating the quotient\n\t */\n\tfunction divCeil(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\t// Solidity only automatically asserts when dividing by 0\n\t\trequire(b != 0, errorMessage);\n\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 c = ((a - 1) / b) + 1;\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn mod(a, b, \"SafeMath: modulo by zero\");\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts with custom message when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction mod(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\trequire(b != 0, errorMessage);\n\t\treturn a % b;\n\t}\n\n\tfunction min256(uint256 _a, uint256 _b) internal pure returns (uint256) {\n\t\treturn _a < _b ? _a : _b;\n\t}\n}\n\n// File: contracts/interfaces/IERC20.sol\n\n/**\n * Copyright 2017-2021, bZeroX, LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0.\n */\n\npragma solidity >=0.5.0 <0.6.0;\n\ncontract IERC20 {\n\tstring public name;\n\tuint8 public decimals;\n\tstring public symbol;\n\n\tfunction totalSupply() public view returns (uint256);\n\n\tfunction balanceOf(address _who) public view returns (uint256);\n\n\tfunction allowance(address _owner, address _spender) public view returns (uint256);\n\n\tfunction approve(address _spender, uint256 _value) public returns (bool);\n\n\tfunction transfer(address _to, uint256 _value) public returns (bool);\n\n\tfunction transferFrom(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _value\n\t) public returns (bool);\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/openzeppelin/Context.sol\n\npragma solidity >=0.5.0 <0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n\t// Empty internal constructor, to prevent people from mistakenly deploying\n\t// an instance of this contract, which should be used via inheritance.\n\tconstructor() internal {}\n\n\t// solhint-disable-previous-line no-empty-blocks\n\n\tfunction _msgSender() internal view returns (address payable) {\n\t\treturn msg.sender;\n\t}\n\n\tfunction _msgData() internal view returns (bytes memory) {\n\t\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\t\treturn msg.data;\n\t}\n}\n\n// File: contracts/openzeppelin/Ownable.sol\n\npragma solidity >=0.5.0 <0.6.0;\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n\taddress private _owner;\n\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\t/**\n\t * @dev Initializes the contract setting the deployer as the initial owner.\n\t */\n\tconstructor() internal {\n\t\taddress msgSender = _msgSender();\n\t\t_owner = msgSender;\n\t\temit OwnershipTransferred(address(0), msgSender);\n\t}\n\n\t/**\n\t * @dev Returns the address of the current owner.\n\t */\n\tfunction owner() public view returns (address) {\n\t\treturn _owner;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the owner.\n\t */\n\tmodifier onlyOwner() {\n\t\trequire(isOwner(), \"unauthorized\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Returns true if the caller is the current owner.\n\t */\n\tfunction isOwner() public view returns (bool) {\n\t\treturn _msgSender() == _owner;\n\t}\n\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t * Can only be called by the current owner.\n\t */\n\tfunction transferOwnership(address newOwner) public onlyOwner {\n\t\t_transferOwnership(newOwner);\n\t}\n\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t */\n\tfunction _transferOwnership(address newOwner) internal {\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\t\temit OwnershipTransferred(_owner, newOwner);\n\t\t_owner = newOwner;\n\t}\n}\n\n// File: contracts/governance/Staking/IStaking.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title Interface for contract governance/Staking/Staking.sol\n * @dev Interfaces are used to cast a contract address into a callable instance.\n */\ninterface IStaking {\n\tfunction stakesBySchedule(\n\t\tuint256 amount,\n\t\tuint256 cliff,\n\t\tuint256 duration,\n\t\tuint256 intervalLength,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) external;\n\n\tfunction stake(\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) external;\n\n\tfunction getPriorVotes(\n\t\taddress account,\n\t\tuint256 blockNumber,\n\t\tuint256 date\n\t) external view returns (uint96);\n\n\tfunction getPriorTotalVotingPower(uint32 blockNumber, uint256 time) external view returns (uint96);\n\n\tfunction getPriorWeightedStake(\n\t\taddress account,\n\t\tuint256 blockNumber,\n\t\tuint256 date\n\t) external view returns (uint96);\n\n\tfunction timestampToLockDate(uint256 timestamp) external view returns (uint256 lockDate);\n}\n\n// File: contracts/governance/IFeeSharingProxy.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title Interface for contract governance/FeeSharingProxy.sol\n * @dev Interfaces are used to cast a contract address into a callable instance.\n * */\ninterface IFeeSharingProxy {\n\tfunction withdrawFees(address _token) external;\n\n\tfunction transferTokens(address _token, uint96 _amount) external;\n\n\tfunction withdraw(\n\t\taddress _loanPoolToken,\n\t\tuint32 _maxCheckpoints,\n\t\taddress _receiver\n\t) external;\n}\n\n// File: contracts/governance/Vesting/IVestingFactory.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title Interface for Vesting Factory contract.\n * @dev Interfaces are used to cast a contract address into a callable instance.\n * This interface is used by VestingFactory contract to override empty\n * implemention of deployVesting and deployTeamVesting functions\n * and on VestingRegistry contract to use an instance of VestingFactory.\n */\ninterface IVestingFactory {\n\tfunction deployVesting(\n\t\taddress _SOV,\n\t\taddress _staking,\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration,\n\t\taddress _feeSharing,\n\t\taddress _owner\n\t) external returns (address);\n\n\tfunction deployTeamVesting(\n\t\taddress _SOV,\n\t\taddress _staking,\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration,\n\t\taddress _feeSharing,\n\t\taddress _owner\n\t) external returns (address);\n}\n\n// File: contracts/governance/Vesting/IVesting.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title Interface for Vesting contract.\n * @dev Interfaces are used to cast a contract address into a callable instance.\n * This interface is used by VestingLogic contract to implement stakeTokens function\n * and on VestingRegistry contract to call IVesting(vesting).stakeTokens function\n * at a vesting instance.\n */\ninterface IVesting {\n\tfunction duration() external returns (uint256);\n\n\tfunction endDate() external returns (uint256);\n\n\tfunction stakeTokens(uint256 amount) external;\n}\n\n// File: contracts/governance/Vesting/ITeamVesting.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title Interface for TeamVesting contract.\n * @dev Interfaces are used to cast a contract address into a callable instance.\n * This interface is used by Staking contract to call governanceWithdrawTokens\n * function having the vesting contract instance address.\n */\ninterface ITeamVesting {\n\tfunction governanceWithdrawTokens(address receiver) external;\n}\n\n// File: contracts/governance/Vesting/VestingRegistry.sol\n\npragma solidity ^0.5.17;\n\n\n\n\n\n\n\n\n\n/**\n * @title Vesting Registry contract.\n *\n * @notice On January 25, 2020, Sovryn launched the Genesis Reservation system.\n * Sovryn community members who controlled a special NFT were granted access to\n * stake BTC or rBTC for cSOV tokens at a rate of 2500 satoshis per cSOV. Per\n * SIP-0003, up to 2,000,000 cSOV were made available in the Genesis event,\n * which will be redeemable on a 1:1 basis for cSOV, subject to approval by\n * existing SOV holders.\n *\n * On 15 Feb 2021 Sovryn is taking another step in its journey to decentralized\n * financial sovereignty with the vote on SIP 0005. This proposal will enable\n * participants of the Genesis Reservation system to redeem their reserved cSOV\n * tokens for SOV. They will also have the choice to redeem cSOV for rBTC if\n * they decide to exit the system.\n *\n * This contract deals with the vesting and redemption of cSOV tokens.\n * */\ncontract VestingRegistry is Ownable {\n\tusing SafeMath for uint256;\n\n\t/* Storage */\n\n\t/// @notice Constant used for computing the vesting dates.\n\tuint256 public constant FOUR_WEEKS = 4 weeks;\n\n\tuint256 public constant CSOV_VESTING_CLIFF = FOUR_WEEKS;\n\tuint256 public constant CSOV_VESTING_DURATION = 10 * FOUR_WEEKS;\n\n\tIVestingFactory public vestingFactory;\n\n\t/// @notice The SOV token contract.\n\taddress public SOV;\n\n\t/// @notice The cSOV token contracts.\n\taddress[] public CSOVtokens;\n\n\tuint256 public priceSats;\n\n\t/// @notice The staking contract address.\n\taddress public staking;\n\n\t/// @notice Fee sharing proxy.\n\taddress public feeSharingProxy;\n\n\t/// @notice The vesting owner (e.g. governance timelock address).\n\taddress public vestingOwner;\n\n\t/// @dev TODO: Add to the documentation: address can have only one vesting of each type.\n\t/// @dev user => vesting type => vesting contract.\n\tmapping(address => mapping(uint256 => address)) public vestingContracts;\n\n\t/**\n\t * @dev Struct can be created to save storage slots, but it doesn't make\n\t * sense. We don't have a lot of blacklisted accounts or account with\n\t * locked amount.\n\t * */\n\n\t/// @dev user => flag whether user has already exchange cSOV or got a reimbursement.\n\tmapping(address => bool) public processedList;\n\n\t/// @dev user => flag whether user shouldn't be able to exchange or reimburse.\n\tmapping(address => bool) public blacklist;\n\n\t/// @dev user => amount of tokens should not be processed.\n\tmapping(address => uint256) public lockedAmount;\n\n\t/// @dev user => flag whether user has admin role.\n\tmapping(address => bool) public admins;\n\n\tenum VestingType {\n\t\tTeamVesting, // MultisigVesting\n\t\tVesting // TokenHolderVesting\n\t}\n\n\t/* Events */\n\n\tevent CSOVReImburse(address from, uint256 CSOVamount, uint256 reImburseAmount);\n\tevent CSOVTokensExchanged(address indexed caller, uint256 amount);\n\tevent SOVTransferred(address indexed receiver, uint256 amount);\n\tevent VestingCreated(address indexed tokenOwner, address vesting, uint256 cliff, uint256 duration, uint256 amount);\n\tevent TeamVestingCreated(address indexed tokenOwner, address vesting, uint256 cliff, uint256 duration, uint256 amount);\n\tevent TokensStaked(address indexed vesting, uint256 amount);\n\tevent AdminAdded(address admin);\n\tevent AdminRemoved(address admin);\n\n\t/* Functions */\n\n\t/**\n\t * @notice Contract deployment settings.\n\t * @param _vestingFactory The address of vesting factory contract.\n\t * @param _SOV The SOV token address.\n\t * @param _CSOVtokens The array of cSOV tokens.\n\t * @param _priceSats The price of cSOV tokens in satoshis.\n\t * @param _staking The address of staking contract.\n\t * @param _feeSharingProxy The address of fee sharing proxy contract.\n\t * @param _vestingOwner The address of an owner of vesting contract.\n\t * @dev On Sovryn the vesting owner is Exchequer Multisig.\n\t * According to SIP-0007 The Exchequer Multisig is designated to hold\n\t * certain funds in the form of rBTC and SOV, in order to allow for\n\t * flexible deployment of such funds on:\n\t *  + facilitating rBTC redemptions for Genesis pre-sale participants.\n\t *  + deploying of SOV for the purposes of exchange listings, market\n\t *    making, and partnerships with third parties.\n\t * */\n\tconstructor(\n\t\taddress _vestingFactory,\n\t\taddress _SOV,\n\t\taddress[] memory _CSOVtokens,\n\t\tuint256 _priceSats,\n\t\taddress _staking,\n\t\taddress _feeSharingProxy,\n\t\taddress _vestingOwner\n\t) public {\n\t\trequire(_SOV != address(0), \"SOV address invalid\");\n\t\trequire(_staking != address(0), \"staking address invalid\");\n\t\trequire(_feeSharingProxy != address(0), \"feeSharingProxy address invalid\");\n\t\trequire(_vestingOwner != address(0), \"vestingOwner address invalid\");\n\n\t\t_setVestingFactory(_vestingFactory);\n\t\t_setCSOVtokens(_CSOVtokens);\n\n\t\tSOV = _SOV;\n\t\tpriceSats = _priceSats;\n\t\tstaking = _staking;\n\t\tfeeSharingProxy = _feeSharingProxy;\n\t\tvestingOwner = _vestingOwner;\n\t}\n\n\t//---ACL------------------------------------------------------------------\n\n\t/**\n\t * @dev Throws if called by any account other than the owner or admin.\n\t * TODO: This ACL logic should be available on OpenZeppeling Ownable.sol\n\t * or on our own overriding sovrynOwnable. This same logic is repeated\n\t * on OriginInvestorsClaim.sol, TokenSender.sol and VestingRegistry2.sol\n\t */\n\tmodifier onlyAuthorized() {\n\t\trequire(isOwner() || admins[msg.sender], \"unauthorized\");\n\t\t_;\n\t}\n\n\t/**\n\t * @notice Add account to ACL.\n\t * @param _admin The addresses of the account to grant permissions.\n\t * */\n\tfunction addAdmin(address _admin) public onlyOwner {\n\t\tadmins[_admin] = true;\n\t\temit AdminAdded(_admin);\n\t}\n\n\t/**\n\t * @notice Remove account from ACL.\n\t * @param _admin The addresses of the account to revoke permissions.\n\t * */\n\tfunction removeAdmin(address _admin) public onlyOwner {\n\t\tadmins[_admin] = false;\n\t\temit AdminRemoved(_admin);\n\t}\n\n\t//---PostCSOV--------------------------------------------------------------\n\n\tmodifier isNotProcessed() {\n\t\trequire(!processedList[msg.sender], \"Address cannot be processed twice\");\n\t\t_;\n\t}\n\n\tmodifier isNotBlacklisted() {\n\t\trequire(!blacklist[msg.sender], \"Address blacklisted\");\n\t\t_;\n\t}\n\n\t/**\n\t * @notice cSOV payout to sender with rBTC currency.\n\t * 1.- Check holder cSOV balance by adding up every cSOV token balance.\n\t * 2.- ReImburse rBTC if funds available.\n\t * 3.- And store holder address in processedList.\n\t */\n\tfunction reImburse() public isNotProcessed isNotBlacklisted {\n\t\tuint256 CSOVAmountWei = 0;\n\t\tfor (uint256 i = 0; i < CSOVtokens.length; i++) {\n\t\t\taddress CSOV = CSOVtokens[i];\n\t\t\tuint256 balance = IERC20(CSOV).balanceOf(msg.sender);\n\t\t\tCSOVAmountWei = CSOVAmountWei.add(balance);\n\t\t}\n\n\t\trequire(CSOVAmountWei > lockedAmount[msg.sender], \"holder has no CSOV\");\n\t\tCSOVAmountWei -= lockedAmount[msg.sender];\n\t\tprocessedList[msg.sender] = true;\n\n\t\t/**\n\t\t * @dev Found and fixed the SIP-0007 bug on VestingRegistry::reImburse formula.\n\t\t * More details at Documenting Code issues at point 11 in\n\t\t * https://docs.google.com/document/d/10idTD1K6JvoBmtPKGuJ2Ub_mMh6qTLLlTP693GQKMyU/\n\t\t * Previous buggy code: uint256 reImburseAmount = (CSOVAmountWei.mul(priceSats)).div(10**10);\n\t\t * */\n\t\tuint256 reImburseAmount = (CSOVAmountWei.mul(priceSats)).div(10**8);\n\t\trequire(address(this).balance >= reImburseAmount, \"Not enough funds to reimburse\");\n\t\tmsg.sender.transfer(reImburseAmount);\n\n\t\temit CSOVReImburse(msg.sender, CSOVAmountWei, reImburseAmount);\n\t}\n\n\t/**\n\t * @notice Get contract balance.\n\t * @return The token balance of the contract.\n\t * */\n\tfunction budget() external view returns (uint256) {\n\t\tuint256 SCBudget = address(this).balance;\n\t\treturn SCBudget;\n\t}\n\n\t/**\n\t * @notice Deposit function to receiving value (rBTC).\n\t * */\n\tfunction deposit() public payable {}\n\n\t/**\n\t * @notice Send all contract balance to an account.\n\t * @param to The account address to send the balance to.\n\t * */\n\tfunction withdrawAll(address payable to) public onlyOwner {\n\t\tto.transfer(address(this).balance);\n\t}\n\n\t//--------------------------------------------------------------------------------------------------------------------------------------\n\n\t/**\n\t * @notice Sets vesting factory address. High level endpoint.\n\t * @param _vestingFactory The address of vesting factory contract.\n\t *\n\t * @dev Splitting code on two functions: high level and low level\n\t * is a pattern that makes easy to extend functionality in a readable way,\n\t * without accidentally breaking the actual action being performed.\n\t * For example, checks should be done on high level endpoint, while core\n\t * functionality should be coded on the low level function.\n\t * */\n\tfunction setVestingFactory(address _vestingFactory) public onlyOwner {\n\t\t_setVestingFactory(_vestingFactory);\n\t}\n\n\t/**\n\t * @notice Sets vesting factory address. Low level core function.\n\t * @param _vestingFactory The address of vesting factory contract.\n\t * */\n\tfunction _setVestingFactory(address _vestingFactory) internal {\n\t\trequire(_vestingFactory != address(0), \"vestingFactory address invalid\");\n\t\tvestingFactory = IVestingFactory(_vestingFactory);\n\t}\n\n\t/**\n\t * @notice Sets cSOV tokens array. High level endpoint.\n\t * @param _CSOVtokens The array of cSOV tokens.\n\t * */\n\tfunction setCSOVtokens(address[] memory _CSOVtokens) public onlyOwner {\n\t\t_setCSOVtokens(_CSOVtokens);\n\t}\n\n\t/**\n\t * @notice Sets cSOV tokens array by looping through input. Low level function.\n\t * @param _CSOVtokens The array of cSOV tokens.\n\t * */\n\tfunction _setCSOVtokens(address[] memory _CSOVtokens) internal {\n\t\tfor (uint256 i = 0; i < _CSOVtokens.length; i++) {\n\t\t\trequire(_CSOVtokens[i] != address(0), \"CSOV address invalid\");\n\t\t}\n\t\tCSOVtokens = _CSOVtokens;\n\t}\n\n\t/**\n\t * @notice Set blacklist flag (true/false).\n\t * @param _account The address to be blacklisted.\n\t * @param _blacklisted The flag to add/remove to/from a blacklist.\n\t * */\n\tfunction setBlacklistFlag(address _account, bool _blacklisted) public onlyOwner {\n\t\trequire(_account != address(0), \"account address invalid\");\n\n\t\tblacklist[_account] = _blacklisted;\n\t}\n\n\t/**\n\t * @notice Set amount to be subtracted from user token balance.\n\t * @param _account The address with locked amount.\n\t * @param _amount The amount to be locked.\n\t * */\n\tfunction setLockedAmount(address _account, uint256 _amount) public onlyOwner {\n\t\trequire(_account != address(0), \"account address invalid\");\n\t\trequire(_amount != 0, \"amount invalid\");\n\n\t\tlockedAmount[_account] = _amount;\n\t}\n\n\t/**\n\t * @notice Transfer SOV tokens to given address.\n\t *\n\t * @dev This is a wrapper for ERC-20 transfer function w/\n\t * additional checks and triggering an event.\n\t *\n\t * @param _receiver The address of the SOV receiver.\n\t * @param _amount The amount to be transferred.\n\t * */\n\tfunction transferSOV(address _receiver, uint256 _amount) public onlyOwner {\n\t\trequire(_receiver != address(0), \"receiver address invalid\");\n\t\trequire(_amount != 0, \"amount invalid\");\n\n\t\tIERC20(SOV).transfer(_receiver, _amount);\n\t\temit SOVTransferred(_receiver, _amount);\n\t}\n\n\t/**\n\t * @notice Exchange cSOV to SOV with 1:1 rate\n\t */\n\tfunction exchangeAllCSOV() public isNotProcessed isNotBlacklisted {\n\t\tprocessedList[msg.sender] = true;\n\n\t\tuint256 amount = 0;\n\t\tfor (uint256 i = 0; i < CSOVtokens.length; i++) {\n\t\t\taddress CSOV = CSOVtokens[i];\n\t\t\tuint256 balance = IERC20(CSOV).balanceOf(msg.sender);\n\t\t\tamount += balance;\n\t\t}\n\n\t\trequire(amount > lockedAmount[msg.sender], \"amount invalid\");\n\t\tamount -= lockedAmount[msg.sender];\n\n\t\t_createVestingForCSOV(amount);\n\t}\n\n\t/**\n\t * @notice cSOV tokens are moved and staked on Vesting contract.\n\t * @param _amount The amount of tokens to be vested.\n\t * */\n\tfunction _createVestingForCSOV(uint256 _amount) internal {\n\t\taddress vesting = _getOrCreateVesting(msg.sender, CSOV_VESTING_CLIFF, CSOV_VESTING_DURATION);\n\n\t\tIERC20(SOV).approve(vesting, _amount);\n\t\tIVesting(vesting).stakeTokens(_amount);\n\n\t\temit CSOVTokensExchanged(msg.sender, _amount);\n\t}\n\n\t/**\n\t * @notice Check a token address is among the cSOV token addresses.\n\t * @param _CSOV The cSOV token address.\n\t * */\n\tfunction _validateCSOV(address _CSOV) internal view {\n\t\tbool isValid = false;\n\t\tfor (uint256 i = 0; i < CSOVtokens.length; i++) {\n\t\t\tif (_CSOV == CSOVtokens[i]) {\n\t\t\t\tisValid = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequire(isValid, \"wrong CSOV address\");\n\t}\n\n\t/**\n\t * @notice Create Vesting contract.\n\t * @param _tokenOwner The owner of the tokens.\n\t * @param _amount The amount to be staked.\n\t * @param _cliff The time interval to the first withdraw in seconds.\n\t * @param _duration The total duration in seconds.\n\t * */\n\tfunction createVesting(\n\t\taddress _tokenOwner,\n\t\tuint256 _amount,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) public onlyAuthorized {\n\t\taddress vesting = _getOrCreateVesting(_tokenOwner, _cliff, _duration);\n\t\temit VestingCreated(_tokenOwner, vesting, _cliff, _duration, _amount);\n\t}\n\n\t/**\n\t * @notice Create Team Vesting contract.\n\t * @param _tokenOwner The owner of the tokens.\n\t * @param _amount The amount to be staked.\n\t * @param _cliff The time interval to the first withdraw in seconds.\n\t * @param _duration The total duration in seconds.\n\t * */\n\tfunction createTeamVesting(\n\t\taddress _tokenOwner,\n\t\tuint256 _amount,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) public onlyAuthorized {\n\t\taddress vesting = _getOrCreateTeamVesting(_tokenOwner, _cliff, _duration);\n\t\temit TeamVestingCreated(_tokenOwner, vesting, _cliff, _duration, _amount);\n\t}\n\n\t/**\n\t * @notice Stake tokens according to the vesting schedule.\n\t * @param _vesting The address of Vesting contract.\n\t * @param _amount The amount of tokens to stake.\n\t * */\n\tfunction stakeTokens(address _vesting, uint256 _amount) public onlyAuthorized {\n\t\trequire(_vesting != address(0), \"vesting address invalid\");\n\t\trequire(_amount > 0, \"amount invalid\");\n\n\t\tIERC20(SOV).approve(_vesting, _amount);\n\t\tIVesting(_vesting).stakeTokens(_amount);\n\t\temit TokensStaked(_vesting, _amount);\n\t}\n\n\t/**\n\t * @notice Query the vesting contract for an account.\n\t * @param _tokenOwner The owner of the tokens.\n\t * @return The vesting contract address for the given token owner.\n\t * */\n\tfunction getVesting(address _tokenOwner) public view returns (address) {\n\t\treturn vestingContracts[_tokenOwner][uint256(VestingType.Vesting)];\n\t}\n\n\t/**\n\t * @notice Query the team vesting contract for an account.\n\t * @param _tokenOwner The owner of the tokens.\n\t * @return The team vesting contract address for the given token owner.\n\t * */\n\tfunction getTeamVesting(address _tokenOwner) public view returns (address) {\n\t\treturn vestingContracts[_tokenOwner][uint256(VestingType.TeamVesting)];\n\t}\n\n\t/**\n\t * @notice If not exists, deploy a vesting contract through factory.\n\t * @param _tokenOwner The owner of the tokens.\n\t * @param _cliff The time interval to the first withdraw in seconds.\n\t * @param _duration The total duration in seconds.\n\t * @return The vesting contract address for the given token owner\n\t * whether it existed previously or not.\n\t * */\n\tfunction _getOrCreateVesting(\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) internal returns (address) {\n\t\tuint256 type_ = uint256(VestingType.Vesting);\n\t\tif (vestingContracts[_tokenOwner][type_] == address(0)) {\n\t\t\t/// @dev TODO: Owner of OwnerVesting contracts - the same address as tokenOwner.\n\t\t\taddress vesting = vestingFactory.deployVesting(SOV, staking, _tokenOwner, _cliff, _duration, feeSharingProxy, _tokenOwner);\n\t\t\tvestingContracts[_tokenOwner][type_] = vesting;\n\t\t}\n\t\treturn vestingContracts[_tokenOwner][type_];\n\t}\n\n\t/**\n\t * @notice If not exists, deploy a team vesting contract through factory.\n\t * @param _tokenOwner The owner of the tokens.\n\t * @param _cliff The time interval to the first withdraw in seconds.\n\t * @param _duration The total duration in seconds.\n\t * @return The team vesting contract address for the given token owner\n\t * whether it existed previously or not.\n\t * */\n\tfunction _getOrCreateTeamVesting(\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) internal returns (address) {\n\t\tuint256 type_ = uint256(VestingType.TeamVesting);\n\t\tif (vestingContracts[_tokenOwner][type_] == address(0)) {\n\t\t\taddress vesting = vestingFactory.deployTeamVesting(SOV, staking, _tokenOwner, _cliff, _duration, feeSharingProxy, vestingOwner);\n\t\t\tvestingContracts[_tokenOwner][type_] = vesting;\n\t\t}\n\t\treturn vestingContracts[_tokenOwner][type_];\n\t}\n}\n\n// File: contracts/governance/Staking/StakingStorage.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title Staking Storage contact.\n * @notice Just the storage part of stacking contract, no functions,\n * only constant, variables and required structures (mappings).\n * Used by StackingProxy and Checkpoints contracts.\n *\n * What is SOV staking?\n * The purpose of the SOV token is to provide a pseudonymous,\n * censorship-resistant mechanism for governing the parameters of the Sovryn\n * protocol, while aligning the incentives of protocol governors with the\n * long-term success of the protocol. Any SOV token holder can choose to\n * stake (lock up) their tokens for a fixed period of time in return for\n * voting rights in the Bitocracy. Stakers are further incentivised through\n * fee and slashing rewards.\n * */\ncontract StakingStorage is Ownable {\n\t/// @notice 2 weeks in seconds.\n\tuint256 constant TWO_WEEKS = 1209600;\n\n\t/// @notice The maximum possible voting weight before adding +1 (actually 10, but need 9 for computation).\n\tuint96 public constant MAX_VOTING_WEIGHT = 9;\n\n\t/// @notice weight is multiplied with this factor (for allowing decimals, like 1.2x).\n\t/// @dev MAX_VOTING_WEIGHT * WEIGHT_FACTOR needs to be < 792, because there are 100,000,000 SOV with 18 decimals\n\tuint96 public constant WEIGHT_FACTOR = 10;\n\n\t/// @notice The maximum duration to stake tokens for.\n\tuint256 public constant MAX_DURATION = 1092 days;\n\n\t/// @notice The maximum duration ^2\n\tuint96 constant MAX_DURATION_POW_2 = 1092 * 1092;\n\n\t/// @notice Default weight scaling.\n\tuint96 constant DEFAULT_WEIGHT_SCALING = 3;\n\n\t/// @notice Range for weight scaling.\n\tuint96 constant MIN_WEIGHT_SCALING = 1;\n\tuint96 constant MAX_WEIGHT_SCALING = 9;\n\n\t/// @notice The timestamp of contract creation. Base for the staking period calculation.\n\tuint256 public kickoffTS;\n\n\tstring name = \"SOVStaking\";\n\n\t/// @notice The token to be staked.\n\tIERC20 public SOVToken;\n\n\t/// @notice A record of each accounts delegate.\n\tmapping(address => mapping(uint256 => address)) public delegates;\n\n\t/// @notice If this flag is set to true, all tokens are unlocked immediately.\n\tbool public allUnlocked = false;\n\n\t/// @notice The EIP-712 typehash for the contract's domain.\n\tbytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n\t/// @notice The EIP-712 typehash for the delegation struct used by the contract.\n\tbytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 lockDate,uint256 nonce,uint256 expiry)\");\n\n\t/// @notice Used for stake migrations to a new staking contract with a different storage structure.\n\taddress public newStakingContract;\n\n\t/*************************** Checkpoints *******************************/\n\n\t/// @notice A checkpoint for marking the stakes from a given block\n\tstruct Checkpoint {\n\t\tuint32 fromBlock;\n\t\tuint96 stake;\n\t}\n\n\t/// @notice A record of tokens to be unstaked at a given time in total.\n\t/// For total voting power computation. Voting weights get adjusted bi-weekly.\n\t/// @dev totalStakingCheckpoints[date][index] is a checkpoint.\n\tmapping(uint256 => mapping(uint32 => Checkpoint)) public totalStakingCheckpoints;\n\n\t/// @notice The number of total staking checkpoints for each date.\n\t/// @dev numTotalStakingCheckpoints[date] is a number.\n\tmapping(uint256 => uint32) public numTotalStakingCheckpoints;\n\n\t/// @notice A record of tokens to be unstaked at a given time which were delegated to a certain address.\n\t/// For delegatee voting power computation. Voting weights get adjusted bi-weekly.\n\t/// @dev delegateStakingCheckpoints[delegatee][date][index] is a checkpoint.\n\tmapping(address => mapping(uint256 => mapping(uint32 => Checkpoint))) public delegateStakingCheckpoints;\n\n\t/// @notice The number of total staking checkpoints for each date per delegate.\n\t/// @dev numDelegateStakingCheckpoints[delegatee][date] is a number.\n\tmapping(address => mapping(uint256 => uint32)) public numDelegateStakingCheckpoints;\n\n\t/// @notice A record of tokens to be unstaked at a given time which per user address (address -> lockDate -> stake checkpoint)\n\t/// @dev userStakingCheckpoints[user][date][index] is a checkpoint.\n\tmapping(address => mapping(uint256 => mapping(uint32 => Checkpoint))) public userStakingCheckpoints;\n\n\t/// @notice The number of total staking checkpoints for each date per user.\n\t/// @dev numUserStakingCheckpoints[user][date] is a number.\n\tmapping(address => mapping(uint256 => uint32)) public numUserStakingCheckpoints;\n\n\t/// @notice A record of states for signing / validating signatures\n\t/// @dev nonces[user] is a number.\n\tmapping(address => uint256) public nonces;\n\n\t/*************************** Slashing *******************************/\n\n\t/// @notice the address of FeeSharingProxy contract, we need it for unstaking with slashing.\n\tIFeeSharingProxy public feeSharing;\n\n\t/// @notice used for weight scaling when unstaking with slashing.\n\tuint96 public weightScaling = DEFAULT_WEIGHT_SCALING;\n\n\t/// @notice List of vesting contracts, tokens for these contracts won't be slashed if unstaked by governance.\n\t/// @dev vestingWhitelist[contract] is true/false.\n\tmapping(address => bool) public vestingWhitelist;\n}\n\n// File: contracts/governance/Staking/SafeMath96.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title SafeMath96 contract.\n * @notice Improved Solidity's arithmetic operations with added overflow checks.\n * @dev SafeMath96 uses uint96, unsigned integers of 96 bits length, so every\n * integer from 0 to 2^96-1 can be operated.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * SafeMath restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this contract instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n * */\ncontract SafeMath96 {\n\tfunction safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n\t\trequire(n < 2**32, errorMessage);\n\t\treturn uint32(n);\n\t}\n\n\tfunction safe64(uint256 n, string memory errorMessage) internal pure returns (uint64) {\n\t\trequire(n < 2**64, errorMessage);\n\t\treturn uint64(n);\n\t}\n\n\tfunction safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\n\t\trequire(n < 2**96, errorMessage);\n\t\treturn uint96(n);\n\t}\n\n\t/**\n\t * @notice Adds two unsigned integers, reverting on overflow.\n\t * @dev Counterpart to Solidity's `+` operator.\n\t * @param a First integer.\n\t * @param b Second integer.\n\t * @param errorMessage The revert message on overflow.\n\t * @return The safe addition a+b.\n\t * */\n\tfunction add96(\n\t\tuint96 a,\n\t\tuint96 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint96) {\n\t\tuint96 c = a + b;\n\t\trequire(c >= a, errorMessage);\n\t\treturn c;\n\t}\n\n\t/**\n\t * @notice Substracts two unsigned integers, reverting on underflow.\n\t * @dev Counterpart to Solidity's `-` operator.\n\t * @param a First integer.\n\t * @param b Second integer.\n\t * @param errorMessage The revert message on underflow.\n\t * @return The safe substraction a-b.\n\t * */\n\tfunction sub96(\n\t\tuint96 a,\n\t\tuint96 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint96) {\n\t\trequire(b <= a, errorMessage);\n\t\treturn a - b;\n\t}\n\n\t/**\n\t * @notice Multiplies two unsigned integers, reverting on overflow.\n\t * @dev Counterpart to Solidity's `*` operator.\n\t * @param a First integer.\n\t * @param b Second integer.\n\t * @param errorMessage The revert message on overflow.\n\t * @return The safe product a*b.\n\t * */\n\tfunction mul96(\n\t\tuint96 a,\n\t\tuint96 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint96) {\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint96 c = a * b;\n\t\trequire(c / a == b, errorMessage);\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @notice Divides two unsigned integers, reverting on overflow.\n\t * @dev Counterpart to Solidity's `/` operator.\n\t * @param a First integer.\n\t * @param b Second integer.\n\t * @param errorMessage The revert message on overflow.\n\t * @return The safe division a/b.\n\t * */\n\tfunction div96(\n\t\tuint96 a,\n\t\tuint96 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint96) {\n\t\t// Solidity only automatically asserts when dividing by 0\n\t\trequire(b > 0, errorMessage);\n\t\tuint96 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\t\treturn c;\n\t}\n}\n\n// File: contracts/governance/Staking/Checkpoints.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title Checkpoints contract.\n * @notice Increases and decreases storage values for users, delegatees and\n * total daily stake.\n * */\ncontract Checkpoints is StakingStorage, SafeMath96 {\n\t/// @notice An event emitted when an account changes its delegate.\n\tevent DelegateChanged(address indexed delegator, uint256 lockedUntil, address indexed fromDelegate, address indexed toDelegate);\n\n\t/// @notice An event emitted when a delegate account's stake balance changes.\n\tevent DelegateStakeChanged(address indexed delegate, uint256 lockedUntil, uint256 previousBalance, uint256 newBalance);\n\n\t/// @notice An event emitted when tokens get staked.\n\tevent TokensStaked(address indexed staker, uint256 amount, uint256 lockedUntil, uint256 totalStaked);\n\n\t/// @notice An event emitted when tokens get withdrawn.\n\tevent TokensWithdrawn(address indexed staker, address receiver, uint256 amount);\n\n\t/// @notice An event emitted when vesting tokens get withdrawn.\n\tevent VestingTokensWithdrawn(address vesting, address receiver);\n\n\t/// @notice An event emitted when the owner unlocks all tokens.\n\tevent TokensUnlocked(uint256 amount);\n\n\t/// @notice An event emitted when a staking period gets extended.\n\tevent ExtendedStakingDuration(address indexed staker, uint256 previousDate, uint256 newDate);\n\n\t/**\n\t * @notice Increases the user's stake for a giving lock date and writes a checkpoint.\n\t * @param account The user address.\n\t * @param lockedTS The lock date.\n\t * @param value The value to add to the staked balance.\n\t * */\n\tfunction _increaseUserStake(\n\t\taddress account,\n\t\tuint256 lockedTS,\n\t\tuint96 value\n\t) internal {\n\t\tuint32 nCheckpoints = numUserStakingCheckpoints[account][lockedTS];\n\t\tuint96 staked = userStakingCheckpoints[account][lockedTS][nCheckpoints - 1].stake;\n\t\tuint96 newStake = add96(staked, value, \"Staking::_increaseUserStake: staked amount overflow\");\n\t\t_writeUserCheckpoint(account, lockedTS, nCheckpoints, newStake);\n\t}\n\n\t/**\n\t * @notice Decreases the user's stake for a giving lock date and writes a checkpoint.\n\t * @param account The user address.\n\t * @param lockedTS The lock date.\n\t * @param value The value to substract to the staked balance.\n\t * */\n\tfunction _decreaseUserStake(\n\t\taddress account,\n\t\tuint256 lockedTS,\n\t\tuint96 value\n\t) internal {\n\t\tuint32 nCheckpoints = numUserStakingCheckpoints[account][lockedTS];\n\t\tuint96 staked = userStakingCheckpoints[account][lockedTS][nCheckpoints - 1].stake;\n\t\tuint96 newStake = sub96(staked, value, \"Staking::_decreaseUserStake: staked amount underflow\");\n\t\t_writeUserCheckpoint(account, lockedTS, nCheckpoints, newStake);\n\t}\n\n\t/**\n\t * @notice Writes on storage the user stake.\n\t * @param account The user address.\n\t * @param lockedTS The lock date.\n\t * @param nCheckpoints The number of checkpoints, to find out the last one index.\n\t * @param newStake The new staked balance.\n\t * */\n\tfunction _writeUserCheckpoint(\n\t\taddress account,\n\t\tuint256 lockedTS,\n\t\tuint32 nCheckpoints,\n\t\tuint96 newStake\n\t) internal {\n\t\tuint32 blockNumber = safe32(block.number, \"Staking::_writeStakingCheckpoint: block number exceeds 32 bits\");\n\n\t\tif (nCheckpoints > 0 && userStakingCheckpoints[account][lockedTS][nCheckpoints - 1].fromBlock == blockNumber) {\n\t\t\tuserStakingCheckpoints[account][lockedTS][nCheckpoints - 1].stake = newStake;\n\t\t} else {\n\t\t\tuserStakingCheckpoints[account][lockedTS][nCheckpoints] = Checkpoint(blockNumber, newStake);\n\t\t\tnumUserStakingCheckpoints[account][lockedTS] = nCheckpoints + 1;\n\t\t}\n\t}\n\n\t/**\n\t * @notice Increases the delegatee's stake for a giving lock date and writes a checkpoint.\n\t * @param delegatee The delegatee address.\n\t * @param lockedTS The lock date.\n\t * @param value The value to add to the staked balance.\n\t * */\n\tfunction _increaseDelegateStake(\n\t\taddress delegatee,\n\t\tuint256 lockedTS,\n\t\tuint96 value\n\t) internal {\n\t\tuint32 nCheckpoints = numDelegateStakingCheckpoints[delegatee][lockedTS];\n\t\tuint96 staked = delegateStakingCheckpoints[delegatee][lockedTS][nCheckpoints - 1].stake;\n\t\tuint96 newStake = add96(staked, value, \"Staking::_increaseDelegateeStake: staked amount overflow\");\n\t\t_writeDelegateCheckpoint(delegatee, lockedTS, nCheckpoints, newStake);\n\t}\n\n\t/**\n\t * @notice Decreases the delegatee's stake for a giving lock date and writes a checkpoint.\n\t * @param delegatee The delegatee address.\n\t * @param lockedTS The lock date.\n\t * @param value The value to substract to the staked balance.\n\t * */\n\tfunction _decreaseDelegateStake(\n\t\taddress delegatee,\n\t\tuint256 lockedTS,\n\t\tuint96 value\n\t) internal {\n\t\tuint32 nCheckpoints = numDelegateStakingCheckpoints[delegatee][lockedTS];\n\t\tuint96 staked = delegateStakingCheckpoints[delegatee][lockedTS][nCheckpoints - 1].stake;\n\t\tuint96 newStake = sub96(staked, value, \"Staking::_decreaseDailyStake: staked amount underflow\");\n\t\t_writeDelegateCheckpoint(delegatee, lockedTS, nCheckpoints, newStake);\n\t}\n\n\t/**\n\t * @notice Writes on storage the delegate stake.\n\t * @param delegatee The delegate address.\n\t * @param lockedTS The lock date.\n\t * @param nCheckpoints The number of checkpoints, to find out the last one index.\n\t * @param newStake The new staked balance.\n\t * */\n\tfunction _writeDelegateCheckpoint(\n\t\taddress delegatee,\n\t\tuint256 lockedTS,\n\t\tuint32 nCheckpoints,\n\t\tuint96 newStake\n\t) internal {\n\t\tuint32 blockNumber = safe32(block.number, \"Staking::_writeStakingCheckpoint: block number exceeds 32 bits\");\n\t\tuint96 oldStake = delegateStakingCheckpoints[delegatee][lockedTS][nCheckpoints - 1].stake;\n\n\t\tif (nCheckpoints > 0 && delegateStakingCheckpoints[delegatee][lockedTS][nCheckpoints - 1].fromBlock == blockNumber) {\n\t\t\tdelegateStakingCheckpoints[delegatee][lockedTS][nCheckpoints - 1].stake = newStake;\n\t\t} else {\n\t\t\tdelegateStakingCheckpoints[delegatee][lockedTS][nCheckpoints] = Checkpoint(blockNumber, newStake);\n\t\t\tnumDelegateStakingCheckpoints[delegatee][lockedTS] = nCheckpoints + 1;\n\t\t}\n\t\temit DelegateStakeChanged(delegatee, lockedTS, oldStake, newStake);\n\t}\n\n\t/**\n\t * @notice Increases the total stake for a giving lock date and writes a checkpoint.\n\t * @param lockedTS The lock date.\n\t * @param value The value to add to the staked balance.\n\t * */\n\tfunction _increaseDailyStake(uint256 lockedTS, uint96 value) internal {\n\t\tuint32 nCheckpoints = numTotalStakingCheckpoints[lockedTS];\n\t\tuint96 staked = totalStakingCheckpoints[lockedTS][nCheckpoints - 1].stake;\n\t\tuint96 newStake = add96(staked, value, \"Staking::_increaseDailyStake: staked amount overflow\");\n\t\t_writeStakingCheckpoint(lockedTS, nCheckpoints, newStake);\n\t}\n\n\t/**\n\t * @notice Decreases the total stake for a giving lock date and writes a checkpoint.\n\t * @param lockedTS The lock date.\n\t * @param value The value to substract to the staked balance.\n\t * */\n\tfunction _decreaseDailyStake(uint256 lockedTS, uint96 value) internal {\n\t\tuint32 nCheckpoints = numTotalStakingCheckpoints[lockedTS];\n\t\tuint96 staked = totalStakingCheckpoints[lockedTS][nCheckpoints - 1].stake;\n\t\tuint96 newStake = sub96(staked, value, \"Staking::_decreaseDailyStake: staked amount underflow\");\n\t\t_writeStakingCheckpoint(lockedTS, nCheckpoints, newStake);\n\t}\n\n\t/**\n\t * @notice Writes on storage the total stake.\n\t * @param lockedTS The lock date.\n\t * @param nCheckpoints The number of checkpoints, to find out the last one index.\n\t * @param newStake The new staked balance.\n\t * */\n\tfunction _writeStakingCheckpoint(\n\t\tuint256 lockedTS,\n\t\tuint32 nCheckpoints,\n\t\tuint96 newStake\n\t) internal {\n\t\tuint32 blockNumber = safe32(block.number, \"Staking::_writeStakingCheckpoint: block number exceeds 32 bits\");\n\n\t\tif (nCheckpoints > 0 && totalStakingCheckpoints[lockedTS][nCheckpoints - 1].fromBlock == blockNumber) {\n\t\t\ttotalStakingCheckpoints[lockedTS][nCheckpoints - 1].stake = newStake;\n\t\t} else {\n\t\t\ttotalStakingCheckpoints[lockedTS][nCheckpoints] = Checkpoint(blockNumber, newStake);\n\t\t\tnumTotalStakingCheckpoints[lockedTS] = nCheckpoints + 1;\n\t\t}\n\t}\n}\n\n// File: contracts/governance/Staking/WeightedStaking.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title Weighted Staking contract.\n * @notice Computation of power and votes used by FeeSharingProxy and\n * GovernorAlpha and Staking contracts w/ mainly 3 public functions:\n *   + getPriorTotalVotingPower => Total voting power.\n *   + getPriorVotes  => Delegatee voting power.\n *   + getPriorWeightedStake  => User Weighted Stake.\n * Staking contract inherits WeightedStaking.\n * FeeSharingProxy and GovernorAlpha invoke Staking instance functions.\n * */\ncontract WeightedStaking is Checkpoints {\n\t/************* TOTAL VOTING POWER COMPUTATION ************************/\n\n\t/**\n\t * @notice Compute the total voting power at a given time.\n\t * @param time The timestamp for which to calculate the total voting power.\n\t * @return The total voting power at the given time.\n\t * */\n\tfunction getPriorTotalVotingPower(uint32 blockNumber, uint256 time) public view returns (uint96 totalVotingPower) {\n\t\t/// @dev Start the computation with the exact or previous unlocking date (voting weight remians the same until the next break point).\n\t\tuint256 start = timestampToLockDate(time);\n\t\tuint256 end = start + MAX_DURATION;\n\n\t\t/// @dev Max 78 iterations.\n\t\tfor (uint256 i = start; i <= end; i += TWO_WEEKS) {\n\t\t\ttotalVotingPower = add96(\n\t\t\t\ttotalVotingPower,\n\t\t\t\t_totalPowerByDate(i, start, blockNumber),\n\t\t\t\t\"WeightedStaking::getPriorTotalVotingPower: overflow on total voting power computation\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Compute the voting power for a specific date.\n\t * Power = stake * weight\n\t * @param date The staking date to compute the power for.\n\t * @param startDate The date for which we need to know the power of the stake.\n\t * @param blockNumber The block number, needed for checkpointing.\n\t * */\n\tfunction _totalPowerByDate(\n\t\tuint256 date,\n\t\tuint256 startDate,\n\t\tuint256 blockNumber\n\t) internal view returns (uint96 power) {\n\t\tuint96 weight = computeWeightByDate(date, startDate);\n\t\tuint96 staked = getPriorTotalStakesForDate(date, blockNumber);\n\t\t/// @dev weight is multiplied by some factor to allow decimals.\n\t\tpower = mul96(staked, weight, \"WeightedStaking::_totalPowerByDate: multiplication overflow\") / WEIGHT_FACTOR;\n\t}\n\n\t/**\n\t * @notice Determine the prior number of stake for an unlocking date as of a block number.\n\t * @dev Block number must be a finalized block or else this function will\n\t * revert to prevent misinformation.\n\t * TODO: WeightedStaking::getPriorTotalStakesForDate should probably better\n\t * be internal instead of a public function.\n\t * @param date The date to check the stakes for.\n\t * @param blockNumber The block number to get the vote balance at.\n\t * @return The number of votes the account had as of the given block.\n\t * */\n\tfunction getPriorTotalStakesForDate(uint256 date, uint256 blockNumber) public view returns (uint96) {\n\t\trequire(blockNumber < block.number, \"WeightedStaking::getPriorTotalStakesForDate: not yet determined\");\n\n\t\tuint32 nCheckpoints = numTotalStakingCheckpoints[date];\n\t\tif (nCheckpoints == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// First check most recent balance\n\t\tif (totalStakingCheckpoints[date][nCheckpoints - 1].fromBlock <= blockNumber) {\n\t\t\treturn totalStakingCheckpoints[date][nCheckpoints - 1].stake;\n\t\t}\n\n\t\t// Next check implicit zero balance\n\t\tif (totalStakingCheckpoints[date][0].fromBlock > blockNumber) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint32 lower = 0;\n\t\tuint32 upper = nCheckpoints - 1;\n\t\twhile (upper > lower) {\n\t\t\tuint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n\t\t\tCheckpoint memory cp = totalStakingCheckpoints[date][center];\n\t\t\tif (cp.fromBlock == blockNumber) {\n\t\t\t\treturn cp.stake;\n\t\t\t} else if (cp.fromBlock < blockNumber) {\n\t\t\t\tlower = center;\n\t\t\t} else {\n\t\t\t\tupper = center - 1;\n\t\t\t}\n\t\t}\n\t\treturn totalStakingCheckpoints[date][lower].stake;\n\t}\n\n\t/****************************** DELEGATED VOTING POWER COMPUTATION ************************/\n\n\t/**\n\t * @notice Determine the prior number of votes for a delegatee as of a block number.\n\t * Iterate through checkpoints adding up voting power.\n\t * @dev Block number must be a finalized block or else this function will revert\n\t * to prevent misinformation.\n\t *      Used for Voting, not for fee sharing.\n\t * @param account The address of the account to check.\n\t * @param blockNumber The block number to get the vote balance at.\n\t * @return The number of votes the delegatee had as of the given block.\n\t * */\n\tfunction getPriorVotes(\n\t\taddress account,\n\t\tuint256 blockNumber,\n\t\tuint256 date\n\t) public view returns (uint96 votes) {\n\t\t/// @dev If date is not an exact break point, start weight computation from the previous break point (alternative would be the next).\n\t\tuint256 start = timestampToLockDate(date);\n\t\tuint256 end = start + MAX_DURATION;\n\n\t\t/// @dev Max 78 iterations.\n\t\tfor (uint256 i = start; i <= end; i += TWO_WEEKS) {\n\t\t\tvotes = add96(\n\t\t\t\tvotes,\n\t\t\t\t_totalPowerByDateForDelegatee(account, i, start, blockNumber),\n\t\t\t\t\"WeightedStaking::getPriorVotes: overflow on total voting power computation\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Compute the voting power for a specific date.\n\t * Power = stake * weight\n\t * @param date The staking date to compute the power for.\n\t * @param startDate The date for which we need to know the power of the stake.\n\t * @param blockNumber The block number, needed for checkpointing.\n\t * */\n\tfunction _totalPowerByDateForDelegatee(\n\t\taddress account,\n\t\tuint256 date,\n\t\tuint256 startDate,\n\t\tuint256 blockNumber\n\t) internal view returns (uint96 power) {\n\t\tuint96 weight = computeWeightByDate(date, startDate);\n\t\tuint96 staked = getPriorStakeByDateForDelegatee(account, date, blockNumber);\n\t\tpower = mul96(staked, weight, \"WeightedStaking::_totalPowerByDateForDelegatee: multiplication overflow\") / WEIGHT_FACTOR;\n\t}\n\n\t/**\n\t * @notice Determine the prior number of stake for an account as of a block number.\n\t * @dev Block number must be a finalized block or else this function will\n\t * revert to prevent misinformation.\n\t * TODO: WeightedStaking::getPriorStakeByDateForDelegatee should probably better\n\t * be internal instead of a public function.\n\t * @param account The address of the account to check.\n\t * @param blockNumber The block number to get the vote balance at.\n\t * @return The number of votes the account had as of the given block.\n\t * */\n\tfunction getPriorStakeByDateForDelegatee(\n\t\taddress account,\n\t\tuint256 date,\n\t\tuint256 blockNumber\n\t) public view returns (uint96) {\n\t\trequire(blockNumber < block.number, \"WeightedStaking::getPriorStakeByDateForDelegatee: not yet determined\");\n\n\t\tuint32 nCheckpoints = numDelegateStakingCheckpoints[account][date];\n\t\tif (nCheckpoints == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t/// @dev First check most recent balance.\n\t\tif (delegateStakingCheckpoints[account][date][nCheckpoints - 1].fromBlock <= blockNumber) {\n\t\t\treturn delegateStakingCheckpoints[account][date][nCheckpoints - 1].stake;\n\t\t}\n\n\t\t/// @dev Next check implicit zero balance.\n\t\tif (delegateStakingCheckpoints[account][date][0].fromBlock > blockNumber) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint32 lower = 0;\n\t\tuint32 upper = nCheckpoints - 1;\n\t\twhile (upper > lower) {\n\t\t\tuint32 center = upper - (upper - lower) / 2; /// @dev ceil, avoiding overflow.\n\t\t\tCheckpoint memory cp = delegateStakingCheckpoints[account][date][center];\n\t\t\tif (cp.fromBlock == blockNumber) {\n\t\t\t\treturn cp.stake;\n\t\t\t} else if (cp.fromBlock < blockNumber) {\n\t\t\t\tlower = center;\n\t\t\t} else {\n\t\t\t\tupper = center - 1;\n\t\t\t}\n\t\t}\n\t\treturn delegateStakingCheckpoints[account][date][lower].stake;\n\t}\n\n\t/*************************** User Weighted Stake computation for fee sharing *******************************/\n\n\t/**\n\t * @notice Determine the prior weighted stake for an account as of a block number.\n\t * Iterate through checkpoints adding up voting power.\n\t * @dev Block number must be a finalized block or else this function will\n\t * revert to prevent misinformation.\n\t *      Used for fee sharing, not voting.\n\t * TODO: WeightedStaking::getPriorWeightedStake is using the variable name \"votes\"\n\t * to add up token stake, and that could be misleading.\n\t *\n\t * @param account The address of the account to check.\n\t * @param blockNumber The block number to get the vote balance at.\n\t * @return The weighted stake the account had as of the given block.\n\t * */\n\tfunction getPriorWeightedStake(\n\t\taddress account,\n\t\tuint256 blockNumber,\n\t\tuint256 date\n\t) public view returns (uint96 votes) {\n\t\t/// @dev If date is not an exact break point, start weight computation from the previous break point (alternative would be the next).\n\t\tuint256 start = timestampToLockDate(date);\n\t\tuint256 end = start + MAX_DURATION;\n\n\t\t/// @dev Max 78 iterations.\n\t\tfor (uint256 i = start; i <= end; i += TWO_WEEKS) {\n\t\t\tuint96 weightedStake = weightedStakeByDate(account, i, start, blockNumber);\n\t\t\tif (weightedStake > 0) {\n\t\t\t\tvotes = add96(votes, weightedStake, \"WeightedStaking::getPriorWeightedStake: overflow on total weight computation\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Compute the voting power for a specific date.\n\t * Power = stake * weight\n\t * TODO: WeightedStaking::weightedStakeByDate should probably better\n\t * be internal instead of a public function.\n\t * @param date The staking date to compute the power for.\n\t * @param startDate The date for which we need to know the power of the stake.\n\t * @param blockNumber The block number, needed for checkpointing.\n\t * */\n\tfunction weightedStakeByDate(\n\t\taddress account,\n\t\tuint256 date,\n\t\tuint256 startDate,\n\t\tuint256 blockNumber\n\t) public view returns (uint96 power) {\n\t\tuint96 staked = getPriorUserStakeByDate(account, date, blockNumber);\n\t\tif (staked > 0) {\n\t\t\tuint96 weight = computeWeightByDate(date, startDate);\n\t\t\tpower = mul96(staked, weight, \"WeightedStaking::weightedStakeByDate: multiplication overflow\") / WEIGHT_FACTOR;\n\t\t} else {\n\t\t\tpower = 0;\n\t\t}\n\t}\n\n\t/**\n\t * @notice Determine the prior number of stake for an account until a\n\t * certain lock date as of a block number.\n\t * @dev Block number must be a finalized block or else this function\n\t * will revert to prevent misinformation.\n\t * @param account The address of the account to check.\n\t * @param date The lock date.\n\t * @param blockNumber The block number to get the vote balance at.\n\t * @return The number of votes the account had as of the given block.\n\t * */\n\tfunction getPriorUserStakeByDate(\n\t\taddress account,\n\t\tuint256 date,\n\t\tuint256 blockNumber\n\t) public view returns (uint96) {\n\t\trequire(blockNumber < block.number, \"WeightedStaking::getPriorUserStakeAndDate: not yet determined\");\n\n\t\tdate = _adjustDateForOrigin(date);\n\t\tuint32 nCheckpoints = numUserStakingCheckpoints[account][date];\n\t\tif (nCheckpoints == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t/// @dev First check most recent balance.\n\t\tif (userStakingCheckpoints[account][date][nCheckpoints - 1].fromBlock <= blockNumber) {\n\t\t\treturn userStakingCheckpoints[account][date][nCheckpoints - 1].stake;\n\t\t}\n\n\t\t/// @dev Next check implicit zero balance.\n\t\tif (userStakingCheckpoints[account][date][0].fromBlock > blockNumber) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint32 lower = 0;\n\t\tuint32 upper = nCheckpoints - 1;\n\t\twhile (upper > lower) {\n\t\t\tuint32 center = upper - (upper - lower) / 2; /// @dev ceil, avoiding overflow.\n\t\t\tCheckpoint memory cp = userStakingCheckpoints[account][date][center];\n\t\t\tif (cp.fromBlock == blockNumber) {\n\t\t\t\treturn cp.stake;\n\t\t\t} else if (cp.fromBlock < blockNumber) {\n\t\t\t\tlower = center;\n\t\t\t} else {\n\t\t\t\tupper = center - 1;\n\t\t\t}\n\t\t}\n\t\treturn userStakingCheckpoints[account][date][lower].stake;\n\t}\n\n\t/**************** SHARED FUNCTIONS *********************/\n\n\t/**\n\t * @notice Compute the weight for a specific date.\n\t * @param date The unlocking date.\n\t * @param startDate We compute the weight for the tokens staked until 'date' on 'startDate'.\n\t * */\n\tfunction computeWeightByDate(uint256 date, uint256 startDate) public pure returns (uint96 weight) {\n\t\trequire(date >= startDate, \"WeightedStaking::computeWeightByDate: date needs to be bigger than startDate\");\n\t\tuint256 remainingTime = (date - startDate);\n\t\trequire(MAX_DURATION >= remainingTime, \"Staking::computeWeightByDate:remaining time can't be bigger than max duration\");\n\t\t/// @dev x = max days - remaining days\n\t\tuint96 x = uint96(MAX_DURATION - remainingTime) / (1 days);\n\t\t/// @dev w = (m^2 - x^2)/m^2 +1 (multiplied by the weight factor)\n\t\tweight = add96(\n\t\t\tWEIGHT_FACTOR,\n\t\t\tmul96(\n\t\t\t\tMAX_VOTING_WEIGHT * WEIGHT_FACTOR,\n\t\t\t\tsub96(MAX_DURATION_POW_2, x * x, \"underflow on weight calculation\"),\n\t\t\t\t\"multiplication overflow on weight computation\"\n\t\t\t) / MAX_DURATION_POW_2,\n\t\t\t\"overflow on weight computation\"\n\t\t);\n\t}\n\n\t/**\n\t * @notice Unstaking is possible every 2 weeks only. This means, to\n\t * calculate the key value for the staking checkpoints, we need to\n\t * map the intended timestamp to the closest available date.\n\t * @param timestamp The unlocking timestamp.\n\t * @return The actual unlocking date (might be up to 2 weeks shorter than intended).\n\t * */\n\tfunction timestampToLockDate(uint256 timestamp) public view returns (uint256 lockDate) {\n\t\trequire(timestamp >= kickoffTS, \"WeightedStaking::timestampToLockDate: timestamp lies before contract creation\");\n\t\t/**\n\t\t * @dev If staking timestamp does not match any of the unstaking dates\n\t\t * , set the lockDate to the closest one before the timestamp.\n\t\t * E.g. Passed timestamps lies 7 weeks after kickoff -> only stake for 6 weeks.\n\t\t * */\n\t\tuint256 periodFromKickoff = (timestamp - kickoffTS) / TWO_WEEKS;\n\t\tlockDate = periodFromKickoff * TWO_WEEKS + kickoffTS;\n\t}\n\n\tfunction _adjustDateForOrigin(uint256 date) internal view returns (uint256) {\n\t\tuint256 adjustedDate = timestampToLockDate(date);\n\t\t//origin vesting contracts have different dates\n\t\t//we need to add 2 weeks to get end of period (by default, it's start)\n\t\tif (adjustedDate != date) {\n\t\t\tdate = adjustedDate + TWO_WEEKS;\n\t\t}\n\t\treturn date;\n\t}\n}\n\n// File: contracts/rsk/RSKAddrValidator.sol\n\n// SPDX-License-Identifier:MIT\npragma solidity ^0.5.17;\n\nlibrary RSKAddrValidator {\n\t/*\n\t * @param addr it is an address to check that it does not originates from\n\t * signing with PK = ZERO. RSK has a small difference in which @ZERO_PK_ADDR is\n\t * also an address from PK = ZERO. So we check for both of them.\n\t * */\n\tfunction checkPKNotZero(address addr) internal pure returns (bool) {\n\t\treturn (addr != 0xdcc703c0E500B653Ca82273B7BFAd8045D85a470 && addr != address(0));\n\t}\n\n\t/*\n\t * Safely compares two addresses, checking they do not originate from\n\t * a zero private key.\n\t * */\n\tfunction safeEquals(address addr1, address addr2) internal pure returns (bool) {\n\t\treturn (addr1 == addr2 && addr1 != 0xdcc703c0E500B653Ca82273B7BFAd8045D85a470 && addr1 != address(0));\n\t}\n}\n\n// File: contracts/governance/ErrorDecoder.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title Base contract to properly handle returned data on failed calls\n * @dev On EVM if the return data length of a call is less than 68,\n * then the transaction fails silently without a revert message!\n *\n * As described in the Solidity documentation\n * https://solidity.readthedocs.io/en/v0.5.17/control-structures.html#revert\n * the revert reason is an ABI-encoded string consisting of:\n * 0x08c379a0 // Function selector (method id) for \"Error(string)\" signature\n * 0x0000000000000000000000000000000000000000000000000000000000000020 // Data offset\n * 0x000000000000000000000000000000000000000000000000000000000000001a // String length\n * 0x4e6f7420656e6f7567682045746865722070726f76696465642e000000000000 // String data\n *\n * Another example, debug data from test:\n *   0x08c379a0\n *   0000000000000000000000000000000000000000000000000000000000000020\n *   0000000000000000000000000000000000000000000000000000000000000034\n *   54696d656c6f636b3a3a73657444656c61793a2044656c6179206d7573742065\n *   7863656564206d696e696d756d2064656c61792e000000000000000000000000\n *\n * Parsed into:\n *   Data offset: 20\n *   Length: 34\n *   Error message:\n *     54696d656c6f636b3a3a73657444656c61793a2044656c6179206d7573742065\n *     7863656564206d696e696d756d2064656c61792e000000000000000000000000\n */\ncontract ErrorDecoder {\n\tuint256 constant ERROR_MESSAGE_SHIFT = 68; // EVM silent revert error string length\n\n\t/**\n\t * @notice Concats two error strings taking into account ERROR_MESSAGE_SHIFT.\n\t * @param str1 First string, usually a hardcoded context written by dev.\n\t * @param str2 Second string, usually the error message from the reverted call.\n\t * @return The concatenated error string\n\t */\n\tfunction _addErrorMessage(string memory str1, string memory str2) internal pure returns (string memory) {\n\t\tbytes memory bytesStr1 = bytes(str1);\n\t\tbytes memory bytesStr2 = bytes(str2);\n\t\tstring memory str12 = new string(bytesStr1.length + bytesStr2.length - ERROR_MESSAGE_SHIFT);\n\t\tbytes memory bytesStr12 = bytes(str12);\n\t\tuint256 j = 0;\n\t\tfor (uint256 i = 0; i < bytesStr1.length; i++) {\n\t\t\tbytesStr12[j++] = bytesStr1[i];\n\t\t}\n\t\tfor (uint256 i = ERROR_MESSAGE_SHIFT; i < bytesStr2.length; i++) {\n\t\t\tbytesStr12[j++] = bytesStr2[i];\n\t\t}\n\t\treturn string(bytesStr12);\n\t}\n}\n\n// File: contracts/token/IApproveAndCall.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title Interface for contract governance/ApprovalReceiver.sol\n * @dev Interfaces are used to cast a contract address into a callable instance.\n */\ninterface IApproveAndCall {\n\t/**\n\t * @notice Receives approval from SOV token.\n\t * @param _sender The sender of SOV.approveAndCall function.\n\t * @param _amount The amount was approved.\n\t * @param _token The address of token.\n\t * @param _data The data will be used for low level call.\n\t * */\n\tfunction receiveApproval(\n\t\taddress _sender,\n\t\tuint256 _amount,\n\t\taddress _token,\n\t\tbytes calldata _data\n\t) external;\n}\n\n// File: contracts/governance/ApprovalReceiver.sol\n\npragma solidity ^0.5.17;\n\n\n\n/**\n * @title Base contract for receiving approval from SOV token.\n */\ncontract ApprovalReceiver is ErrorDecoder, IApproveAndCall {\n\tmodifier onlyThisContract() {\n\t\t// Accepts calls only from receiveApproval function.\n\t\trequire(msg.sender == address(this), \"unauthorized\");\n\t\t_;\n\t}\n\n\t/**\n\t * @notice Receives approval from SOV token.\n\t * @param _data The data will be used for low level call.\n\t */\n\tfunction receiveApproval(\n\t\taddress _sender,\n\t\tuint256 _amount,\n\t\taddress _token,\n\t\tbytes calldata _data\n\t) external {\n\t\t// Accepts calls only from SOV token.\n\t\trequire(msg.sender == _getToken(), \"unauthorized\");\n\t\trequire(msg.sender == _token, \"unauthorized\");\n\n\t\t// Only allowed methods.\n\t\tbool isAllowed = false;\n\t\tbytes4[] memory selectors = _getSelectors();\n\t\tbytes4 sig = _getSig(_data);\n\t\tfor (uint256 i = 0; i < selectors.length; i++) {\n\t\t\tif (sig == selectors[i]) {\n\t\t\t\tisAllowed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequire(isAllowed, \"method is not allowed\");\n\n\t\t// Check sender and amount.\n\t\taddress sender;\n\t\tuint256 amount;\n\t\t(, sender, amount) = abi.decode(abi.encodePacked(bytes28(0), _data), (bytes32, address, uint256));\n\t\trequire(sender == _sender, \"sender mismatch\");\n\t\trequire(amount == _amount, \"amount mismatch\");\n\n\t\t_call(_data);\n\t}\n\n\t/**\n\t * @notice Returns token address, only this address can be a sender for receiveApproval.\n\t * @dev Should be overridden in child contracts, otherwise error will be thrown.\n\t * @return By default, 0x. When overriden, the token address making the call.\n\t */\n\tfunction _getToken() internal view returns (address) {\n\t\treturn address(0);\n\t}\n\n\t/**\n\t * @notice Returns list of function selectors allowed to be invoked.\n\t * @dev Should be overridden in child contracts, otherwise error will be thrown.\n\t * @return By default, empty array. When overriden, allowed selectors.\n\t */\n\tfunction _getSelectors() internal view returns (bytes4[] memory) {\n\t\treturn new bytes4[](0);\n\t}\n\n\t/**\n\t * @notice Makes call and reverts w/ enhanced error message.\n\t * @param _data Error message as bytes.\n\t */\n\tfunction _call(bytes memory _data) internal {\n\t\t(bool success, bytes memory returnData) = address(this).call(_data);\n\t\tif (!success) {\n\t\t\tif (returnData.length <= ERROR_MESSAGE_SHIFT) {\n\t\t\t\trevert(\"receiveApproval: Transaction execution reverted.\");\n\t\t\t} else {\n\t\t\t\trevert(_addErrorMessage(\"receiveApproval: \", string(returnData)));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Extracts the called function selector, a hash of the signature.\n\t * @dev The first four bytes of the call data for a function call specifies\n\t * the function to be called. It is the first (left, high-order in big-endian)\n\t * four bytes of the Keccak-256 (SHA-3) hash of the signature of the function.\n\t * Solidity doesn't yet support a casting of byte[4] to bytes4.\n\t * Example:\n\t *  msg.data:\n\t *    0xcdcd77c000000000000000000000000000000000000000000000000000000000000\n\t *    000450000000000000000000000000000000000000000000000000000000000000001\n\t *  selector (or method ID): 0xcdcd77c0\n\t *  signature: baz(uint32,bool)\n\t * @param _data The msg.data from the low level call.\n\t * @return sig First 4 bytes of msg.data i.e. the selector, hash of the signature.\n\t */\n\tfunction _getSig(bytes memory _data) internal pure returns (bytes4 sig) {\n\t\tassembly {\n\t\t\tsig := mload(add(_data, 32))\n\t\t}\n\t}\n}\n\n// File: contracts/governance/Staking/Staking.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title Staking contract.\n * @notice Pay-in and pay-out function for staking and withdrawing tokens.\n * Staking is delegated and vested: To gain voting power, SOV holders must\n * stake their SOV for a given period of time. Aside from Bitocracy\n * participation, there's a financially-rewarding reason for staking SOV.\n * Tokenholders who stake their SOV receive staking rewards, a pro-rata share\n * of the revenue that the platform generates from various transaction fees\n * plus revenues from stakers who have a portion of their SOV slashed for\n * early unstaking.\n * */\ncontract Staking is IStaking, WeightedStaking, ApprovalReceiver {\n\t/**\n\t * @notice Stake the given amount for the given duration of time.\n\t * @param amount The number of tokens to stake.\n\t * @param until Timestamp indicating the date until which to stake.\n\t * @param stakeFor The address to stake the tokens for or 0x0 if staking for oneself.\n\t * @param delegatee The address of the delegatee or 0x0 if there is none.\n\t * */\n\tfunction stake(\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) external {\n\t\t_stake(msg.sender, amount, until, stakeFor, delegatee, false);\n\t}\n\n\t/**\n\t * @notice Stake the given amount for the given duration of time.\n\t * @dev This function will be invoked from receiveApproval\n\t * @dev SOV.approveAndCall -> this.receiveApproval -> this.stakeWithApproval\n\t * @param sender The sender of SOV.approveAndCall\n\t * @param amount The number of tokens to stake.\n\t * @param until Timestamp indicating the date until which to stake.\n\t * @param stakeFor The address to stake the tokens for or 0x0 if staking for oneself.\n\t * @param delegatee The address of the delegatee or 0x0 if there is none.\n\t * */\n\tfunction stakeWithApproval(\n\t\taddress sender,\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) public onlyThisContract {\n\t\t_stake(sender, amount, until, stakeFor, delegatee, false);\n\t}\n\n\t/**\n\t * @notice Send sender's tokens to this contract and update its staked balance.\n\t * @param sender The sender of the tokens.\n\t * @param amount The number of tokens to send.\n\t * @param until The date until which the tokens will be staked.\n\t * @param stakeFor The beneficiary whose stake will be increased.\n\t * @param delegatee The address of the delegatee or stakeFor if default 0x0.\n\t * @param timeAdjusted Whether fixing date to stacking periods or not.\n\t * */\n\tfunction _stake(\n\t\taddress sender,\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress stakeFor,\n\t\taddress delegatee,\n\t\tbool timeAdjusted\n\t) internal {\n\t\trequire(amount > 0, \"Staking::stake: amount of tokens to stake needs to be bigger than 0\");\n\n\t\tif (!timeAdjusted) {\n\t\t\tuntil = timestampToLockDate(until);\n\t\t}\n\t\trequire(until > block.timestamp, \"Staking::timestampToLockDate: staking period too short\");\n\n\t\t/// @dev Stake for the sender if not specified otherwise.\n\t\tif (stakeFor == address(0)) {\n\t\t\tstakeFor = sender;\n\t\t}\n\n\t\t/// @dev Delegate for stakeFor if not specified otherwise.\n\t\tif (delegatee == address(0)) {\n\t\t\tdelegatee = stakeFor;\n\t\t}\n\n\t\t/// @dev Do not stake longer than the max duration.\n\t\tif (!timeAdjusted) {\n\t\t\tuint256 latest = timestampToLockDate(block.timestamp + MAX_DURATION);\n\t\t\tif (until > latest) until = latest;\n\t\t}\n\n\t\tuint96 previousBalance = currentBalance(stakeFor, until);\n\n\t\t/// @dev Increase stake.\n\t\t_increaseStake(sender, amount, stakeFor, until);\n\n\t\tif (previousBalance == 0) {\n\t\t\t/// @dev Regular delegation if it's a first stake.\n\t\t\t_delegate(stakeFor, delegatee, until);\n\t\t} else {\n\t\t\taddress previousDelegatee = delegates[stakeFor][until];\n\t\t\tif (previousDelegatee != delegatee) {\n\t\t\t\t/// @dev Update delegatee.\n\t\t\t\tdelegates[stakeFor][until] = delegatee;\n\n\t\t\t\t/// @dev Decrease stake on previous balance for previous delegatee.\n\t\t\t\t_decreaseDelegateStake(previousDelegatee, until, previousBalance);\n\n\t\t\t\t/// @dev Add previousBalance to amount.\n\t\t\t\tamount = add96(previousBalance, amount, \"Staking::stake: balance overflow\");\n\t\t\t}\n\n\t\t\t/// @dev Increase stake.\n\t\t\t_increaseDelegateStake(delegatee, until, amount);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Extend the staking duration until the specified date.\n\t * @param previousLock The old unlocking timestamp.\n\t * @param until The new unlocking timestamp in seconds.\n\t * */\n\tfunction extendStakingDuration(uint256 previousLock, uint256 until) public {\n\t\tuntil = timestampToLockDate(until);\n\t\trequire(previousLock <= until, \"Staking::extendStakingDuration: cannot reduce the staking duration\");\n\n\t\t/// @dev Do not exceed the max duration, no overflow possible.\n\t\tuint256 latest = timestampToLockDate(block.timestamp + MAX_DURATION);\n\t\tif (until > latest) until = latest;\n\n\t\t/// @dev Update checkpoints.\n\t\t/// @dev TODO James: Can reading stake at block.number -1 cause trouble with multiple tx in a block?\n\t\tuint96 amount = getPriorUserStakeByDate(msg.sender, previousLock, block.number - 1);\n\t\trequire(amount > 0, \"Staking::extendStakingDuration: nothing staked until the previous lock date\");\n\t\t_decreaseUserStake(msg.sender, previousLock, amount);\n\t\t_increaseUserStake(msg.sender, until, amount);\n\t\t_decreaseDailyStake(previousLock, amount);\n\t\t_increaseDailyStake(until, amount);\n\n\t\t/// @dev Delegate might change: if there is already a delegate set for the until date, it will remain the delegate for this position\n\t\taddress delegateFrom = delegates[msg.sender][previousLock];\n\t\taddress delegateTo = delegates[msg.sender][until];\n\t\tif (delegateTo == address(0)) {\n\t\t\tdelegateTo = delegateFrom;\n\t\t\tdelegates[msg.sender][until] = delegateFrom;\n\t\t}\n\t\tdelegates[msg.sender][previousLock] = address(0);\n\t\t_decreaseDelegateStake(delegateFrom, previousLock, amount);\n\t\t_increaseDelegateStake(delegateTo, until, amount);\n\n\t\temit ExtendedStakingDuration(msg.sender, previousLock, until);\n\t}\n\n\t/**\n\t * @notice Send sender's tokens to this contract and update its staked balance.\n\t * @param sender The sender of the tokens.\n\t * @param amount The number of tokens to send.\n\t * @param stakeFor The beneficiary whose stake will be increased.\n\t * @param until The date until which the tokens will be staked.\n\t * */\n\tfunction _increaseStake(\n\t\taddress sender,\n\t\tuint96 amount,\n\t\taddress stakeFor,\n\t\tuint256 until\n\t) internal {\n\t\t/// @dev Retrieve the SOV tokens.\n\t\tbool success = SOVToken.transferFrom(sender, address(this), amount);\n\t\trequire(success);\n\n\t\t/// @dev Increase staked balance.\n\t\tuint96 balance = currentBalance(stakeFor, until);\n\t\tbalance = add96(balance, amount, \"Staking::increaseStake: balance overflow\");\n\n\t\t/// @dev Update checkpoints.\n\t\t_increaseDailyStake(until, amount);\n\t\t_increaseUserStake(stakeFor, until, amount);\n\n\t\temit TokensStaked(stakeFor, amount, until, balance);\n\t}\n\n\t/**\n\t * @notice Stake tokens according to the vesting schedule.\n\t * @param amount The amount of tokens to stake.\n\t * @param cliff The time interval to the first withdraw.\n\t * @param duration The staking duration.\n\t * @param intervalLength The length of each staking interval when cliff passed.\n\t * @param stakeFor The address to stake the tokens for or 0x0 if staking for oneself.\n\t * @param delegatee The address of the delegatee or 0x0 if there is none.\n\t * */\n\tfunction stakesBySchedule(\n\t\tuint256 amount,\n\t\tuint256 cliff,\n\t\tuint256 duration,\n\t\tuint256 intervalLength,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) public {\n\t\t/**\n\t\t * @dev Stake them until lock dates according to the vesting schedule.\n\t\t * Note: because staking is only possible in periods of 2 weeks,\n\t\t * the total duration might end up a bit shorter than specified\n\t\t * depending on the date of staking.\n\t\t * */\n\t\tuint256 start = timestampToLockDate(block.timestamp + cliff);\n\t\tif (duration > MAX_DURATION) {\n\t\t\tduration = MAX_DURATION;\n\t\t}\n\t\tuint256 end = timestampToLockDate(block.timestamp + duration);\n\t\tuint256 numIntervals = (end - start) / intervalLength + 1;\n\t\tuint256 stakedPerInterval = amount / numIntervals;\n\t\t/// @dev stakedPerInterval might lose some dust on rounding. Add it to the first staking date.\n\t\tif (numIntervals >= 1) {\n\t\t\t_stake(msg.sender, uint96(amount - stakedPerInterval * (numIntervals - 1)), start, stakeFor, delegatee, true);\n\t\t}\n\t\t/// @dev Stake the rest in 4 week intervals.\n\t\tfor (uint256 i = start + intervalLength; i <= end; i += intervalLength) {\n\t\t\t/// @dev Stakes for itself, delegates to the owner.\n\t\t\t_stake(msg.sender, uint96(stakedPerInterval), i, stakeFor, delegatee, true);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Withdraw the given amount of tokens if they are unlocked.\n\t * @param amount The number of tokens to withdraw.\n\t * @param until The date until which the tokens were staked.\n\t * @param receiver The receiver of the tokens. If not specified, send to the msg.sender\n\t * */\n\tfunction withdraw(\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress receiver\n\t) public {\n\t\t_withdraw(amount, until, receiver, false);\n\t}\n\n\t/**\n\t * @notice Withdraw the given amount of tokens.\n\t * @param amount The number of tokens to withdraw.\n\t * @param until The date until which the tokens were staked.\n\t * @param receiver The receiver of the tokens. If not specified, send to the msg.sender\n\t * @dev Can be invoked only by whitelisted contract passed to governanceWithdrawVesting\n\t * */\n\tfunction governanceWithdraw(\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress receiver\n\t) public {\n\t\trequire(vestingWhitelist[msg.sender], \"unauthorized\");\n\n\t\t_withdraw(amount, until, receiver, true);\n\t}\n\n\t/**\n\t * @notice Withdraw tokens for vesting contract.\n\t * @param vesting The address of Vesting contract.\n\t * @param receiver The receiver of the tokens. If not specified, send to the msg.sender\n\t * @dev Can be invoked only by whitelisted contract passed to governanceWithdrawVesting.\n\t * */\n\tfunction governanceWithdrawVesting(address vesting, address receiver) public onlyOwner {\n\t\tvestingWhitelist[vesting] = true;\n\t\tITeamVesting(vesting).governanceWithdrawTokens(receiver);\n\t\tvestingWhitelist[vesting] = false;\n\n\t\temit VestingTokensWithdrawn(vesting, receiver);\n\t}\n\n\t/**\n\t * @notice Send user' staked tokens to a receiver taking into account punishments.\n\t * Sovryn encourages long-term commitment and thinking. When/if you unstake before\n\t * the end of the staking period, a percentage of the original staking amount will\n\t * be slashed. This amount is also added to the reward pool and is distributed\n\t * between all other stakers.\n\t *\n\t * @param amount The number of tokens to withdraw.\n\t * @param until The date until which the tokens were staked.\n\t * @param receiver The receiver of the tokens. If not specified, send to the msg.sender\n\t * @param isGovernance Whether all tokens (true)\n\t * or just unlocked tokens (false).\n\t * */\n\tfunction _withdraw(\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress receiver,\n\t\tbool isGovernance\n\t) internal {\n\t\tuntil = _adjustDateForOrigin(until);\n\t\t_validateWithdrawParams(amount, until);\n\n\t\t/// @dev Determine the receiver.\n\t\tif (receiver == address(0)) receiver = msg.sender;\n\n\t\t/// @dev Update the checkpoints.\n\t\t_decreaseDailyStake(until, amount);\n\t\t_decreaseUserStake(msg.sender, until, amount);\n\t\t_decreaseDelegateStake(delegates[msg.sender][until], until, amount);\n\n\t\t/// @dev Early unstaking should be punished.\n\t\tif (block.timestamp < until && !allUnlocked && !isGovernance) {\n\t\t\tuint96 punishedAmount = _getPunishedAmount(amount, until);\n\t\t\tamount -= punishedAmount;\n\n\t\t\t/// @dev punishedAmount can be 0 if block.timestamp are very close to 'until'\n\t\t\tif (punishedAmount > 0) {\n\t\t\t\trequire(address(feeSharing) != address(0), \"Staking::withdraw: FeeSharing address wasn't set\");\n\t\t\t\t/// @dev Move punished amount to fee sharing.\n\t\t\t\t/// @dev Approve transfer here and let feeSharing do transfer and write checkpoint.\n\t\t\t\tSOVToken.approve(address(feeSharing), punishedAmount);\n\t\t\t\tfeeSharing.transferTokens(address(SOVToken), punishedAmount);\n\t\t\t}\n\t\t}\n\n\t\t/// @dev transferFrom\n\t\tbool success = SOVToken.transfer(receiver, amount);\n\t\trequire(success, \"Staking::withdraw: Token transfer failed\");\n\n\t\temit TokensWithdrawn(msg.sender, receiver, amount);\n\t}\n\n\t/**\n\t * @notice Get available and punished amount for withdrawing.\n\t * @param amount The number of tokens to withdraw.\n\t * @param until The date until which the tokens were staked.\n\t * */\n\tfunction getWithdrawAmounts(uint96 amount, uint256 until) public view returns (uint96, uint96) {\n\t\t_validateWithdrawParams(amount, until);\n\t\tuint96 punishedAmount = _getPunishedAmount(amount, until);\n\t\treturn (amount - punishedAmount, punishedAmount);\n\t}\n\n\t/**\n\t * @notice Get punished amount for withdrawing.\n\t * @param amount The number of tokens to withdraw.\n\t * @param until The date until which the tokens were staked.\n\t * */\n\tfunction _getPunishedAmount(uint96 amount, uint256 until) internal view returns (uint96) {\n\t\tuint256 date = timestampToLockDate(block.timestamp);\n\t\tuint96 weight = computeWeightByDate(until, date); /// @dev (10 - 1) * WEIGHT_FACTOR\n\t\tweight = weight * weightScaling;\n\t\treturn (amount * weight) / WEIGHT_FACTOR / 100;\n\t}\n\n\t/**\n\t * @notice Validate withdraw parameters.\n\t * @param amount The number of tokens to withdraw.\n\t * @param until The date until which the tokens were staked.\n\t * */\n\tfunction _validateWithdrawParams(uint96 amount, uint256 until) internal view {\n\t\trequire(amount > 0, \"Staking::withdraw: amount of tokens to be withdrawn needs to be bigger than 0\");\n\t\tuint96 balance = getPriorUserStakeByDate(msg.sender, until, block.number - 1);\n\t\trequire(amount <= balance, \"Staking::withdraw: not enough balance\");\n\t}\n\n\t/**\n\t * @notice Get the current balance of an account locked until a certain date.\n\t * @param account The user address.\n\t * @param lockDate The lock date.\n\t * @return The stake amount.\n\t * */\n\tfunction currentBalance(address account, uint256 lockDate) internal view returns (uint96) {\n\t\treturn userStakingCheckpoints[account][lockDate][numUserStakingCheckpoints[account][lockDate] - 1].stake;\n\t}\n\n\t/**\n\t * @notice Get the number of staked tokens held by the user account.\n\t * @dev Iterate checkpoints adding up stakes.\n\t * @param account The address of the account to get the balance of.\n\t * @return The number of tokens held.\n\t * */\n\tfunction balanceOf(address account) public view returns (uint96 balance) {\n\t\tfor (uint256 i = kickoffTS; i <= block.timestamp + MAX_DURATION; i += TWO_WEEKS) {\n\t\t\tbalance = add96(balance, currentBalance(account, i), \"Staking::balanceOf: overflow\");\n\t\t}\n\t}\n\n\t/**\n\t * @notice Delegate votes from `msg.sender` which are locked until lockDate to `delegatee`.\n\t * @param delegatee The address to delegate votes to.\n\t * @param lockDate the date if the position to delegate.\n\t * */\n\tfunction delegate(address delegatee, uint256 lockDate) public {\n\t\treturn _delegate(msg.sender, delegatee, lockDate);\n\t}\n\n\t/**\n\t * @notice Delegates votes from signatory to a delegatee account.\n\t * Voting with EIP-712 Signatures.\n\t *\n\t * Voting power can be delegated to any address, and then can be used to\n\t * vote on proposals. A key benefit to users of by-signature functionality\n\t * is that they can create a signed vote transaction for free, and have a\n\t * trusted third-party spend rBTC(or ETH) on gas fees and write it to the\n\t * blockchain for them.\n\t *\n\t * The third party in this scenario, submitting the SOV-holder’s signed\n\t * transaction holds a voting power that is for only a single proposal.\n\t * The signatory still holds the power to vote on their own behalf in\n\t * the proposal if the third party has not yet published the signed\n\t * transaction that was given to them.\n\t *\n\t * @dev The signature needs to be broken up into 3 parameters, known as\n\t * v, r and s:\n\t * const r = '0x' + sig.substring(2).substring(0, 64);\n\t * const s = '0x' + sig.substring(2).substring(64, 128);\n\t * const v = '0x' + sig.substring(2).substring(128, 130);\n\t *\n\t * @param delegatee The address to delegate votes to.\n\t * @param lockDate The date until which the position is locked.\n\t * @param nonce The contract state required to match the signature.\n\t * @param expiry The time at which to expire the signature.\n\t * @param v The recovery byte of the signature.\n\t * @param r Half of the ECDSA signature pair.\n\t * @param s Half of the ECDSA signature pair.\n\t * */\n\tfunction delegateBySig(\n\t\taddress delegatee,\n\t\tuint256 lockDate,\n\t\tuint256 nonce,\n\t\tuint256 expiry,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public {\n\t\t/**\n\t\t * @dev The DOMAIN_SEPARATOR is a hash that uniquely identifies a\n\t\t * smart contract. It is built from a string denoting it as an\n\t\t * EIP712 Domain, the name of the token contract, the version,\n\t\t * the chainId in case it changes, and the address that the\n\t\t * contract is deployed at.\n\t\t * */\n\t\tbytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n\n\t\t/// @dev GovernorAlpha uses BALLOT_TYPEHASH, while Staking uses DELEGATION_TYPEHASH\n\t\tbytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, lockDate, nonce, expiry));\n\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n\t\taddress signatory = ecrecover(digest, v, r, s);\n\n\t\t/// @dev Verify address is not null and PK is not null either.\n\t\trequire(RSKAddrValidator.checkPKNotZero(signatory), \"Staking::delegateBySig: invalid signature\");\n\t\trequire(nonce == nonces[signatory]++, \"Staking::delegateBySig: invalid nonce\");\n\t\trequire(now <= expiry, \"Staking::delegateBySig: signature expired\");\n\t\treturn _delegate(signatory, delegatee, lockDate);\n\t}\n\n\t/**\n\t * @notice Get the current votes balance for a user account.\n\t * @param account The address to get votes balance.\n\t * @dev This is a wrapper to simplify arguments. The actual computation is\n\t * performed on WeightedStaking parent contract.\n\t * @return The number of current votes for a user account.\n\t * */\n\tfunction getCurrentVotes(address account) external view returns (uint96) {\n\t\treturn getPriorVotes(account, block.number - 1, block.timestamp);\n\t}\n\n\t/**\n\t * @notice Get the current number of tokens staked for a day.\n\t * @param lockedTS The timestamp to get the staked tokens for.\n\t * */\n\tfunction getCurrentStakedUntil(uint256 lockedTS) external view returns (uint96) {\n\t\tuint32 nCheckpoints = numTotalStakingCheckpoints[lockedTS];\n\t\treturn nCheckpoints > 0 ? totalStakingCheckpoints[lockedTS][nCheckpoints - 1].stake : 0;\n\t}\n\n\t/**\n\t * @notice Set new delegatee. Move from user's current delegate to a new\n\t * delegatee the stake balance.\n\t * @param delegator The user address to move stake balance from its current delegatee.\n\t * @param delegatee The new delegatee. The address to move stake balance to.\n\t * @param lockedTS The lock date.\n\t * */\n\tfunction _delegate(\n\t\taddress delegator,\n\t\taddress delegatee,\n\t\tuint256 lockedTS\n\t) internal {\n\t\taddress currentDelegate = delegates[delegator][lockedTS];\n\t\tuint96 delegatorBalance = currentBalance(delegator, lockedTS);\n\t\tdelegates[delegator][lockedTS] = delegatee;\n\n\t\temit DelegateChanged(delegator, lockedTS, currentDelegate, delegatee);\n\n\t\t_moveDelegates(currentDelegate, delegatee, delegatorBalance, lockedTS);\n\t}\n\n\t/**\n\t * @notice Move an amount of delegate stake from a source address to a\n\t * destination address.\n\t * @param srcRep The address to get the staked amount from.\n\t * @param dstRep The address to send the staked amount to.\n\t * @param amount The staked amount to move.\n\t * @param lockedTS The lock date.\n\t * */\n\tfunction _moveDelegates(\n\t\taddress srcRep,\n\t\taddress dstRep,\n\t\tuint96 amount,\n\t\tuint256 lockedTS\n\t) internal {\n\t\tif (srcRep != dstRep && amount > 0) {\n\t\t\tif (srcRep != address(0)) _decreaseDelegateStake(srcRep, lockedTS, amount);\n\n\t\t\tif (dstRep != address(0)) _increaseDelegateStake(dstRep, lockedTS, amount);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Retrieve CHAIN_ID of the executing chain.\n\t *\n\t * Chain identifier (chainID) introduced in EIP-155 protects transaction\n\t * included into one chain from being included into another chain.\n\t * Basically, chain identifier is an integer number being used in the\n\t * processes of signing transactions and verifying transaction signatures.\n\t *\n\t * @dev As of version 0.5.12, Solidity includes an assembly function\n\t * chainid() that provides access to the new CHAINID opcode.\n\t *\n\t * TODO: chainId is included in block. So you can get chain id like\n\t * block timestamp or block number: block.chainid;\n\t * */\n\tfunction getChainId() internal pure returns (uint256) {\n\t\tuint256 chainId;\n\t\tassembly {\n\t\t\tchainId := chainid()\n\t\t}\n\t\treturn chainId;\n\t}\n\n\t/**\n\t * @notice Allow the owner to set a new staking contract.\n\t * As a consequence it allows the stakers to migrate their positions\n\t * to the new contract.\n\t * @dev Doesn't have any influence as long as migrateToNewStakingContract\n\t * is not implemented.\n\t * @param _newStakingContract The address of the new staking contract.\n\t * */\n\tfunction setNewStakingContract(address _newStakingContract) public onlyOwner {\n\t\trequire(_newStakingContract != address(0), \"can't reset the new staking contract to 0\");\n\t\tnewStakingContract = _newStakingContract;\n\t}\n\n\t/**\n\t * @notice Allow the owner to set a fee sharing proxy contract.\n\t * We need it for unstaking with slashing.\n\t * @param _feeSharing The address of FeeSharingProxy contract.\n\t * */\n\tfunction setFeeSharing(address _feeSharing) public onlyOwner {\n\t\trequire(_feeSharing != address(0), \"FeeSharing address shouldn't be 0\");\n\t\tfeeSharing = IFeeSharingProxy(_feeSharing);\n\t}\n\n\t/**\n\t * @notice Allow the owner to set weight scaling.\n\t * We need it for unstaking with slashing.\n\t * @param _weightScaling The weight scaling.\n\t * */\n\tfunction setWeightScaling(uint96 _weightScaling) public onlyOwner {\n\t\trequire(\n\t\t\tMIN_WEIGHT_SCALING <= _weightScaling && _weightScaling <= MAX_WEIGHT_SCALING,\n\t\t\t\"weight scaling doesn't belong to range [1, 9]\"\n\t\t);\n\t\tweightScaling = _weightScaling;\n\t}\n\n\t/**\n\t * @notice Allow a staker to migrate his positions to the new staking contract.\n\t * @dev Staking contract needs to be set before by the owner.\n\t * Currently not implemented, just needed for the interface.\n\t *      In case it's needed at some point in the future,\n\t *      the implementation needs to be changed first.\n\t * */\n\tfunction migrateToNewStakingContract() public {\n\t\trequire(newStakingContract != address(0), \"there is no new staking contract set\");\n\t\t/// @dev implementation:\n\t\t/// @dev Iterate over all possible lock dates from now until now + MAX_DURATION.\n\t\t/// @dev Read the stake & delegate of the msg.sender\n\t\t/// @dev If stake > 0, stake it at the new contract until the lock date with the current delegate.\n\t}\n\n\t/**\n\t * @notice Allow the owner to unlock all tokens in case the staking contract\n\t * is going to be replaced\n\t * Note: Not reversible on purpose. once unlocked, everything is unlocked.\n\t * The owner should not be able to just quickly unlock to withdraw his own\n\t * tokens and lock again.\n\t * @dev Last resort.\n\t * */\n\tfunction unlockAllTokens() public onlyOwner {\n\t\tallUnlocked = true;\n\t\temit TokensUnlocked(SOVToken.balanceOf(address(this)));\n\t}\n\n\t/**\n\t * @notice Get list of stakes for a user account.\n\t * @param account The address to get stakes.\n\t * @return The arrays of dates and stakes.\n\t * */\n\tfunction getStakes(address account) external view returns (uint256[] memory dates, uint96[] memory stakes) {\n\t\tuint256 latest = timestampToLockDate(block.timestamp + MAX_DURATION);\n\n\t\t/// @dev Calculate stakes.\n\t\tuint256 count = 0;\n\t\t/// @dev We need to iterate from first possible stake date after deployment to the latest from current time.\n\t\tfor (uint256 i = kickoffTS + TWO_WEEKS; i <= latest; i += TWO_WEEKS) {\n\t\t\tif (currentBalance(account, i) > 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tdates = new uint256[](count);\n\t\tstakes = new uint96[](count);\n\n\t\t/// @dev We need to iterate from first possible stake date after deployment to the latest from current time.\n\t\tuint256 j = 0;\n\t\tfor (uint256 i = kickoffTS + TWO_WEEKS; i <= latest; i += TWO_WEEKS) {\n\t\t\tuint96 balance = currentBalance(account, i);\n\t\t\tif (balance > 0) {\n\t\t\t\tdates[j] = i;\n\t\t\t\tstakes[j] = balance;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Overrides default ApprovalReceiver._getToken function to\n\t * register SOV token on this contract.\n\t * @return The address of SOV token.\n\t * */\n\tfunction _getToken() internal view returns (address) {\n\t\treturn address(SOVToken);\n\t}\n\n\t/**\n\t * @notice Overrides default ApprovalReceiver._getSelectors function to\n\t * register stakeWithApproval selector on this contract.\n\t * @return The array of registered selectors on this contract.\n\t * */\n\tfunction _getSelectors() internal view returns (bytes4[] memory) {\n\t\tbytes4[] memory selectors = new bytes4[](1);\n\t\tselectors[0] = this.stakeWithApproval.selector;\n\t\treturn selectors;\n\t}\n}\n\n// File: contracts/governance/Vesting/VestingStorage.sol\n\npragma solidity ^0.5.17;\n\n\n\n\n\n/**\n * @title Vesting Storage Contract.\n *\n * @notice This contract is just the storage required for vesting.\n * It is parent of VestingLogic and TeamVesting.\n *\n * @dev Use Ownable as a parent to align storage structure for Logic and Proxy contracts.\n * */\ncontract VestingStorage is Ownable {\n\t/// @notice The SOV token contract.\n\tIERC20 public SOV;\n\n\t/// @notice The staking contract address.\n\tStaking public staking;\n\n\t/// @notice The owner of the vested tokens.\n\taddress public tokenOwner;\n\n\t/// @notice Fee sharing Proxy.\n\tIFeeSharingProxy public feeSharingProxy;\n\n\t/// @notice The cliff. After this time period the tokens begin to unlock.\n\tuint256 public cliff;\n\n\t/// @notice The duration. After this period all tokens will have been unlocked.\n\tuint256 public duration;\n\n\t/// @notice The start date of the vesting.\n\tuint256 public startDate;\n\n\t/// @notice The end date of the vesting.\n\tuint256 public endDate;\n\n\t/// @notice Constant used for computing the vesting dates.\n\tuint256 constant FOUR_WEEKS = 4 weeks;\n}\n\n// File: contracts/governance/Vesting/VestingLogic.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title Vesting Logic contract.\n * @notice Staking, delegating and withdrawal functionality.\n * @dev Deployed by a VestingFactory contract.\n * */\ncontract VestingLogic is IVesting, VestingStorage, ApprovalReceiver {\n\t/* Events */\n\n\tevent TokensStaked(address indexed caller, uint256 amount);\n\tevent VotesDelegated(address indexed caller, address delegatee);\n\tevent TokensWithdrawn(address indexed caller, address receiver);\n\tevent DividendsCollected(address indexed caller, address loanPoolToken, address receiver, uint32 maxCheckpoints);\n\tevent MigratedToNewStakingContract(address indexed caller, address newStakingContract);\n\n\t/* Modifiers */\n\n\t/**\n\t * @dev Throws if called by any account other than the token owner or the contract owner.\n\t */\n\tmodifier onlyOwners() {\n\t\trequire(msg.sender == tokenOwner || isOwner(), \"unauthorized\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the token owner.\n\t */\n\tmodifier onlyTokenOwner() {\n\t\trequire(msg.sender == tokenOwner, \"unauthorized\");\n\t\t_;\n\t}\n\n\t/* Functions */\n\n\t/**\n\t * @notice Stakes tokens according to the vesting schedule.\n\t * @param _amount The amount of tokens to stake.\n\t * */\n\tfunction stakeTokens(uint256 _amount) public {\n\t\t_stakeTokens(msg.sender, _amount);\n\t}\n\n\t/**\n\t * @notice Stakes tokens according to the vesting schedule.\n\t * @dev This function will be invoked from receiveApproval.\n\t * @dev SOV.approveAndCall -> this.receiveApproval -> this.stakeTokensWithApproval\n\t * @param _sender The sender of SOV.approveAndCall\n\t * @param _amount The amount of tokens to stake.\n\t * */\n\tfunction stakeTokensWithApproval(address _sender, uint256 _amount) public onlyThisContract {\n\t\t_stakeTokens(_sender, _amount);\n\t}\n\n\t/**\n\t * @notice Stakes tokens according to the vesting schedule. Low level function.\n\t * @dev Once here the allowance of tokens is taken for granted.\n\t * @param _sender The sender of tokens to stake.\n\t * @param _amount The amount of tokens to stake.\n\t * */\n\tfunction _stakeTokens(address _sender, uint256 _amount) internal {\n\t\t/// @dev Maybe better to allow staking unil the cliff was reached.\n\t\tif (startDate == 0) {\n\t\t\tstartDate = staking.timestampToLockDate(block.timestamp);\n\t\t}\n\t\tendDate = staking.timestampToLockDate(block.timestamp + duration);\n\n\t\t/// @dev Transfer the tokens to this contract.\n\t\tbool success = SOV.transferFrom(_sender, address(this), _amount);\n\t\trequire(success);\n\n\t\t/// @dev Allow the staking contract to access them.\n\t\tSOV.approve(address(staking), _amount);\n\n\t\tstaking.stakesBySchedule(_amount, cliff, duration, FOUR_WEEKS, address(this), tokenOwner);\n\n\t\temit TokensStaked(_sender, _amount);\n\t}\n\n\t/**\n\t * @notice Delegate votes from `msg.sender` which are locked until lockDate\n\t * to `delegatee`.\n\t * @param _delegatee The address to delegate votes to.\n\t * */\n\tfunction delegate(address _delegatee) public onlyTokenOwner {\n\t\trequire(_delegatee != address(0), \"delegatee address invalid\");\n\n\t\t/// @dev Withdraw for each unlocked position.\n\t\tfor (uint256 i = startDate + cliff; i <= endDate; i += FOUR_WEEKS) {\n\t\t\tstaking.delegate(_delegatee, i);\n\t\t}\n\t\temit VotesDelegated(msg.sender, _delegatee);\n\t}\n\n\t/**\n\t * @notice Withdraws all tokens from the staking contract and\n\t * forwards them to an address specified by the token owner.\n\t * @param receiver The receiving address.\n\t * @dev Can be called only by owner.\n\t * */\n\tfunction governanceWithdrawTokens(address receiver) public {\n\t\trequire(msg.sender == address(staking), \"unauthorized\");\n\n\t\t_withdrawTokens(receiver, true);\n\t}\n\n\t/**\n\t * @notice Withdraws unlocked tokens from the staking contract and\n\t * forwards them to an address specified by the token owner.\n\t * @param receiver The receiving address.\n\t * */\n\tfunction withdrawTokens(address receiver) public onlyOwners {\n\t\t_withdrawTokens(receiver, false);\n\t}\n\n\t/**\n\t * @notice Withdraws tokens from the staking contract and forwards them\n\t * to an address specified by the token owner. Low level function.\n\t * @dev Once here the caller permission is taken for granted.\n\t * @param receiver The receiving address.\n\t * @param isGovernance Whether all tokens (true)\n\t * or just unlocked tokens (false).\n\t * */\n\tfunction _withdrawTokens(address receiver, bool isGovernance) internal {\n\t\trequire(receiver != address(0), \"receiver address invalid\");\n\n\t\tuint96 stake;\n\n\t\t/// @dev Usually we just need to iterate over the possible dates until now.\n\t\tuint256 end;\n\n\t\t/// @dev In the unlikely case that all tokens have been unlocked early,\n\t\t///   allow to withdraw all of them.\n\t\tif (staking.allUnlocked() || isGovernance) {\n\t\t\tend = endDate;\n\t\t} else {\n\t\t\tend = block.timestamp;\n\t\t}\n\n\t\t/// @dev Withdraw for each unlocked position.\n\t\tfor (uint256 i = startDate + cliff; i <= end; i += FOUR_WEEKS) {\n\t\t\t/// @dev Read amount to withdraw.\n\t\t\tstake = staking.getPriorUserStakeByDate(address(this), i, block.number - 1);\n\n\t\t\t/// @dev Withdraw if > 0\n\t\t\tif (stake > 0) {\n\t\t\t\tif (isGovernance) {\n\t\t\t\t\tstaking.governanceWithdraw(stake, i, receiver);\n\t\t\t\t} else {\n\t\t\t\t\tstaking.withdraw(stake, i, receiver);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\temit TokensWithdrawn(msg.sender, receiver);\n\t}\n\n\t/**\n\t * @notice Collect dividends from fee sharing proxy.\n\t * @param _loanPoolToken The loan pool token address.\n\t * @param _maxCheckpoints Maximum number of checkpoints to be processed.\n\t * @param _receiver The receiver of tokens or msg.sender\n\t * */\n\tfunction collectDividends(\n\t\taddress _loanPoolToken,\n\t\tuint32 _maxCheckpoints,\n\t\taddress _receiver\n\t) public onlyOwners {\n\t\trequire(_receiver != address(0), \"receiver address invalid\");\n\n\t\t/// @dev Invokes the fee sharing proxy.\n\t\tfeeSharingProxy.withdraw(_loanPoolToken, _maxCheckpoints, _receiver);\n\n\t\temit DividendsCollected(msg.sender, _loanPoolToken, _receiver, _maxCheckpoints);\n\t}\n\n\t/**\n\t * @notice Allows the owners to migrate the positions\n\t * to a new staking contract.\n\t * */\n\tfunction migrateToNewStakingContract() public onlyOwners {\n\t\tstaking.migrateToNewStakingContract();\n\t\tstaking = Staking(staking.newStakingContract());\n\t\temit MigratedToNewStakingContract(msg.sender, address(staking));\n\t}\n\n\t/**\n\t * @notice Overrides default ApprovalReceiver._getToken function to\n\t * register SOV token on this contract.\n\t * @return The address of SOV token.\n\t * */\n\tfunction _getToken() internal view returns (address) {\n\t\treturn address(SOV);\n\t}\n\n\t/**\n\t * @notice Overrides default ApprovalReceiver._getSelectors function to\n\t * register stakeTokensWithApproval selector on this contract.\n\t * @return The array of registered selectors on this contract.\n\t * */\n\tfunction _getSelectors() internal view returns (bytes4[] memory) {\n\t\tbytes4[] memory selectors = new bytes4[](1);\n\t\tselectors[0] = this.stakeTokensWithApproval.selector;\n\t\treturn selectors;\n\t}\n}\n\n// File: contracts/locked/ILockedSOV.sol\n\npragma solidity ^0.5.17;\n\n/**\n *  @title The Locked SOV Interface.\n *  @author Franklin Richards - powerhousefrank@protonmail.com\n *  @notice This interface is an incomplete yet useful for future migration of LockedSOV Contract.\n *  @dev Only use it if you know what you are doing.\n */\ninterface ILockedSOV {\n\t/**\n\t * @notice Adds SOV to the user balance (Locked and Unlocked Balance based on `_basisPoint`).\n\t * @param _userAddress The user whose locked balance has to be updated with `_sovAmount`.\n\t * @param _sovAmount The amount of SOV to be added to the locked and/or unlocked balance.\n\t * @param _basisPoint The % (in Basis Point)which determines how much will be unlocked immediately.\n\t */\n\tfunction deposit(\n\t\taddress _userAddress,\n\t\tuint256 _sovAmount,\n\t\tuint256 _basisPoint\n\t) external;\n\n\t/**\n\t * @notice Adds SOV to the locked balance of a user.\n\t * @param _userAddress The user whose locked balance has to be updated with _sovAmount.\n\t * @param _sovAmount The amount of SOV to be added to the locked balance.\n\t */\n\tfunction depositSOV(address _userAddress, uint256 _sovAmount) external;\n\n\t/**\n\t * @notice Withdraws unlocked tokens and Stakes Locked tokens for a user who already have a vesting created.\n\t * @param _userAddress The address of user tokens will be withdrawn.\n\t */\n\tfunction withdrawAndStakeTokensFrom(address _userAddress) external;\n}\n\n// File: contracts/locked/LockedSOV.sol\n\npragma solidity ^0.5.17;\n\n\n\n\n\n\n/**\n *  @title The Locked SOV Contract.\n *  @author Franklin Richards - powerhousefrank@protonmail.com\n *  @notice This contract is used to receive reward from other contracts, Create Vesting and Stake Tokens.\n */\ncontract LockedSOV is ILockedSOV {\n\tusing SafeMath for uint256;\n\n\t/* Storage */\n\n\t/// @notice True if the migration to a new Locked SOV Contract has started.\n\tbool public migration;\n\n\t/// @notice The cliff is the time period after which the tokens begin to unlock.\n\tuint256 public cliff;\n\t/// @notice The duration is the time period after all tokens will have been unlocked.\n\tuint256 public duration;\n\n\t/// @notice The SOV token contract.\n\tIERC20 public SOV;\n\t/// @notice The Vesting registry contract.\n\tVestingRegistry public vestingRegistry;\n\t/// @notice The New (Future) Locked SOV.\n\tILockedSOV public newLockedSOV;\n\n\t/// @notice The locked user balances.\n\tmapping(address => uint256) private lockedBalances;\n\t/// @notice The unlocked user balances.\n\tmapping(address => uint256) private unlockedBalances;\n\t/// @notice The contracts/wallets with admin power.\n\tmapping(address => bool) private isAdmin;\n\n\t/* Events */\n\n\t/// @notice Emitted when a new Admin is added to the admin list.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _newAdmin The address of the new admin.\n\tevent AdminAdded(address indexed _initiator, address indexed _newAdmin);\n\n\t/// @notice Emitted when an admin is removed from the admin list.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _removedAdmin The address of the removed admin.\n\tevent AdminRemoved(address indexed _initiator, address indexed _removedAdmin);\n\n\t/// @notice Emitted when Vesting Registry, Duration and/or Cliff is updated.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _vestingRegistry The Vesting Registry Contract.\n\t/// @param _cliff The time period after which the tokens begin to unlock.\n\t/// @param _duration The time period after all tokens will have been unlocked.\n\tevent RegistryCliffAndDurationUpdated(address indexed _initiator, address indexed _vestingRegistry, uint256 _cliff, uint256 _duration);\n\n\t/// @notice Emitted when a new deposit is made.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _userAddress The user to whose un/locked balance a new deposit was made.\n\t/// @param _sovAmount The amount of SOV to be added to the un/locked balance.\n\t/// @param _basisPoint The % (in Basis Point) which determines how much will be unlocked immediately.\n\tevent Deposited(address indexed _initiator, address indexed _userAddress, uint256 _sovAmount, uint256 _basisPoint);\n\n\t/// @notice Emitted when a user withdraws the fund.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _userAddress The user whose unlocked balance has to be withdrawn.\n\t/// @param _sovAmount The amount of SOV withdrawn from the unlocked balance.\n\tevent Withdrawn(address indexed _initiator, address indexed _userAddress, uint256 _sovAmount);\n\n\t/// @notice Emitted when a user creates a vesting for himself.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _userAddress The user whose unlocked balance has to be withdrawn.\n\t/// @param _vesting The Vesting Contract.\n\tevent VestingCreated(address indexed _initiator, address indexed _userAddress, address indexed _vesting);\n\n\t/// @notice Emitted when a user stakes tokens.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _vesting The Vesting Contract.\n\t/// @param _amount The amount of locked tokens staked by the user.\n\tevent TokenStaked(address indexed _initiator, address indexed _vesting, uint256 _amount);\n\n\t/// @notice Emitted when an admin initiates a migration to new Locked SOV Contract.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _newLockedSOV The address of the new Locked SOV Contract.\n\tevent MigrationStarted(address indexed _initiator, address indexed _newLockedSOV);\n\n\t/// @notice Emitted when a user initiates the transfer to a new Locked SOV Contract.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _amount The amount of locked tokens to transfer from this contract to the new one.\n\tevent UserTransfered(address indexed _initiator, uint256 _amount);\n\n\t/* Modifiers */\n\n\tmodifier onlyAdmin {\n\t\trequire(isAdmin[msg.sender], \"Only admin can call this.\");\n\t\t_;\n\t}\n\n\tmodifier migrationAllowed {\n\t\trequire(migration, \"Migration has not yet started.\");\n\t\t_;\n\t}\n\n\t/* Constructor */\n\n\t/**\n\t * @notice Setup the required parameters.\n\t * @param _SOV The SOV Token Address.\n\t * @param _vestingRegistry The Vesting Registry Address.\n\t * @param _cliff The time period after which the tokens begin to unlock.\n\t * @param _duration The time period after all tokens will have been unlocked.\n\t * @param _admins The list of Admins to be added.\n\t */\n\tconstructor(\n\t\taddress _SOV,\n\t\taddress _vestingRegistry,\n\t\tuint256 _cliff,\n\t\tuint256 _duration,\n\t\taddress[] memory _admins\n\t) public {\n\t\trequire(_SOV != address(0), \"Invalid SOV Address.\");\n\t\trequire(_vestingRegistry != address(0), \"Vesting registry address is invalid.\");\n\t\trequire(_duration < 37, \"Duration is too long.\");\n\n\t\tSOV = IERC20(_SOV);\n\t\tvestingRegistry = VestingRegistry(_vestingRegistry);\n\t\tcliff = _cliff * 4 weeks;\n\t\tduration = _duration * 4 weeks;\n\n\t\tfor (uint256 index = 0; index < _admins.length; index++) {\n\t\t\tisAdmin[_admins[index]] = true;\n\t\t}\n\t}\n\n\t/* Public or External Functions */\n\n\t/**\n\t * @notice The function to add a new admin.\n\t * @param _newAdmin The address of the new admin.\n\t * @dev Only callable by an Admin.\n\t */\n\tfunction addAdmin(address _newAdmin) public onlyAdmin {\n\t\trequire(_newAdmin != address(0), \"Invalid Address.\");\n\t\trequire(!isAdmin[_newAdmin], \"Address is already admin.\");\n\t\tisAdmin[_newAdmin] = true;\n\n\t\temit AdminAdded(msg.sender, _newAdmin);\n\t}\n\n\t/**\n\t * @notice The function to remove an admin.\n\t * @param _adminToRemove The address of the admin which should be removed.\n\t * @dev Only callable by an Admin.\n\t */\n\tfunction removeAdmin(address _adminToRemove) public onlyAdmin {\n\t\trequire(isAdmin[_adminToRemove], \"Address is not an admin.\");\n\t\tisAdmin[_adminToRemove] = false;\n\n\t\temit AdminRemoved(msg.sender, _adminToRemove);\n\t}\n\n\t/**\n\t * @notice The function to update the Vesting Registry, Duration and Cliff.\n\t * @param _vestingRegistry The Vesting Registry Address.\n\t * @param _cliff The time period after which the tokens begin to unlock.\n\t * @param _duration The time period after all tokens will have been unlocked.\n\t * @dev IMPORTANT 1: You have to change Vesting Registry if you want to change Duration and/or Cliff.\n\t * IMPORTANT 2: `_cliff` and `_duration` is multiplied by 4 weeks in this function.\n\t */\n\tfunction changeRegistryCliffAndDuration(\n\t\taddress _vestingRegistry,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) external onlyAdmin {\n\t\trequire(address(vestingRegistry) != _vestingRegistry, \"Vesting Registry has to be different for changing duration and cliff.\");\n\t\t/// If duration is also zero, then it is similar to Unlocked SOV.\n\t\trequire(_duration != 0, \"Duration cannot be zero.\");\n\t\trequire(_duration < 37, \"Duration is too long.\");\n\n\t\tvestingRegistry = VestingRegistry(_vestingRegistry);\n\n\t\tcliff = _cliff * 4 weeks;\n\t\tduration = _duration * 4 weeks;\n\n\t\temit RegistryCliffAndDurationUpdated(msg.sender, _vestingRegistry, _cliff, _duration);\n\t}\n\n\t/**\n\t * @notice Adds SOV to the user balance (Locked and Unlocked Balance based on `_basisPoint`).\n\t * @param _userAddress The user whose locked balance has to be updated with `_sovAmount`.\n\t * @param _sovAmount The amount of SOV to be added to the locked and/or unlocked balance.\n\t * @param _basisPoint The % (in Basis Point)which determines how much will be unlocked immediately.\n\t */\n\tfunction deposit(\n\t\taddress _userAddress,\n\t\tuint256 _sovAmount,\n\t\tuint256 _basisPoint\n\t) external {\n\t\t_deposit(_userAddress, _sovAmount, _basisPoint);\n\t}\n\n\t/**\n\t * @notice Adds SOV to the locked balance of a user.\n\t * @param _userAddress The user whose locked balance has to be updated with _sovAmount.\n\t * @param _sovAmount The amount of SOV to be added to the locked balance.\n\t * @dev This is here because there are dependency with other contracts.\n\t */\n\tfunction depositSOV(address _userAddress, uint256 _sovAmount) external {\n\t\t_deposit(_userAddress, _sovAmount, 0);\n\t}\n\n\tfunction _deposit(\n\t\taddress _userAddress,\n\t\tuint256 _sovAmount,\n\t\tuint256 _basisPoint\n\t) private {\n\t\t// 10000 is not included because if 100% is unlocked, then LockedSOV is not required to be used.\n\t\trequire(_basisPoint < 10000, \"Basis Point has to be less than 10000.\");\n\t\tbool txStatus = SOV.transferFrom(msg.sender, address(this), _sovAmount);\n\t\trequire(txStatus, \"Token transfer was not successful. Check receiver address.\");\n\n\t\tuint256 unlockedBal = _sovAmount.mul(_basisPoint).div(10000);\n\n\t\tunlockedBalances[_userAddress] = unlockedBalances[_userAddress].add(unlockedBal);\n\t\tlockedBalances[_userAddress] = lockedBalances[_userAddress].add(_sovAmount).sub(unlockedBal);\n\n\t\temit Deposited(msg.sender, _userAddress, _sovAmount, _basisPoint);\n\t}\n\n\t/**\n\t * @notice A function to withdraw the unlocked balance.\n\t * @param _receiverAddress If specified, the unlocked balance will go to this address, else to msg.sender.\n\t */\n\tfunction withdraw(address _receiverAddress) public {\n\t\t_withdraw(msg.sender, _receiverAddress);\n\t}\n\n\tfunction _withdraw(address _sender, address _receiverAddress) private {\n\t\taddress userAddr = _receiverAddress;\n\t\tif (_receiverAddress == address(0)) {\n\t\t\tuserAddr = _sender;\n\t\t}\n\n\t\tuint256 amount = unlockedBalances[_sender];\n\t\tunlockedBalances[_sender] = 0;\n\n\t\tbool txStatus = SOV.transfer(userAddr, amount);\n\t\trequire(txStatus, \"Token transfer was not successful. Check receiver address.\");\n\n\t\temit Withdrawn(_sender, userAddr, amount);\n\t}\n\n\t/**\n\t * @notice Creates vesting if not already created and Stakes tokens for a user.\n\t * @dev Only use this function if the `duration` is small.\n\t */\n\tfunction createVestingAndStake() public {\n\t\t_createVestingAndStake(msg.sender);\n\t}\n\n\tfunction _createVestingAndStake(address _sender) private {\n\t\taddress vestingAddr = _getVesting(_sender);\n\n\t\tif (vestingAddr == address(0)) {\n\t\t\tvestingAddr = _createVesting(_sender);\n\t\t}\n\n\t\t_stakeTokens(_sender, vestingAddr);\n\t}\n\n\t/**\n\t * @notice Creates vesting contract (if it hasn't been created yet) for the calling user.\n\t * @return _vestingAddress The New Vesting Contract Created.\n\t */\n\tfunction createVesting() public returns (address _vestingAddress) {\n\t\t_vestingAddress = _createVesting(msg.sender);\n\t}\n\n\t/**\n\t * @notice Stakes tokens for a user who already have a vesting created.\n\t * @dev The user should already have a vesting created, else this function will throw error.\n\t */\n\tfunction stakeTokens() public {\n\t\tVestingLogic vesting = VestingLogic(_getVesting(msg.sender));\n\n\t\trequire(cliff == vesting.cliff() && duration == vesting.duration(), \"Wrong Vesting Schedule.\");\n\n\t\t_stakeTokens(msg.sender, address(vesting));\n\t}\n\n\t/**\n\t * @notice Withdraws unlocked tokens and Stakes Locked tokens for a user who already have a vesting created.\n\t * @param _receiverAddress If specified, the unlocked balance will go to this address, else to msg.sender.\n\t */\n\tfunction withdrawAndStakeTokens(address _receiverAddress) external {\n\t\t_withdraw(msg.sender, _receiverAddress);\n\t\t_createVestingAndStake(msg.sender);\n\t}\n\n\t/**\n\t * @notice Withdraws unlocked tokens and Stakes Locked tokens for a user who already have a vesting created.\n\t * @param _userAddress The address of user tokens will be withdrawn.\n\t */\n\tfunction withdrawAndStakeTokensFrom(address _userAddress) external {\n\t\t_withdraw(_userAddress, _userAddress);\n\t\t_createVestingAndStake(_userAddress);\n\t}\n\n\t/**\n\t * @notice Function to start the process of migration to new contract.\n\t * @param _newLockedSOV The new locked sov contract address.\n\t */\n\tfunction startMigration(address _newLockedSOV) external onlyAdmin {\n\t\trequire(_newLockedSOV != address(0), \"New Locked SOV Address is Invalid.\");\n\t\tnewLockedSOV = ILockedSOV(_newLockedSOV);\n\t\tSOV.approve(_newLockedSOV, SOV.balanceOf(address(this)));\n\t\tmigration = true;\n\n\t\temit MigrationStarted(msg.sender, _newLockedSOV);\n\t}\n\n\t/**\n\t * @notice Function to transfer the locked balance from this contract to new LockedSOV Contract.\n\t * @dev Address is not specified to discourage selling lockedSOV to other address.\n\t */\n\tfunction transfer() external migrationAllowed {\n\t\tuint256 amount = lockedBalances[msg.sender];\n\t\tlockedBalances[msg.sender] = 0;\n\n\t\tnewLockedSOV.depositSOV(msg.sender, amount);\n\n\t\temit UserTransfered(msg.sender, amount);\n\t}\n\n\t/* Internal Functions */\n\n\t/**\n\t * @notice Creates a Vesting Contract for a user.\n\t * @param _tokenOwner The owner of the vesting contract.\n\t * @return _vestingAddress The Vesting Contract Address.\n\t * @dev Does not do anything if Vesting Contract was already created.\n\t */\n\tfunction _createVesting(address _tokenOwner) internal returns (address _vestingAddress) {\n\t\t/// Here zero is given in place of amount, as amount is not really used in `vestingRegistry.createVesting()`.\n\t\tvestingRegistry.createVesting(_tokenOwner, 0, cliff, duration);\n\t\t_vestingAddress = _getVesting(_tokenOwner);\n\t\temit VestingCreated(msg.sender, _tokenOwner, _vestingAddress);\n\t}\n\n\t/**\n\t * @notice Returns the Vesting Contract Address.\n\t * @param _tokenOwner The owner of the vesting contract.\n\t * @return _vestingAddress The Vesting Contract Address.\n\t */\n\tfunction _getVesting(address _tokenOwner) internal view returns (address _vestingAddress) {\n\t\treturn vestingRegistry.getVesting(_tokenOwner);\n\t}\n\n\t/**\n\t * @notice Stakes the tokens in a particular vesting contract.\n\t * @param _vesting The Vesting Contract Address.\n\t */\n\tfunction _stakeTokens(address _sender, address _vesting) internal {\n\t\tuint256 amount = lockedBalances[_sender];\n\t\tlockedBalances[_sender] = 0;\n\n\t\tSOV.approve(_vesting, amount);\n\t\tVestingLogic(_vesting).stakeTokens(amount);\n\n\t\temit TokenStaked(_sender, _vesting, amount);\n\t}\n\n\t/* Getter or Read Functions */\n\n\t/**\n\t * @notice The function to get the locked balance of a user.\n\t * @param _addr The address of the user to check the locked balance.\n\t * @return _balance The locked balance of the address `_addr`.\n\t */\n\tfunction getLockedBalance(address _addr) external view returns (uint256 _balance) {\n\t\treturn lockedBalances[_addr];\n\t}\n\n\t/**\n\t * @notice The function to get the unlocked balance of a user.\n\t * @param _addr The address of the user to check the unlocked balance.\n\t * @return _balance The unlocked balance of the address `_addr`.\n\t */\n\tfunction getUnlockedBalance(address _addr) external view returns (uint256 _balance) {\n\t\treturn unlockedBalances[_addr];\n\t}\n\n\t/**\n\t * @notice The function to check is an address is admin or not.\n\t * @param _addr The address of the user to check the admin status.\n\t * @return _status True if admin, False otherwise.\n\t */\n\tfunction adminStatus(address _addr) external view returns (bool _status) {\n\t\treturn isAdmin[_addr];\n\t}\n}\n",
    "imports": [
        {
            "name": "LockedSOVFlattened.sol",
            "contents": "// File: contracts/openzeppelin/SafeMath.sol\n\npragma solidity >=0.5.0 <0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n\t/**\n\t * @dev Returns the addition of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `+` operator.\n\t *\n\t * Requirements:\n\t * - Addition cannot overflow.\n\t */\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\trequire(c >= a, \"SafeMath: addition overflow\");\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t * - Subtraction cannot overflow.\n\t */\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn sub(a, b, \"SafeMath: subtraction overflow\");\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t * - Subtraction cannot overflow.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction sub(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\trequire(b <= a, errorMessage);\n\t\tuint256 c = a - b;\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the multiplication of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `*` operator.\n\t *\n\t * Requirements:\n\t * - Multiplication cannot overflow.\n\t */\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\t\t// benefit is lost if 'b' is also tested.\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 c = a * b;\n\t\trequire(c / a == b, \"SafeMath: multiplication overflow\");\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers. Reverts on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn div(a, b, \"SafeMath: division by zero\");\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction div(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\t// Solidity only automatically asserts when dividing by 0\n\t\trequire(b != 0, errorMessage);\n\t\tuint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Integer division of two numbers, rounding up and truncating the quotient\n\t */\n\tfunction divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn divCeil(a, b, \"SafeMath: division by zero\");\n\t}\n\n\t/**\n\t * @dev Integer division of two numbers, rounding up and truncating the quotient\n\t */\n\tfunction divCeil(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\t// Solidity only automatically asserts when dividing by 0\n\t\trequire(b != 0, errorMessage);\n\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 c = ((a - 1) / b) + 1;\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn mod(a, b, \"SafeMath: modulo by zero\");\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts with custom message when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction mod(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\trequire(b != 0, errorMessage);\n\t\treturn a % b;\n\t}\n\n\tfunction min256(uint256 _a, uint256 _b) internal pure returns (uint256) {\n\t\treturn _a < _b ? _a : _b;\n\t}\n}\n\n// File: contracts/interfaces/IERC20.sol\n\n/**\n * Copyright 2017-2021, bZeroX, LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0.\n */\n\npragma solidity >=0.5.0 <0.6.0;\n\ncontract IERC20 {\n\tstring public name;\n\tuint8 public decimals;\n\tstring public symbol;\n\n\tfunction totalSupply() public view returns (uint256);\n\n\tfunction balanceOf(address _who) public view returns (uint256);\n\n\tfunction allowance(address _owner, address _spender) public view returns (uint256);\n\n\tfunction approve(address _spender, uint256 _value) public returns (bool);\n\n\tfunction transfer(address _to, uint256 _value) public returns (bool);\n\n\tfunction transferFrom(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _value\n\t) public returns (bool);\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/openzeppelin/Context.sol\n\npragma solidity >=0.5.0 <0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n\t// Empty internal constructor, to prevent people from mistakenly deploying\n\t// an instance of this contract, which should be used via inheritance.\n\tconstructor() internal {}\n\n\t// solhint-disable-previous-line no-empty-blocks\n\n\tfunction _msgSender() internal view returns (address payable) {\n\t\treturn msg.sender;\n\t}\n\n\tfunction _msgData() internal view returns (bytes memory) {\n\t\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\t\treturn msg.data;\n\t}\n}\n\n// File: contracts/openzeppelin/Ownable.sol\n\npragma solidity >=0.5.0 <0.6.0;\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n\taddress private _owner;\n\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\t/**\n\t * @dev Initializes the contract setting the deployer as the initial owner.\n\t */\n\tconstructor() internal {\n\t\taddress msgSender = _msgSender();\n\t\t_owner = msgSender;\n\t\temit OwnershipTransferred(address(0), msgSender);\n\t}\n\n\t/**\n\t * @dev Returns the address of the current owner.\n\t */\n\tfunction owner() public view returns (address) {\n\t\treturn _owner;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the owner.\n\t */\n\tmodifier onlyOwner() {\n\t\trequire(isOwner(), \"unauthorized\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Returns true if the caller is the current owner.\n\t */\n\tfunction isOwner() public view returns (bool) {\n\t\treturn _msgSender() == _owner;\n\t}\n\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t * Can only be called by the current owner.\n\t */\n\tfunction transferOwnership(address newOwner) public onlyOwner {\n\t\t_transferOwnership(newOwner);\n\t}\n\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t */\n\tfunction _transferOwnership(address newOwner) internal {\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\t\temit OwnershipTransferred(_owner, newOwner);\n\t\t_owner = newOwner;\n\t}\n}\n\n// File: contracts/governance/Staking/IStaking.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title Interface for contract governance/Staking/Staking.sol\n * @dev Interfaces are used to cast a contract address into a callable instance.\n */\ninterface IStaking {\n\tfunction stakesBySchedule(\n\t\tuint256 amount,\n\t\tuint256 cliff,\n\t\tuint256 duration,\n\t\tuint256 intervalLength,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) external;\n\n\tfunction stake(\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) external;\n\n\tfunction getPriorVotes(\n\t\taddress account,\n\t\tuint256 blockNumber,\n\t\tuint256 date\n\t) external view returns (uint96);\n\n\tfunction getPriorTotalVotingPower(uint32 blockNumber, uint256 time) external view returns (uint96);\n\n\tfunction getPriorWeightedStake(\n\t\taddress account,\n\t\tuint256 blockNumber,\n\t\tuint256 date\n\t) external view returns (uint96);\n\n\tfunction timestampToLockDate(uint256 timestamp) external view returns (uint256 lockDate);\n}\n\n// File: contracts/governance/IFeeSharingProxy.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title Interface for contract governance/FeeSharingProxy.sol\n * @dev Interfaces are used to cast a contract address into a callable instance.\n * */\ninterface IFeeSharingProxy {\n\tfunction withdrawFees(address _token) external;\n\n\tfunction transferTokens(address _token, uint96 _amount) external;\n\n\tfunction withdraw(\n\t\taddress _loanPoolToken,\n\t\tuint32 _maxCheckpoints,\n\t\taddress _receiver\n\t) external;\n}\n\n// File: contracts/governance/Vesting/IVestingFactory.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title Interface for Vesting Factory contract.\n * @dev Interfaces are used to cast a contract address into a callable instance.\n * This interface is used by VestingFactory contract to override empty\n * implemention of deployVesting and deployTeamVesting functions\n * and on VestingRegistry contract to use an instance of VestingFactory.\n */\ninterface IVestingFactory {\n\tfunction deployVesting(\n\t\taddress _SOV,\n\t\taddress _staking,\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration,\n\t\taddress _feeSharing,\n\t\taddress _owner\n\t) external returns (address);\n\n\tfunction deployTeamVesting(\n\t\taddress _SOV,\n\t\taddress _staking,\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration,\n\t\taddress _feeSharing,\n\t\taddress _owner\n\t) external returns (address);\n}\n\n// File: contracts/governance/Vesting/IVesting.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title Interface for Vesting contract.\n * @dev Interfaces are used to cast a contract address into a callable instance.\n * This interface is used by VestingLogic contract to implement stakeTokens function\n * and on VestingRegistry contract to call IVesting(vesting).stakeTokens function\n * at a vesting instance.\n */\ninterface IVesting {\n\tfunction duration() external returns (uint256);\n\n\tfunction endDate() external returns (uint256);\n\n\tfunction stakeTokens(uint256 amount) external;\n}\n\n// File: contracts/governance/Vesting/ITeamVesting.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title Interface for TeamVesting contract.\n * @dev Interfaces are used to cast a contract address into a callable instance.\n * This interface is used by Staking contract to call governanceWithdrawTokens\n * function having the vesting contract instance address.\n */\ninterface ITeamVesting {\n\tfunction governanceWithdrawTokens(address receiver) external;\n}\n\n// File: contracts/governance/Vesting/VestingRegistry.sol\n\npragma solidity ^0.5.17;\n\n\n\n\n\n\n\n\n\n/**\n * @title Vesting Registry contract.\n *\n * @notice On January 25, 2020, Sovryn launched the Genesis Reservation system.\n * Sovryn community members who controlled a special NFT were granted access to\n * stake BTC or rBTC for cSOV tokens at a rate of 2500 satoshis per cSOV. Per\n * SIP-0003, up to 2,000,000 cSOV were made available in the Genesis event,\n * which will be redeemable on a 1:1 basis for cSOV, subject to approval by\n * existing SOV holders.\n *\n * On 15 Feb 2021 Sovryn is taking another step in its journey to decentralized\n * financial sovereignty with the vote on SIP 0005. This proposal will enable\n * participants of the Genesis Reservation system to redeem their reserved cSOV\n * tokens for SOV. They will also have the choice to redeem cSOV for rBTC if\n * they decide to exit the system.\n *\n * This contract deals with the vesting and redemption of cSOV tokens.\n * */\ncontract VestingRegistry is Ownable {\n\tusing SafeMath for uint256;\n\n\t/* Storage */\n\n\t/// @notice Constant used for computing the vesting dates.\n\tuint256 public constant FOUR_WEEKS = 4 weeks;\n\n\tuint256 public constant CSOV_VESTING_CLIFF = FOUR_WEEKS;\n\tuint256 public constant CSOV_VESTING_DURATION = 10 * FOUR_WEEKS;\n\n\tIVestingFactory public vestingFactory;\n\n\t/// @notice The SOV token contract.\n\taddress public SOV;\n\n\t/// @notice The cSOV token contracts.\n\taddress[] public CSOVtokens;\n\n\tuint256 public priceSats;\n\n\t/// @notice The staking contract address.\n\taddress public staking;\n\n\t/// @notice Fee sharing proxy.\n\taddress public feeSharingProxy;\n\n\t/// @notice The vesting owner (e.g. governance timelock address).\n\taddress public vestingOwner;\n\n\t/// @dev TODO: Add to the documentation: address can have only one vesting of each type.\n\t/// @dev user => vesting type => vesting contract.\n\tmapping(address => mapping(uint256 => address)) public vestingContracts;\n\n\t/**\n\t * @dev Struct can be created to save storage slots, but it doesn't make\n\t * sense. We don't have a lot of blacklisted accounts or account with\n\t * locked amount.\n\t * */\n\n\t/// @dev user => flag whether user has already exchange cSOV or got a reimbursement.\n\tmapping(address => bool) public processedList;\n\n\t/// @dev user => flag whether user shouldn't be able to exchange or reimburse.\n\tmapping(address => bool) public blacklist;\n\n\t/// @dev user => amount of tokens should not be processed.\n\tmapping(address => uint256) public lockedAmount;\n\n\t/// @dev user => flag whether user has admin role.\n\tmapping(address => bool) public admins;\n\n\tenum VestingType {\n\t\tTeamVesting, // MultisigVesting\n\t\tVesting // TokenHolderVesting\n\t}\n\n\t/* Events */\n\n\tevent CSOVReImburse(address from, uint256 CSOVamount, uint256 reImburseAmount);\n\tevent CSOVTokensExchanged(address indexed caller, uint256 amount);\n\tevent SOVTransferred(address indexed receiver, uint256 amount);\n\tevent VestingCreated(address indexed tokenOwner, address vesting, uint256 cliff, uint256 duration, uint256 amount);\n\tevent TeamVestingCreated(address indexed tokenOwner, address vesting, uint256 cliff, uint256 duration, uint256 amount);\n\tevent TokensStaked(address indexed vesting, uint256 amount);\n\tevent AdminAdded(address admin);\n\tevent AdminRemoved(address admin);\n\n\t/* Functions */\n\n\t/**\n\t * @notice Contract deployment settings.\n\t * @param _vestingFactory The address of vesting factory contract.\n\t * @param _SOV The SOV token address.\n\t * @param _CSOVtokens The array of cSOV tokens.\n\t * @param _priceSats The price of cSOV tokens in satoshis.\n\t * @param _staking The address of staking contract.\n\t * @param _feeSharingProxy The address of fee sharing proxy contract.\n\t * @param _vestingOwner The address of an owner of vesting contract.\n\t * @dev On Sovryn the vesting owner is Exchequer Multisig.\n\t * According to SIP-0007 The Exchequer Multisig is designated to hold\n\t * certain funds in the form of rBTC and SOV, in order to allow for\n\t * flexible deployment of such funds on:\n\t *  + facilitating rBTC redemptions for Genesis pre-sale participants.\n\t *  + deploying of SOV for the purposes of exchange listings, market\n\t *    making, and partnerships with third parties.\n\t * */\n\tconstructor(\n\t\taddress _vestingFactory,\n\t\taddress _SOV,\n\t\taddress[] memory _CSOVtokens,\n\t\tuint256 _priceSats,\n\t\taddress _staking,\n\t\taddress _feeSharingProxy,\n\t\taddress _vestingOwner\n\t) public {\n\t\trequire(_SOV != address(0), \"SOV address invalid\");\n\t\trequire(_staking != address(0), \"staking address invalid\");\n\t\trequire(_feeSharingProxy != address(0), \"feeSharingProxy address invalid\");\n\t\trequire(_vestingOwner != address(0), \"vestingOwner address invalid\");\n\n\t\t_setVestingFactory(_vestingFactory);\n\t\t_setCSOVtokens(_CSOVtokens);\n\n\t\tSOV = _SOV;\n\t\tpriceSats = _priceSats;\n\t\tstaking = _staking;\n\t\tfeeSharingProxy = _feeSharingProxy;\n\t\tvestingOwner = _vestingOwner;\n\t}\n\n\t//---ACL------------------------------------------------------------------\n\n\t/**\n\t * @dev Throws if called by any account other than the owner or admin.\n\t * TODO: This ACL logic should be available on OpenZeppeling Ownable.sol\n\t * or on our own overriding sovrynOwnable. This same logic is repeated\n\t * on OriginInvestorsClaim.sol, TokenSender.sol and VestingRegistry2.sol\n\t */\n\tmodifier onlyAuthorized() {\n\t\trequire(isOwner() || admins[msg.sender], \"unauthorized\");\n\t\t_;\n\t}\n\n\t/**\n\t * @notice Add account to ACL.\n\t * @param _admin The addresses of the account to grant permissions.\n\t * */\n\tfunction addAdmin(address _admin) public onlyOwner {\n\t\tadmins[_admin] = true;\n\t\temit AdminAdded(_admin);\n\t}\n\n\t/**\n\t * @notice Remove account from ACL.\n\t * @param _admin The addresses of the account to revoke permissions.\n\t * */\n\tfunction removeAdmin(address _admin) public onlyOwner {\n\t\tadmins[_admin] = false;\n\t\temit AdminRemoved(_admin);\n\t}\n\n\t//---PostCSOV--------------------------------------------------------------\n\n\tmodifier isNotProcessed() {\n\t\trequire(!processedList[msg.sender], \"Address cannot be processed twice\");\n\t\t_;\n\t}\n\n\tmodifier isNotBlacklisted() {\n\t\trequire(!blacklist[msg.sender], \"Address blacklisted\");\n\t\t_;\n\t}\n\n\t/**\n\t * @notice cSOV payout to sender with rBTC currency.\n\t * 1.- Check holder cSOV balance by adding up every cSOV token balance.\n\t * 2.- ReImburse rBTC if funds available.\n\t * 3.- And store holder address in processedList.\n\t */\n\tfunction reImburse() public isNotProcessed isNotBlacklisted {\n\t\tuint256 CSOVAmountWei = 0;\n\t\tfor (uint256 i = 0; i < CSOVtokens.length; i++) {\n\t\t\taddress CSOV = CSOVtokens[i];\n\t\t\tuint256 balance = IERC20(CSOV).balanceOf(msg.sender);\n\t\t\tCSOVAmountWei = CSOVAmountWei.add(balance);\n\t\t}\n\n\t\trequire(CSOVAmountWei > lockedAmount[msg.sender], \"holder has no CSOV\");\n\t\tCSOVAmountWei -= lockedAmount[msg.sender];\n\t\tprocessedList[msg.sender] = true;\n\n\t\t/**\n\t\t * @dev Found and fixed the SIP-0007 bug on VestingRegistry::reImburse formula.\n\t\t * More details at Documenting Code issues at point 11 in\n\t\t * https://docs.google.com/document/d/10idTD1K6JvoBmtPKGuJ2Ub_mMh6qTLLlTP693GQKMyU/\n\t\t * Previous buggy code: uint256 reImburseAmount = (CSOVAmountWei.mul(priceSats)).div(10**10);\n\t\t * */\n\t\tuint256 reImburseAmount = (CSOVAmountWei.mul(priceSats)).div(10**8);\n\t\trequire(address(this).balance >= reImburseAmount, \"Not enough funds to reimburse\");\n\t\tmsg.sender.transfer(reImburseAmount);\n\n\t\temit CSOVReImburse(msg.sender, CSOVAmountWei, reImburseAmount);\n\t}\n\n\t/**\n\t * @notice Get contract balance.\n\t * @return The token balance of the contract.\n\t * */\n\tfunction budget() external view returns (uint256) {\n\t\tuint256 SCBudget = address(this).balance;\n\t\treturn SCBudget;\n\t}\n\n\t/**\n\t * @notice Deposit function to receiving value (rBTC).\n\t * */\n\tfunction deposit() public payable {}\n\n\t/**\n\t * @notice Send all contract balance to an account.\n\t * @param to The account address to send the balance to.\n\t * */\n\tfunction withdrawAll(address payable to) public onlyOwner {\n\t\tto.transfer(address(this).balance);\n\t}\n\n\t//--------------------------------------------------------------------------------------------------------------------------------------\n\n\t/**\n\t * @notice Sets vesting factory address. High level endpoint.\n\t * @param _vestingFactory The address of vesting factory contract.\n\t *\n\t * @dev Splitting code on two functions: high level and low level\n\t * is a pattern that makes easy to extend functionality in a readable way,\n\t * without accidentally breaking the actual action being performed.\n\t * For example, checks should be done on high level endpoint, while core\n\t * functionality should be coded on the low level function.\n\t * */\n\tfunction setVestingFactory(address _vestingFactory) public onlyOwner {\n\t\t_setVestingFactory(_vestingFactory);\n\t}\n\n\t/**\n\t * @notice Sets vesting factory address. Low level core function.\n\t * @param _vestingFactory The address of vesting factory contract.\n\t * */\n\tfunction _setVestingFactory(address _vestingFactory) internal {\n\t\trequire(_vestingFactory != address(0), \"vestingFactory address invalid\");\n\t\tvestingFactory = IVestingFactory(_vestingFactory);\n\t}\n\n\t/**\n\t * @notice Sets cSOV tokens array. High level endpoint.\n\t * @param _CSOVtokens The array of cSOV tokens.\n\t * */\n\tfunction setCSOVtokens(address[] memory _CSOVtokens) public onlyOwner {\n\t\t_setCSOVtokens(_CSOVtokens);\n\t}\n\n\t/**\n\t * @notice Sets cSOV tokens array by looping through input. Low level function.\n\t * @param _CSOVtokens The array of cSOV tokens.\n\t * */\n\tfunction _setCSOVtokens(address[] memory _CSOVtokens) internal {\n\t\tfor (uint256 i = 0; i < _CSOVtokens.length; i++) {\n\t\t\trequire(_CSOVtokens[i] != address(0), \"CSOV address invalid\");\n\t\t}\n\t\tCSOVtokens = _CSOVtokens;\n\t}\n\n\t/**\n\t * @notice Set blacklist flag (true/false).\n\t * @param _account The address to be blacklisted.\n\t * @param _blacklisted The flag to add/remove to/from a blacklist.\n\t * */\n\tfunction setBlacklistFlag(address _account, bool _blacklisted) public onlyOwner {\n\t\trequire(_account != address(0), \"account address invalid\");\n\n\t\tblacklist[_account] = _blacklisted;\n\t}\n\n\t/**\n\t * @notice Set amount to be subtracted from user token balance.\n\t * @param _account The address with locked amount.\n\t * @param _amount The amount to be locked.\n\t * */\n\tfunction setLockedAmount(address _account, uint256 _amount) public onlyOwner {\n\t\trequire(_account != address(0), \"account address invalid\");\n\t\trequire(_amount != 0, \"amount invalid\");\n\n\t\tlockedAmount[_account] = _amount;\n\t}\n\n\t/**\n\t * @notice Transfer SOV tokens to given address.\n\t *\n\t * @dev This is a wrapper for ERC-20 transfer function w/\n\t * additional checks and triggering an event.\n\t *\n\t * @param _receiver The address of the SOV receiver.\n\t * @param _amount The amount to be transferred.\n\t * */\n\tfunction transferSOV(address _receiver, uint256 _amount) public onlyOwner {\n\t\trequire(_receiver != address(0), \"receiver address invalid\");\n\t\trequire(_amount != 0, \"amount invalid\");\n\n\t\tIERC20(SOV).transfer(_receiver, _amount);\n\t\temit SOVTransferred(_receiver, _amount);\n\t}\n\n\t/**\n\t * @notice Exchange cSOV to SOV with 1:1 rate\n\t */\n\tfunction exchangeAllCSOV() public isNotProcessed isNotBlacklisted {\n\t\tprocessedList[msg.sender] = true;\n\n\t\tuint256 amount = 0;\n\t\tfor (uint256 i = 0; i < CSOVtokens.length; i++) {\n\t\t\taddress CSOV = CSOVtokens[i];\n\t\t\tuint256 balance = IERC20(CSOV).balanceOf(msg.sender);\n\t\t\tamount += balance;\n\t\t}\n\n\t\trequire(amount > lockedAmount[msg.sender], \"amount invalid\");\n\t\tamount -= lockedAmount[msg.sender];\n\n\t\t_createVestingForCSOV(amount);\n\t}\n\n\t/**\n\t * @notice cSOV tokens are moved and staked on Vesting contract.\n\t * @param _amount The amount of tokens to be vested.\n\t * */\n\tfunction _createVestingForCSOV(uint256 _amount) internal {\n\t\taddress vesting = _getOrCreateVesting(msg.sender, CSOV_VESTING_CLIFF, CSOV_VESTING_DURATION);\n\n\t\tIERC20(SOV).approve(vesting, _amount);\n\t\tIVesting(vesting).stakeTokens(_amount);\n\n\t\temit CSOVTokensExchanged(msg.sender, _amount);\n\t}\n\n\t/**\n\t * @notice Check a token address is among the cSOV token addresses.\n\t * @param _CSOV The cSOV token address.\n\t * */\n\tfunction _validateCSOV(address _CSOV) internal view {\n\t\tbool isValid = false;\n\t\tfor (uint256 i = 0; i < CSOVtokens.length; i++) {\n\t\t\tif (_CSOV == CSOVtokens[i]) {\n\t\t\t\tisValid = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequire(isValid, \"wrong CSOV address\");\n\t}\n\n\t/**\n\t * @notice Create Vesting contract.\n\t * @param _tokenOwner The owner of the tokens.\n\t * @param _amount The amount to be staked.\n\t * @param _cliff The time interval to the first withdraw in seconds.\n\t * @param _duration The total duration in seconds.\n\t * */\n\tfunction createVesting(\n\t\taddress _tokenOwner,\n\t\tuint256 _amount,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) public onlyAuthorized {\n\t\taddress vesting = _getOrCreateVesting(_tokenOwner, _cliff, _duration);\n\t\temit VestingCreated(_tokenOwner, vesting, _cliff, _duration, _amount);\n\t}\n\n\t/**\n\t * @notice Create Team Vesting contract.\n\t * @param _tokenOwner The owner of the tokens.\n\t * @param _amount The amount to be staked.\n\t * @param _cliff The time interval to the first withdraw in seconds.\n\t * @param _duration The total duration in seconds.\n\t * */\n\tfunction createTeamVesting(\n\t\taddress _tokenOwner,\n\t\tuint256 _amount,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) public onlyAuthorized {\n\t\taddress vesting = _getOrCreateTeamVesting(_tokenOwner, _cliff, _duration);\n\t\temit TeamVestingCreated(_tokenOwner, vesting, _cliff, _duration, _amount);\n\t}\n\n\t/**\n\t * @notice Stake tokens according to the vesting schedule.\n\t * @param _vesting The address of Vesting contract.\n\t * @param _amount The amount of tokens to stake.\n\t * */\n\tfunction stakeTokens(address _vesting, uint256 _amount) public onlyAuthorized {\n\t\trequire(_vesting != address(0), \"vesting address invalid\");\n\t\trequire(_amount > 0, \"amount invalid\");\n\n\t\tIERC20(SOV).approve(_vesting, _amount);\n\t\tIVesting(_vesting).stakeTokens(_amount);\n\t\temit TokensStaked(_vesting, _amount);\n\t}\n\n\t/**\n\t * @notice Query the vesting contract for an account.\n\t * @param _tokenOwner The owner of the tokens.\n\t * @return The vesting contract address for the given token owner.\n\t * */\n\tfunction getVesting(address _tokenOwner) public view returns (address) {\n\t\treturn vestingContracts[_tokenOwner][uint256(VestingType.Vesting)];\n\t}\n\n\t/**\n\t * @notice Query the team vesting contract for an account.\n\t * @param _tokenOwner The owner of the tokens.\n\t * @return The team vesting contract address for the given token owner.\n\t * */\n\tfunction getTeamVesting(address _tokenOwner) public view returns (address) {\n\t\treturn vestingContracts[_tokenOwner][uint256(VestingType.TeamVesting)];\n\t}\n\n\t/**\n\t * @notice If not exists, deploy a vesting contract through factory.\n\t * @param _tokenOwner The owner of the tokens.\n\t * @param _cliff The time interval to the first withdraw in seconds.\n\t * @param _duration The total duration in seconds.\n\t * @return The vesting contract address for the given token owner\n\t * whether it existed previously or not.\n\t * */\n\tfunction _getOrCreateVesting(\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) internal returns (address) {\n\t\tuint256 type_ = uint256(VestingType.Vesting);\n\t\tif (vestingContracts[_tokenOwner][type_] == address(0)) {\n\t\t\t/// @dev TODO: Owner of OwnerVesting contracts - the same address as tokenOwner.\n\t\t\taddress vesting = vestingFactory.deployVesting(SOV, staking, _tokenOwner, _cliff, _duration, feeSharingProxy, _tokenOwner);\n\t\t\tvestingContracts[_tokenOwner][type_] = vesting;\n\t\t}\n\t\treturn vestingContracts[_tokenOwner][type_];\n\t}\n\n\t/**\n\t * @notice If not exists, deploy a team vesting contract through factory.\n\t * @param _tokenOwner The owner of the tokens.\n\t * @param _cliff The time interval to the first withdraw in seconds.\n\t * @param _duration The total duration in seconds.\n\t * @return The team vesting contract address for the given token owner\n\t * whether it existed previously or not.\n\t * */\n\tfunction _getOrCreateTeamVesting(\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) internal returns (address) {\n\t\tuint256 type_ = uint256(VestingType.TeamVesting);\n\t\tif (vestingContracts[_tokenOwner][type_] == address(0)) {\n\t\t\taddress vesting = vestingFactory.deployTeamVesting(SOV, staking, _tokenOwner, _cliff, _duration, feeSharingProxy, vestingOwner);\n\t\t\tvestingContracts[_tokenOwner][type_] = vesting;\n\t\t}\n\t\treturn vestingContracts[_tokenOwner][type_];\n\t}\n}\n\n// File: contracts/governance/Staking/StakingStorage.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title Staking Storage contact.\n * @notice Just the storage part of stacking contract, no functions,\n * only constant, variables and required structures (mappings).\n * Used by StackingProxy and Checkpoints contracts.\n *\n * What is SOV staking?\n * The purpose of the SOV token is to provide a pseudonymous,\n * censorship-resistant mechanism for governing the parameters of the Sovryn\n * protocol, while aligning the incentives of protocol governors with the\n * long-term success of the protocol. Any SOV token holder can choose to\n * stake (lock up) their tokens for a fixed period of time in return for\n * voting rights in the Bitocracy. Stakers are further incentivised through\n * fee and slashing rewards.\n * */\ncontract StakingStorage is Ownable {\n\t/// @notice 2 weeks in seconds.\n\tuint256 constant TWO_WEEKS = 1209600;\n\n\t/// @notice The maximum possible voting weight before adding +1 (actually 10, but need 9 for computation).\n\tuint96 public constant MAX_VOTING_WEIGHT = 9;\n\n\t/// @notice weight is multiplied with this factor (for allowing decimals, like 1.2x).\n\t/// @dev MAX_VOTING_WEIGHT * WEIGHT_FACTOR needs to be < 792, because there are 100,000,000 SOV with 18 decimals\n\tuint96 public constant WEIGHT_FACTOR = 10;\n\n\t/// @notice The maximum duration to stake tokens for.\n\tuint256 public constant MAX_DURATION = 1092 days;\n\n\t/// @notice The maximum duration ^2\n\tuint96 constant MAX_DURATION_POW_2 = 1092 * 1092;\n\n\t/// @notice Default weight scaling.\n\tuint96 constant DEFAULT_WEIGHT_SCALING = 3;\n\n\t/// @notice Range for weight scaling.\n\tuint96 constant MIN_WEIGHT_SCALING = 1;\n\tuint96 constant MAX_WEIGHT_SCALING = 9;\n\n\t/// @notice The timestamp of contract creation. Base for the staking period calculation.\n\tuint256 public kickoffTS;\n\n\tstring name = \"SOVStaking\";\n\n\t/// @notice The token to be staked.\n\tIERC20 public SOVToken;\n\n\t/// @notice A record of each accounts delegate.\n\tmapping(address => mapping(uint256 => address)) public delegates;\n\n\t/// @notice If this flag is set to true, all tokens are unlocked immediately.\n\tbool public allUnlocked = false;\n\n\t/// @notice The EIP-712 typehash for the contract's domain.\n\tbytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n\t/// @notice The EIP-712 typehash for the delegation struct used by the contract.\n\tbytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 lockDate,uint256 nonce,uint256 expiry)\");\n\n\t/// @notice Used for stake migrations to a new staking contract with a different storage structure.\n\taddress public newStakingContract;\n\n\t/*************************** Checkpoints *******************************/\n\n\t/// @notice A checkpoint for marking the stakes from a given block\n\tstruct Checkpoint {\n\t\tuint32 fromBlock;\n\t\tuint96 stake;\n\t}\n\n\t/// @notice A record of tokens to be unstaked at a given time in total.\n\t/// For total voting power computation. Voting weights get adjusted bi-weekly.\n\t/// @dev totalStakingCheckpoints[date][index] is a checkpoint.\n\tmapping(uint256 => mapping(uint32 => Checkpoint)) public totalStakingCheckpoints;\n\n\t/// @notice The number of total staking checkpoints for each date.\n\t/// @dev numTotalStakingCheckpoints[date] is a number.\n\tmapping(uint256 => uint32) public numTotalStakingCheckpoints;\n\n\t/// @notice A record of tokens to be unstaked at a given time which were delegated to a certain address.\n\t/// For delegatee voting power computation. Voting weights get adjusted bi-weekly.\n\t/// @dev delegateStakingCheckpoints[delegatee][date][index] is a checkpoint.\n\tmapping(address => mapping(uint256 => mapping(uint32 => Checkpoint))) public delegateStakingCheckpoints;\n\n\t/// @notice The number of total staking checkpoints for each date per delegate.\n\t/// @dev numDelegateStakingCheckpoints[delegatee][date] is a number.\n\tmapping(address => mapping(uint256 => uint32)) public numDelegateStakingCheckpoints;\n\n\t/// @notice A record of tokens to be unstaked at a given time which per user address (address -> lockDate -> stake checkpoint)\n\t/// @dev userStakingCheckpoints[user][date][index] is a checkpoint.\n\tmapping(address => mapping(uint256 => mapping(uint32 => Checkpoint))) public userStakingCheckpoints;\n\n\t/// @notice The number of total staking checkpoints for each date per user.\n\t/// @dev numUserStakingCheckpoints[user][date] is a number.\n\tmapping(address => mapping(uint256 => uint32)) public numUserStakingCheckpoints;\n\n\t/// @notice A record of states for signing / validating signatures\n\t/// @dev nonces[user] is a number.\n\tmapping(address => uint256) public nonces;\n\n\t/*************************** Slashing *******************************/\n\n\t/// @notice the address of FeeSharingProxy contract, we need it for unstaking with slashing.\n\tIFeeSharingProxy public feeSharing;\n\n\t/// @notice used for weight scaling when unstaking with slashing.\n\tuint96 public weightScaling = DEFAULT_WEIGHT_SCALING;\n\n\t/// @notice List of vesting contracts, tokens for these contracts won't be slashed if unstaked by governance.\n\t/// @dev vestingWhitelist[contract] is true/false.\n\tmapping(address => bool) public vestingWhitelist;\n}\n\n// File: contracts/governance/Staking/SafeMath96.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title SafeMath96 contract.\n * @notice Improved Solidity's arithmetic operations with added overflow checks.\n * @dev SafeMath96 uses uint96, unsigned integers of 96 bits length, so every\n * integer from 0 to 2^96-1 can be operated.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * SafeMath restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this contract instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n * */\ncontract SafeMath96 {\n\tfunction safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n\t\trequire(n < 2**32, errorMessage);\n\t\treturn uint32(n);\n\t}\n\n\tfunction safe64(uint256 n, string memory errorMessage) internal pure returns (uint64) {\n\t\trequire(n < 2**64, errorMessage);\n\t\treturn uint64(n);\n\t}\n\n\tfunction safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\n\t\trequire(n < 2**96, errorMessage);\n\t\treturn uint96(n);\n\t}\n\n\t/**\n\t * @notice Adds two unsigned integers, reverting on overflow.\n\t * @dev Counterpart to Solidity's `+` operator.\n\t * @param a First integer.\n\t * @param b Second integer.\n\t * @param errorMessage The revert message on overflow.\n\t * @return The safe addition a+b.\n\t * */\n\tfunction add96(\n\t\tuint96 a,\n\t\tuint96 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint96) {\n\t\tuint96 c = a + b;\n\t\trequire(c >= a, errorMessage);\n\t\treturn c;\n\t}\n\n\t/**\n\t * @notice Substracts two unsigned integers, reverting on underflow.\n\t * @dev Counterpart to Solidity's `-` operator.\n\t * @param a First integer.\n\t * @param b Second integer.\n\t * @param errorMessage The revert message on underflow.\n\t * @return The safe substraction a-b.\n\t * */\n\tfunction sub96(\n\t\tuint96 a,\n\t\tuint96 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint96) {\n\t\trequire(b <= a, errorMessage);\n\t\treturn a - b;\n\t}\n\n\t/**\n\t * @notice Multiplies two unsigned integers, reverting on overflow.\n\t * @dev Counterpart to Solidity's `*` operator.\n\t * @param a First integer.\n\t * @param b Second integer.\n\t * @param errorMessage The revert message on overflow.\n\t * @return The safe product a*b.\n\t * */\n\tfunction mul96(\n\t\tuint96 a,\n\t\tuint96 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint96) {\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint96 c = a * b;\n\t\trequire(c / a == b, errorMessage);\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @notice Divides two unsigned integers, reverting on overflow.\n\t * @dev Counterpart to Solidity's `/` operator.\n\t * @param a First integer.\n\t * @param b Second integer.\n\t * @param errorMessage The revert message on overflow.\n\t * @return The safe division a/b.\n\t * */\n\tfunction div96(\n\t\tuint96 a,\n\t\tuint96 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint96) {\n\t\t// Solidity only automatically asserts when dividing by 0\n\t\trequire(b > 0, errorMessage);\n\t\tuint96 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\t\treturn c;\n\t}\n}\n\n// File: contracts/governance/Staking/Checkpoints.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title Checkpoints contract.\n * @notice Increases and decreases storage values for users, delegatees and\n * total daily stake.\n * */\ncontract Checkpoints is StakingStorage, SafeMath96 {\n\t/// @notice An event emitted when an account changes its delegate.\n\tevent DelegateChanged(address indexed delegator, uint256 lockedUntil, address indexed fromDelegate, address indexed toDelegate);\n\n\t/// @notice An event emitted when a delegate account's stake balance changes.\n\tevent DelegateStakeChanged(address indexed delegate, uint256 lockedUntil, uint256 previousBalance, uint256 newBalance);\n\n\t/// @notice An event emitted when tokens get staked.\n\tevent TokensStaked(address indexed staker, uint256 amount, uint256 lockedUntil, uint256 totalStaked);\n\n\t/// @notice An event emitted when tokens get withdrawn.\n\tevent TokensWithdrawn(address indexed staker, address receiver, uint256 amount);\n\n\t/// @notice An event emitted when vesting tokens get withdrawn.\n\tevent VestingTokensWithdrawn(address vesting, address receiver);\n\n\t/// @notice An event emitted when the owner unlocks all tokens.\n\tevent TokensUnlocked(uint256 amount);\n\n\t/// @notice An event emitted when a staking period gets extended.\n\tevent ExtendedStakingDuration(address indexed staker, uint256 previousDate, uint256 newDate);\n\n\t/**\n\t * @notice Increases the user's stake for a giving lock date and writes a checkpoint.\n\t * @param account The user address.\n\t * @param lockedTS The lock date.\n\t * @param value The value to add to the staked balance.\n\t * */\n\tfunction _increaseUserStake(\n\t\taddress account,\n\t\tuint256 lockedTS,\n\t\tuint96 value\n\t) internal {\n\t\tuint32 nCheckpoints = numUserStakingCheckpoints[account][lockedTS];\n\t\tuint96 staked = userStakingCheckpoints[account][lockedTS][nCheckpoints - 1].stake;\n\t\tuint96 newStake = add96(staked, value, \"Staking::_increaseUserStake: staked amount overflow\");\n\t\t_writeUserCheckpoint(account, lockedTS, nCheckpoints, newStake);\n\t}\n\n\t/**\n\t * @notice Decreases the user's stake for a giving lock date and writes a checkpoint.\n\t * @param account The user address.\n\t * @param lockedTS The lock date.\n\t * @param value The value to substract to the staked balance.\n\t * */\n\tfunction _decreaseUserStake(\n\t\taddress account,\n\t\tuint256 lockedTS,\n\t\tuint96 value\n\t) internal {\n\t\tuint32 nCheckpoints = numUserStakingCheckpoints[account][lockedTS];\n\t\tuint96 staked = userStakingCheckpoints[account][lockedTS][nCheckpoints - 1].stake;\n\t\tuint96 newStake = sub96(staked, value, \"Staking::_decreaseUserStake: staked amount underflow\");\n\t\t_writeUserCheckpoint(account, lockedTS, nCheckpoints, newStake);\n\t}\n\n\t/**\n\t * @notice Writes on storage the user stake.\n\t * @param account The user address.\n\t * @param lockedTS The lock date.\n\t * @param nCheckpoints The number of checkpoints, to find out the last one index.\n\t * @param newStake The new staked balance.\n\t * */\n\tfunction _writeUserCheckpoint(\n\t\taddress account,\n\t\tuint256 lockedTS,\n\t\tuint32 nCheckpoints,\n\t\tuint96 newStake\n\t) internal {\n\t\tuint32 blockNumber = safe32(block.number, \"Staking::_writeStakingCheckpoint: block number exceeds 32 bits\");\n\n\t\tif (nCheckpoints > 0 && userStakingCheckpoints[account][lockedTS][nCheckpoints - 1].fromBlock == blockNumber) {\n\t\t\tuserStakingCheckpoints[account][lockedTS][nCheckpoints - 1].stake = newStake;\n\t\t} else {\n\t\t\tuserStakingCheckpoints[account][lockedTS][nCheckpoints] = Checkpoint(blockNumber, newStake);\n\t\t\tnumUserStakingCheckpoints[account][lockedTS] = nCheckpoints + 1;\n\t\t}\n\t}\n\n\t/**\n\t * @notice Increases the delegatee's stake for a giving lock date and writes a checkpoint.\n\t * @param delegatee The delegatee address.\n\t * @param lockedTS The lock date.\n\t * @param value The value to add to the staked balance.\n\t * */\n\tfunction _increaseDelegateStake(\n\t\taddress delegatee,\n\t\tuint256 lockedTS,\n\t\tuint96 value\n\t) internal {\n\t\tuint32 nCheckpoints = numDelegateStakingCheckpoints[delegatee][lockedTS];\n\t\tuint96 staked = delegateStakingCheckpoints[delegatee][lockedTS][nCheckpoints - 1].stake;\n\t\tuint96 newStake = add96(staked, value, \"Staking::_increaseDelegateeStake: staked amount overflow\");\n\t\t_writeDelegateCheckpoint(delegatee, lockedTS, nCheckpoints, newStake);\n\t}\n\n\t/**\n\t * @notice Decreases the delegatee's stake for a giving lock date and writes a checkpoint.\n\t * @param delegatee The delegatee address.\n\t * @param lockedTS The lock date.\n\t * @param value The value to substract to the staked balance.\n\t * */\n\tfunction _decreaseDelegateStake(\n\t\taddress delegatee,\n\t\tuint256 lockedTS,\n\t\tuint96 value\n\t) internal {\n\t\tuint32 nCheckpoints = numDelegateStakingCheckpoints[delegatee][lockedTS];\n\t\tuint96 staked = delegateStakingCheckpoints[delegatee][lockedTS][nCheckpoints - 1].stake;\n\t\tuint96 newStake = sub96(staked, value, \"Staking::_decreaseDailyStake: staked amount underflow\");\n\t\t_writeDelegateCheckpoint(delegatee, lockedTS, nCheckpoints, newStake);\n\t}\n\n\t/**\n\t * @notice Writes on storage the delegate stake.\n\t * @param delegatee The delegate address.\n\t * @param lockedTS The lock date.\n\t * @param nCheckpoints The number of checkpoints, to find out the last one index.\n\t * @param newStake The new staked balance.\n\t * */\n\tfunction _writeDelegateCheckpoint(\n\t\taddress delegatee,\n\t\tuint256 lockedTS,\n\t\tuint32 nCheckpoints,\n\t\tuint96 newStake\n\t) internal {\n\t\tuint32 blockNumber = safe32(block.number, \"Staking::_writeStakingCheckpoint: block number exceeds 32 bits\");\n\t\tuint96 oldStake = delegateStakingCheckpoints[delegatee][lockedTS][nCheckpoints - 1].stake;\n\n\t\tif (nCheckpoints > 0 && delegateStakingCheckpoints[delegatee][lockedTS][nCheckpoints - 1].fromBlock == blockNumber) {\n\t\t\tdelegateStakingCheckpoints[delegatee][lockedTS][nCheckpoints - 1].stake = newStake;\n\t\t} else {\n\t\t\tdelegateStakingCheckpoints[delegatee][lockedTS][nCheckpoints] = Checkpoint(blockNumber, newStake);\n\t\t\tnumDelegateStakingCheckpoints[delegatee][lockedTS] = nCheckpoints + 1;\n\t\t}\n\t\temit DelegateStakeChanged(delegatee, lockedTS, oldStake, newStake);\n\t}\n\n\t/**\n\t * @notice Increases the total stake for a giving lock date and writes a checkpoint.\n\t * @param lockedTS The lock date.\n\t * @param value The value to add to the staked balance.\n\t * */\n\tfunction _increaseDailyStake(uint256 lockedTS, uint96 value) internal {\n\t\tuint32 nCheckpoints = numTotalStakingCheckpoints[lockedTS];\n\t\tuint96 staked = totalStakingCheckpoints[lockedTS][nCheckpoints - 1].stake;\n\t\tuint96 newStake = add96(staked, value, \"Staking::_increaseDailyStake: staked amount overflow\");\n\t\t_writeStakingCheckpoint(lockedTS, nCheckpoints, newStake);\n\t}\n\n\t/**\n\t * @notice Decreases the total stake for a giving lock date and writes a checkpoint.\n\t * @param lockedTS The lock date.\n\t * @param value The value to substract to the staked balance.\n\t * */\n\tfunction _decreaseDailyStake(uint256 lockedTS, uint96 value) internal {\n\t\tuint32 nCheckpoints = numTotalStakingCheckpoints[lockedTS];\n\t\tuint96 staked = totalStakingCheckpoints[lockedTS][nCheckpoints - 1].stake;\n\t\tuint96 newStake = sub96(staked, value, \"Staking::_decreaseDailyStake: staked amount underflow\");\n\t\t_writeStakingCheckpoint(lockedTS, nCheckpoints, newStake);\n\t}\n\n\t/**\n\t * @notice Writes on storage the total stake.\n\t * @param lockedTS The lock date.\n\t * @param nCheckpoints The number of checkpoints, to find out the last one index.\n\t * @param newStake The new staked balance.\n\t * */\n\tfunction _writeStakingCheckpoint(\n\t\tuint256 lockedTS,\n\t\tuint32 nCheckpoints,\n\t\tuint96 newStake\n\t) internal {\n\t\tuint32 blockNumber = safe32(block.number, \"Staking::_writeStakingCheckpoint: block number exceeds 32 bits\");\n\n\t\tif (nCheckpoints > 0 && totalStakingCheckpoints[lockedTS][nCheckpoints - 1].fromBlock == blockNumber) {\n\t\t\ttotalStakingCheckpoints[lockedTS][nCheckpoints - 1].stake = newStake;\n\t\t} else {\n\t\t\ttotalStakingCheckpoints[lockedTS][nCheckpoints] = Checkpoint(blockNumber, newStake);\n\t\t\tnumTotalStakingCheckpoints[lockedTS] = nCheckpoints + 1;\n\t\t}\n\t}\n}\n\n// File: contracts/governance/Staking/WeightedStaking.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title Weighted Staking contract.\n * @notice Computation of power and votes used by FeeSharingProxy and\n * GovernorAlpha and Staking contracts w/ mainly 3 public functions:\n *   + getPriorTotalVotingPower => Total voting power.\n *   + getPriorVotes  => Delegatee voting power.\n *   + getPriorWeightedStake  => User Weighted Stake.\n * Staking contract inherits WeightedStaking.\n * FeeSharingProxy and GovernorAlpha invoke Staking instance functions.\n * */\ncontract WeightedStaking is Checkpoints {\n\t/************* TOTAL VOTING POWER COMPUTATION ************************/\n\n\t/**\n\t * @notice Compute the total voting power at a given time.\n\t * @param time The timestamp for which to calculate the total voting power.\n\t * @return The total voting power at the given time.\n\t * */\n\tfunction getPriorTotalVotingPower(uint32 blockNumber, uint256 time) public view returns (uint96 totalVotingPower) {\n\t\t/// @dev Start the computation with the exact or previous unlocking date (voting weight remians the same until the next break point).\n\t\tuint256 start = timestampToLockDate(time);\n\t\tuint256 end = start + MAX_DURATION;\n\n\t\t/// @dev Max 78 iterations.\n\t\tfor (uint256 i = start; i <= end; i += TWO_WEEKS) {\n\t\t\ttotalVotingPower = add96(\n\t\t\t\ttotalVotingPower,\n\t\t\t\t_totalPowerByDate(i, start, blockNumber),\n\t\t\t\t\"WeightedStaking::getPriorTotalVotingPower: overflow on total voting power computation\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Compute the voting power for a specific date.\n\t * Power = stake * weight\n\t * @param date The staking date to compute the power for.\n\t * @param startDate The date for which we need to know the power of the stake.\n\t * @param blockNumber The block number, needed for checkpointing.\n\t * */\n\tfunction _totalPowerByDate(\n\t\tuint256 date,\n\t\tuint256 startDate,\n\t\tuint256 blockNumber\n\t) internal view returns (uint96 power) {\n\t\tuint96 weight = computeWeightByDate(date, startDate);\n\t\tuint96 staked = getPriorTotalStakesForDate(date, blockNumber);\n\t\t/// @dev weight is multiplied by some factor to allow decimals.\n\t\tpower = mul96(staked, weight, \"WeightedStaking::_totalPowerByDate: multiplication overflow\") / WEIGHT_FACTOR;\n\t}\n\n\t/**\n\t * @notice Determine the prior number of stake for an unlocking date as of a block number.\n\t * @dev Block number must be a finalized block or else this function will\n\t * revert to prevent misinformation.\n\t * TODO: WeightedStaking::getPriorTotalStakesForDate should probably better\n\t * be internal instead of a public function.\n\t * @param date The date to check the stakes for.\n\t * @param blockNumber The block number to get the vote balance at.\n\t * @return The number of votes the account had as of the given block.\n\t * */\n\tfunction getPriorTotalStakesForDate(uint256 date, uint256 blockNumber) public view returns (uint96) {\n\t\trequire(blockNumber < block.number, \"WeightedStaking::getPriorTotalStakesForDate: not yet determined\");\n\n\t\tuint32 nCheckpoints = numTotalStakingCheckpoints[date];\n\t\tif (nCheckpoints == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// First check most recent balance\n\t\tif (totalStakingCheckpoints[date][nCheckpoints - 1].fromBlock <= blockNumber) {\n\t\t\treturn totalStakingCheckpoints[date][nCheckpoints - 1].stake;\n\t\t}\n\n\t\t// Next check implicit zero balance\n\t\tif (totalStakingCheckpoints[date][0].fromBlock > blockNumber) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint32 lower = 0;\n\t\tuint32 upper = nCheckpoints - 1;\n\t\twhile (upper > lower) {\n\t\t\tuint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n\t\t\tCheckpoint memory cp = totalStakingCheckpoints[date][center];\n\t\t\tif (cp.fromBlock == blockNumber) {\n\t\t\t\treturn cp.stake;\n\t\t\t} else if (cp.fromBlock < blockNumber) {\n\t\t\t\tlower = center;\n\t\t\t} else {\n\t\t\t\tupper = center - 1;\n\t\t\t}\n\t\t}\n\t\treturn totalStakingCheckpoints[date][lower].stake;\n\t}\n\n\t/****************************** DELEGATED VOTING POWER COMPUTATION ************************/\n\n\t/**\n\t * @notice Determine the prior number of votes for a delegatee as of a block number.\n\t * Iterate through checkpoints adding up voting power.\n\t * @dev Block number must be a finalized block or else this function will revert\n\t * to prevent misinformation.\n\t *      Used for Voting, not for fee sharing.\n\t * @param account The address of the account to check.\n\t * @param blockNumber The block number to get the vote balance at.\n\t * @return The number of votes the delegatee had as of the given block.\n\t * */\n\tfunction getPriorVotes(\n\t\taddress account,\n\t\tuint256 blockNumber,\n\t\tuint256 date\n\t) public view returns (uint96 votes) {\n\t\t/// @dev If date is not an exact break point, start weight computation from the previous break point (alternative would be the next).\n\t\tuint256 start = timestampToLockDate(date);\n\t\tuint256 end = start + MAX_DURATION;\n\n\t\t/// @dev Max 78 iterations.\n\t\tfor (uint256 i = start; i <= end; i += TWO_WEEKS) {\n\t\t\tvotes = add96(\n\t\t\t\tvotes,\n\t\t\t\t_totalPowerByDateForDelegatee(account, i, start, blockNumber),\n\t\t\t\t\"WeightedStaking::getPriorVotes: overflow on total voting power computation\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Compute the voting power for a specific date.\n\t * Power = stake * weight\n\t * @param date The staking date to compute the power for.\n\t * @param startDate The date for which we need to know the power of the stake.\n\t * @param blockNumber The block number, needed for checkpointing.\n\t * */\n\tfunction _totalPowerByDateForDelegatee(\n\t\taddress account,\n\t\tuint256 date,\n\t\tuint256 startDate,\n\t\tuint256 blockNumber\n\t) internal view returns (uint96 power) {\n\t\tuint96 weight = computeWeightByDate(date, startDate);\n\t\tuint96 staked = getPriorStakeByDateForDelegatee(account, date, blockNumber);\n\t\tpower = mul96(staked, weight, \"WeightedStaking::_totalPowerByDateForDelegatee: multiplication overflow\") / WEIGHT_FACTOR;\n\t}\n\n\t/**\n\t * @notice Determine the prior number of stake for an account as of a block number.\n\t * @dev Block number must be a finalized block or else this function will\n\t * revert to prevent misinformation.\n\t * TODO: WeightedStaking::getPriorStakeByDateForDelegatee should probably better\n\t * be internal instead of a public function.\n\t * @param account The address of the account to check.\n\t * @param blockNumber The block number to get the vote balance at.\n\t * @return The number of votes the account had as of the given block.\n\t * */\n\tfunction getPriorStakeByDateForDelegatee(\n\t\taddress account,\n\t\tuint256 date,\n\t\tuint256 blockNumber\n\t) public view returns (uint96) {\n\t\trequire(blockNumber < block.number, \"WeightedStaking::getPriorStakeByDateForDelegatee: not yet determined\");\n\n\t\tuint32 nCheckpoints = numDelegateStakingCheckpoints[account][date];\n\t\tif (nCheckpoints == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t/// @dev First check most recent balance.\n\t\tif (delegateStakingCheckpoints[account][date][nCheckpoints - 1].fromBlock <= blockNumber) {\n\t\t\treturn delegateStakingCheckpoints[account][date][nCheckpoints - 1].stake;\n\t\t}\n\n\t\t/// @dev Next check implicit zero balance.\n\t\tif (delegateStakingCheckpoints[account][date][0].fromBlock > blockNumber) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint32 lower = 0;\n\t\tuint32 upper = nCheckpoints - 1;\n\t\twhile (upper > lower) {\n\t\t\tuint32 center = upper - (upper - lower) / 2; /// @dev ceil, avoiding overflow.\n\t\t\tCheckpoint memory cp = delegateStakingCheckpoints[account][date][center];\n\t\t\tif (cp.fromBlock == blockNumber) {\n\t\t\t\treturn cp.stake;\n\t\t\t} else if (cp.fromBlock < blockNumber) {\n\t\t\t\tlower = center;\n\t\t\t} else {\n\t\t\t\tupper = center - 1;\n\t\t\t}\n\t\t}\n\t\treturn delegateStakingCheckpoints[account][date][lower].stake;\n\t}\n\n\t/*************************** User Weighted Stake computation for fee sharing *******************************/\n\n\t/**\n\t * @notice Determine the prior weighted stake for an account as of a block number.\n\t * Iterate through checkpoints adding up voting power.\n\t * @dev Block number must be a finalized block or else this function will\n\t * revert to prevent misinformation.\n\t *      Used for fee sharing, not voting.\n\t * TODO: WeightedStaking::getPriorWeightedStake is using the variable name \"votes\"\n\t * to add up token stake, and that could be misleading.\n\t *\n\t * @param account The address of the account to check.\n\t * @param blockNumber The block number to get the vote balance at.\n\t * @return The weighted stake the account had as of the given block.\n\t * */\n\tfunction getPriorWeightedStake(\n\t\taddress account,\n\t\tuint256 blockNumber,\n\t\tuint256 date\n\t) public view returns (uint96 votes) {\n\t\t/// @dev If date is not an exact break point, start weight computation from the previous break point (alternative would be the next).\n\t\tuint256 start = timestampToLockDate(date);\n\t\tuint256 end = start + MAX_DURATION;\n\n\t\t/// @dev Max 78 iterations.\n\t\tfor (uint256 i = start; i <= end; i += TWO_WEEKS) {\n\t\t\tuint96 weightedStake = weightedStakeByDate(account, i, start, blockNumber);\n\t\t\tif (weightedStake > 0) {\n\t\t\t\tvotes = add96(votes, weightedStake, \"WeightedStaking::getPriorWeightedStake: overflow on total weight computation\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Compute the voting power for a specific date.\n\t * Power = stake * weight\n\t * TODO: WeightedStaking::weightedStakeByDate should probably better\n\t * be internal instead of a public function.\n\t * @param date The staking date to compute the power for.\n\t * @param startDate The date for which we need to know the power of the stake.\n\t * @param blockNumber The block number, needed for checkpointing.\n\t * */\n\tfunction weightedStakeByDate(\n\t\taddress account,\n\t\tuint256 date,\n\t\tuint256 startDate,\n\t\tuint256 blockNumber\n\t) public view returns (uint96 power) {\n\t\tuint96 staked = getPriorUserStakeByDate(account, date, blockNumber);\n\t\tif (staked > 0) {\n\t\t\tuint96 weight = computeWeightByDate(date, startDate);\n\t\t\tpower = mul96(staked, weight, \"WeightedStaking::weightedStakeByDate: multiplication overflow\") / WEIGHT_FACTOR;\n\t\t} else {\n\t\t\tpower = 0;\n\t\t}\n\t}\n\n\t/**\n\t * @notice Determine the prior number of stake for an account until a\n\t * certain lock date as of a block number.\n\t * @dev Block number must be a finalized block or else this function\n\t * will revert to prevent misinformation.\n\t * @param account The address of the account to check.\n\t * @param date The lock date.\n\t * @param blockNumber The block number to get the vote balance at.\n\t * @return The number of votes the account had as of the given block.\n\t * */\n\tfunction getPriorUserStakeByDate(\n\t\taddress account,\n\t\tuint256 date,\n\t\tuint256 blockNumber\n\t) public view returns (uint96) {\n\t\trequire(blockNumber < block.number, \"WeightedStaking::getPriorUserStakeAndDate: not yet determined\");\n\n\t\tdate = _adjustDateForOrigin(date);\n\t\tuint32 nCheckpoints = numUserStakingCheckpoints[account][date];\n\t\tif (nCheckpoints == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t/// @dev First check most recent balance.\n\t\tif (userStakingCheckpoints[account][date][nCheckpoints - 1].fromBlock <= blockNumber) {\n\t\t\treturn userStakingCheckpoints[account][date][nCheckpoints - 1].stake;\n\t\t}\n\n\t\t/// @dev Next check implicit zero balance.\n\t\tif (userStakingCheckpoints[account][date][0].fromBlock > blockNumber) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint32 lower = 0;\n\t\tuint32 upper = nCheckpoints - 1;\n\t\twhile (upper > lower) {\n\t\t\tuint32 center = upper - (upper - lower) / 2; /// @dev ceil, avoiding overflow.\n\t\t\tCheckpoint memory cp = userStakingCheckpoints[account][date][center];\n\t\t\tif (cp.fromBlock == blockNumber) {\n\t\t\t\treturn cp.stake;\n\t\t\t} else if (cp.fromBlock < blockNumber) {\n\t\t\t\tlower = center;\n\t\t\t} else {\n\t\t\t\tupper = center - 1;\n\t\t\t}\n\t\t}\n\t\treturn userStakingCheckpoints[account][date][lower].stake;\n\t}\n\n\t/**************** SHARED FUNCTIONS *********************/\n\n\t/**\n\t * @notice Compute the weight for a specific date.\n\t * @param date The unlocking date.\n\t * @param startDate We compute the weight for the tokens staked until 'date' on 'startDate'.\n\t * */\n\tfunction computeWeightByDate(uint256 date, uint256 startDate) public pure returns (uint96 weight) {\n\t\trequire(date >= startDate, \"WeightedStaking::computeWeightByDate: date needs to be bigger than startDate\");\n\t\tuint256 remainingTime = (date - startDate);\n\t\trequire(MAX_DURATION >= remainingTime, \"Staking::computeWeightByDate:remaining time can't be bigger than max duration\");\n\t\t/// @dev x = max days - remaining days\n\t\tuint96 x = uint96(MAX_DURATION - remainingTime) / (1 days);\n\t\t/// @dev w = (m^2 - x^2)/m^2 +1 (multiplied by the weight factor)\n\t\tweight = add96(\n\t\t\tWEIGHT_FACTOR,\n\t\t\tmul96(\n\t\t\t\tMAX_VOTING_WEIGHT * WEIGHT_FACTOR,\n\t\t\t\tsub96(MAX_DURATION_POW_2, x * x, \"underflow on weight calculation\"),\n\t\t\t\t\"multiplication overflow on weight computation\"\n\t\t\t) / MAX_DURATION_POW_2,\n\t\t\t\"overflow on weight computation\"\n\t\t);\n\t}\n\n\t/**\n\t * @notice Unstaking is possible every 2 weeks only. This means, to\n\t * calculate the key value for the staking checkpoints, we need to\n\t * map the intended timestamp to the closest available date.\n\t * @param timestamp The unlocking timestamp.\n\t * @return The actual unlocking date (might be up to 2 weeks shorter than intended).\n\t * */\n\tfunction timestampToLockDate(uint256 timestamp) public view returns (uint256 lockDate) {\n\t\trequire(timestamp >= kickoffTS, \"WeightedStaking::timestampToLockDate: timestamp lies before contract creation\");\n\t\t/**\n\t\t * @dev If staking timestamp does not match any of the unstaking dates\n\t\t * , set the lockDate to the closest one before the timestamp.\n\t\t * E.g. Passed timestamps lies 7 weeks after kickoff -> only stake for 6 weeks.\n\t\t * */\n\t\tuint256 periodFromKickoff = (timestamp - kickoffTS) / TWO_WEEKS;\n\t\tlockDate = periodFromKickoff * TWO_WEEKS + kickoffTS;\n\t}\n\n\tfunction _adjustDateForOrigin(uint256 date) internal view returns (uint256) {\n\t\tuint256 adjustedDate = timestampToLockDate(date);\n\t\t//origin vesting contracts have different dates\n\t\t//we need to add 2 weeks to get end of period (by default, it's start)\n\t\tif (adjustedDate != date) {\n\t\t\tdate = adjustedDate + TWO_WEEKS;\n\t\t}\n\t\treturn date;\n\t}\n}\n\n// File: contracts/rsk/RSKAddrValidator.sol\n\n// SPDX-License-Identifier:MIT\npragma solidity ^0.5.17;\n\nlibrary RSKAddrValidator {\n\t/*\n\t * @param addr it is an address to check that it does not originates from\n\t * signing with PK = ZERO. RSK has a small difference in which @ZERO_PK_ADDR is\n\t * also an address from PK = ZERO. So we check for both of them.\n\t * */\n\tfunction checkPKNotZero(address addr) internal pure returns (bool) {\n\t\treturn (addr != 0xdcc703c0E500B653Ca82273B7BFAd8045D85a470 && addr != address(0));\n\t}\n\n\t/*\n\t * Safely compares two addresses, checking they do not originate from\n\t * a zero private key.\n\t * */\n\tfunction safeEquals(address addr1, address addr2) internal pure returns (bool) {\n\t\treturn (addr1 == addr2 && addr1 != 0xdcc703c0E500B653Ca82273B7BFAd8045D85a470 && addr1 != address(0));\n\t}\n}\n\n// File: contracts/governance/ErrorDecoder.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title Base contract to properly handle returned data on failed calls\n * @dev On EVM if the return data length of a call is less than 68,\n * then the transaction fails silently without a revert message!\n *\n * As described in the Solidity documentation\n * https://solidity.readthedocs.io/en/v0.5.17/control-structures.html#revert\n * the revert reason is an ABI-encoded string consisting of:\n * 0x08c379a0 // Function selector (method id) for \"Error(string)\" signature\n * 0x0000000000000000000000000000000000000000000000000000000000000020 // Data offset\n * 0x000000000000000000000000000000000000000000000000000000000000001a // String length\n * 0x4e6f7420656e6f7567682045746865722070726f76696465642e000000000000 // String data\n *\n * Another example, debug data from test:\n *   0x08c379a0\n *   0000000000000000000000000000000000000000000000000000000000000020\n *   0000000000000000000000000000000000000000000000000000000000000034\n *   54696d656c6f636b3a3a73657444656c61793a2044656c6179206d7573742065\n *   7863656564206d696e696d756d2064656c61792e000000000000000000000000\n *\n * Parsed into:\n *   Data offset: 20\n *   Length: 34\n *   Error message:\n *     54696d656c6f636b3a3a73657444656c61793a2044656c6179206d7573742065\n *     7863656564206d696e696d756d2064656c61792e000000000000000000000000\n */\ncontract ErrorDecoder {\n\tuint256 constant ERROR_MESSAGE_SHIFT = 68; // EVM silent revert error string length\n\n\t/**\n\t * @notice Concats two error strings taking into account ERROR_MESSAGE_SHIFT.\n\t * @param str1 First string, usually a hardcoded context written by dev.\n\t * @param str2 Second string, usually the error message from the reverted call.\n\t * @return The concatenated error string\n\t */\n\tfunction _addErrorMessage(string memory str1, string memory str2) internal pure returns (string memory) {\n\t\tbytes memory bytesStr1 = bytes(str1);\n\t\tbytes memory bytesStr2 = bytes(str2);\n\t\tstring memory str12 = new string(bytesStr1.length + bytesStr2.length - ERROR_MESSAGE_SHIFT);\n\t\tbytes memory bytesStr12 = bytes(str12);\n\t\tuint256 j = 0;\n\t\tfor (uint256 i = 0; i < bytesStr1.length; i++) {\n\t\t\tbytesStr12[j++] = bytesStr1[i];\n\t\t}\n\t\tfor (uint256 i = ERROR_MESSAGE_SHIFT; i < bytesStr2.length; i++) {\n\t\t\tbytesStr12[j++] = bytesStr2[i];\n\t\t}\n\t\treturn string(bytesStr12);\n\t}\n}\n\n// File: contracts/token/IApproveAndCall.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title Interface for contract governance/ApprovalReceiver.sol\n * @dev Interfaces are used to cast a contract address into a callable instance.\n */\ninterface IApproveAndCall {\n\t/**\n\t * @notice Receives approval from SOV token.\n\t * @param _sender The sender of SOV.approveAndCall function.\n\t * @param _amount The amount was approved.\n\t * @param _token The address of token.\n\t * @param _data The data will be used for low level call.\n\t * */\n\tfunction receiveApproval(\n\t\taddress _sender,\n\t\tuint256 _amount,\n\t\taddress _token,\n\t\tbytes calldata _data\n\t) external;\n}\n\n// File: contracts/governance/ApprovalReceiver.sol\n\npragma solidity ^0.5.17;\n\n\n\n/**\n * @title Base contract for receiving approval from SOV token.\n */\ncontract ApprovalReceiver is ErrorDecoder, IApproveAndCall {\n\tmodifier onlyThisContract() {\n\t\t// Accepts calls only from receiveApproval function.\n\t\trequire(msg.sender == address(this), \"unauthorized\");\n\t\t_;\n\t}\n\n\t/**\n\t * @notice Receives approval from SOV token.\n\t * @param _data The data will be used for low level call.\n\t */\n\tfunction receiveApproval(\n\t\taddress _sender,\n\t\tuint256 _amount,\n\t\taddress _token,\n\t\tbytes calldata _data\n\t) external {\n\t\t// Accepts calls only from SOV token.\n\t\trequire(msg.sender == _getToken(), \"unauthorized\");\n\t\trequire(msg.sender == _token, \"unauthorized\");\n\n\t\t// Only allowed methods.\n\t\tbool isAllowed = false;\n\t\tbytes4[] memory selectors = _getSelectors();\n\t\tbytes4 sig = _getSig(_data);\n\t\tfor (uint256 i = 0; i < selectors.length; i++) {\n\t\t\tif (sig == selectors[i]) {\n\t\t\t\tisAllowed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequire(isAllowed, \"method is not allowed\");\n\n\t\t// Check sender and amount.\n\t\taddress sender;\n\t\tuint256 amount;\n\t\t(, sender, amount) = abi.decode(abi.encodePacked(bytes28(0), _data), (bytes32, address, uint256));\n\t\trequire(sender == _sender, \"sender mismatch\");\n\t\trequire(amount == _amount, \"amount mismatch\");\n\n\t\t_call(_data);\n\t}\n\n\t/**\n\t * @notice Returns token address, only this address can be a sender for receiveApproval.\n\t * @dev Should be overridden in child contracts, otherwise error will be thrown.\n\t * @return By default, 0x. When overriden, the token address making the call.\n\t */\n\tfunction _getToken() internal view returns (address) {\n\t\treturn address(0);\n\t}\n\n\t/**\n\t * @notice Returns list of function selectors allowed to be invoked.\n\t * @dev Should be overridden in child contracts, otherwise error will be thrown.\n\t * @return By default, empty array. When overriden, allowed selectors.\n\t */\n\tfunction _getSelectors() internal view returns (bytes4[] memory) {\n\t\treturn new bytes4[](0);\n\t}\n\n\t/**\n\t * @notice Makes call and reverts w/ enhanced error message.\n\t * @param _data Error message as bytes.\n\t */\n\tfunction _call(bytes memory _data) internal {\n\t\t(bool success, bytes memory returnData) = address(this).call(_data);\n\t\tif (!success) {\n\t\t\tif (returnData.length <= ERROR_MESSAGE_SHIFT) {\n\t\t\t\trevert(\"receiveApproval: Transaction execution reverted.\");\n\t\t\t} else {\n\t\t\t\trevert(_addErrorMessage(\"receiveApproval: \", string(returnData)));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Extracts the called function selector, a hash of the signature.\n\t * @dev The first four bytes of the call data for a function call specifies\n\t * the function to be called. It is the first (left, high-order in big-endian)\n\t * four bytes of the Keccak-256 (SHA-3) hash of the signature of the function.\n\t * Solidity doesn't yet support a casting of byte[4] to bytes4.\n\t * Example:\n\t *  msg.data:\n\t *    0xcdcd77c000000000000000000000000000000000000000000000000000000000000\n\t *    000450000000000000000000000000000000000000000000000000000000000000001\n\t *  selector (or method ID): 0xcdcd77c0\n\t *  signature: baz(uint32,bool)\n\t * @param _data The msg.data from the low level call.\n\t * @return sig First 4 bytes of msg.data i.e. the selector, hash of the signature.\n\t */\n\tfunction _getSig(bytes memory _data) internal pure returns (bytes4 sig) {\n\t\tassembly {\n\t\t\tsig := mload(add(_data, 32))\n\t\t}\n\t}\n}\n\n// File: contracts/governance/Staking/Staking.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title Staking contract.\n * @notice Pay-in and pay-out function for staking and withdrawing tokens.\n * Staking is delegated and vested: To gain voting power, SOV holders must\n * stake their SOV for a given period of time. Aside from Bitocracy\n * participation, there's a financially-rewarding reason for staking SOV.\n * Tokenholders who stake their SOV receive staking rewards, a pro-rata share\n * of the revenue that the platform generates from various transaction fees\n * plus revenues from stakers who have a portion of their SOV slashed for\n * early unstaking.\n * */\ncontract Staking is IStaking, WeightedStaking, ApprovalReceiver {\n\t/**\n\t * @notice Stake the given amount for the given duration of time.\n\t * @param amount The number of tokens to stake.\n\t * @param until Timestamp indicating the date until which to stake.\n\t * @param stakeFor The address to stake the tokens for or 0x0 if staking for oneself.\n\t * @param delegatee The address of the delegatee or 0x0 if there is none.\n\t * */\n\tfunction stake(\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) external {\n\t\t_stake(msg.sender, amount, until, stakeFor, delegatee, false);\n\t}\n\n\t/**\n\t * @notice Stake the given amount for the given duration of time.\n\t * @dev This function will be invoked from receiveApproval\n\t * @dev SOV.approveAndCall -> this.receiveApproval -> this.stakeWithApproval\n\t * @param sender The sender of SOV.approveAndCall\n\t * @param amount The number of tokens to stake.\n\t * @param until Timestamp indicating the date until which to stake.\n\t * @param stakeFor The address to stake the tokens for or 0x0 if staking for oneself.\n\t * @param delegatee The address of the delegatee or 0x0 if there is none.\n\t * */\n\tfunction stakeWithApproval(\n\t\taddress sender,\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) public onlyThisContract {\n\t\t_stake(sender, amount, until, stakeFor, delegatee, false);\n\t}\n\n\t/**\n\t * @notice Send sender's tokens to this contract and update its staked balance.\n\t * @param sender The sender of the tokens.\n\t * @param amount The number of tokens to send.\n\t * @param until The date until which the tokens will be staked.\n\t * @param stakeFor The beneficiary whose stake will be increased.\n\t * @param delegatee The address of the delegatee or stakeFor if default 0x0.\n\t * @param timeAdjusted Whether fixing date to stacking periods or not.\n\t * */\n\tfunction _stake(\n\t\taddress sender,\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress stakeFor,\n\t\taddress delegatee,\n\t\tbool timeAdjusted\n\t) internal {\n\t\trequire(amount > 0, \"Staking::stake: amount of tokens to stake needs to be bigger than 0\");\n\n\t\tif (!timeAdjusted) {\n\t\t\tuntil = timestampToLockDate(until);\n\t\t}\n\t\trequire(until > block.timestamp, \"Staking::timestampToLockDate: staking period too short\");\n\n\t\t/// @dev Stake for the sender if not specified otherwise.\n\t\tif (stakeFor == address(0)) {\n\t\t\tstakeFor = sender;\n\t\t}\n\n\t\t/// @dev Delegate for stakeFor if not specified otherwise.\n\t\tif (delegatee == address(0)) {\n\t\t\tdelegatee = stakeFor;\n\t\t}\n\n\t\t/// @dev Do not stake longer than the max duration.\n\t\tif (!timeAdjusted) {\n\t\t\tuint256 latest = timestampToLockDate(block.timestamp + MAX_DURATION);\n\t\t\tif (until > latest) until = latest;\n\t\t}\n\n\t\tuint96 previousBalance = currentBalance(stakeFor, until);\n\n\t\t/// @dev Increase stake.\n\t\t_increaseStake(sender, amount, stakeFor, until);\n\n\t\tif (previousBalance == 0) {\n\t\t\t/// @dev Regular delegation if it's a first stake.\n\t\t\t_delegate(stakeFor, delegatee, until);\n\t\t} else {\n\t\t\taddress previousDelegatee = delegates[stakeFor][until];\n\t\t\tif (previousDelegatee != delegatee) {\n\t\t\t\t/// @dev Update delegatee.\n\t\t\t\tdelegates[stakeFor][until] = delegatee;\n\n\t\t\t\t/// @dev Decrease stake on previous balance for previous delegatee.\n\t\t\t\t_decreaseDelegateStake(previousDelegatee, until, previousBalance);\n\n\t\t\t\t/// @dev Add previousBalance to amount.\n\t\t\t\tamount = add96(previousBalance, amount, \"Staking::stake: balance overflow\");\n\t\t\t}\n\n\t\t\t/// @dev Increase stake.\n\t\t\t_increaseDelegateStake(delegatee, until, amount);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Extend the staking duration until the specified date.\n\t * @param previousLock The old unlocking timestamp.\n\t * @param until The new unlocking timestamp in seconds.\n\t * */\n\tfunction extendStakingDuration(uint256 previousLock, uint256 until) public {\n\t\tuntil = timestampToLockDate(until);\n\t\trequire(previousLock <= until, \"Staking::extendStakingDuration: cannot reduce the staking duration\");\n\n\t\t/// @dev Do not exceed the max duration, no overflow possible.\n\t\tuint256 latest = timestampToLockDate(block.timestamp + MAX_DURATION);\n\t\tif (until > latest) until = latest;\n\n\t\t/// @dev Update checkpoints.\n\t\t/// @dev TODO James: Can reading stake at block.number -1 cause trouble with multiple tx in a block?\n\t\tuint96 amount = getPriorUserStakeByDate(msg.sender, previousLock, block.number - 1);\n\t\trequire(amount > 0, \"Staking::extendStakingDuration: nothing staked until the previous lock date\");\n\t\t_decreaseUserStake(msg.sender, previousLock, amount);\n\t\t_increaseUserStake(msg.sender, until, amount);\n\t\t_decreaseDailyStake(previousLock, amount);\n\t\t_increaseDailyStake(until, amount);\n\n\t\t/// @dev Delegate might change: if there is already a delegate set for the until date, it will remain the delegate for this position\n\t\taddress delegateFrom = delegates[msg.sender][previousLock];\n\t\taddress delegateTo = delegates[msg.sender][until];\n\t\tif (delegateTo == address(0)) {\n\t\t\tdelegateTo = delegateFrom;\n\t\t\tdelegates[msg.sender][until] = delegateFrom;\n\t\t}\n\t\tdelegates[msg.sender][previousLock] = address(0);\n\t\t_decreaseDelegateStake(delegateFrom, previousLock, amount);\n\t\t_increaseDelegateStake(delegateTo, until, amount);\n\n\t\temit ExtendedStakingDuration(msg.sender, previousLock, until);\n\t}\n\n\t/**\n\t * @notice Send sender's tokens to this contract and update its staked balance.\n\t * @param sender The sender of the tokens.\n\t * @param amount The number of tokens to send.\n\t * @param stakeFor The beneficiary whose stake will be increased.\n\t * @param until The date until which the tokens will be staked.\n\t * */\n\tfunction _increaseStake(\n\t\taddress sender,\n\t\tuint96 amount,\n\t\taddress stakeFor,\n\t\tuint256 until\n\t) internal {\n\t\t/// @dev Retrieve the SOV tokens.\n\t\tbool success = SOVToken.transferFrom(sender, address(this), amount);\n\t\trequire(success);\n\n\t\t/// @dev Increase staked balance.\n\t\tuint96 balance = currentBalance(stakeFor, until);\n\t\tbalance = add96(balance, amount, \"Staking::increaseStake: balance overflow\");\n\n\t\t/// @dev Update checkpoints.\n\t\t_increaseDailyStake(until, amount);\n\t\t_increaseUserStake(stakeFor, until, amount);\n\n\t\temit TokensStaked(stakeFor, amount, until, balance);\n\t}\n\n\t/**\n\t * @notice Stake tokens according to the vesting schedule.\n\t * @param amount The amount of tokens to stake.\n\t * @param cliff The time interval to the first withdraw.\n\t * @param duration The staking duration.\n\t * @param intervalLength The length of each staking interval when cliff passed.\n\t * @param stakeFor The address to stake the tokens for or 0x0 if staking for oneself.\n\t * @param delegatee The address of the delegatee or 0x0 if there is none.\n\t * */\n\tfunction stakesBySchedule(\n\t\tuint256 amount,\n\t\tuint256 cliff,\n\t\tuint256 duration,\n\t\tuint256 intervalLength,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) public {\n\t\t/**\n\t\t * @dev Stake them until lock dates according to the vesting schedule.\n\t\t * Note: because staking is only possible in periods of 2 weeks,\n\t\t * the total duration might end up a bit shorter than specified\n\t\t * depending on the date of staking.\n\t\t * */\n\t\tuint256 start = timestampToLockDate(block.timestamp + cliff);\n\t\tif (duration > MAX_DURATION) {\n\t\t\tduration = MAX_DURATION;\n\t\t}\n\t\tuint256 end = timestampToLockDate(block.timestamp + duration);\n\t\tuint256 numIntervals = (end - start) / intervalLength + 1;\n\t\tuint256 stakedPerInterval = amount / numIntervals;\n\t\t/// @dev stakedPerInterval might lose some dust on rounding. Add it to the first staking date.\n\t\tif (numIntervals >= 1) {\n\t\t\t_stake(msg.sender, uint96(amount - stakedPerInterval * (numIntervals - 1)), start, stakeFor, delegatee, true);\n\t\t}\n\t\t/// @dev Stake the rest in 4 week intervals.\n\t\tfor (uint256 i = start + intervalLength; i <= end; i += intervalLength) {\n\t\t\t/// @dev Stakes for itself, delegates to the owner.\n\t\t\t_stake(msg.sender, uint96(stakedPerInterval), i, stakeFor, delegatee, true);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Withdraw the given amount of tokens if they are unlocked.\n\t * @param amount The number of tokens to withdraw.\n\t * @param until The date until which the tokens were staked.\n\t * @param receiver The receiver of the tokens. If not specified, send to the msg.sender\n\t * */\n\tfunction withdraw(\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress receiver\n\t) public {\n\t\t_withdraw(amount, until, receiver, false);\n\t}\n\n\t/**\n\t * @notice Withdraw the given amount of tokens.\n\t * @param amount The number of tokens to withdraw.\n\t * @param until The date until which the tokens were staked.\n\t * @param receiver The receiver of the tokens. If not specified, send to the msg.sender\n\t * @dev Can be invoked only by whitelisted contract passed to governanceWithdrawVesting\n\t * */\n\tfunction governanceWithdraw(\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress receiver\n\t) public {\n\t\trequire(vestingWhitelist[msg.sender], \"unauthorized\");\n\n\t\t_withdraw(amount, until, receiver, true);\n\t}\n\n\t/**\n\t * @notice Withdraw tokens for vesting contract.\n\t * @param vesting The address of Vesting contract.\n\t * @param receiver The receiver of the tokens. If not specified, send to the msg.sender\n\t * @dev Can be invoked only by whitelisted contract passed to governanceWithdrawVesting.\n\t * */\n\tfunction governanceWithdrawVesting(address vesting, address receiver) public onlyOwner {\n\t\tvestingWhitelist[vesting] = true;\n\t\tITeamVesting(vesting).governanceWithdrawTokens(receiver);\n\t\tvestingWhitelist[vesting] = false;\n\n\t\temit VestingTokensWithdrawn(vesting, receiver);\n\t}\n\n\t/**\n\t * @notice Send user' staked tokens to a receiver taking into account punishments.\n\t * Sovryn encourages long-term commitment and thinking. When/if you unstake before\n\t * the end of the staking period, a percentage of the original staking amount will\n\t * be slashed. This amount is also added to the reward pool and is distributed\n\t * between all other stakers.\n\t *\n\t * @param amount The number of tokens to withdraw.\n\t * @param until The date until which the tokens were staked.\n\t * @param receiver The receiver of the tokens. If not specified, send to the msg.sender\n\t * @param isGovernance Whether all tokens (true)\n\t * or just unlocked tokens (false).\n\t * */\n\tfunction _withdraw(\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress receiver,\n\t\tbool isGovernance\n\t) internal {\n\t\tuntil = _adjustDateForOrigin(until);\n\t\t_validateWithdrawParams(amount, until);\n\n\t\t/// @dev Determine the receiver.\n\t\tif (receiver == address(0)) receiver = msg.sender;\n\n\t\t/// @dev Update the checkpoints.\n\t\t_decreaseDailyStake(until, amount);\n\t\t_decreaseUserStake(msg.sender, until, amount);\n\t\t_decreaseDelegateStake(delegates[msg.sender][until], until, amount);\n\n\t\t/// @dev Early unstaking should be punished.\n\t\tif (block.timestamp < until && !allUnlocked && !isGovernance) {\n\t\t\tuint96 punishedAmount = _getPunishedAmount(amount, until);\n\t\t\tamount -= punishedAmount;\n\n\t\t\t/// @dev punishedAmount can be 0 if block.timestamp are very close to 'until'\n\t\t\tif (punishedAmount > 0) {\n\t\t\t\trequire(address(feeSharing) != address(0), \"Staking::withdraw: FeeSharing address wasn't set\");\n\t\t\t\t/// @dev Move punished amount to fee sharing.\n\t\t\t\t/// @dev Approve transfer here and let feeSharing do transfer and write checkpoint.\n\t\t\t\tSOVToken.approve(address(feeSharing), punishedAmount);\n\t\t\t\tfeeSharing.transferTokens(address(SOVToken), punishedAmount);\n\t\t\t}\n\t\t}\n\n\t\t/// @dev transferFrom\n\t\tbool success = SOVToken.transfer(receiver, amount);\n\t\trequire(success, \"Staking::withdraw: Token transfer failed\");\n\n\t\temit TokensWithdrawn(msg.sender, receiver, amount);\n\t}\n\n\t/**\n\t * @notice Get available and punished amount for withdrawing.\n\t * @param amount The number of tokens to withdraw.\n\t * @param until The date until which the tokens were staked.\n\t * */\n\tfunction getWithdrawAmounts(uint96 amount, uint256 until) public view returns (uint96, uint96) {\n\t\t_validateWithdrawParams(amount, until);\n\t\tuint96 punishedAmount = _getPunishedAmount(amount, until);\n\t\treturn (amount - punishedAmount, punishedAmount);\n\t}\n\n\t/**\n\t * @notice Get punished amount for withdrawing.\n\t * @param amount The number of tokens to withdraw.\n\t * @param until The date until which the tokens were staked.\n\t * */\n\tfunction _getPunishedAmount(uint96 amount, uint256 until) internal view returns (uint96) {\n\t\tuint256 date = timestampToLockDate(block.timestamp);\n\t\tuint96 weight = computeWeightByDate(until, date); /// @dev (10 - 1) * WEIGHT_FACTOR\n\t\tweight = weight * weightScaling;\n\t\treturn (amount * weight) / WEIGHT_FACTOR / 100;\n\t}\n\n\t/**\n\t * @notice Validate withdraw parameters.\n\t * @param amount The number of tokens to withdraw.\n\t * @param until The date until which the tokens were staked.\n\t * */\n\tfunction _validateWithdrawParams(uint96 amount, uint256 until) internal view {\n\t\trequire(amount > 0, \"Staking::withdraw: amount of tokens to be withdrawn needs to be bigger than 0\");\n\t\tuint96 balance = getPriorUserStakeByDate(msg.sender, until, block.number - 1);\n\t\trequire(amount <= balance, \"Staking::withdraw: not enough balance\");\n\t}\n\n\t/**\n\t * @notice Get the current balance of an account locked until a certain date.\n\t * @param account The user address.\n\t * @param lockDate The lock date.\n\t * @return The stake amount.\n\t * */\n\tfunction currentBalance(address account, uint256 lockDate) internal view returns (uint96) {\n\t\treturn userStakingCheckpoints[account][lockDate][numUserStakingCheckpoints[account][lockDate] - 1].stake;\n\t}\n\n\t/**\n\t * @notice Get the number of staked tokens held by the user account.\n\t * @dev Iterate checkpoints adding up stakes.\n\t * @param account The address of the account to get the balance of.\n\t * @return The number of tokens held.\n\t * */\n\tfunction balanceOf(address account) public view returns (uint96 balance) {\n\t\tfor (uint256 i = kickoffTS; i <= block.timestamp + MAX_DURATION; i += TWO_WEEKS) {\n\t\t\tbalance = add96(balance, currentBalance(account, i), \"Staking::balanceOf: overflow\");\n\t\t}\n\t}\n\n\t/**\n\t * @notice Delegate votes from `msg.sender` which are locked until lockDate to `delegatee`.\n\t * @param delegatee The address to delegate votes to.\n\t * @param lockDate the date if the position to delegate.\n\t * */\n\tfunction delegate(address delegatee, uint256 lockDate) public {\n\t\treturn _delegate(msg.sender, delegatee, lockDate);\n\t}\n\n\t/**\n\t * @notice Delegates votes from signatory to a delegatee account.\n\t * Voting with EIP-712 Signatures.\n\t *\n\t * Voting power can be delegated to any address, and then can be used to\n\t * vote on proposals. A key benefit to users of by-signature functionality\n\t * is that they can create a signed vote transaction for free, and have a\n\t * trusted third-party spend rBTC(or ETH) on gas fees and write it to the\n\t * blockchain for them.\n\t *\n\t * The third party in this scenario, submitting the SOV-holder’s signed\n\t * transaction holds a voting power that is for only a single proposal.\n\t * The signatory still holds the power to vote on their own behalf in\n\t * the proposal if the third party has not yet published the signed\n\t * transaction that was given to them.\n\t *\n\t * @dev The signature needs to be broken up into 3 parameters, known as\n\t * v, r and s:\n\t * const r = '0x' + sig.substring(2).substring(0, 64);\n\t * const s = '0x' + sig.substring(2).substring(64, 128);\n\t * const v = '0x' + sig.substring(2).substring(128, 130);\n\t *\n\t * @param delegatee The address to delegate votes to.\n\t * @param lockDate The date until which the position is locked.\n\t * @param nonce The contract state required to match the signature.\n\t * @param expiry The time at which to expire the signature.\n\t * @param v The recovery byte of the signature.\n\t * @param r Half of the ECDSA signature pair.\n\t * @param s Half of the ECDSA signature pair.\n\t * */\n\tfunction delegateBySig(\n\t\taddress delegatee,\n\t\tuint256 lockDate,\n\t\tuint256 nonce,\n\t\tuint256 expiry,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public {\n\t\t/**\n\t\t * @dev The DOMAIN_SEPARATOR is a hash that uniquely identifies a\n\t\t * smart contract. It is built from a string denoting it as an\n\t\t * EIP712 Domain, the name of the token contract, the version,\n\t\t * the chainId in case it changes, and the address that the\n\t\t * contract is deployed at.\n\t\t * */\n\t\tbytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n\n\t\t/// @dev GovernorAlpha uses BALLOT_TYPEHASH, while Staking uses DELEGATION_TYPEHASH\n\t\tbytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, lockDate, nonce, expiry));\n\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n\t\taddress signatory = ecrecover(digest, v, r, s);\n\n\t\t/// @dev Verify address is not null and PK is not null either.\n\t\trequire(RSKAddrValidator.checkPKNotZero(signatory), \"Staking::delegateBySig: invalid signature\");\n\t\trequire(nonce == nonces[signatory]++, \"Staking::delegateBySig: invalid nonce\");\n\t\trequire(now <= expiry, \"Staking::delegateBySig: signature expired\");\n\t\treturn _delegate(signatory, delegatee, lockDate);\n\t}\n\n\t/**\n\t * @notice Get the current votes balance for a user account.\n\t * @param account The address to get votes balance.\n\t * @dev This is a wrapper to simplify arguments. The actual computation is\n\t * performed on WeightedStaking parent contract.\n\t * @return The number of current votes for a user account.\n\t * */\n\tfunction getCurrentVotes(address account) external view returns (uint96) {\n\t\treturn getPriorVotes(account, block.number - 1, block.timestamp);\n\t}\n\n\t/**\n\t * @notice Get the current number of tokens staked for a day.\n\t * @param lockedTS The timestamp to get the staked tokens for.\n\t * */\n\tfunction getCurrentStakedUntil(uint256 lockedTS) external view returns (uint96) {\n\t\tuint32 nCheckpoints = numTotalStakingCheckpoints[lockedTS];\n\t\treturn nCheckpoints > 0 ? totalStakingCheckpoints[lockedTS][nCheckpoints - 1].stake : 0;\n\t}\n\n\t/**\n\t * @notice Set new delegatee. Move from user's current delegate to a new\n\t * delegatee the stake balance.\n\t * @param delegator The user address to move stake balance from its current delegatee.\n\t * @param delegatee The new delegatee. The address to move stake balance to.\n\t * @param lockedTS The lock date.\n\t * */\n\tfunction _delegate(\n\t\taddress delegator,\n\t\taddress delegatee,\n\t\tuint256 lockedTS\n\t) internal {\n\t\taddress currentDelegate = delegates[delegator][lockedTS];\n\t\tuint96 delegatorBalance = currentBalance(delegator, lockedTS);\n\t\tdelegates[delegator][lockedTS] = delegatee;\n\n\t\temit DelegateChanged(delegator, lockedTS, currentDelegate, delegatee);\n\n\t\t_moveDelegates(currentDelegate, delegatee, delegatorBalance, lockedTS);\n\t}\n\n\t/**\n\t * @notice Move an amount of delegate stake from a source address to a\n\t * destination address.\n\t * @param srcRep The address to get the staked amount from.\n\t * @param dstRep The address to send the staked amount to.\n\t * @param amount The staked amount to move.\n\t * @param lockedTS The lock date.\n\t * */\n\tfunction _moveDelegates(\n\t\taddress srcRep,\n\t\taddress dstRep,\n\t\tuint96 amount,\n\t\tuint256 lockedTS\n\t) internal {\n\t\tif (srcRep != dstRep && amount > 0) {\n\t\t\tif (srcRep != address(0)) _decreaseDelegateStake(srcRep, lockedTS, amount);\n\n\t\t\tif (dstRep != address(0)) _increaseDelegateStake(dstRep, lockedTS, amount);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Retrieve CHAIN_ID of the executing chain.\n\t *\n\t * Chain identifier (chainID) introduced in EIP-155 protects transaction\n\t * included into one chain from being included into another chain.\n\t * Basically, chain identifier is an integer number being used in the\n\t * processes of signing transactions and verifying transaction signatures.\n\t *\n\t * @dev As of version 0.5.12, Solidity includes an assembly function\n\t * chainid() that provides access to the new CHAINID opcode.\n\t *\n\t * TODO: chainId is included in block. So you can get chain id like\n\t * block timestamp or block number: block.chainid;\n\t * */\n\tfunction getChainId() internal pure returns (uint256) {\n\t\tuint256 chainId;\n\t\tassembly {\n\t\t\tchainId := chainid()\n\t\t}\n\t\treturn chainId;\n\t}\n\n\t/**\n\t * @notice Allow the owner to set a new staking contract.\n\t * As a consequence it allows the stakers to migrate their positions\n\t * to the new contract.\n\t * @dev Doesn't have any influence as long as migrateToNewStakingContract\n\t * is not implemented.\n\t * @param _newStakingContract The address of the new staking contract.\n\t * */\n\tfunction setNewStakingContract(address _newStakingContract) public onlyOwner {\n\t\trequire(_newStakingContract != address(0), \"can't reset the new staking contract to 0\");\n\t\tnewStakingContract = _newStakingContract;\n\t}\n\n\t/**\n\t * @notice Allow the owner to set a fee sharing proxy contract.\n\t * We need it for unstaking with slashing.\n\t * @param _feeSharing The address of FeeSharingProxy contract.\n\t * */\n\tfunction setFeeSharing(address _feeSharing) public onlyOwner {\n\t\trequire(_feeSharing != address(0), \"FeeSharing address shouldn't be 0\");\n\t\tfeeSharing = IFeeSharingProxy(_feeSharing);\n\t}\n\n\t/**\n\t * @notice Allow the owner to set weight scaling.\n\t * We need it for unstaking with slashing.\n\t * @param _weightScaling The weight scaling.\n\t * */\n\tfunction setWeightScaling(uint96 _weightScaling) public onlyOwner {\n\t\trequire(\n\t\t\tMIN_WEIGHT_SCALING <= _weightScaling && _weightScaling <= MAX_WEIGHT_SCALING,\n\t\t\t\"weight scaling doesn't belong to range [1, 9]\"\n\t\t);\n\t\tweightScaling = _weightScaling;\n\t}\n\n\t/**\n\t * @notice Allow a staker to migrate his positions to the new staking contract.\n\t * @dev Staking contract needs to be set before by the owner.\n\t * Currently not implemented, just needed for the interface.\n\t *      In case it's needed at some point in the future,\n\t *      the implementation needs to be changed first.\n\t * */\n\tfunction migrateToNewStakingContract() public {\n\t\trequire(newStakingContract != address(0), \"there is no new staking contract set\");\n\t\t/// @dev implementation:\n\t\t/// @dev Iterate over all possible lock dates from now until now + MAX_DURATION.\n\t\t/// @dev Read the stake & delegate of the msg.sender\n\t\t/// @dev If stake > 0, stake it at the new contract until the lock date with the current delegate.\n\t}\n\n\t/**\n\t * @notice Allow the owner to unlock all tokens in case the staking contract\n\t * is going to be replaced\n\t * Note: Not reversible on purpose. once unlocked, everything is unlocked.\n\t * The owner should not be able to just quickly unlock to withdraw his own\n\t * tokens and lock again.\n\t * @dev Last resort.\n\t * */\n\tfunction unlockAllTokens() public onlyOwner {\n\t\tallUnlocked = true;\n\t\temit TokensUnlocked(SOVToken.balanceOf(address(this)));\n\t}\n\n\t/**\n\t * @notice Get list of stakes for a user account.\n\t * @param account The address to get stakes.\n\t * @return The arrays of dates and stakes.\n\t * */\n\tfunction getStakes(address account) external view returns (uint256[] memory dates, uint96[] memory stakes) {\n\t\tuint256 latest = timestampToLockDate(block.timestamp + MAX_DURATION);\n\n\t\t/// @dev Calculate stakes.\n\t\tuint256 count = 0;\n\t\t/// @dev We need to iterate from first possible stake date after deployment to the latest from current time.\n\t\tfor (uint256 i = kickoffTS + TWO_WEEKS; i <= latest; i += TWO_WEEKS) {\n\t\t\tif (currentBalance(account, i) > 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tdates = new uint256[](count);\n\t\tstakes = new uint96[](count);\n\n\t\t/// @dev We need to iterate from first possible stake date after deployment to the latest from current time.\n\t\tuint256 j = 0;\n\t\tfor (uint256 i = kickoffTS + TWO_WEEKS; i <= latest; i += TWO_WEEKS) {\n\t\t\tuint96 balance = currentBalance(account, i);\n\t\t\tif (balance > 0) {\n\t\t\t\tdates[j] = i;\n\t\t\t\tstakes[j] = balance;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Overrides default ApprovalReceiver._getToken function to\n\t * register SOV token on this contract.\n\t * @return The address of SOV token.\n\t * */\n\tfunction _getToken() internal view returns (address) {\n\t\treturn address(SOVToken);\n\t}\n\n\t/**\n\t * @notice Overrides default ApprovalReceiver._getSelectors function to\n\t * register stakeWithApproval selector on this contract.\n\t * @return The array of registered selectors on this contract.\n\t * */\n\tfunction _getSelectors() internal view returns (bytes4[] memory) {\n\t\tbytes4[] memory selectors = new bytes4[](1);\n\t\tselectors[0] = this.stakeWithApproval.selector;\n\t\treturn selectors;\n\t}\n}\n\n// File: contracts/governance/Vesting/VestingStorage.sol\n\npragma solidity ^0.5.17;\n\n\n\n\n\n/**\n * @title Vesting Storage Contract.\n *\n * @notice This contract is just the storage required for vesting.\n * It is parent of VestingLogic and TeamVesting.\n *\n * @dev Use Ownable as a parent to align storage structure for Logic and Proxy contracts.\n * */\ncontract VestingStorage is Ownable {\n\t/// @notice The SOV token contract.\n\tIERC20 public SOV;\n\n\t/// @notice The staking contract address.\n\tStaking public staking;\n\n\t/// @notice The owner of the vested tokens.\n\taddress public tokenOwner;\n\n\t/// @notice Fee sharing Proxy.\n\tIFeeSharingProxy public feeSharingProxy;\n\n\t/// @notice The cliff. After this time period the tokens begin to unlock.\n\tuint256 public cliff;\n\n\t/// @notice The duration. After this period all tokens will have been unlocked.\n\tuint256 public duration;\n\n\t/// @notice The start date of the vesting.\n\tuint256 public startDate;\n\n\t/// @notice The end date of the vesting.\n\tuint256 public endDate;\n\n\t/// @notice Constant used for computing the vesting dates.\n\tuint256 constant FOUR_WEEKS = 4 weeks;\n}\n\n// File: contracts/governance/Vesting/VestingLogic.sol\n\npragma solidity ^0.5.17;\n\n/**\n * @title Vesting Logic contract.\n * @notice Staking, delegating and withdrawal functionality.\n * @dev Deployed by a VestingFactory contract.\n * */\ncontract VestingLogic is IVesting, VestingStorage, ApprovalReceiver {\n\t/* Events */\n\n\tevent TokensStaked(address indexed caller, uint256 amount);\n\tevent VotesDelegated(address indexed caller, address delegatee);\n\tevent TokensWithdrawn(address indexed caller, address receiver);\n\tevent DividendsCollected(address indexed caller, address loanPoolToken, address receiver, uint32 maxCheckpoints);\n\tevent MigratedToNewStakingContract(address indexed caller, address newStakingContract);\n\n\t/* Modifiers */\n\n\t/**\n\t * @dev Throws if called by any account other than the token owner or the contract owner.\n\t */\n\tmodifier onlyOwners() {\n\t\trequire(msg.sender == tokenOwner || isOwner(), \"unauthorized\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the token owner.\n\t */\n\tmodifier onlyTokenOwner() {\n\t\trequire(msg.sender == tokenOwner, \"unauthorized\");\n\t\t_;\n\t}\n\n\t/* Functions */\n\n\t/**\n\t * @notice Stakes tokens according to the vesting schedule.\n\t * @param _amount The amount of tokens to stake.\n\t * */\n\tfunction stakeTokens(uint256 _amount) public {\n\t\t_stakeTokens(msg.sender, _amount);\n\t}\n\n\t/**\n\t * @notice Stakes tokens according to the vesting schedule.\n\t * @dev This function will be invoked from receiveApproval.\n\t * @dev SOV.approveAndCall -> this.receiveApproval -> this.stakeTokensWithApproval\n\t * @param _sender The sender of SOV.approveAndCall\n\t * @param _amount The amount of tokens to stake.\n\t * */\n\tfunction stakeTokensWithApproval(address _sender, uint256 _amount) public onlyThisContract {\n\t\t_stakeTokens(_sender, _amount);\n\t}\n\n\t/**\n\t * @notice Stakes tokens according to the vesting schedule. Low level function.\n\t * @dev Once here the allowance of tokens is taken for granted.\n\t * @param _sender The sender of tokens to stake.\n\t * @param _amount The amount of tokens to stake.\n\t * */\n\tfunction _stakeTokens(address _sender, uint256 _amount) internal {\n\t\t/// @dev Maybe better to allow staking unil the cliff was reached.\n\t\tif (startDate == 0) {\n\t\t\tstartDate = staking.timestampToLockDate(block.timestamp);\n\t\t}\n\t\tendDate = staking.timestampToLockDate(block.timestamp + duration);\n\n\t\t/// @dev Transfer the tokens to this contract.\n\t\tbool success = SOV.transferFrom(_sender, address(this), _amount);\n\t\trequire(success);\n\n\t\t/// @dev Allow the staking contract to access them.\n\t\tSOV.approve(address(staking), _amount);\n\n\t\tstaking.stakesBySchedule(_amount, cliff, duration, FOUR_WEEKS, address(this), tokenOwner);\n\n\t\temit TokensStaked(_sender, _amount);\n\t}\n\n\t/**\n\t * @notice Delegate votes from `msg.sender` which are locked until lockDate\n\t * to `delegatee`.\n\t * @param _delegatee The address to delegate votes to.\n\t * */\n\tfunction delegate(address _delegatee) public onlyTokenOwner {\n\t\trequire(_delegatee != address(0), \"delegatee address invalid\");\n\n\t\t/// @dev Withdraw for each unlocked position.\n\t\tfor (uint256 i = startDate + cliff; i <= endDate; i += FOUR_WEEKS) {\n\t\t\tstaking.delegate(_delegatee, i);\n\t\t}\n\t\temit VotesDelegated(msg.sender, _delegatee);\n\t}\n\n\t/**\n\t * @notice Withdraws all tokens from the staking contract and\n\t * forwards them to an address specified by the token owner.\n\t * @param receiver The receiving address.\n\t * @dev Can be called only by owner.\n\t * */\n\tfunction governanceWithdrawTokens(address receiver) public {\n\t\trequire(msg.sender == address(staking), \"unauthorized\");\n\n\t\t_withdrawTokens(receiver, true);\n\t}\n\n\t/**\n\t * @notice Withdraws unlocked tokens from the staking contract and\n\t * forwards them to an address specified by the token owner.\n\t * @param receiver The receiving address.\n\t * */\n\tfunction withdrawTokens(address receiver) public onlyOwners {\n\t\t_withdrawTokens(receiver, false);\n\t}\n\n\t/**\n\t * @notice Withdraws tokens from the staking contract and forwards them\n\t * to an address specified by the token owner. Low level function.\n\t * @dev Once here the caller permission is taken for granted.\n\t * @param receiver The receiving address.\n\t * @param isGovernance Whether all tokens (true)\n\t * or just unlocked tokens (false).\n\t * */\n\tfunction _withdrawTokens(address receiver, bool isGovernance) internal {\n\t\trequire(receiver != address(0), \"receiver address invalid\");\n\n\t\tuint96 stake;\n\n\t\t/// @dev Usually we just need to iterate over the possible dates until now.\n\t\tuint256 end;\n\n\t\t/// @dev In the unlikely case that all tokens have been unlocked early,\n\t\t///   allow to withdraw all of them.\n\t\tif (staking.allUnlocked() || isGovernance) {\n\t\t\tend = endDate;\n\t\t} else {\n\t\t\tend = block.timestamp;\n\t\t}\n\n\t\t/// @dev Withdraw for each unlocked position.\n\t\tfor (uint256 i = startDate + cliff; i <= end; i += FOUR_WEEKS) {\n\t\t\t/// @dev Read amount to withdraw.\n\t\t\tstake = staking.getPriorUserStakeByDate(address(this), i, block.number - 1);\n\n\t\t\t/// @dev Withdraw if > 0\n\t\t\tif (stake > 0) {\n\t\t\t\tif (isGovernance) {\n\t\t\t\t\tstaking.governanceWithdraw(stake, i, receiver);\n\t\t\t\t} else {\n\t\t\t\t\tstaking.withdraw(stake, i, receiver);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\temit TokensWithdrawn(msg.sender, receiver);\n\t}\n\n\t/**\n\t * @notice Collect dividends from fee sharing proxy.\n\t * @param _loanPoolToken The loan pool token address.\n\t * @param _maxCheckpoints Maximum number of checkpoints to be processed.\n\t * @param _receiver The receiver of tokens or msg.sender\n\t * */\n\tfunction collectDividends(\n\t\taddress _loanPoolToken,\n\t\tuint32 _maxCheckpoints,\n\t\taddress _receiver\n\t) public onlyOwners {\n\t\trequire(_receiver != address(0), \"receiver address invalid\");\n\n\t\t/// @dev Invokes the fee sharing proxy.\n\t\tfeeSharingProxy.withdraw(_loanPoolToken, _maxCheckpoints, _receiver);\n\n\t\temit DividendsCollected(msg.sender, _loanPoolToken, _receiver, _maxCheckpoints);\n\t}\n\n\t/**\n\t * @notice Allows the owners to migrate the positions\n\t * to a new staking contract.\n\t * */\n\tfunction migrateToNewStakingContract() public onlyOwners {\n\t\tstaking.migrateToNewStakingContract();\n\t\tstaking = Staking(staking.newStakingContract());\n\t\temit MigratedToNewStakingContract(msg.sender, address(staking));\n\t}\n\n\t/**\n\t * @notice Overrides default ApprovalReceiver._getToken function to\n\t * register SOV token on this contract.\n\t * @return The address of SOV token.\n\t * */\n\tfunction _getToken() internal view returns (address) {\n\t\treturn address(SOV);\n\t}\n\n\t/**\n\t * @notice Overrides default ApprovalReceiver._getSelectors function to\n\t * register stakeTokensWithApproval selector on this contract.\n\t * @return The array of registered selectors on this contract.\n\t * */\n\tfunction _getSelectors() internal view returns (bytes4[] memory) {\n\t\tbytes4[] memory selectors = new bytes4[](1);\n\t\tselectors[0] = this.stakeTokensWithApproval.selector;\n\t\treturn selectors;\n\t}\n}\n\n// File: contracts/locked/ILockedSOV.sol\n\npragma solidity ^0.5.17;\n\n/**\n *  @title The Locked SOV Interface.\n *  @author Franklin Richards - powerhousefrank@protonmail.com\n *  @notice This interface is an incomplete yet useful for future migration of LockedSOV Contract.\n *  @dev Only use it if you know what you are doing.\n */\ninterface ILockedSOV {\n\t/**\n\t * @notice Adds SOV to the user balance (Locked and Unlocked Balance based on `_basisPoint`).\n\t * @param _userAddress The user whose locked balance has to be updated with `_sovAmount`.\n\t * @param _sovAmount The amount of SOV to be added to the locked and/or unlocked balance.\n\t * @param _basisPoint The % (in Basis Point)which determines how much will be unlocked immediately.\n\t */\n\tfunction deposit(\n\t\taddress _userAddress,\n\t\tuint256 _sovAmount,\n\t\tuint256 _basisPoint\n\t) external;\n\n\t/**\n\t * @notice Adds SOV to the locked balance of a user.\n\t * @param _userAddress The user whose locked balance has to be updated with _sovAmount.\n\t * @param _sovAmount The amount of SOV to be added to the locked balance.\n\t */\n\tfunction depositSOV(address _userAddress, uint256 _sovAmount) external;\n\n\t/**\n\t * @notice Withdraws unlocked tokens and Stakes Locked tokens for a user who already have a vesting created.\n\t * @param _userAddress The address of user tokens will be withdrawn.\n\t */\n\tfunction withdrawAndStakeTokensFrom(address _userAddress) external;\n}\n\n// File: contracts/locked/LockedSOV.sol\n\npragma solidity ^0.5.17;\n\n\n\n\n\n\n/**\n *  @title The Locked SOV Contract.\n *  @author Franklin Richards - powerhousefrank@protonmail.com\n *  @notice This contract is used to receive reward from other contracts, Create Vesting and Stake Tokens.\n */\ncontract LockedSOV is ILockedSOV {\n\tusing SafeMath for uint256;\n\n\t/* Storage */\n\n\t/// @notice True if the migration to a new Locked SOV Contract has started.\n\tbool public migration;\n\n\t/// @notice The cliff is the time period after which the tokens begin to unlock.\n\tuint256 public cliff;\n\t/// @notice The duration is the time period after all tokens will have been unlocked.\n\tuint256 public duration;\n\n\t/// @notice The SOV token contract.\n\tIERC20 public SOV;\n\t/// @notice The Vesting registry contract.\n\tVestingRegistry public vestingRegistry;\n\t/// @notice The New (Future) Locked SOV.\n\tILockedSOV public newLockedSOV;\n\n\t/// @notice The locked user balances.\n\tmapping(address => uint256) private lockedBalances;\n\t/// @notice The unlocked user balances.\n\tmapping(address => uint256) private unlockedBalances;\n\t/// @notice The contracts/wallets with admin power.\n\tmapping(address => bool) private isAdmin;\n\n\t/* Events */\n\n\t/// @notice Emitted when a new Admin is added to the admin list.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _newAdmin The address of the new admin.\n\tevent AdminAdded(address indexed _initiator, address indexed _newAdmin);\n\n\t/// @notice Emitted when an admin is removed from the admin list.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _removedAdmin The address of the removed admin.\n\tevent AdminRemoved(address indexed _initiator, address indexed _removedAdmin);\n\n\t/// @notice Emitted when Vesting Registry, Duration and/or Cliff is updated.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _vestingRegistry The Vesting Registry Contract.\n\t/// @param _cliff The time period after which the tokens begin to unlock.\n\t/// @param _duration The time period after all tokens will have been unlocked.\n\tevent RegistryCliffAndDurationUpdated(address indexed _initiator, address indexed _vestingRegistry, uint256 _cliff, uint256 _duration);\n\n\t/// @notice Emitted when a new deposit is made.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _userAddress The user to whose un/locked balance a new deposit was made.\n\t/// @param _sovAmount The amount of SOV to be added to the un/locked balance.\n\t/// @param _basisPoint The % (in Basis Point) which determines how much will be unlocked immediately.\n\tevent Deposited(address indexed _initiator, address indexed _userAddress, uint256 _sovAmount, uint256 _basisPoint);\n\n\t/// @notice Emitted when a user withdraws the fund.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _userAddress The user whose unlocked balance has to be withdrawn.\n\t/// @param _sovAmount The amount of SOV withdrawn from the unlocked balance.\n\tevent Withdrawn(address indexed _initiator, address indexed _userAddress, uint256 _sovAmount);\n\n\t/// @notice Emitted when a user creates a vesting for himself.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _userAddress The user whose unlocked balance has to be withdrawn.\n\t/// @param _vesting The Vesting Contract.\n\tevent VestingCreated(address indexed _initiator, address indexed _userAddress, address indexed _vesting);\n\n\t/// @notice Emitted when a user stakes tokens.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _vesting The Vesting Contract.\n\t/// @param _amount The amount of locked tokens staked by the user.\n\tevent TokenStaked(address indexed _initiator, address indexed _vesting, uint256 _amount);\n\n\t/// @notice Emitted when an admin initiates a migration to new Locked SOV Contract.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _newLockedSOV The address of the new Locked SOV Contract.\n\tevent MigrationStarted(address indexed _initiator, address indexed _newLockedSOV);\n\n\t/// @notice Emitted when a user initiates the transfer to a new Locked SOV Contract.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _amount The amount of locked tokens to transfer from this contract to the new one.\n\tevent UserTransfered(address indexed _initiator, uint256 _amount);\n\n\t/* Modifiers */\n\n\tmodifier onlyAdmin {\n\t\trequire(isAdmin[msg.sender], \"Only admin can call this.\");\n\t\t_;\n\t}\n\n\tmodifier migrationAllowed {\n\t\trequire(migration, \"Migration has not yet started.\");\n\t\t_;\n\t}\n\n\t/* Constructor */\n\n\t/**\n\t * @notice Setup the required parameters.\n\t * @param _SOV The SOV Token Address.\n\t * @param _vestingRegistry The Vesting Registry Address.\n\t * @param _cliff The time period after which the tokens begin to unlock.\n\t * @param _duration The time period after all tokens will have been unlocked.\n\t * @param _admins The list of Admins to be added.\n\t */\n\tconstructor(\n\t\taddress _SOV,\n\t\taddress _vestingRegistry,\n\t\tuint256 _cliff,\n\t\tuint256 _duration,\n\t\taddress[] memory _admins\n\t) public {\n\t\trequire(_SOV != address(0), \"Invalid SOV Address.\");\n\t\trequire(_vestingRegistry != address(0), \"Vesting registry address is invalid.\");\n\t\trequire(_duration < 37, \"Duration is too long.\");\n\n\t\tSOV = IERC20(_SOV);\n\t\tvestingRegistry = VestingRegistry(_vestingRegistry);\n\t\tcliff = _cliff * 4 weeks;\n\t\tduration = _duration * 4 weeks;\n\n\t\tfor (uint256 index = 0; index < _admins.length; index++) {\n\t\t\tisAdmin[_admins[index]] = true;\n\t\t}\n\t}\n\n\t/* Public or External Functions */\n\n\t/**\n\t * @notice The function to add a new admin.\n\t * @param _newAdmin The address of the new admin.\n\t * @dev Only callable by an Admin.\n\t */\n\tfunction addAdmin(address _newAdmin) public onlyAdmin {\n\t\trequire(_newAdmin != address(0), \"Invalid Address.\");\n\t\trequire(!isAdmin[_newAdmin], \"Address is already admin.\");\n\t\tisAdmin[_newAdmin] = true;\n\n\t\temit AdminAdded(msg.sender, _newAdmin);\n\t}\n\n\t/**\n\t * @notice The function to remove an admin.\n\t * @param _adminToRemove The address of the admin which should be removed.\n\t * @dev Only callable by an Admin.\n\t */\n\tfunction removeAdmin(address _adminToRemove) public onlyAdmin {\n\t\trequire(isAdmin[_adminToRemove], \"Address is not an admin.\");\n\t\tisAdmin[_adminToRemove] = false;\n\n\t\temit AdminRemoved(msg.sender, _adminToRemove);\n\t}\n\n\t/**\n\t * @notice The function to update the Vesting Registry, Duration and Cliff.\n\t * @param _vestingRegistry The Vesting Registry Address.\n\t * @param _cliff The time period after which the tokens begin to unlock.\n\t * @param _duration The time period after all tokens will have been unlocked.\n\t * @dev IMPORTANT 1: You have to change Vesting Registry if you want to change Duration and/or Cliff.\n\t * IMPORTANT 2: `_cliff` and `_duration` is multiplied by 4 weeks in this function.\n\t */\n\tfunction changeRegistryCliffAndDuration(\n\t\taddress _vestingRegistry,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) external onlyAdmin {\n\t\trequire(address(vestingRegistry) != _vestingRegistry, \"Vesting Registry has to be different for changing duration and cliff.\");\n\t\t/// If duration is also zero, then it is similar to Unlocked SOV.\n\t\trequire(_duration != 0, \"Duration cannot be zero.\");\n\t\trequire(_duration < 37, \"Duration is too long.\");\n\n\t\tvestingRegistry = VestingRegistry(_vestingRegistry);\n\n\t\tcliff = _cliff * 4 weeks;\n\t\tduration = _duration * 4 weeks;\n\n\t\temit RegistryCliffAndDurationUpdated(msg.sender, _vestingRegistry, _cliff, _duration);\n\t}\n\n\t/**\n\t * @notice Adds SOV to the user balance (Locked and Unlocked Balance based on `_basisPoint`).\n\t * @param _userAddress The user whose locked balance has to be updated with `_sovAmount`.\n\t * @param _sovAmount The amount of SOV to be added to the locked and/or unlocked balance.\n\t * @param _basisPoint The % (in Basis Point)which determines how much will be unlocked immediately.\n\t */\n\tfunction deposit(\n\t\taddress _userAddress,\n\t\tuint256 _sovAmount,\n\t\tuint256 _basisPoint\n\t) external {\n\t\t_deposit(_userAddress, _sovAmount, _basisPoint);\n\t}\n\n\t/**\n\t * @notice Adds SOV to the locked balance of a user.\n\t * @param _userAddress The user whose locked balance has to be updated with _sovAmount.\n\t * @param _sovAmount The amount of SOV to be added to the locked balance.\n\t * @dev This is here because there are dependency with other contracts.\n\t */\n\tfunction depositSOV(address _userAddress, uint256 _sovAmount) external {\n\t\t_deposit(_userAddress, _sovAmount, 0);\n\t}\n\n\tfunction _deposit(\n\t\taddress _userAddress,\n\t\tuint256 _sovAmount,\n\t\tuint256 _basisPoint\n\t) private {\n\t\t// 10000 is not included because if 100% is unlocked, then LockedSOV is not required to be used.\n\t\trequire(_basisPoint < 10000, \"Basis Point has to be less than 10000.\");\n\t\tbool txStatus = SOV.transferFrom(msg.sender, address(this), _sovAmount);\n\t\trequire(txStatus, \"Token transfer was not successful. Check receiver address.\");\n\n\t\tuint256 unlockedBal = _sovAmount.mul(_basisPoint).div(10000);\n\n\t\tunlockedBalances[_userAddress] = unlockedBalances[_userAddress].add(unlockedBal);\n\t\tlockedBalances[_userAddress] = lockedBalances[_userAddress].add(_sovAmount).sub(unlockedBal);\n\n\t\temit Deposited(msg.sender, _userAddress, _sovAmount, _basisPoint);\n\t}\n\n\t/**\n\t * @notice A function to withdraw the unlocked balance.\n\t * @param _receiverAddress If specified, the unlocked balance will go to this address, else to msg.sender.\n\t */\n\tfunction withdraw(address _receiverAddress) public {\n\t\t_withdraw(msg.sender, _receiverAddress);\n\t}\n\n\tfunction _withdraw(address _sender, address _receiverAddress) private {\n\t\taddress userAddr = _receiverAddress;\n\t\tif (_receiverAddress == address(0)) {\n\t\t\tuserAddr = _sender;\n\t\t}\n\n\t\tuint256 amount = unlockedBalances[_sender];\n\t\tunlockedBalances[_sender] = 0;\n\n\t\tbool txStatus = SOV.transfer(userAddr, amount);\n\t\trequire(txStatus, \"Token transfer was not successful. Check receiver address.\");\n\n\t\temit Withdrawn(_sender, userAddr, amount);\n\t}\n\n\t/**\n\t * @notice Creates vesting if not already created and Stakes tokens for a user.\n\t * @dev Only use this function if the `duration` is small.\n\t */\n\tfunction createVestingAndStake() public {\n\t\t_createVestingAndStake(msg.sender);\n\t}\n\n\tfunction _createVestingAndStake(address _sender) private {\n\t\taddress vestingAddr = _getVesting(_sender);\n\n\t\tif (vestingAddr == address(0)) {\n\t\t\tvestingAddr = _createVesting(_sender);\n\t\t}\n\n\t\t_stakeTokens(_sender, vestingAddr);\n\t}\n\n\t/**\n\t * @notice Creates vesting contract (if it hasn't been created yet) for the calling user.\n\t * @return _vestingAddress The New Vesting Contract Created.\n\t */\n\tfunction createVesting() public returns (address _vestingAddress) {\n\t\t_vestingAddress = _createVesting(msg.sender);\n\t}\n\n\t/**\n\t * @notice Stakes tokens for a user who already have a vesting created.\n\t * @dev The user should already have a vesting created, else this function will throw error.\n\t */\n\tfunction stakeTokens() public {\n\t\tVestingLogic vesting = VestingLogic(_getVesting(msg.sender));\n\n\t\trequire(cliff == vesting.cliff() && duration == vesting.duration(), \"Wrong Vesting Schedule.\");\n\n\t\t_stakeTokens(msg.sender, address(vesting));\n\t}\n\n\t/**\n\t * @notice Withdraws unlocked tokens and Stakes Locked tokens for a user who already have a vesting created.\n\t * @param _receiverAddress If specified, the unlocked balance will go to this address, else to msg.sender.\n\t */\n\tfunction withdrawAndStakeTokens(address _receiverAddress) external {\n\t\t_withdraw(msg.sender, _receiverAddress);\n\t\t_createVestingAndStake(msg.sender);\n\t}\n\n\t/**\n\t * @notice Withdraws unlocked tokens and Stakes Locked tokens for a user who already have a vesting created.\n\t * @param _userAddress The address of user tokens will be withdrawn.\n\t */\n\tfunction withdrawAndStakeTokensFrom(address _userAddress) external {\n\t\t_withdraw(_userAddress, _userAddress);\n\t\t_createVestingAndStake(_userAddress);\n\t}\n\n\t/**\n\t * @notice Function to start the process of migration to new contract.\n\t * @param _newLockedSOV The new locked sov contract address.\n\t */\n\tfunction startMigration(address _newLockedSOV) external onlyAdmin {\n\t\trequire(_newLockedSOV != address(0), \"New Locked SOV Address is Invalid.\");\n\t\tnewLockedSOV = ILockedSOV(_newLockedSOV);\n\t\tSOV.approve(_newLockedSOV, SOV.balanceOf(address(this)));\n\t\tmigration = true;\n\n\t\temit MigrationStarted(msg.sender, _newLockedSOV);\n\t}\n\n\t/**\n\t * @notice Function to transfer the locked balance from this contract to new LockedSOV Contract.\n\t * @dev Address is not specified to discourage selling lockedSOV to other address.\n\t */\n\tfunction transfer() external migrationAllowed {\n\t\tuint256 amount = lockedBalances[msg.sender];\n\t\tlockedBalances[msg.sender] = 0;\n\n\t\tnewLockedSOV.depositSOV(msg.sender, amount);\n\n\t\temit UserTransfered(msg.sender, amount);\n\t}\n\n\t/* Internal Functions */\n\n\t/**\n\t * @notice Creates a Vesting Contract for a user.\n\t * @param _tokenOwner The owner of the vesting contract.\n\t * @return _vestingAddress The Vesting Contract Address.\n\t * @dev Does not do anything if Vesting Contract was already created.\n\t */\n\tfunction _createVesting(address _tokenOwner) internal returns (address _vestingAddress) {\n\t\t/// Here zero is given in place of amount, as amount is not really used in `vestingRegistry.createVesting()`.\n\t\tvestingRegistry.createVesting(_tokenOwner, 0, cliff, duration);\n\t\t_vestingAddress = _getVesting(_tokenOwner);\n\t\temit VestingCreated(msg.sender, _tokenOwner, _vestingAddress);\n\t}\n\n\t/**\n\t * @notice Returns the Vesting Contract Address.\n\t * @param _tokenOwner The owner of the vesting contract.\n\t * @return _vestingAddress The Vesting Contract Address.\n\t */\n\tfunction _getVesting(address _tokenOwner) internal view returns (address _vestingAddress) {\n\t\treturn vestingRegistry.getVesting(_tokenOwner);\n\t}\n\n\t/**\n\t * @notice Stakes the tokens in a particular vesting contract.\n\t * @param _vesting The Vesting Contract Address.\n\t */\n\tfunction _stakeTokens(address _sender, address _vesting) internal {\n\t\tuint256 amount = lockedBalances[_sender];\n\t\tlockedBalances[_sender] = 0;\n\n\t\tSOV.approve(_vesting, amount);\n\t\tVestingLogic(_vesting).stakeTokens(amount);\n\n\t\temit TokenStaked(_sender, _vesting, amount);\n\t}\n\n\t/* Getter or Read Functions */\n\n\t/**\n\t * @notice The function to get the locked balance of a user.\n\t * @param _addr The address of the user to check the locked balance.\n\t * @return _balance The locked balance of the address `_addr`.\n\t */\n\tfunction getLockedBalance(address _addr) external view returns (uint256 _balance) {\n\t\treturn lockedBalances[_addr];\n\t}\n\n\t/**\n\t * @notice The function to get the unlocked balance of a user.\n\t * @param _addr The address of the user to check the unlocked balance.\n\t * @return _balance The unlocked balance of the address `_addr`.\n\t */\n\tfunction getUnlockedBalance(address _addr) external view returns (uint256 _balance) {\n\t\treturn unlockedBalances[_addr];\n\t}\n\n\t/**\n\t * @notice The function to check is an address is admin or not.\n\t * @param _addr The address of the user to check the admin status.\n\t * @return _status True if admin, False otherwise.\n\t */\n\tfunction adminStatus(address _addr) external view returns (bool _status) {\n\t\treturn isAdmin[_addr];\n\t}\n}\n",
            "file": "LockedSOVFlattened.sol"
        }
    ],
    "libraries": {},
    "encodedConstructorArguments": "000000000000000000000000efc78fc7d48b64958315949279ba181c2114abbd00000000000000000000000014f3fe332e21ef3f5d244c45c8d5fbfcef2fb5c90000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000924f5ad34698fd20c90fe5d5a8a0abd3b42dc711",
    "creationData": {
        "blockHash": "0x09ddd4cf413011778ee8c03e0707b3e472162d1632c5212717b23e0ef3c47b63",
        "blockNumber": 3368550,
        "transactionHash": "0x06c98d9df93e1b23eeb57decdbf7d6419c107a6f188b4fc5db6da3a5d1d5490d",
        "timestamp": 1621597890
    }
}