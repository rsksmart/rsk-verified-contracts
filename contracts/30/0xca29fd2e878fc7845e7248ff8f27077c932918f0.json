{
  "address": "0xca29fd2e878fc7845e7248ff8f27077c932918f0",
  "net": {
    "id": "30",
    "name": "RSK Mainnet"
  },
  "name": "AddressHelper",
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "evmVersion": "byzantium"
  },
  "version": "0.4.25+commit.59dbf8f1",
  "source": "pragma solidity ^0.4.24;\n\nlibrary AddressHelper {\n    function recoverAddress(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public pure\n        returns (address) {\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        uint8 vv = v;\n        if (vv < 27) {\n            vv += 27;\n        }\n\n        // If the version is correct return the signer address\n        if (vv != 27 && vv != 28) {\n            return (address(0));\n        } else {\n            return ecrecover(hash, vv, r, s);\n        }\n\n    }\n\n    function char(byte b) public pure returns (byte c) {\n        if (b < 10) return byte(uint8(b) + 0x30);\n        else return byte(uint8(b) + 0x57);\n    }\n\n    function getHashedPublicKey(\n        bytes32 _xPoint,\n        bytes32 _yPoint)\n        pure public\n        returns(\n            bytes20 hashedPubKey)\n    {\n        byte startingByte = 0x04;\n        return ripemd160(abi.encodePacked(sha256(abi.encodePacked(startingByte, _xPoint, _yPoint))));\n    }\n\n    function fromHexChar(uint c) public pure returns (uint) {\n        if (c >= uint(byte('0')) && c <= uint(byte('9'))) {\n            return c - uint(byte('0'));\n        }\n\n        if (c >= uint(byte('a')) && c <= uint(byte('f'))) {\n            return 10 + c - uint(byte('a'));\n        }\n\n        if (c >= uint(byte('A')) && c <= uint(byte('F'))) {\n            return 10 + c - uint(byte('A'));\n        }\n\n        // Reaching this point means the ordinal is not for a hex char.\n        revert();\n    }\n\n    function fromAsciiString(string s) public pure returns(address) {\n        bytes memory ss = bytes(s);\n\n        // it should have 40 or 42 characters\n        if (ss.length != 40 && ss.length != 42) revert();\n\n        uint r = 0;\n        uint offset = 0;\n\n        if (ss.length == 42) {\n            offset = 2;\n\n            if (ss[0] != byte('0')) revert();\n            if (ss[1] != byte('x') && ss[1] != byte('X')) revert();\n        }\n\n        uint i;\n        uint x;\n        uint v;\n\n        // loads first 32 bytes from array,\n        // skipping array length (32 bytes to skip)\n        // offset == 0x20\n        assembly { v := mload(add(0x20, ss)) }\n\n        // converts the first 32 bytes, adding to result\n        for (i = offset; i < 32; ++i) {\n            assembly { x := byte(i, v) }\n            r = r * 16 + fromHexChar(x);\n        }\n\n        // loads second 32 bytes from array,\n        // skipping array length (32 bytes to skip)\n        // and first 32 bytes\n        // offset == 0x40\n        assembly { v := mload(add(0x40, ss)) }\n\n        // converts the last 8 bytes, adding to result\n        for (i = 0; i < 8 + offset; ++i) {\n            assembly { x := byte(i, v) }\n            r = r * 16 + fromHexChar(x);\n        }\n\n        return address(r);\n    }\n}\n",
  "imports": [
    {
      "name": "AddressHelper.sol",
      "contents": "pragma solidity ^0.4.24;\n\nlibrary AddressHelper {\n    function recoverAddress(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public pure\n        returns (address) {\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        uint8 vv = v;\n        if (vv < 27) {\n            vv += 27;\n        }\n\n        // If the version is correct return the signer address\n        if (vv != 27 && vv != 28) {\n            return (address(0));\n        } else {\n            return ecrecover(hash, vv, r, s);\n        }\n\n    }\n\n    function char(byte b) public pure returns (byte c) {\n        if (b < 10) return byte(uint8(b) + 0x30);\n        else return byte(uint8(b) + 0x57);\n    }\n\n    function getHashedPublicKey(\n        bytes32 _xPoint,\n        bytes32 _yPoint)\n        pure public\n        returns(\n            bytes20 hashedPubKey)\n    {\n        byte startingByte = 0x04;\n        return ripemd160(abi.encodePacked(sha256(abi.encodePacked(startingByte, _xPoint, _yPoint))));\n    }\n\n    function fromHexChar(uint c) public pure returns (uint) {\n        if (c >= uint(byte('0')) && c <= uint(byte('9'))) {\n            return c - uint(byte('0'));\n        }\n\n        if (c >= uint(byte('a')) && c <= uint(byte('f'))) {\n            return 10 + c - uint(byte('a'));\n        }\n\n        if (c >= uint(byte('A')) && c <= uint(byte('F'))) {\n            return 10 + c - uint(byte('A'));\n        }\n\n        // Reaching this point means the ordinal is not for a hex char.\n        revert();\n    }\n\n    function fromAsciiString(string s) public pure returns(address) {\n        bytes memory ss = bytes(s);\n\n        // it should have 40 or 42 characters\n        if (ss.length != 40 && ss.length != 42) revert();\n\n        uint r = 0;\n        uint offset = 0;\n\n        if (ss.length == 42) {\n            offset = 2;\n\n            if (ss[0] != byte('0')) revert();\n            if (ss[1] != byte('x') && ss[1] != byte('X')) revert();\n        }\n\n        uint i;\n        uint x;\n        uint v;\n\n        // loads first 32 bytes from array,\n        // skipping array length (32 bytes to skip)\n        // offset == 0x20\n        assembly { v := mload(add(0x20, ss)) }\n\n        // converts the first 32 bytes, adding to result\n        for (i = offset; i < 32; ++i) {\n            assembly { x := byte(i, v) }\n            r = r * 16 + fromHexChar(x);\n        }\n\n        // loads second 32 bytes from array,\n        // skipping array length (32 bytes to skip)\n        // and first 32 bytes\n        // offset == 0x40\n        assembly { v := mload(add(0x40, ss)) }\n\n        // converts the last 8 bytes, adding to result\n        for (i = 0; i < 8 + offset; ++i) {\n            assembly { x := byte(i, v) }\n            r = r * 16 + fromHexChar(x);\n        }\n\n        return address(r);\n    }\n}\n",
      "file": "AddressHelper.sol"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x94b1b9eb7085e1028f393d21e2d80ad31d944f088916d78954eb0f50742f08e0",
    "blockNumber": 892209,
    "transactionHash": "0x5e6a4675bf8becc271a0598a578d96ef0763623bb16cf2b8e8e24b95604b423b",
    "timestamp": 1541794116
  }
}