{
  "address": "0x779195c53cc7c1a33bd2eea5f63f2c1da8798d61",
  "net": {
    "id": "30",
    "name": "RSK Mainnet"
  },
  "name": "FIFSRegistrar",
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "evmVersion": "petersburg",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "metadata",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ]
      }
    }
  },
  "version": "0.5.12+commit.7709ece9",
  "source": "\n// File: @openzeppelin/contracts/math/SafeMath.sol\n\n\npragma solidity ^0.5.0;\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: @openzeppelin/contracts/GSN/Context.sol\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\n\n\n\n\n\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\n\n\n\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\n// File: contracts/testing/ContractReceiver.sol\n\n\n\n// Used only for testing reasons\n\n /*\n * Contract interface that is working with ERC677 tokens\n */\ncontract ContractReceiver {\n    function tokenFallback(address _from, uint _value, bytes memory _data) public returns(bool);\n}\n\n// File: contracts/testing/ERC677.sol\n\n\n\n// Used only for testing reasons\n// See https://github.com/ethereum/EIPs/issues/677\n\n/* ERC677 contract interface */\ncontract ERC677 {\n    function transferAndCall(address to, uint256 value, bytes memory data) public returns (bool ok);\n\n    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);\n}\n\n// File: contracts/testing/ERC677TokenContract.sol\n\n\n\n// Used only for testing reasons\n\n\n\n\n\ncontract ERC677TokenContract is ERC677, ERC20, ERC20Detailed {\n\n    constructor(address initialAccount, uint256 initialBalance) ERC20Detailed(\"RIF Token\", \"RIF\", 18) public {\n        _mint(initialAccount, initialBalance);\n    }\n\n    function transferAndCall(address to, uint256 value, bytes memory data) public returns (bool) {\n        super.transfer(to, value);\n\n        ContractReceiver(to).tokenFallback(msg.sender, value, data);\n\n        emit Transfer(msg.sender, to, value, data);\n\n        return true;\n    }\n}\n\n// File: @openzeppelin/contracts/introspection/IERC165.sol\n\n\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\n\n\n\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address owner) public view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     *\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\n\n\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract IERC721Receiver {\n    /**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\n     * otherwise the caller will revert the transaction. The selector to be\n     * returned can be obtained as `this.onERC721Received.selector`. This\n     * function MAY throw to revert and reject the transfer.\n     * Note: the ERC721 contract address is always the message sender.\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n    public returns (bytes4);\n}\n\n// File: @openzeppelin/contracts/utils/Address.sol\n\n\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract's constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * IMPORTANT: It is unsafe to assume that an address for which this\n     * function returns false is an externally-owned account (EOA) and not a\n     * contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\n// File: @openzeppelin/contracts/drafts/Counters.sol\n\n\n\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n\n// File: @openzeppelin/contracts/introspection/ERC165.sol\n\n\n\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\ncontract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/ERC721.sol\n\n\n\n\n\n\n\n\n\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is Context, ERC165, IERC721 {\n    using SafeMath for uint256;\n    using Address for address;\n    using Counters for Counters.Counter;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from token ID to owner\n    mapping (uint256 => address) private _tokenOwner;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping (address => Counters.Counter) private _ownedTokensCount;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    constructor () public {\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner address to query the balance of\n     * @return uint256 representing the amount owned by the passed address\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n\n        return _ownedTokensCount[owner].current();\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _tokenOwner[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n\n        return owner;\n    }\n\n    /**\n     * @dev Approves another address to transfer the given token ID\n     * The zero address indicates there is no approved address.\n     * There can only be one approved address per token at a given time.\n     * Can only be called by the token owner or an approved operator.\n     * @param to address to be approved for the given token ID\n     * @param tokenId uint256 ID of the token to be approved\n     */\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Gets the approved address for a token ID, or zero if no address set\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to query the approval of\n     * @return address currently approved for the given token ID\n     */\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Sets or unsets the approval of a given operator\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\n     * @param to operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     */\n    function setApprovalForAll(address to, bool approved) public {\n        require(to != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][to] = approved;\n        emit ApprovalForAll(_msgSender(), to, approved);\n    }\n\n    /**\n     * @dev Tells whether an operator is approved by a given owner.\n     * @param owner owner address which you want to query the approval of\n     * @param operator operator address which you want to query the approval of\n     * @return bool whether the given operator is approved by the given owner\n     */\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Transfers the ownership of a given token ID to another address.\n     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     * Requires the msg.sender to be the owner, approved, or operator.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the _msgSender() to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransferFrom(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function _safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) internal {\n        _transferFrom(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether the specified token exists.\n     * @param tokenId uint256 ID of the token to query the existence of\n     * @return bool whether the token exists\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner = _tokenOwner[tokenId];\n        return owner != address(0);\n    }\n\n    /**\n     * @dev Returns whether the given spender can transfer a given token ID.\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     * is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Internal function to safely mint a new token.\n     * Reverts if the given token ID already exists.\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Internal function to safely mint a new token.\n     * Reverts if the given token ID already exists.\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Internal function to mint a new token.\n     * Reverts if the given token ID already exists.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _tokenOwner[tokenId] = to;\n        _ownedTokensCount[to].increment();\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use {_burn} instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == owner, \"ERC721: burn of token that is not own\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[owner].decrement();\n        _tokenOwner[tokenId] = address(0);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(uint256 tokenId) internal {\n        _burn(ownerOf(tokenId), tokenId);\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[from].decrement();\n        _ownedTokensCount[to].increment();\n\n        _tokenOwner[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * This function is deprecated.\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        internal returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n\n        bytes4 retval = IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data);\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /**\n     * @dev Private function to clear current approval of a given token ID.\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _clearApproval(uint256 tokenId) private {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n        }\n    }\n}\n\n// File: @openzeppelin/contracts/ownership/Ownable.sol\n\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: @openzeppelin/contracts/access/Roles.sol\n\n\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\n// File: contracts/testing/TokenDeed.sol\n\n\n\n\n// Used only for testing reasons\n\n// See https://github.com/ethereum/EIPs/issues/677\n\n/**\n * @title Deed to hold RIF tokens in exchange for ownership of a node\n *\n * @dev The deed can be controlled only by the registrar and can only send tokens back to the owner.\n */\ncontract TokenDeed {\n\n    address payable constant RESOURCE_POOL_ADDRESS = 0xE594DF49AA7a13ccdD2dB3A7917312E02374f744;\n    uint constant RENT_PAYMENT_TIME = 3 * 30 days; // 3 months\n    uint constant VALIDITY = 365 days; // 1 year\n\n    address public registrar;\n    address public owner;\n    address public previousOwner;\n\n    uint public creationDate;\n    uint public expirationDate;\n\tuint public tokenQuantity;\n\n\tERC677TokenContract public tokenContract;\n\n    bool active;\n\n    event OwnerChanged(address newOwner);\n    event DeedClosed();\n\n    modifier onlyRegistrar {\n        require(msg.sender == registrar);\n        _;\n    }\n\n    modifier onlyActive {\n        require(active);\n        _;\n    }\n\n    /** \n     * @dev Constructor for a TokenDeed\n     *\n     * @param _owner The deed's owner\n     * @param _tokenQuantity Amount of tokens locked in the Deed\n     * @param _tokenContract Address of the contract which handles tokens\n    **/\n    constructor(address _owner, uint _tokenQuantity, ERC677TokenContract _tokenContract) public {\n        owner = _owner;\n        registrar = msg.sender;\n        creationDate = now;\n        expirationDate = 0;\n        active = true;\n        tokenQuantity = _tokenQuantity;\n        tokenContract = _tokenContract;\n    }\n\n    function setOwner(address newOwner) public onlyRegistrar {\n        require(newOwner != address(0));\n        previousOwner = owner;  // This allows contracts to check who sent them the ownership\n        owner = newOwner;\n        emit OwnerChanged(newOwner);\n    }\n\n    function setRegistrar(address newRegistrar) public onlyRegistrar {\n        registrar = newRegistrar;\n    }\n\n    /** \n     * @dev Sets the Deed's new balance, returning the difference to the owner\n     *\n     * The new balance MUST be lower or equal than the current one\n     *\n     * @param newTokenQuantity The new balance in tokens\n     * @param throwOnFailure Flag to indicate if the token transference should throw or not\n    **/\n    function setBalance(uint newTokenQuantity, bool throwOnFailure) public onlyRegistrar onlyActive {\n        // Check if it has enough balance to set the value\n        require(tokenQuantity >= newTokenQuantity);\n        uint diffTokenQuantity = tokenQuantity - newTokenQuantity;\n        tokenQuantity = newTokenQuantity;\n        // Send the difference to the owner\n        require(tokenContract.transfer(owner, diffTokenQuantity) || !throwOnFailure);\n    }\n\n    /** \n     * @dev Computes and sets the expirationDate from a given date, starting the vigency period\n     *\n     * @param startDate Date to calculate the expirationDate from\n     * @param rentValue The value of the initial rent fee to pay in tokens\n    **/\n    function startExpiration(uint startDate, uint rentValue) public onlyRegistrar onlyActive {\n        require(expirationDate == 0 && startDate <= now); // require expiration hasn't started\n        require(rentValue <= tokenQuantity);\n\n        expirationDate = startDate + VALIDITY;\n\n        // transfer the fee to the resource pool address\n        tokenQuantity = tokenQuantity - rentValue;\n        require(tokenContract.transfer(RESOURCE_POOL_ADDRESS, rentValue));\n    }\n\n    /** \n     * @dev Pay the Deed's rent, thus extending the expirationDate and the vigency period\n     *\n     * Can only be called when the current date falls within the payment period (3 months)\n     *\n     * @param rentValue The value to pay in tokens\n    **/\n    function payRent(uint rentValue) public onlyRegistrar onlyActive returns(bool) {\n        require(canPayRent());\n        \n        require(tokenContract.transfer(RESOURCE_POOL_ADDRESS, rentValue));\n\n        expirationDate = expirationDate + VALIDITY;\n\n        return true;\n    }\n\n    /** \n     * @dev Returns wheter the current date falls within the Deed's rent payment period\n    **/\n    function canPayRent() public view returns(bool) {\n        return expirationDate - RENT_PAYMENT_TIME <= now && now <= expirationDate;\n    }\n\n\n    /** \n     * @dev Returns wether the Deed is expired or not\n    **/\n    function expired() public view returns(bool) {\n        return 0 < expirationDate && expirationDate < now;\n    }\n\n    /**\n     * @dev Close a deed and refund a specified fraction of the bid value\n     *\n     * @param refundRatio The amount*1/1000 to refund in tokens\n     */\n    function closeDeed(uint refundRatio) public onlyRegistrar onlyActive {\n        refundAndDestroy(refundRatio);\n    }\n\n    /** \n     * @dev Close an expired deed. No funds are returned\n    **/\n    function closeExpiredDeed() public onlyActive {\n        require(expired(), \"Deed should be expired\");\n        refundAndDestroy(0);\n    }\n\n    /** \n     * @dev Internal method which handles fund returns/burning and the Deed's destruction\n     *\n     * @param refundRatio The amount*1/1000 to refund in tokens\n    **/\n    function refundAndDestroy(uint refundRatio) private onlyActive {\n        require(refundRatio <= 1000);\n\n        active = false;\n        uint torefund = (1000 - refundRatio) * tokenQuantity / 1000;\n        require(tokenContract.transfer(RESOURCE_POOL_ADDRESS, torefund));\n        tokenQuantity -= torefund;\n        emit DeedClosed();\n        destroyDeed();\n    }\n\n    /**\n     * @dev Close a deed and refund a specified fraction of the bid value\n     */\n    function destroyDeed() private {\n        require(!active);\n\n        if (tokenContract.transfer(owner, tokenQuantity)) {\n            selfdestruct(RESOURCE_POOL_ADDRESS);\n        }\n    }\n\n    function tokenFallback(address from, uint256 amount, bytes memory data) public returns (bool) {\n        return true;\n    }\n}\n\n// File: contracts/testing/AbstractRNS.sol\n\n\n\n// Used only for testing reasons\n\ncontract AbstractRNS {\n    function owner(bytes32 node) public view returns(address);\n    function resolver(bytes32 node) public view returns(address);\n    function ttl(bytes32 node) public view returns(uint64);\n    function setOwner(bytes32 node, address ownerAddress) public;\n    function setSubnodeOwner(bytes32 node, bytes32 label, address ownerAddress) public;\n    function setResolver(bytes32 node, address resolverAddress) public;\n    function setTTL(bytes32 node, uint64 ttlValue) public;\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address ownerAddress);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address ownerAddress);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolverAddress);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttlValue);\n}\n\n// File: contracts/testing/RNS.sol\n\n\n\n\n// Used only for testing reasons\n\n/**\n * The RNS registry contract.\n */\ncontract RNS is AbstractRNS {\n    struct Record {\n        address owner;\n        address resolver;\n        uint64 ttl;\n    }\n\n    mapping(bytes32=>Record) records;\n\n    // Permits modifications only by the owner of the specified node.\n    modifier only_owner(bytes32 node) {\n        require(records[node].owner == msg.sender);\n        _;\n    }\n\n    /**\n     * Constructs a new RNS registrar.\n     */\n    constructor() public {\n        records[bytes32(0)].owner = msg.sender;\n    }\n\n    /**\n     * Returns the address that owns the specified node.\n     */\n    function owner(bytes32 node) public view returns (address) {\n        return records[node].owner;\n    }\n\n    /**\n     * Returns the address of the resolver for the specified node.\n     */\n    function resolver(bytes32 node) public view returns (address) {\n        return records[node].resolver;\n    }\n\n    /**\n     * Returns the TTL of a node, and any records associated with it.\n     */\n    function ttl(bytes32 node) public view returns (uint64) {\n        return records[node].ttl;\n    }\n\n    /**\n     * Transfers ownership of a node to a new address. May only be called by the current\n     * owner of the node.\n     * @param node The node to transfer ownership of.\n     * @param ownerAddress The address of the new owner.\n     */\n    function setOwner(bytes32 node, address ownerAddress) public only_owner(node) {\n        emit Transfer(node, ownerAddress);\n        records[node].owner = ownerAddress;\n    }\n\n    /**\n     * Transfers ownership of a subnode keccak256(node, label) to a new address. May only be\n     * called by the owner of the parent node.\n     * @param node The parent node.\n     * @param label The hash of the label specifying the subnode.\n     * @param ownerAddress The address of the new owner.\n     */\n    function setSubnodeOwner(bytes32 node, bytes32 label, address ownerAddress) public only_owner(node) {\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\n        emit NewOwner(node, label, ownerAddress);\n        records[subnode].owner = ownerAddress;\n\n        emit NewResolver(subnode, records[node].resolver);\n        records[subnode].resolver = records[node].resolver;\n    }\n\n    /**\n     * Sets the resolver address for the specified node.\n     * @param node The node to update.\n     * @param resolverAddress The address of the resolver.\n     */\n    function setResolver(bytes32 node, address resolverAddress) public only_owner(node) {\n        emit NewResolver(node, resolverAddress);\n        records[node].resolver = resolverAddress;\n    }\n\n    /**\n     * Sets the TTL for the specified node.\n     * @param node The node to update.\n     * @param ttlValue The TTL in seconds.\n     */\n    function setTTL(bytes32 node, uint64 ttlValue) public only_owner(node) {\n        emit NewTTL(node, ttlValue);\n        records[node].ttl = ttlValue;\n    }\n\n    /**\n     * Sets the default resolver for new nodes\n     * @param _resolver The address of the new defaultResolver\n     */\n    function setDefaultResolver(address _resolver) public only_owner(0) {\n        records[bytes32(0)].resolver = _resolver;\n    }\n}\n\n// File: contracts/testing/TokenRegistrar.sol\n\n\n\n\n/*\n\nTemporary Hash Registrar\n========================\n\nThis is a simplified version of a hash registrar. It is purporsefully limited:\nnames cannot be six letters or shorter, new auctions will stop after 4 years.\n\nThe plan is to test the basic features and then move to a new contract in at most\n2 years, when some sort of renewal mechanism will be enabled.\n\nRefund schedule\n===============\n\nCase A: Reveal Period\n------------------------------------------------------------------------------------\n| (I) Auction winner | Funds are locked in Deed. 80% are returned on Deed release  |\n------------------------------------------------------------------------------------\n| (II) Auction losser | 100% refund over the losing bid                            |\n------------------------------------------------------------------------------------\n\nCase B: Late-Reveal Period (2 weeks after auction finish)\n---------------------------------------------------------------------------------------------------\n| (I) Bid that would have won                 | 20% taken as fee                                  |\n---------------------------------------------------------------------------------------------------\n| (II) Bid that would have affected 2nd place | Difference with the actual 2nd place taken as fee |\n---------------------------------------------------------------------------------------------------\n| (III) Otherwise                             | 0.5% taken as fee                                 |\n---------------------------------------------------------------------------------------------------\n\nCase C: Any bid unsealed beyond the Late-Reveal period won't be refunded\n*/\n\n\n\n\n// Used only for testing reasons\n\n/**\n * @title TokenRegistrar\n * @dev The registrar handles the auction process for each subnode of the node it owns.\n */\ncontract TokenRegistrar {\n    using SafeMath for uint256;\n\n    RNS public rns;\n    bytes32 public rootNode;\n\tERC677TokenContract public tokenContract;\n\n    mapping (bytes32 => Entry) _entries;\n    mapping (address => mapping (bytes32 => TokenDeed)) public sealedBids;\n\n    enum Mode { Open, Auction, Owned, Forbidden, Reveal }\n\n    bytes4 constant SIGN_NEW_BID = 0x1413151f;  // sha3('newBidWithToken(address,uint256,bytes32)')\n    bytes4 constant SIGN_PAY_RENT = 0xe1ac9915; // sha3('payRentWithToken(address,uint256,bytes32)')\n    uint32 constant TOTAL_AUCTION_LENGTH = 5 days;\n    uint32 constant REVEAL_PERIOD = 48 hours;\n    uint32 constant LATE_UNSEAL_PERIOD = 15 days;\n    uint constant RELEASE_FEE_PER_MIL = 200;    // 200 of 1000 = 20%\n    uint constant MIN_TOKEN_QUANTITY = 1 * 10**18;  // 1 token\n    uint constant RENT_VALUE = 1 * 10**18;  // 1 token\n\n    event AuctionStarted(bytes32 indexed hash, uint registrationDate);\n    event NewBid(bytes32 indexed hash, address indexed bidder, uint deposit);\n    event BidRevealed(bytes32 indexed hash, address indexed owner, uint value, uint8 status);\n    event HashRegistered(bytes32 indexed hash, address indexed owner, uint value, uint registrationDate);\n    event HashReleased(bytes32 indexed hash, uint value);\n\n    struct Entry {\n        TokenDeed deed;\n        uint registrationDate;\n        uint value;\n        uint highestBid;\n    }\n\n    modifier inState(bytes32 _hash, Mode _state) {\n        require(state(_hash) == _state);\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _hash) {\n        require(state(_hash) == Mode.Owned && msg.sender == _entries[_hash].deed.owner());\n        _;\n    }\n\n    modifier registryOpen() {\n        require(rns.owner(rootNode) == address(this));\n        _;\n    }\n\n    /**\n     * @dev Constructs a new Registrar, with the provided address as the owner of the root node.\n     *\n     * @param _rns The address of the RNS\n     * @param _rootNode The hash of the rootnode.\n     * @param _tokenAddr The ERC677 contract address to handle tokens\n     */\n    constructor(RNS _rns, bytes32 _rootNode, ERC677TokenContract _tokenAddr) public {\n        rns = _rns;\n        rootNode = _rootNode;\n        tokenContract = _tokenAddr;\n    }\n\n    /**\n     * @dev Start an auction for an available hash\n     *\n     * @param _hash The hash to start an auction on\n     */\n    function startAuction(bytes32 _hash) public registryOpen() {\n        Mode mode = state(_hash);\n        if (mode == Mode.Auction) return;\n        require(mode == Mode.Open);\n\n        Entry storage newAuction = _entries[_hash];\n        newAuction.registrationDate = now + TOTAL_AUCTION_LENGTH;\n        newAuction.value = 0;\n        newAuction.highestBid = 0;\n        newAuction.deed = TokenDeed(0);\n\n        emit AuctionStarted(_hash, newAuction.registrationDate);\n    }\n\n    /**\n     * @dev Start multiple auctions for better anonymity\n     *\n     * Anyone can start an auction by sending an array of hashes that they want to bid for.\n     * Arrays are sent so that someone can open up an auction for X dummy hashes when they\n     * are only really interested in bidding for one. This will increase the cost for an\n     * attacker to simply bid blindly on all new auctions. Dummy auctions that are\n     * open but not bid on are closed after a week.\n     *\n     * @param _hashes An array of hashes, at least one of which you presumably want to bid on\n     */\n    function startAuctions(bytes32[] memory _hashes) public {\n        for (uint i = 0; i < _hashes.length; i ++) {\n            startAuction(_hashes[i]);\n        }\n    }\n\n    /**\n     * @dev Submit a new sealed bid on a desired hash in a blind auction\n     *\n     * Bids are sent by sending a message to the main contract with a hash and an amount. The hash\n     * contains information about the bid, including the bidded hash, the bid amount, and a random\n     * salt. Bids are not tied to any one auction until they are revealed. The value of the bid\n     * itself can be masqueraded by sending more than the value of your actual bid. This is\n     * followed by a 48h reveal period. For bids revealed after this period, a percentage (defined in the late unsealing \n     * Refund schedule) will be sent to a special resource pool address.\n     * Since this is an auction, it is expected that most public hashes, like known domains and common dictionary\n     * words, will have multiple bidders pushing the price up.\n     *\n     * This method requires the sender to approve the Registrar to use the specified tokenQuantity in the ERC677 contract.\n     * Otherwise it can be done through the tokenFallback after a transfer with the corresponding parameters\n     *\n     * @param _sealedBid A sealedBid, created by the shaBid function\n     * @param _tokenQuantity token quantity to bid\n     */\n    function newBid(bytes32 _sealedBid, uint _tokenQuantity) public {\n        require(tokenContract.transferFrom(msg.sender, address(this), _tokenQuantity));\n\n        newBidAfterTransfer(msg.sender, _tokenQuantity, _sealedBid);\n    }\n\n    /**\n     * @dev Method to be called through a dynamic invocation from an ERC677 token contract\n     *\n     * @param _from Address sending the tokens as well as submitting the bid\n     * @param _tokenQuantity Amount in tokens received throuh the transference\n     * @param _sealedBid Sealed bid, created through the shaBid function\n    **/\n    function newBidWithToken(address _from, uint _tokenQuantity, bytes32 _sealedBid) public {\n        require(msg.sender == address(tokenContract));\n        newBidAfterTransfer(_from, _tokenQuantity, _sealedBid);\n    }\n\n    /**\n     * @dev Internal method which handles the new bidding logic\n     *\n     * @param _from Address sending the tokens as well as submitting the bid\n     * @param _tokenQuantity Amount in tokens received through the transference. To be used to mask the actual bidded value\n     * @param _sealedBid Sealed bid, created through the shaBid function\n    **/\n    function newBidAfterTransfer(address _from, uint _tokenQuantity, bytes32 _sealedBid) private {\n        require(address(sealedBids[_from][_sealedBid]) == address(0));\n\n        // Creates a new hash contract with the owner\n        TokenDeed createdBid = new TokenDeed(_from, _tokenQuantity, tokenContract);\n        require(tokenContract.transfer(address(createdBid), _tokenQuantity));\n        sealedBids[_from][_sealedBid] = createdBid;\n\n        emit NewBid(_sealedBid, _from, _tokenQuantity);\n    }\n\n    /**\n     * @dev Start a set of auctions and bid on one of them\n     *\n     * This method functions identically to calling `startAuctions` followed by `newBid`,\n     * but all in one transaction.\n     *\n     * @param _hashes A list of hashes to start auctions on.\n     * @param _sealedBid A sealed bid for one of the auctions.\n     * @param _tokenQuantity Amount of tokens to mask the bid with.\n     */\n    function startAuctionsAndBid(bytes32[] memory _hashes, bytes32 _sealedBid, uint _tokenQuantity) public payable {\n        startAuctions(_hashes);\n        newBid(_sealedBid, _tokenQuantity);\n    }\n\n    /**\n     * @dev Submit the properties of a bid to reveal them\n     *\n     * @param _hash The node in the sealedBid\n     * @param _value The bid amount in the sealedBid\n     * @param _salt The sale in the sealedBid\n     */\n    function unsealBid(bytes32 _hash, uint _value, bytes32 _salt) public {\n        bytes32 seal = shaBid(_hash, msg.sender, _value, _salt);\n        TokenDeed bid = sealedBids[msg.sender][seal];\n        require(address(bid) != address(0));\n\n        sealedBids[msg.sender][seal] = TokenDeed(0);\n        Entry storage h = _entries[_hash];\n        uint value = min(_value, bid.tokenQuantity());\n        bid.setBalance(value, true);\n\n        Mode auctionState = state(_hash);\n\n        if (auctionState == Mode.Owned) {\n            // By this point the auction has ended. The refund values are defined in the above Refund Schedule\n\n            uint256 refundRatio = 995; // See: Case B)III\n\n            if (h.registrationDate + LATE_UNSEAL_PERIOD < now) {\n                refundRatio = 0; // See: Case C\n            } else {\n                if (value > h.highestBid) {\n                    refundRatio = 800; // See: Case B)I\n                } else if (value > h.value) {\n                    // See: Case B)II\n                    // Compute percentage corresponding to the difference between the actual 2nd place (h.value)\n                    // and the late unsealed bid (value)\n                    refundRatio = h.value.mul(1000).div(value);\n                }\n            }\n\n            bid.closeDeed(refundRatio);\n            emit BidRevealed(_hash, msg.sender, value, 1);\n        } else if (auctionState != Mode.Reveal) {\n            // invalid phase for unsealing\n            revert();\n        } else if (value < MIN_TOKEN_QUANTITY || bid.creationDate() > h.registrationDate - REVEAL_PERIOD) {\n            // Bid below the minimum or too late (created in the reveal period)\n            bid.closeDeed(1000);\n            emit BidRevealed(_hash, msg.sender, value, 0);\n        } else if (value > h.highestBid) {\n            // New winner\n            // Cancel the other bid\n            if (address(h.deed) != address(0)) {\n                TokenDeed previousWinner = h.deed;\n                previousWinner.closeDeed(1000);\n            }\n\n            // Set new winner\n            // Per the rules of a vickery auction, the value becomes the previous highestBid\n            h.value = h.highestBid;  // will be zero if there's only 1 bidder\n            h.highestBid = value;\n            h.deed = bid;\n            emit BidRevealed(_hash, msg.sender, value, 2);\n        } else if (value > h.value) {\n            // Not winner, but affects second place\n            h.value = value;\n            bid.closeDeed(1000);\n            emit BidRevealed(_hash, msg.sender, value, 3);\n        } else {\n            // Bid doesn't affect auction\n            bid.closeDeed(1000);\n            emit BidRevealed(_hash, msg.sender, value, 4);\n        }\n    }\n\n    /**\n     * @dev Finalize an auction after the registration date has passed\n     *\n     * Updates the Registry to reflect the new node owner. Starts the winning Deed's expiration period.\n     *\n     * @param _hash The hash of the name the auction is for\n     */\n    function finalizeAuction(bytes32 _hash) public onlyOwner(_hash) {\n        Entry storage h = _entries[_hash];\n\n        // Handles the case when there's only a single bidder (h.value is zero)\n        h.value = max(h.value, MIN_TOKEN_QUANTITY);\n        h.deed.setBalance(h.value, true);\n        h.deed.startExpiration(h.registrationDate, RENT_VALUE);\n\n        trySetSubnodeOwner(_hash, h.deed.owner());\n        emit HashRegistered(_hash, h.deed.owner(), h.value, h.registrationDate);\n    }\n\n    /**\n     * @dev The owner of a domain may transfer it to someone else at any time.\n     *\n     * @param _hash The node to transfer\n     * @param _newOwner The address to transfer ownership to\n     */\n    function transfer(bytes32 _hash, address _newOwner) public onlyOwner(_hash) {\n        require(_newOwner != address(0));\n\n        Entry storage h = _entries[_hash];\n        h.deed.setOwner(_newOwner);\n        trySetSubnodeOwner(_hash, _newOwner);\n    }\n\n    /**\n     * @dev After some time, or if we're no longer the registrar, the owner can release\n     *      the name and get a part of their tokens back.\n     *\n     * The allowed release period is within the rent payment period, which starts 3 months before the expiration date\n     *\n     * @param _hash The node to release\n     */\n    function releaseDeed(bytes32 _hash) public onlyOwner(_hash) {\n        Entry storage h = _entries[_hash];\n        TokenDeed deedContract = h.deed;\n\n        require(now < deedContract.expirationDate() || rns.owner(rootNode) != address(this));\n\n        h.value = 0;\n        h.highestBid = 0;\n        h.deed = TokenDeed(0);\n\n        _tryEraseSingleNode(_hash);\n\n        // return funds after deducting a fee and close the deed\n        deedContract.closeDeed(1000 - RELEASE_FEE_PER_MIL);\n\n        emit HashReleased(_hash, h.value);\n    }\n\n    /**\n     * @dev Allows anyone to delete the owner and resolver records for a (subdomain of) a\n     *      name that is not currently owned in the registrar. If passing, eg, 'foo.bar.rsk',\n     *      the owner and resolver fields on 'foo.bar.rsk' and 'bar.rsk' will all be cleared.\n     *\n     * @param _labels A series of label hashes identifying the name to zero out, rooted at the\n     *        registrar's root. Must contain at least one element. For instance, to zero\n     *        'foo.bar.rsk' on a registrar that owns '.rsk', pass an array containing\n     *        [keccak256('foo'), keccak256('bar')].\n     */\n    function eraseNode(bytes32[] memory _labels) public {\n        require(_labels.length != 0);\n        require(state(_labels[_labels.length - 1]) != Mode.Owned);\n\n        _eraseNodeHierarchy(_labels.length - 1, _labels, rootNode);\n    }\n\n    /**\n     * @dev Transfers the deed to the current registrar, if different from this one.\n     *\n     * Used during the upgrade process to a permanent registrar.\n     *\n     * @param _hash The name hash to transfer.\n     */\n    function transferRegistrars(bytes32 _hash) public onlyOwner(_hash) {\n        address registrar = rns.owner(rootNode);\n        require(registrar != address(this));\n\n        // Migrate the deed\n        Entry storage h = _entries[_hash];\n        h.deed.setRegistrar(registrar);\n\n        // Call the new registrar to accept the transfer\n        TokenRegistrar(registrar).acceptRegistrarTransfer(_hash, h.deed, h.registrationDate);\n\n        // Zero out the Entry\n        h.deed = TokenDeed(0);\n        h.registrationDate = 0;\n        h.value = 0;\n        h.highestBid = 0;\n    }\n\n    /**\n     * @dev Pay the yearly rent for a name\n     *\n     * Names have a vigency of 1 year after the registration date. Said expiry date is reflected through the associated Deed \n     * contract. Owners have a period of 3 months before the expiryDate to pay the rent and extend their ownership for 1 year\n     *\n     * @param _hash The hash of the name to pay the rent for\n     */\n    function payRent(bytes32 _hash) public {\n        require(tokenContract.transferFrom(msg.sender, address(this), RENT_VALUE));\n        payRentAfterTransfer(_hash);\n    }\n\n    /**\n     * @dev Method to be called through a dynamic invocation from an ERC677 token contract\n     *\n     * @param _from Address sending the tokens as well as submitting the bid\n     * @param _tokenQuantity Amount in tokens received throuh the transference\n     * @param _hash Hash of the name to pay the rent for\n    **/\n    function payRentWithToken(address _from, uint _tokenQuantity, bytes32 _hash) public {\n        require(_tokenQuantity == RENT_VALUE);\n        require(msg.sender == address(tokenContract));\n        payRentAfterTransfer(_hash);\n    }\n\n    /**\n     * @dev Internal method which handles the rent payment logic\n     *\n     * @param _hash Hash of the name to pay the rent for\n    **/\n    function payRentAfterTransfer(bytes32 _hash) private {\n        require(state(_hash) == Mode.Owned);\n\n        Entry storage h = _entries[_hash];\n\n        require(address(h.deed) != address(0));\n\n        require(tokenContract.transfer(address(h.deed), RENT_VALUE));\n        require(h.deed.payRent(RENT_VALUE));\n    }\n\n    /**\n     * @dev Accepts a transfer from a previous registrar; stubbed out here since there\n     *      is no previous registrar implementing this interface.\n     *\n     * @param _hash The sha3 hash of the label to transfer.\n     * @param _deed The TokenDeed object for the name being transferred in.\n     * @param _registrationDate The date at which the name was originally registered.\n     */\n    function acceptRegistrarTransfer(bytes32 _hash, TokenDeed _deed, uint _registrationDate) public {\n        _hash; _deed; _registrationDate; // Don't warn about unused variables\n    }\n\n    // State transitions for names:\n    //   Open -> Auction (startAuction)\n    //   Auction -> Reveal\n    //   Reveal -> Owned\n    //   Reveal -> Open (if nobody bid)\n    //   Owned -> Open (releaseDeed or the deed has expired)\n    function state(bytes32 _hash) public view returns (Mode) {\n        Entry storage entry = _entries[_hash];\n\n        if (now < entry.registrationDate) {\n            if (now < entry.registrationDate - REVEAL_PERIOD) {\n                return Mode.Auction;\n            } else {\n                return Mode.Reveal;\n            }\n        } else {\n            // there may not be any bid (not yet auctioned) or there is and it may have already expired (Expired)\n            if (entry.highestBid == 0 || entry.deed.expired()) {\n                return Mode.Open;\n            } else {\n                return Mode.Owned;\n            }\n        }\n    }\n\n    /**\n     * @dev Returns information related to a certain name\n     *\n     * @param _hash Hash of the name to query about\n    **/\n    function entries(bytes32 _hash) public view returns (Mode, address, uint, uint, uint) {\n        Entry storage h = _entries[_hash];\n        return (state(_hash), address(h.deed), h.registrationDate, h.value, h.highestBid);\n    }\n\n    /**\n     * @dev Hash the values required for a secret bid\n     *\n     * @param _hash The node corresponding to the desired namehash\n     * @param _value The bid amount in tokens\n     * @param _salt A random value to ensure secrecy of the bid\n     * @return The hash of the bid values\n     */\n    function shaBid(bytes32 _hash, address _owner, uint _value, bytes32 _salt) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_hash, _owner, _value, _salt));\n    }\n\n    function _tryEraseSingleNode(bytes32 _label) internal {\n        if (rns.owner(rootNode) == address(this)) {\n            rns.setSubnodeOwner(rootNode, _label, address(this));\n            bytes32 node = keccak256(abi.encodePacked(rootNode, _label));\n            rns.setResolver(node, address(0));\n            rns.setOwner(node, address(0));\n        }\n    }\n\n    function _eraseNodeHierarchy(uint _idx, bytes32[] memory _labels, bytes32 _node) internal {\n        // Take ownership of the node\n        rns.setSubnodeOwner(_node, _labels[_idx], address(this));\n        _node = keccak256(abi.encodePacked(_node, _labels[_idx]));\n\n        // Recurse if there are more labels\n        if (_idx > 0) {\n            _eraseNodeHierarchy(_idx - 1, _labels, _node);\n        }\n\n        // Erase the resolver and owner records\n        rns.setResolver(_node, address(0));\n        rns.setOwner(_node, address(0));\n    }\n\n    /**\n     * @dev Assign the owner in RNS, if we're still the registrar\n     *\n     * @param _hash hash to change owner\n     * @param _newOwner new owner to transfer to\n     */\n    function trySetSubnodeOwner(bytes32 _hash, address _newOwner) internal {\n        if (rns.owner(rootNode) == address(this))\n            rns.setSubnodeOwner(rootNode, _hash, _newOwner);\n    }\n\n    /**\n     * @dev Returns the maximum of two unsigned integers\n     *\n     * @param a A number to compare\n     * @param b A number to compare\n     * @return The maximum of two unsigned integers\n     */\n    function max(uint a, uint b) internal pure returns (uint) {\n        if (a > b)\n            return a;\n        else\n            return b;\n    }\n\n    /**\n     * @dev Returns the minimum of two unsigned integers\n     *\n     * @param a A number to compare\n     * @param b A number to compare\n     * @return The minimum of two unsigned integers\n     */\n    function min(uint a, uint b) internal pure returns (uint) {\n        if (a < b)\n            return a;\n        else\n            return b;\n    }\n\n    /**\n     * @dev Fallback function to be called when the contract receives a transference through an ERC677 contract\n     *\n     * Functions supported:\n     * - newBidWithToken (signature 0x1413151f) with a 32 byte parameter (sealedBid to submit)\n     * - payRentWithToken (signature 0xe1ac9915) with a 32 byte parameter (hash of the name to pay the rent for)\n     *\n     * @param _from Address which sent the tokens\n     * @param _value Amount of tokens sent\n     * @param _data Byte array with information of which function to call and the parameters used for the invocation\n    **/\n    function tokenFallback(address _from, uint256 _value, bytes memory _data) public returns (bool) {\n        if (_data.length < 4) return true;\n\n        require(msg.sender == address(tokenContract));\n\n        bytes4 signature =  bytesToBytes4(_data, 0);\n\n        if (signature == SIGN_NEW_BID) {\n            bytes32 sealedBid = bytesToBytes32(_data, 4);\n\n            newBidWithToken(_from, _value, sealedBid);\n        } else if (signature == SIGN_PAY_RENT) {\n            bytes32 name = bytesToBytes32(_data, 4);\n\n            payRentWithToken(_from, _value, name);\n        } else {\n            revert();\n        }\n\n        return true;\n    }\n\n    function bytesToBytes4(bytes memory _b, uint _offset) private pure returns (bytes4) {\n        bytes4 out;\n\n        for (uint i = 0; i < 4; i++) {\n            out |= bytes4(_b[_offset + i] & 0xFF) >> (i * 8);\n        }\n\n        return out;\n    }\n\n    /**\n     * @dev Given a byte array and a given offset, extract the following 32 bytes into an array\n     *\n     * from https://ethereum.stackexchange.com/questions/7702/how-to-convert-byte-array-to-bytes32-in-solidity\n    **/\n    function bytesToBytes32(bytes memory _b, uint _offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        for (uint i = 0; i < 32; i++) {\n            out |= bytes32(_b[_offset + i] & 0xFF) >> (i * 8);\n        }\n\n        return out;\n    }\n}\n\n// File: contracts/RSKOwner.sol\n\n\n\n\n\n\n\n\n\ncontract RSKOwner is ERC721, Ownable {\n    using Roles for Roles.Role;\n\n    TokenRegistrar private previousRegistrar;\n    AbstractRNS private rns;\n    bytes32 private rootNode;\n\n    Roles.Role registrars;\n    Roles.Role renewers;\n\n    mapping (uint256 => uint) public expirationTime;\n\n    event ExpirationChanged(uint256 tokenId, uint expirationTime);\n\n    modifier onlyPreviousRegistrar {\n        require(msg.sender == address(previousRegistrar), \"Only previous registrar.\");\n        _;\n    }\n\n    modifier onlyRegistrar {\n        require(registrars.has(msg.sender), \"Only registrar.\");\n        _;\n    }\n\n    modifier onlyRenewer {\n        require(renewers.has(msg.sender), \"Only renewer.\");\n        _;\n    }\n\n    constructor (\n        TokenRegistrar _previousRegistrar,\n        AbstractRNS _rns,\n        bytes32 _rootNode\n    ) public {\n        previousRegistrar = _previousRegistrar;\n        rns = _rns;\n        rootNode = _rootNode;\n    }\n\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        require(expirationTime[tokenId] > now, \"ERC721: owner query for nonexistent token\");\n        return super.ownerOf(tokenId);\n    }\n\n    function available(uint256 tokenId) public view returns(bool) {\n        return (\n            expirationTime[tokenId] < now &&\n            previousRegistrar.state(bytes32(tokenId)) != TokenRegistrar.Mode.Owned\n        );\n    }\n\n    // Auction migration\n    function acceptRegistrarTransfer(bytes32 label, TokenDeed deed, uint) external onlyPreviousRegistrar {\n        uint256 tokenId = uint256(label);\n        expirationTime[tokenId] = deed.expirationDate();\n        _mint(deed.owner(), tokenId);\n        deed.closeDeed(1000);\n    }\n\n    // Registrar role\n    function addRegistrar(address registrar) external onlyOwner {\n        registrars.add(registrar);\n    }\n\n    function isRegistrar(address registrar) external view returns (bool) {\n        return registrars.has(registrar);\n    }\n\n    function removeRegistrar(address registrar) external onlyOwner {\n        registrars.remove(registrar);\n    }\n\n    // Registration\n    function register(bytes32 label, address tokenOwner, uint duration) external onlyRegistrar {\n        uint256 tokenId = uint256(label);\n\n        require(available(tokenId), \"Not available\");\n\n        uint newExpirationTime = now.add(duration);\n        expirationTime[tokenId] = newExpirationTime;\n        emit ExpirationChanged(tokenId, newExpirationTime);\n\n        if (_exists(tokenId))\n            _burn(tokenId);\n\n        _mint(tokenOwner, tokenId);\n\n        rns.setSubnodeOwner(rootNode, label, tokenOwner);\n    }\n\n    // Reclaim\n    function reclaim(uint256 id, address newOwner) external {\n        require(_isApprovedOrOwner(msg.sender, id), \"Not approved or owner\");\n        rns.setSubnodeOwner(rootNode, bytes32(id), newOwner);\n    }\n\n    // Renewer role\n    function addRenewer(address renewer) external onlyOwner {\n        renewers.add(renewer);\n    }\n\n    function isRenewer(address renewer) external view returns (bool) {\n        return renewers.has(renewer);\n    }\n\n    function removeRenewer(address renewer) external onlyOwner {\n        renewers.remove(renewer);\n    }\n\n    // Renovation\n    function renew (bytes32 label, uint time) external onlyRenewer {\n        uint256 tokenId = uint256(label);\n        require(expirationTime[tokenId] > now, \"Name already expired\");\n        uint newExpirationTime = expirationTime[tokenId].add(time);\n        expirationTime[tokenId] = newExpirationTime;\n        emit ExpirationChanged(tokenId, newExpirationTime);\n    }\n\n    // After expiration\n    function removeExpired(uint256[] calldata tokenIds) external {\n        uint256 tokenId;\n        bytes32 label;\n\n        for (uint i = 0; i < tokenIds.length; i++) {\n            tokenId = tokenIds[i];\n\n            if (_exists(tokenId) && available(tokenId)) {\n                expirationTime[tokenId] = ~uint(0);\n                _burn(tokenId);\n                expirationTime[tokenId] = 0;\n\n                label = bytes32(tokenId);\n                rns.setSubnodeOwner(rootNode, label, address(0));\n            }\n        }\n    }\n\n    // rsk admin\n    function setRootResolver (address resolver) external onlyOwner {\n        rns.setResolver(rootNode, resolver);\n    }\n\n    function setRootTTL (uint64 ttl) external onlyOwner {\n        rns.setTTL(rootNode, ttl);\n    }\n}\n\n// File: contracts/AbstractNamePrice.sol\n\n\n\n/// @title NamePrice interface\n/// @author Javier Esses\n/// @notice Defines an interface for name price calculations\ncontract AbstractNamePrice {\n    function price (string calldata name, uint expires, uint duration) external view returns(uint);\n}\n\n// File: contracts/PricedContract.sol\n\n\n\n\n\ncontract PricedContract is Ownable {\n    AbstractNamePrice public namePrice;\n\n    event NamePriceChanged(AbstractNamePrice contractAddress);\n\n    constructor(AbstractNamePrice _namePrice) public Ownable() {\n        namePrice = _namePrice;\n    }\n\n    /// @notice Change price contract\n    /// @dev Only owner\n    /// @param newNamePrice The new maturity required\n    function setNamePrice(AbstractNamePrice newNamePrice) external onlyOwner {\n        namePrice = newNamePrice;\n        emit NamePriceChanged(newNamePrice);\n    }\n\n    /// @notice Price of a name in RIF\n    /// @param duration Time to register the name\n    /// @return cost in RIF\n    function price (string memory name, uint expires, uint duration) public view returns(uint) {\n        return namePrice.price(name, expires, duration);\n    }\n}\n\n// File: @ensdomains/ethregistrar/contracts/StringUtils.sol\n\n\n\nlibrary StringUtils {\n    /**\n     * @dev Returns the length of a given string\n     *\n     * @param s The string to measure the length of\n     * @return The length of the input string\n     */\n    function strlen(string memory s) internal pure returns (uint) {\n        uint len;\n        uint i = 0;\n        uint bytelength = bytes(s).length;\n        for(len = 0; i < bytelength; len++) {\n            byte b = bytes(s)[i];\n            if(b < 0x80) {\n                i += 1;\n            } else if (b < 0xE0) {\n                i += 2;\n            } else if (b < 0xF0) {\n                i += 3;\n            } else if (b < 0xF8) {\n                i += 4;\n            } else if (b < 0xFC) {\n                i += 5;\n            } else {\n                i += 6;\n            }\n        }\n        return len;\n    }\n}\n\n// File: contracts/testing/ERC677Receiver.sol\n\n\n\ncontract ERC677Receiver {\n    function tokenFallback(address from, uint value, bytes calldata data) external returns (bool);\n}\n\n// File: contracts/BytesUtils.sol\n\n\n\n\nlibrary BytesUtils {\n    using SafeMath for uint256;\n\n    modifier minLength (uint size, uint offset, uint length) {\n        require(size >= offset.add(length), \"Short input\");\n        _;\n    }\n\n    function toBytes32 (bytes memory input, uint offset) public view minLength(input.length, offset, 32) returns (bytes32) {\n        bytes32 output;\n\n        assembly {\n            output := mload(add(add(input, 0x20), offset))\n        }\n\n        return output;\n    }\n\n    function toBytes4 (bytes memory input, uint offset) public view minLength(input.length, offset, 4) returns (bytes4) {\n        bytes4 output;\n\n        assembly {\n            output := mload(add(add(input, 0x20), offset))\n        }\n\n        return output;\n    }\n\n    function toUint (bytes memory input, uint offset) public view returns (uint) {\n        return uint(toBytes32(input, offset));\n    }\n\n    // source: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n    function toString (bytes memory input, uint offset, uint strLength) public view minLength(input.length, offset, strLength) returns (string memory) {\n        bytes memory output;\n\n        assembly {\n            switch iszero(strLength)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                output := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(strLength, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(output, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, strLength)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(input, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(output, strLength)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                output := mload(0x40)\n\n                mstore(0x40, add(output, 0x20))\n            }\n        }\n\n        return string(output);\n    }\n\n    function toAddress (bytes memory input, uint offset) public view minLength(input.length, offset, 20) returns (address) {\n        bytes20 output;\n\n        assembly {\n            output := mload(add(add(input, 0x20), offset))\n        }\n\n        return address(output);\n    }\n}\n\n// File: contracts/FIFSRegistrar.sol\n\n\n\n/// @title First-in first-served registrar\n/// @notice You can use this contract to register .rsk names in RNS.\n/// First make a commitment of the name to be registered, wait 1\n/// minute, and proceed to register the name.\n/// @dev This contract has permission to register in RSK Owner\ncontract FIFSRegistrar is PricedContract, ERC677Receiver {\n    using SafeMath for uint256;\n    using StringUtils for string;\n    using BytesUtils for bytes;\n\n    mapping (bytes32 => uint) private commitmentRevealTime;\n    uint public minCommitmentAge = 1 minutes;\n\n    uint public minLength = 5;\n\n    ERC677TokenContract rif;\n    RSKOwner rskOwner;\n    address pool;\n\n    // sha3('register(string,address,bytes32,uint)')\n    bytes4 constant REGISTER_SIGNATURE = 0xc2c414c8;\n\n    constructor (\n        ERC677TokenContract _rif,\n        RSKOwner _rskOwner,\n        address _pool,\n        AbstractNamePrice _namePrice\n    ) public PricedContract(_namePrice) {\n        rif = _rif;\n        rskOwner = _rskOwner;\n        pool = _pool;\n    }\n\n    /// @notice Create a commitment for register action\n    /// @dev Don't use this method on-chain when commiting\n    /// @param label keccak256 of the name to be registered\n    /// @param nameOwner Owner of the name to be registered\n    /// @param secret Secret to protect the name to be registered\n    /// @return The commitment hash\n    function makeCommitment (bytes32 label, address nameOwner, bytes32 secret) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(label, nameOwner, secret));\n    }\n\n    /// @notice Commit before registring a name\n    /// @dev A valid commitment can be calculated using makeCommitment off-chain\n    /// @param commitment A valid commitment hash\n    function commit(bytes32 commitment) external {\n        require(commitmentRevealTime[commitment] < 1, \"Existent commitment\");\n        commitmentRevealTime[commitment] = now.add(minCommitmentAge);\n    }\n\n    /// @notice Ensure the commitment is ready to be revealed\n    /// @param commitment Commitment to be queried\n    /// @return Wether the commitment can be revealed or not\n    function canReveal(bytes32 commitment) public view returns (bool) {\n        uint revealTime = commitmentRevealTime[commitment];\n        return 0 < revealTime && revealTime <= now;\n    }\n\n    /// @notice Registers a .rsk name in RNS\n    /// @dev This method must be called after commiting\n    /// @param name The name to register\n    /// @param nameOwner The owner of the name to regiter\n    /// @param secret The secret used to make the commitment\n    /// @param duration Time to register in years\n    function register(string calldata name, address nameOwner, bytes32 secret, uint duration) external {\n        uint cost = executeRegistration(name, nameOwner, secret, duration);\n        require(rif.transferFrom(msg.sender, pool, cost), \"Token transfer failed\");\n    }\n\n    /// @notice Change required commitment maturity\n    /// @dev Only owner\n    /// @param newMinCommitmentAge The new maturity required\n    function setMinCommitmentAge (uint newMinCommitmentAge) external onlyOwner {\n        minCommitmentAge = newMinCommitmentAge;\n    }\n\n    /// @notice Change disbaled names\n    /// @dev Only owner\n    /// @param newMinLength The new minimum length enabled\n    function setMinLength (uint newMinLength) external onlyOwner {\n        minLength = newMinLength;\n    }\n\n    function registerWithToken(string memory name, address nameOwner, bytes32 secret, uint duration, address from, uint amount) private {\n        uint cost = executeRegistration(name, nameOwner, secret, duration);\n        require(amount >= cost, \"Not enough tokens\");\n        require(rif.transfer(pool, cost), \"Token transfer failed\");\n        // Calculated twise because the common case is the exact amount is sent. No variables.\n        if (amount.sub(cost) > 0)\n            require(rif.transfer(from, amount.sub(cost)), \"Token transfer failed\");\n    }\n\n    /// @notice Executes registration without any payments.\n    /// @dev This method is used to abstract from payment method.\n    /// @param name The name to register\n    /// @param nameOwner The owner of the name to regiter\n    /// @param secret The secret used to make the commitment\n    /// @param duration Time to register in years\n    /// @return price Price of the name to register\n    function executeRegistration (string memory name, address nameOwner, bytes32 secret, uint duration) private returns (uint) {\n        bytes32 label = keccak256(abi.encodePacked(name));\n\n        require(name.strlen() >= minLength, \"Short names not available\");\n\n        bytes32 commitment = makeCommitment(label, nameOwner, secret);\n        require(canReveal(commitment), \"No commitment found\");\n        commitmentRevealTime[commitment] = 0;\n\n        rskOwner.register(label, nameOwner, duration.mul(365 days));\n\n        return price(name, rskOwner.expirationTime(uint(label)), duration);\n    }\n\n    /**\n        Register encoding:\n        | signature | 4 bytes - offset 0\n        | owner | 20 bytes - offset 4\n        | secret | 32 bytes - offest 24\n        | duration | 32 bytes - offset 56\n        | name | variable size - offset 88\n     */\n\n    /// @notice ERC-677 token fallback function\n    /// @dev Follow 'Register encoding' to execute a one-transaction regitration.\n    /// @param from token sender\n    /// @param value amount of tokens sent\n    /// @param data data associated with transaction\n    /// @return true if successfull\n    function tokenFallback(address from, uint value, bytes calldata data) external returns (bool) {\n        require(msg.sender == address(rif), \"Only RIF token\");\n        require(data.length > 88, \"Invalid data\");\n\n        bytes4 signature = data.toBytes4(0);\n\n        require(signature == REGISTER_SIGNATURE, \"Invalid signature\");\n\n        address nameOwner = data.toAddress(4);\n        bytes32 secret = data.toBytes32(24);\n        uint duration = data.toUint(56);\n        string memory name = data.toString(88, data.length.sub(88));\n\n        registerWithToken(name, nameOwner, secret, duration, from, value);\n\n        return true;\n    }\n}\n",
  "imports": [
    {
      "name": "FIFSRegistrar.sol",
      "contents": "\n// File: @openzeppelin/contracts/math/SafeMath.sol\n\n\npragma solidity ^0.5.0;\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: @openzeppelin/contracts/GSN/Context.sol\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\n\n\n\n\n\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\n\n\n\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\n// File: contracts/testing/ContractReceiver.sol\n\n\n\n// Used only for testing reasons\n\n /*\n * Contract interface that is working with ERC677 tokens\n */\ncontract ContractReceiver {\n    function tokenFallback(address _from, uint _value, bytes memory _data) public returns(bool);\n}\n\n// File: contracts/testing/ERC677.sol\n\n\n\n// Used only for testing reasons\n// See https://github.com/ethereum/EIPs/issues/677\n\n/* ERC677 contract interface */\ncontract ERC677 {\n    function transferAndCall(address to, uint256 value, bytes memory data) public returns (bool ok);\n\n    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);\n}\n\n// File: contracts/testing/ERC677TokenContract.sol\n\n\n\n// Used only for testing reasons\n\n\n\n\n\ncontract ERC677TokenContract is ERC677, ERC20, ERC20Detailed {\n\n    constructor(address initialAccount, uint256 initialBalance) ERC20Detailed(\"RIF Token\", \"RIF\", 18) public {\n        _mint(initialAccount, initialBalance);\n    }\n\n    function transferAndCall(address to, uint256 value, bytes memory data) public returns (bool) {\n        super.transfer(to, value);\n\n        ContractReceiver(to).tokenFallback(msg.sender, value, data);\n\n        emit Transfer(msg.sender, to, value, data);\n\n        return true;\n    }\n}\n\n// File: @openzeppelin/contracts/introspection/IERC165.sol\n\n\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\n\n\n\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address owner) public view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     *\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\n\n\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract IERC721Receiver {\n    /**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\n     * otherwise the caller will revert the transaction. The selector to be\n     * returned can be obtained as `this.onERC721Received.selector`. This\n     * function MAY throw to revert and reject the transfer.\n     * Note: the ERC721 contract address is always the message sender.\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n    public returns (bytes4);\n}\n\n// File: @openzeppelin/contracts/utils/Address.sol\n\n\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract's constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * IMPORTANT: It is unsafe to assume that an address for which this\n     * function returns false is an externally-owned account (EOA) and not a\n     * contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\n// File: @openzeppelin/contracts/drafts/Counters.sol\n\n\n\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n\n// File: @openzeppelin/contracts/introspection/ERC165.sol\n\n\n\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\ncontract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/ERC721.sol\n\n\n\n\n\n\n\n\n\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is Context, ERC165, IERC721 {\n    using SafeMath for uint256;\n    using Address for address;\n    using Counters for Counters.Counter;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from token ID to owner\n    mapping (uint256 => address) private _tokenOwner;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping (address => Counters.Counter) private _ownedTokensCount;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    constructor () public {\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner address to query the balance of\n     * @return uint256 representing the amount owned by the passed address\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n\n        return _ownedTokensCount[owner].current();\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _tokenOwner[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n\n        return owner;\n    }\n\n    /**\n     * @dev Approves another address to transfer the given token ID\n     * The zero address indicates there is no approved address.\n     * There can only be one approved address per token at a given time.\n     * Can only be called by the token owner or an approved operator.\n     * @param to address to be approved for the given token ID\n     * @param tokenId uint256 ID of the token to be approved\n     */\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Gets the approved address for a token ID, or zero if no address set\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to query the approval of\n     * @return address currently approved for the given token ID\n     */\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Sets or unsets the approval of a given operator\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\n     * @param to operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     */\n    function setApprovalForAll(address to, bool approved) public {\n        require(to != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][to] = approved;\n        emit ApprovalForAll(_msgSender(), to, approved);\n    }\n\n    /**\n     * @dev Tells whether an operator is approved by a given owner.\n     * @param owner owner address which you want to query the approval of\n     * @param operator operator address which you want to query the approval of\n     * @return bool whether the given operator is approved by the given owner\n     */\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Transfers the ownership of a given token ID to another address.\n     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     * Requires the msg.sender to be the owner, approved, or operator.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the _msgSender() to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransferFrom(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function _safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) internal {\n        _transferFrom(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether the specified token exists.\n     * @param tokenId uint256 ID of the token to query the existence of\n     * @return bool whether the token exists\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner = _tokenOwner[tokenId];\n        return owner != address(0);\n    }\n\n    /**\n     * @dev Returns whether the given spender can transfer a given token ID.\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     * is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Internal function to safely mint a new token.\n     * Reverts if the given token ID already exists.\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Internal function to safely mint a new token.\n     * Reverts if the given token ID already exists.\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Internal function to mint a new token.\n     * Reverts if the given token ID already exists.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _tokenOwner[tokenId] = to;\n        _ownedTokensCount[to].increment();\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use {_burn} instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == owner, \"ERC721: burn of token that is not own\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[owner].decrement();\n        _tokenOwner[tokenId] = address(0);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(uint256 tokenId) internal {\n        _burn(ownerOf(tokenId), tokenId);\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[from].decrement();\n        _ownedTokensCount[to].increment();\n\n        _tokenOwner[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * This function is deprecated.\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        internal returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n\n        bytes4 retval = IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data);\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /**\n     * @dev Private function to clear current approval of a given token ID.\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _clearApproval(uint256 tokenId) private {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n        }\n    }\n}\n\n// File: @openzeppelin/contracts/ownership/Ownable.sol\n\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: @openzeppelin/contracts/access/Roles.sol\n\n\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\n// File: contracts/testing/TokenDeed.sol\n\n\n\n\n// Used only for testing reasons\n\n// See https://github.com/ethereum/EIPs/issues/677\n\n/**\n * @title Deed to hold RIF tokens in exchange for ownership of a node\n *\n * @dev The deed can be controlled only by the registrar and can only send tokens back to the owner.\n */\ncontract TokenDeed {\n\n    address payable constant RESOURCE_POOL_ADDRESS = 0xE594DF49AA7a13ccdD2dB3A7917312E02374f744;\n    uint constant RENT_PAYMENT_TIME = 3 * 30 days; // 3 months\n    uint constant VALIDITY = 365 days; // 1 year\n\n    address public registrar;\n    address public owner;\n    address public previousOwner;\n\n    uint public creationDate;\n    uint public expirationDate;\n\tuint public tokenQuantity;\n\n\tERC677TokenContract public tokenContract;\n\n    bool active;\n\n    event OwnerChanged(address newOwner);\n    event DeedClosed();\n\n    modifier onlyRegistrar {\n        require(msg.sender == registrar);\n        _;\n    }\n\n    modifier onlyActive {\n        require(active);\n        _;\n    }\n\n    /** \n     * @dev Constructor for a TokenDeed\n     *\n     * @param _owner The deed's owner\n     * @param _tokenQuantity Amount of tokens locked in the Deed\n     * @param _tokenContract Address of the contract which handles tokens\n    **/\n    constructor(address _owner, uint _tokenQuantity, ERC677TokenContract _tokenContract) public {\n        owner = _owner;\n        registrar = msg.sender;\n        creationDate = now;\n        expirationDate = 0;\n        active = true;\n        tokenQuantity = _tokenQuantity;\n        tokenContract = _tokenContract;\n    }\n\n    function setOwner(address newOwner) public onlyRegistrar {\n        require(newOwner != address(0));\n        previousOwner = owner;  // This allows contracts to check who sent them the ownership\n        owner = newOwner;\n        emit OwnerChanged(newOwner);\n    }\n\n    function setRegistrar(address newRegistrar) public onlyRegistrar {\n        registrar = newRegistrar;\n    }\n\n    /** \n     * @dev Sets the Deed's new balance, returning the difference to the owner\n     *\n     * The new balance MUST be lower or equal than the current one\n     *\n     * @param newTokenQuantity The new balance in tokens\n     * @param throwOnFailure Flag to indicate if the token transference should throw or not\n    **/\n    function setBalance(uint newTokenQuantity, bool throwOnFailure) public onlyRegistrar onlyActive {\n        // Check if it has enough balance to set the value\n        require(tokenQuantity >= newTokenQuantity);\n        uint diffTokenQuantity = tokenQuantity - newTokenQuantity;\n        tokenQuantity = newTokenQuantity;\n        // Send the difference to the owner\n        require(tokenContract.transfer(owner, diffTokenQuantity) || !throwOnFailure);\n    }\n\n    /** \n     * @dev Computes and sets the expirationDate from a given date, starting the vigency period\n     *\n     * @param startDate Date to calculate the expirationDate from\n     * @param rentValue The value of the initial rent fee to pay in tokens\n    **/\n    function startExpiration(uint startDate, uint rentValue) public onlyRegistrar onlyActive {\n        require(expirationDate == 0 && startDate <= now); // require expiration hasn't started\n        require(rentValue <= tokenQuantity);\n\n        expirationDate = startDate + VALIDITY;\n\n        // transfer the fee to the resource pool address\n        tokenQuantity = tokenQuantity - rentValue;\n        require(tokenContract.transfer(RESOURCE_POOL_ADDRESS, rentValue));\n    }\n\n    /** \n     * @dev Pay the Deed's rent, thus extending the expirationDate and the vigency period\n     *\n     * Can only be called when the current date falls within the payment period (3 months)\n     *\n     * @param rentValue The value to pay in tokens\n    **/\n    function payRent(uint rentValue) public onlyRegistrar onlyActive returns(bool) {\n        require(canPayRent());\n        \n        require(tokenContract.transfer(RESOURCE_POOL_ADDRESS, rentValue));\n\n        expirationDate = expirationDate + VALIDITY;\n\n        return true;\n    }\n\n    /** \n     * @dev Returns wheter the current date falls within the Deed's rent payment period\n    **/\n    function canPayRent() public view returns(bool) {\n        return expirationDate - RENT_PAYMENT_TIME <= now && now <= expirationDate;\n    }\n\n\n    /** \n     * @dev Returns wether the Deed is expired or not\n    **/\n    function expired() public view returns(bool) {\n        return 0 < expirationDate && expirationDate < now;\n    }\n\n    /**\n     * @dev Close a deed and refund a specified fraction of the bid value\n     *\n     * @param refundRatio The amount*1/1000 to refund in tokens\n     */\n    function closeDeed(uint refundRatio) public onlyRegistrar onlyActive {\n        refundAndDestroy(refundRatio);\n    }\n\n    /** \n     * @dev Close an expired deed. No funds are returned\n    **/\n    function closeExpiredDeed() public onlyActive {\n        require(expired(), \"Deed should be expired\");\n        refundAndDestroy(0);\n    }\n\n    /** \n     * @dev Internal method which handles fund returns/burning and the Deed's destruction\n     *\n     * @param refundRatio The amount*1/1000 to refund in tokens\n    **/\n    function refundAndDestroy(uint refundRatio) private onlyActive {\n        require(refundRatio <= 1000);\n\n        active = false;\n        uint torefund = (1000 - refundRatio) * tokenQuantity / 1000;\n        require(tokenContract.transfer(RESOURCE_POOL_ADDRESS, torefund));\n        tokenQuantity -= torefund;\n        emit DeedClosed();\n        destroyDeed();\n    }\n\n    /**\n     * @dev Close a deed and refund a specified fraction of the bid value\n     */\n    function destroyDeed() private {\n        require(!active);\n\n        if (tokenContract.transfer(owner, tokenQuantity)) {\n            selfdestruct(RESOURCE_POOL_ADDRESS);\n        }\n    }\n\n    function tokenFallback(address from, uint256 amount, bytes memory data) public returns (bool) {\n        return true;\n    }\n}\n\n// File: contracts/testing/AbstractRNS.sol\n\n\n\n// Used only for testing reasons\n\ncontract AbstractRNS {\n    function owner(bytes32 node) public view returns(address);\n    function resolver(bytes32 node) public view returns(address);\n    function ttl(bytes32 node) public view returns(uint64);\n    function setOwner(bytes32 node, address ownerAddress) public;\n    function setSubnodeOwner(bytes32 node, bytes32 label, address ownerAddress) public;\n    function setResolver(bytes32 node, address resolverAddress) public;\n    function setTTL(bytes32 node, uint64 ttlValue) public;\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address ownerAddress);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address ownerAddress);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolverAddress);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttlValue);\n}\n\n// File: contracts/testing/RNS.sol\n\n\n\n\n// Used only for testing reasons\n\n/**\n * The RNS registry contract.\n */\ncontract RNS is AbstractRNS {\n    struct Record {\n        address owner;\n        address resolver;\n        uint64 ttl;\n    }\n\n    mapping(bytes32=>Record) records;\n\n    // Permits modifications only by the owner of the specified node.\n    modifier only_owner(bytes32 node) {\n        require(records[node].owner == msg.sender);\n        _;\n    }\n\n    /**\n     * Constructs a new RNS registrar.\n     */\n    constructor() public {\n        records[bytes32(0)].owner = msg.sender;\n    }\n\n    /**\n     * Returns the address that owns the specified node.\n     */\n    function owner(bytes32 node) public view returns (address) {\n        return records[node].owner;\n    }\n\n    /**\n     * Returns the address of the resolver for the specified node.\n     */\n    function resolver(bytes32 node) public view returns (address) {\n        return records[node].resolver;\n    }\n\n    /**\n     * Returns the TTL of a node, and any records associated with it.\n     */\n    function ttl(bytes32 node) public view returns (uint64) {\n        return records[node].ttl;\n    }\n\n    /**\n     * Transfers ownership of a node to a new address. May only be called by the current\n     * owner of the node.\n     * @param node The node to transfer ownership of.\n     * @param ownerAddress The address of the new owner.\n     */\n    function setOwner(bytes32 node, address ownerAddress) public only_owner(node) {\n        emit Transfer(node, ownerAddress);\n        records[node].owner = ownerAddress;\n    }\n\n    /**\n     * Transfers ownership of a subnode keccak256(node, label) to a new address. May only be\n     * called by the owner of the parent node.\n     * @param node The parent node.\n     * @param label The hash of the label specifying the subnode.\n     * @param ownerAddress The address of the new owner.\n     */\n    function setSubnodeOwner(bytes32 node, bytes32 label, address ownerAddress) public only_owner(node) {\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\n        emit NewOwner(node, label, ownerAddress);\n        records[subnode].owner = ownerAddress;\n\n        emit NewResolver(subnode, records[node].resolver);\n        records[subnode].resolver = records[node].resolver;\n    }\n\n    /**\n     * Sets the resolver address for the specified node.\n     * @param node The node to update.\n     * @param resolverAddress The address of the resolver.\n     */\n    function setResolver(bytes32 node, address resolverAddress) public only_owner(node) {\n        emit NewResolver(node, resolverAddress);\n        records[node].resolver = resolverAddress;\n    }\n\n    /**\n     * Sets the TTL for the specified node.\n     * @param node The node to update.\n     * @param ttlValue The TTL in seconds.\n     */\n    function setTTL(bytes32 node, uint64 ttlValue) public only_owner(node) {\n        emit NewTTL(node, ttlValue);\n        records[node].ttl = ttlValue;\n    }\n\n    /**\n     * Sets the default resolver for new nodes\n     * @param _resolver The address of the new defaultResolver\n     */\n    function setDefaultResolver(address _resolver) public only_owner(0) {\n        records[bytes32(0)].resolver = _resolver;\n    }\n}\n\n// File: contracts/testing/TokenRegistrar.sol\n\n\n\n\n/*\n\nTemporary Hash Registrar\n========================\n\nThis is a simplified version of a hash registrar. It is purporsefully limited:\nnames cannot be six letters or shorter, new auctions will stop after 4 years.\n\nThe plan is to test the basic features and then move to a new contract in at most\n2 years, when some sort of renewal mechanism will be enabled.\n\nRefund schedule\n===============\n\nCase A: Reveal Period\n------------------------------------------------------------------------------------\n| (I) Auction winner | Funds are locked in Deed. 80% are returned on Deed release  |\n------------------------------------------------------------------------------------\n| (II) Auction losser | 100% refund over the losing bid                            |\n------------------------------------------------------------------------------------\n\nCase B: Late-Reveal Period (2 weeks after auction finish)\n---------------------------------------------------------------------------------------------------\n| (I) Bid that would have won                 | 20% taken as fee                                  |\n---------------------------------------------------------------------------------------------------\n| (II) Bid that would have affected 2nd place | Difference with the actual 2nd place taken as fee |\n---------------------------------------------------------------------------------------------------\n| (III) Otherwise                             | 0.5% taken as fee                                 |\n---------------------------------------------------------------------------------------------------\n\nCase C: Any bid unsealed beyond the Late-Reveal period won't be refunded\n*/\n\n\n\n\n// Used only for testing reasons\n\n/**\n * @title TokenRegistrar\n * @dev The registrar handles the auction process for each subnode of the node it owns.\n */\ncontract TokenRegistrar {\n    using SafeMath for uint256;\n\n    RNS public rns;\n    bytes32 public rootNode;\n\tERC677TokenContract public tokenContract;\n\n    mapping (bytes32 => Entry) _entries;\n    mapping (address => mapping (bytes32 => TokenDeed)) public sealedBids;\n\n    enum Mode { Open, Auction, Owned, Forbidden, Reveal }\n\n    bytes4 constant SIGN_NEW_BID = 0x1413151f;  // sha3('newBidWithToken(address,uint256,bytes32)')\n    bytes4 constant SIGN_PAY_RENT = 0xe1ac9915; // sha3('payRentWithToken(address,uint256,bytes32)')\n    uint32 constant TOTAL_AUCTION_LENGTH = 5 days;\n    uint32 constant REVEAL_PERIOD = 48 hours;\n    uint32 constant LATE_UNSEAL_PERIOD = 15 days;\n    uint constant RELEASE_FEE_PER_MIL = 200;    // 200 of 1000 = 20%\n    uint constant MIN_TOKEN_QUANTITY = 1 * 10**18;  // 1 token\n    uint constant RENT_VALUE = 1 * 10**18;  // 1 token\n\n    event AuctionStarted(bytes32 indexed hash, uint registrationDate);\n    event NewBid(bytes32 indexed hash, address indexed bidder, uint deposit);\n    event BidRevealed(bytes32 indexed hash, address indexed owner, uint value, uint8 status);\n    event HashRegistered(bytes32 indexed hash, address indexed owner, uint value, uint registrationDate);\n    event HashReleased(bytes32 indexed hash, uint value);\n\n    struct Entry {\n        TokenDeed deed;\n        uint registrationDate;\n        uint value;\n        uint highestBid;\n    }\n\n    modifier inState(bytes32 _hash, Mode _state) {\n        require(state(_hash) == _state);\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _hash) {\n        require(state(_hash) == Mode.Owned && msg.sender == _entries[_hash].deed.owner());\n        _;\n    }\n\n    modifier registryOpen() {\n        require(rns.owner(rootNode) == address(this));\n        _;\n    }\n\n    /**\n     * @dev Constructs a new Registrar, with the provided address as the owner of the root node.\n     *\n     * @param _rns The address of the RNS\n     * @param _rootNode The hash of the rootnode.\n     * @param _tokenAddr The ERC677 contract address to handle tokens\n     */\n    constructor(RNS _rns, bytes32 _rootNode, ERC677TokenContract _tokenAddr) public {\n        rns = _rns;\n        rootNode = _rootNode;\n        tokenContract = _tokenAddr;\n    }\n\n    /**\n     * @dev Start an auction for an available hash\n     *\n     * @param _hash The hash to start an auction on\n     */\n    function startAuction(bytes32 _hash) public registryOpen() {\n        Mode mode = state(_hash);\n        if (mode == Mode.Auction) return;\n        require(mode == Mode.Open);\n\n        Entry storage newAuction = _entries[_hash];\n        newAuction.registrationDate = now + TOTAL_AUCTION_LENGTH;\n        newAuction.value = 0;\n        newAuction.highestBid = 0;\n        newAuction.deed = TokenDeed(0);\n\n        emit AuctionStarted(_hash, newAuction.registrationDate);\n    }\n\n    /**\n     * @dev Start multiple auctions for better anonymity\n     *\n     * Anyone can start an auction by sending an array of hashes that they want to bid for.\n     * Arrays are sent so that someone can open up an auction for X dummy hashes when they\n     * are only really interested in bidding for one. This will increase the cost for an\n     * attacker to simply bid blindly on all new auctions. Dummy auctions that are\n     * open but not bid on are closed after a week.\n     *\n     * @param _hashes An array of hashes, at least one of which you presumably want to bid on\n     */\n    function startAuctions(bytes32[] memory _hashes) public {\n        for (uint i = 0; i < _hashes.length; i ++) {\n            startAuction(_hashes[i]);\n        }\n    }\n\n    /**\n     * @dev Submit a new sealed bid on a desired hash in a blind auction\n     *\n     * Bids are sent by sending a message to the main contract with a hash and an amount. The hash\n     * contains information about the bid, including the bidded hash, the bid amount, and a random\n     * salt. Bids are not tied to any one auction until they are revealed. The value of the bid\n     * itself can be masqueraded by sending more than the value of your actual bid. This is\n     * followed by a 48h reveal period. For bids revealed after this period, a percentage (defined in the late unsealing \n     * Refund schedule) will be sent to a special resource pool address.\n     * Since this is an auction, it is expected that most public hashes, like known domains and common dictionary\n     * words, will have multiple bidders pushing the price up.\n     *\n     * This method requires the sender to approve the Registrar to use the specified tokenQuantity in the ERC677 contract.\n     * Otherwise it can be done through the tokenFallback after a transfer with the corresponding parameters\n     *\n     * @param _sealedBid A sealedBid, created by the shaBid function\n     * @param _tokenQuantity token quantity to bid\n     */\n    function newBid(bytes32 _sealedBid, uint _tokenQuantity) public {\n        require(tokenContract.transferFrom(msg.sender, address(this), _tokenQuantity));\n\n        newBidAfterTransfer(msg.sender, _tokenQuantity, _sealedBid);\n    }\n\n    /**\n     * @dev Method to be called through a dynamic invocation from an ERC677 token contract\n     *\n     * @param _from Address sending the tokens as well as submitting the bid\n     * @param _tokenQuantity Amount in tokens received throuh the transference\n     * @param _sealedBid Sealed bid, created through the shaBid function\n    **/\n    function newBidWithToken(address _from, uint _tokenQuantity, bytes32 _sealedBid) public {\n        require(msg.sender == address(tokenContract));\n        newBidAfterTransfer(_from, _tokenQuantity, _sealedBid);\n    }\n\n    /**\n     * @dev Internal method which handles the new bidding logic\n     *\n     * @param _from Address sending the tokens as well as submitting the bid\n     * @param _tokenQuantity Amount in tokens received through the transference. To be used to mask the actual bidded value\n     * @param _sealedBid Sealed bid, created through the shaBid function\n    **/\n    function newBidAfterTransfer(address _from, uint _tokenQuantity, bytes32 _sealedBid) private {\n        require(address(sealedBids[_from][_sealedBid]) == address(0));\n\n        // Creates a new hash contract with the owner\n        TokenDeed createdBid = new TokenDeed(_from, _tokenQuantity, tokenContract);\n        require(tokenContract.transfer(address(createdBid), _tokenQuantity));\n        sealedBids[_from][_sealedBid] = createdBid;\n\n        emit NewBid(_sealedBid, _from, _tokenQuantity);\n    }\n\n    /**\n     * @dev Start a set of auctions and bid on one of them\n     *\n     * This method functions identically to calling `startAuctions` followed by `newBid`,\n     * but all in one transaction.\n     *\n     * @param _hashes A list of hashes to start auctions on.\n     * @param _sealedBid A sealed bid for one of the auctions.\n     * @param _tokenQuantity Amount of tokens to mask the bid with.\n     */\n    function startAuctionsAndBid(bytes32[] memory _hashes, bytes32 _sealedBid, uint _tokenQuantity) public payable {\n        startAuctions(_hashes);\n        newBid(_sealedBid, _tokenQuantity);\n    }\n\n    /**\n     * @dev Submit the properties of a bid to reveal them\n     *\n     * @param _hash The node in the sealedBid\n     * @param _value The bid amount in the sealedBid\n     * @param _salt The sale in the sealedBid\n     */\n    function unsealBid(bytes32 _hash, uint _value, bytes32 _salt) public {\n        bytes32 seal = shaBid(_hash, msg.sender, _value, _salt);\n        TokenDeed bid = sealedBids[msg.sender][seal];\n        require(address(bid) != address(0));\n\n        sealedBids[msg.sender][seal] = TokenDeed(0);\n        Entry storage h = _entries[_hash];\n        uint value = min(_value, bid.tokenQuantity());\n        bid.setBalance(value, true);\n\n        Mode auctionState = state(_hash);\n\n        if (auctionState == Mode.Owned) {\n            // By this point the auction has ended. The refund values are defined in the above Refund Schedule\n\n            uint256 refundRatio = 995; // See: Case B)III\n\n            if (h.registrationDate + LATE_UNSEAL_PERIOD < now) {\n                refundRatio = 0; // See: Case C\n            } else {\n                if (value > h.highestBid) {\n                    refundRatio = 800; // See: Case B)I\n                } else if (value > h.value) {\n                    // See: Case B)II\n                    // Compute percentage corresponding to the difference between the actual 2nd place (h.value)\n                    // and the late unsealed bid (value)\n                    refundRatio = h.value.mul(1000).div(value);\n                }\n            }\n\n            bid.closeDeed(refundRatio);\n            emit BidRevealed(_hash, msg.sender, value, 1);\n        } else if (auctionState != Mode.Reveal) {\n            // invalid phase for unsealing\n            revert();\n        } else if (value < MIN_TOKEN_QUANTITY || bid.creationDate() > h.registrationDate - REVEAL_PERIOD) {\n            // Bid below the minimum or too late (created in the reveal period)\n            bid.closeDeed(1000);\n            emit BidRevealed(_hash, msg.sender, value, 0);\n        } else if (value > h.highestBid) {\n            // New winner\n            // Cancel the other bid\n            if (address(h.deed) != address(0)) {\n                TokenDeed previousWinner = h.deed;\n                previousWinner.closeDeed(1000);\n            }\n\n            // Set new winner\n            // Per the rules of a vickery auction, the value becomes the previous highestBid\n            h.value = h.highestBid;  // will be zero if there's only 1 bidder\n            h.highestBid = value;\n            h.deed = bid;\n            emit BidRevealed(_hash, msg.sender, value, 2);\n        } else if (value > h.value) {\n            // Not winner, but affects second place\n            h.value = value;\n            bid.closeDeed(1000);\n            emit BidRevealed(_hash, msg.sender, value, 3);\n        } else {\n            // Bid doesn't affect auction\n            bid.closeDeed(1000);\n            emit BidRevealed(_hash, msg.sender, value, 4);\n        }\n    }\n\n    /**\n     * @dev Finalize an auction after the registration date has passed\n     *\n     * Updates the Registry to reflect the new node owner. Starts the winning Deed's expiration period.\n     *\n     * @param _hash The hash of the name the auction is for\n     */\n    function finalizeAuction(bytes32 _hash) public onlyOwner(_hash) {\n        Entry storage h = _entries[_hash];\n\n        // Handles the case when there's only a single bidder (h.value is zero)\n        h.value = max(h.value, MIN_TOKEN_QUANTITY);\n        h.deed.setBalance(h.value, true);\n        h.deed.startExpiration(h.registrationDate, RENT_VALUE);\n\n        trySetSubnodeOwner(_hash, h.deed.owner());\n        emit HashRegistered(_hash, h.deed.owner(), h.value, h.registrationDate);\n    }\n\n    /**\n     * @dev The owner of a domain may transfer it to someone else at any time.\n     *\n     * @param _hash The node to transfer\n     * @param _newOwner The address to transfer ownership to\n     */\n    function transfer(bytes32 _hash, address _newOwner) public onlyOwner(_hash) {\n        require(_newOwner != address(0));\n\n        Entry storage h = _entries[_hash];\n        h.deed.setOwner(_newOwner);\n        trySetSubnodeOwner(_hash, _newOwner);\n    }\n\n    /**\n     * @dev After some time, or if we're no longer the registrar, the owner can release\n     *      the name and get a part of their tokens back.\n     *\n     * The allowed release period is within the rent payment period, which starts 3 months before the expiration date\n     *\n     * @param _hash The node to release\n     */\n    function releaseDeed(bytes32 _hash) public onlyOwner(_hash) {\n        Entry storage h = _entries[_hash];\n        TokenDeed deedContract = h.deed;\n\n        require(now < deedContract.expirationDate() || rns.owner(rootNode) != address(this));\n\n        h.value = 0;\n        h.highestBid = 0;\n        h.deed = TokenDeed(0);\n\n        _tryEraseSingleNode(_hash);\n\n        // return funds after deducting a fee and close the deed\n        deedContract.closeDeed(1000 - RELEASE_FEE_PER_MIL);\n\n        emit HashReleased(_hash, h.value);\n    }\n\n    /**\n     * @dev Allows anyone to delete the owner and resolver records for a (subdomain of) a\n     *      name that is not currently owned in the registrar. If passing, eg, 'foo.bar.rsk',\n     *      the owner and resolver fields on 'foo.bar.rsk' and 'bar.rsk' will all be cleared.\n     *\n     * @param _labels A series of label hashes identifying the name to zero out, rooted at the\n     *        registrar's root. Must contain at least one element. For instance, to zero\n     *        'foo.bar.rsk' on a registrar that owns '.rsk', pass an array containing\n     *        [keccak256('foo'), keccak256('bar')].\n     */\n    function eraseNode(bytes32[] memory _labels) public {\n        require(_labels.length != 0);\n        require(state(_labels[_labels.length - 1]) != Mode.Owned);\n\n        _eraseNodeHierarchy(_labels.length - 1, _labels, rootNode);\n    }\n\n    /**\n     * @dev Transfers the deed to the current registrar, if different from this one.\n     *\n     * Used during the upgrade process to a permanent registrar.\n     *\n     * @param _hash The name hash to transfer.\n     */\n    function transferRegistrars(bytes32 _hash) public onlyOwner(_hash) {\n        address registrar = rns.owner(rootNode);\n        require(registrar != address(this));\n\n        // Migrate the deed\n        Entry storage h = _entries[_hash];\n        h.deed.setRegistrar(registrar);\n\n        // Call the new registrar to accept the transfer\n        TokenRegistrar(registrar).acceptRegistrarTransfer(_hash, h.deed, h.registrationDate);\n\n        // Zero out the Entry\n        h.deed = TokenDeed(0);\n        h.registrationDate = 0;\n        h.value = 0;\n        h.highestBid = 0;\n    }\n\n    /**\n     * @dev Pay the yearly rent for a name\n     *\n     * Names have a vigency of 1 year after the registration date. Said expiry date is reflected through the associated Deed \n     * contract. Owners have a period of 3 months before the expiryDate to pay the rent and extend their ownership for 1 year\n     *\n     * @param _hash The hash of the name to pay the rent for\n     */\n    function payRent(bytes32 _hash) public {\n        require(tokenContract.transferFrom(msg.sender, address(this), RENT_VALUE));\n        payRentAfterTransfer(_hash);\n    }\n\n    /**\n     * @dev Method to be called through a dynamic invocation from an ERC677 token contract\n     *\n     * @param _from Address sending the tokens as well as submitting the bid\n     * @param _tokenQuantity Amount in tokens received throuh the transference\n     * @param _hash Hash of the name to pay the rent for\n    **/\n    function payRentWithToken(address _from, uint _tokenQuantity, bytes32 _hash) public {\n        require(_tokenQuantity == RENT_VALUE);\n        require(msg.sender == address(tokenContract));\n        payRentAfterTransfer(_hash);\n    }\n\n    /**\n     * @dev Internal method which handles the rent payment logic\n     *\n     * @param _hash Hash of the name to pay the rent for\n    **/\n    function payRentAfterTransfer(bytes32 _hash) private {\n        require(state(_hash) == Mode.Owned);\n\n        Entry storage h = _entries[_hash];\n\n        require(address(h.deed) != address(0));\n\n        require(tokenContract.transfer(address(h.deed), RENT_VALUE));\n        require(h.deed.payRent(RENT_VALUE));\n    }\n\n    /**\n     * @dev Accepts a transfer from a previous registrar; stubbed out here since there\n     *      is no previous registrar implementing this interface.\n     *\n     * @param _hash The sha3 hash of the label to transfer.\n     * @param _deed The TokenDeed object for the name being transferred in.\n     * @param _registrationDate The date at which the name was originally registered.\n     */\n    function acceptRegistrarTransfer(bytes32 _hash, TokenDeed _deed, uint _registrationDate) public {\n        _hash; _deed; _registrationDate; // Don't warn about unused variables\n    }\n\n    // State transitions for names:\n    //   Open -> Auction (startAuction)\n    //   Auction -> Reveal\n    //   Reveal -> Owned\n    //   Reveal -> Open (if nobody bid)\n    //   Owned -> Open (releaseDeed or the deed has expired)\n    function state(bytes32 _hash) public view returns (Mode) {\n        Entry storage entry = _entries[_hash];\n\n        if (now < entry.registrationDate) {\n            if (now < entry.registrationDate - REVEAL_PERIOD) {\n                return Mode.Auction;\n            } else {\n                return Mode.Reveal;\n            }\n        } else {\n            // there may not be any bid (not yet auctioned) or there is and it may have already expired (Expired)\n            if (entry.highestBid == 0 || entry.deed.expired()) {\n                return Mode.Open;\n            } else {\n                return Mode.Owned;\n            }\n        }\n    }\n\n    /**\n     * @dev Returns information related to a certain name\n     *\n     * @param _hash Hash of the name to query about\n    **/\n    function entries(bytes32 _hash) public view returns (Mode, address, uint, uint, uint) {\n        Entry storage h = _entries[_hash];\n        return (state(_hash), address(h.deed), h.registrationDate, h.value, h.highestBid);\n    }\n\n    /**\n     * @dev Hash the values required for a secret bid\n     *\n     * @param _hash The node corresponding to the desired namehash\n     * @param _value The bid amount in tokens\n     * @param _salt A random value to ensure secrecy of the bid\n     * @return The hash of the bid values\n     */\n    function shaBid(bytes32 _hash, address _owner, uint _value, bytes32 _salt) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_hash, _owner, _value, _salt));\n    }\n\n    function _tryEraseSingleNode(bytes32 _label) internal {\n        if (rns.owner(rootNode) == address(this)) {\n            rns.setSubnodeOwner(rootNode, _label, address(this));\n            bytes32 node = keccak256(abi.encodePacked(rootNode, _label));\n            rns.setResolver(node, address(0));\n            rns.setOwner(node, address(0));\n        }\n    }\n\n    function _eraseNodeHierarchy(uint _idx, bytes32[] memory _labels, bytes32 _node) internal {\n        // Take ownership of the node\n        rns.setSubnodeOwner(_node, _labels[_idx], address(this));\n        _node = keccak256(abi.encodePacked(_node, _labels[_idx]));\n\n        // Recurse if there are more labels\n        if (_idx > 0) {\n            _eraseNodeHierarchy(_idx - 1, _labels, _node);\n        }\n\n        // Erase the resolver and owner records\n        rns.setResolver(_node, address(0));\n        rns.setOwner(_node, address(0));\n    }\n\n    /**\n     * @dev Assign the owner in RNS, if we're still the registrar\n     *\n     * @param _hash hash to change owner\n     * @param _newOwner new owner to transfer to\n     */\n    function trySetSubnodeOwner(bytes32 _hash, address _newOwner) internal {\n        if (rns.owner(rootNode) == address(this))\n            rns.setSubnodeOwner(rootNode, _hash, _newOwner);\n    }\n\n    /**\n     * @dev Returns the maximum of two unsigned integers\n     *\n     * @param a A number to compare\n     * @param b A number to compare\n     * @return The maximum of two unsigned integers\n     */\n    function max(uint a, uint b) internal pure returns (uint) {\n        if (a > b)\n            return a;\n        else\n            return b;\n    }\n\n    /**\n     * @dev Returns the minimum of two unsigned integers\n     *\n     * @param a A number to compare\n     * @param b A number to compare\n     * @return The minimum of two unsigned integers\n     */\n    function min(uint a, uint b) internal pure returns (uint) {\n        if (a < b)\n            return a;\n        else\n            return b;\n    }\n\n    /**\n     * @dev Fallback function to be called when the contract receives a transference through an ERC677 contract\n     *\n     * Functions supported:\n     * - newBidWithToken (signature 0x1413151f) with a 32 byte parameter (sealedBid to submit)\n     * - payRentWithToken (signature 0xe1ac9915) with a 32 byte parameter (hash of the name to pay the rent for)\n     *\n     * @param _from Address which sent the tokens\n     * @param _value Amount of tokens sent\n     * @param _data Byte array with information of which function to call and the parameters used for the invocation\n    **/\n    function tokenFallback(address _from, uint256 _value, bytes memory _data) public returns (bool) {\n        if (_data.length < 4) return true;\n\n        require(msg.sender == address(tokenContract));\n\n        bytes4 signature =  bytesToBytes4(_data, 0);\n\n        if (signature == SIGN_NEW_BID) {\n            bytes32 sealedBid = bytesToBytes32(_data, 4);\n\n            newBidWithToken(_from, _value, sealedBid);\n        } else if (signature == SIGN_PAY_RENT) {\n            bytes32 name = bytesToBytes32(_data, 4);\n\n            payRentWithToken(_from, _value, name);\n        } else {\n            revert();\n        }\n\n        return true;\n    }\n\n    function bytesToBytes4(bytes memory _b, uint _offset) private pure returns (bytes4) {\n        bytes4 out;\n\n        for (uint i = 0; i < 4; i++) {\n            out |= bytes4(_b[_offset + i] & 0xFF) >> (i * 8);\n        }\n\n        return out;\n    }\n\n    /**\n     * @dev Given a byte array and a given offset, extract the following 32 bytes into an array\n     *\n     * from https://ethereum.stackexchange.com/questions/7702/how-to-convert-byte-array-to-bytes32-in-solidity\n    **/\n    function bytesToBytes32(bytes memory _b, uint _offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        for (uint i = 0; i < 32; i++) {\n            out |= bytes32(_b[_offset + i] & 0xFF) >> (i * 8);\n        }\n\n        return out;\n    }\n}\n\n// File: contracts/RSKOwner.sol\n\n\n\n\n\n\n\n\n\ncontract RSKOwner is ERC721, Ownable {\n    using Roles for Roles.Role;\n\n    TokenRegistrar private previousRegistrar;\n    AbstractRNS private rns;\n    bytes32 private rootNode;\n\n    Roles.Role registrars;\n    Roles.Role renewers;\n\n    mapping (uint256 => uint) public expirationTime;\n\n    event ExpirationChanged(uint256 tokenId, uint expirationTime);\n\n    modifier onlyPreviousRegistrar {\n        require(msg.sender == address(previousRegistrar), \"Only previous registrar.\");\n        _;\n    }\n\n    modifier onlyRegistrar {\n        require(registrars.has(msg.sender), \"Only registrar.\");\n        _;\n    }\n\n    modifier onlyRenewer {\n        require(renewers.has(msg.sender), \"Only renewer.\");\n        _;\n    }\n\n    constructor (\n        TokenRegistrar _previousRegistrar,\n        AbstractRNS _rns,\n        bytes32 _rootNode\n    ) public {\n        previousRegistrar = _previousRegistrar;\n        rns = _rns;\n        rootNode = _rootNode;\n    }\n\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        require(expirationTime[tokenId] > now, \"ERC721: owner query for nonexistent token\");\n        return super.ownerOf(tokenId);\n    }\n\n    function available(uint256 tokenId) public view returns(bool) {\n        return (\n            expirationTime[tokenId] < now &&\n            previousRegistrar.state(bytes32(tokenId)) != TokenRegistrar.Mode.Owned\n        );\n    }\n\n    // Auction migration\n    function acceptRegistrarTransfer(bytes32 label, TokenDeed deed, uint) external onlyPreviousRegistrar {\n        uint256 tokenId = uint256(label);\n        expirationTime[tokenId] = deed.expirationDate();\n        _mint(deed.owner(), tokenId);\n        deed.closeDeed(1000);\n    }\n\n    // Registrar role\n    function addRegistrar(address registrar) external onlyOwner {\n        registrars.add(registrar);\n    }\n\n    function isRegistrar(address registrar) external view returns (bool) {\n        return registrars.has(registrar);\n    }\n\n    function removeRegistrar(address registrar) external onlyOwner {\n        registrars.remove(registrar);\n    }\n\n    // Registration\n    function register(bytes32 label, address tokenOwner, uint duration) external onlyRegistrar {\n        uint256 tokenId = uint256(label);\n\n        require(available(tokenId), \"Not available\");\n\n        uint newExpirationTime = now.add(duration);\n        expirationTime[tokenId] = newExpirationTime;\n        emit ExpirationChanged(tokenId, newExpirationTime);\n\n        if (_exists(tokenId))\n            _burn(tokenId);\n\n        _mint(tokenOwner, tokenId);\n\n        rns.setSubnodeOwner(rootNode, label, tokenOwner);\n    }\n\n    // Reclaim\n    function reclaim(uint256 id, address newOwner) external {\n        require(_isApprovedOrOwner(msg.sender, id), \"Not approved or owner\");\n        rns.setSubnodeOwner(rootNode, bytes32(id), newOwner);\n    }\n\n    // Renewer role\n    function addRenewer(address renewer) external onlyOwner {\n        renewers.add(renewer);\n    }\n\n    function isRenewer(address renewer) external view returns (bool) {\n        return renewers.has(renewer);\n    }\n\n    function removeRenewer(address renewer) external onlyOwner {\n        renewers.remove(renewer);\n    }\n\n    // Renovation\n    function renew (bytes32 label, uint time) external onlyRenewer {\n        uint256 tokenId = uint256(label);\n        require(expirationTime[tokenId] > now, \"Name already expired\");\n        uint newExpirationTime = expirationTime[tokenId].add(time);\n        expirationTime[tokenId] = newExpirationTime;\n        emit ExpirationChanged(tokenId, newExpirationTime);\n    }\n\n    // After expiration\n    function removeExpired(uint256[] calldata tokenIds) external {\n        uint256 tokenId;\n        bytes32 label;\n\n        for (uint i = 0; i < tokenIds.length; i++) {\n            tokenId = tokenIds[i];\n\n            if (_exists(tokenId) && available(tokenId)) {\n                expirationTime[tokenId] = ~uint(0);\n                _burn(tokenId);\n                expirationTime[tokenId] = 0;\n\n                label = bytes32(tokenId);\n                rns.setSubnodeOwner(rootNode, label, address(0));\n            }\n        }\n    }\n\n    // rsk admin\n    function setRootResolver (address resolver) external onlyOwner {\n        rns.setResolver(rootNode, resolver);\n    }\n\n    function setRootTTL (uint64 ttl) external onlyOwner {\n        rns.setTTL(rootNode, ttl);\n    }\n}\n\n// File: contracts/AbstractNamePrice.sol\n\n\n\n/// @title NamePrice interface\n/// @author Javier Esses\n/// @notice Defines an interface for name price calculations\ncontract AbstractNamePrice {\n    function price (string calldata name, uint expires, uint duration) external view returns(uint);\n}\n\n// File: contracts/PricedContract.sol\n\n\n\n\n\ncontract PricedContract is Ownable {\n    AbstractNamePrice public namePrice;\n\n    event NamePriceChanged(AbstractNamePrice contractAddress);\n\n    constructor(AbstractNamePrice _namePrice) public Ownable() {\n        namePrice = _namePrice;\n    }\n\n    /// @notice Change price contract\n    /// @dev Only owner\n    /// @param newNamePrice The new maturity required\n    function setNamePrice(AbstractNamePrice newNamePrice) external onlyOwner {\n        namePrice = newNamePrice;\n        emit NamePriceChanged(newNamePrice);\n    }\n\n    /// @notice Price of a name in RIF\n    /// @param duration Time to register the name\n    /// @return cost in RIF\n    function price (string memory name, uint expires, uint duration) public view returns(uint) {\n        return namePrice.price(name, expires, duration);\n    }\n}\n\n// File: @ensdomains/ethregistrar/contracts/StringUtils.sol\n\n\n\nlibrary StringUtils {\n    /**\n     * @dev Returns the length of a given string\n     *\n     * @param s The string to measure the length of\n     * @return The length of the input string\n     */\n    function strlen(string memory s) internal pure returns (uint) {\n        uint len;\n        uint i = 0;\n        uint bytelength = bytes(s).length;\n        for(len = 0; i < bytelength; len++) {\n            byte b = bytes(s)[i];\n            if(b < 0x80) {\n                i += 1;\n            } else if (b < 0xE0) {\n                i += 2;\n            } else if (b < 0xF0) {\n                i += 3;\n            } else if (b < 0xF8) {\n                i += 4;\n            } else if (b < 0xFC) {\n                i += 5;\n            } else {\n                i += 6;\n            }\n        }\n        return len;\n    }\n}\n\n// File: contracts/testing/ERC677Receiver.sol\n\n\n\ncontract ERC677Receiver {\n    function tokenFallback(address from, uint value, bytes calldata data) external returns (bool);\n}\n\n// File: contracts/BytesUtils.sol\n\n\n\n\nlibrary BytesUtils {\n    using SafeMath for uint256;\n\n    modifier minLength (uint size, uint offset, uint length) {\n        require(size >= offset.add(length), \"Short input\");\n        _;\n    }\n\n    function toBytes32 (bytes memory input, uint offset) public view minLength(input.length, offset, 32) returns (bytes32) {\n        bytes32 output;\n\n        assembly {\n            output := mload(add(add(input, 0x20), offset))\n        }\n\n        return output;\n    }\n\n    function toBytes4 (bytes memory input, uint offset) public view minLength(input.length, offset, 4) returns (bytes4) {\n        bytes4 output;\n\n        assembly {\n            output := mload(add(add(input, 0x20), offset))\n        }\n\n        return output;\n    }\n\n    function toUint (bytes memory input, uint offset) public view returns (uint) {\n        return uint(toBytes32(input, offset));\n    }\n\n    // source: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n    function toString (bytes memory input, uint offset, uint strLength) public view minLength(input.length, offset, strLength) returns (string memory) {\n        bytes memory output;\n\n        assembly {\n            switch iszero(strLength)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                output := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(strLength, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(output, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, strLength)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(input, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(output, strLength)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                output := mload(0x40)\n\n                mstore(0x40, add(output, 0x20))\n            }\n        }\n\n        return string(output);\n    }\n\n    function toAddress (bytes memory input, uint offset) public view minLength(input.length, offset, 20) returns (address) {\n        bytes20 output;\n\n        assembly {\n            output := mload(add(add(input, 0x20), offset))\n        }\n\n        return address(output);\n    }\n}\n\n// File: contracts/FIFSRegistrar.sol\n\n\n\n/// @title First-in first-served registrar\n/// @notice You can use this contract to register .rsk names in RNS.\n/// First make a commitment of the name to be registered, wait 1\n/// minute, and proceed to register the name.\n/// @dev This contract has permission to register in RSK Owner\ncontract FIFSRegistrar is PricedContract, ERC677Receiver {\n    using SafeMath for uint256;\n    using StringUtils for string;\n    using BytesUtils for bytes;\n\n    mapping (bytes32 => uint) private commitmentRevealTime;\n    uint public minCommitmentAge = 1 minutes;\n\n    uint public minLength = 5;\n\n    ERC677TokenContract rif;\n    RSKOwner rskOwner;\n    address pool;\n\n    // sha3('register(string,address,bytes32,uint)')\n    bytes4 constant REGISTER_SIGNATURE = 0xc2c414c8;\n\n    constructor (\n        ERC677TokenContract _rif,\n        RSKOwner _rskOwner,\n        address _pool,\n        AbstractNamePrice _namePrice\n    ) public PricedContract(_namePrice) {\n        rif = _rif;\n        rskOwner = _rskOwner;\n        pool = _pool;\n    }\n\n    /// @notice Create a commitment for register action\n    /// @dev Don't use this method on-chain when commiting\n    /// @param label keccak256 of the name to be registered\n    /// @param nameOwner Owner of the name to be registered\n    /// @param secret Secret to protect the name to be registered\n    /// @return The commitment hash\n    function makeCommitment (bytes32 label, address nameOwner, bytes32 secret) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(label, nameOwner, secret));\n    }\n\n    /// @notice Commit before registring a name\n    /// @dev A valid commitment can be calculated using makeCommitment off-chain\n    /// @param commitment A valid commitment hash\n    function commit(bytes32 commitment) external {\n        require(commitmentRevealTime[commitment] < 1, \"Existent commitment\");\n        commitmentRevealTime[commitment] = now.add(minCommitmentAge);\n    }\n\n    /// @notice Ensure the commitment is ready to be revealed\n    /// @param commitment Commitment to be queried\n    /// @return Wether the commitment can be revealed or not\n    function canReveal(bytes32 commitment) public view returns (bool) {\n        uint revealTime = commitmentRevealTime[commitment];\n        return 0 < revealTime && revealTime <= now;\n    }\n\n    /// @notice Registers a .rsk name in RNS\n    /// @dev This method must be called after commiting\n    /// @param name The name to register\n    /// @param nameOwner The owner of the name to regiter\n    /// @param secret The secret used to make the commitment\n    /// @param duration Time to register in years\n    function register(string calldata name, address nameOwner, bytes32 secret, uint duration) external {\n        uint cost = executeRegistration(name, nameOwner, secret, duration);\n        require(rif.transferFrom(msg.sender, pool, cost), \"Token transfer failed\");\n    }\n\n    /// @notice Change required commitment maturity\n    /// @dev Only owner\n    /// @param newMinCommitmentAge The new maturity required\n    function setMinCommitmentAge (uint newMinCommitmentAge) external onlyOwner {\n        minCommitmentAge = newMinCommitmentAge;\n    }\n\n    /// @notice Change disbaled names\n    /// @dev Only owner\n    /// @param newMinLength The new minimum length enabled\n    function setMinLength (uint newMinLength) external onlyOwner {\n        minLength = newMinLength;\n    }\n\n    function registerWithToken(string memory name, address nameOwner, bytes32 secret, uint duration, address from, uint amount) private {\n        uint cost = executeRegistration(name, nameOwner, secret, duration);\n        require(amount >= cost, \"Not enough tokens\");\n        require(rif.transfer(pool, cost), \"Token transfer failed\");\n        // Calculated twise because the common case is the exact amount is sent. No variables.\n        if (amount.sub(cost) > 0)\n            require(rif.transfer(from, amount.sub(cost)), \"Token transfer failed\");\n    }\n\n    /// @notice Executes registration without any payments.\n    /// @dev This method is used to abstract from payment method.\n    /// @param name The name to register\n    /// @param nameOwner The owner of the name to regiter\n    /// @param secret The secret used to make the commitment\n    /// @param duration Time to register in years\n    /// @return price Price of the name to register\n    function executeRegistration (string memory name, address nameOwner, bytes32 secret, uint duration) private returns (uint) {\n        bytes32 label = keccak256(abi.encodePacked(name));\n\n        require(name.strlen() >= minLength, \"Short names not available\");\n\n        bytes32 commitment = makeCommitment(label, nameOwner, secret);\n        require(canReveal(commitment), \"No commitment found\");\n        commitmentRevealTime[commitment] = 0;\n\n        rskOwner.register(label, nameOwner, duration.mul(365 days));\n\n        return price(name, rskOwner.expirationTime(uint(label)), duration);\n    }\n\n    /**\n        Register encoding:\n        | signature | 4 bytes - offset 0\n        | owner | 20 bytes - offset 4\n        | secret | 32 bytes - offest 24\n        | duration | 32 bytes - offset 56\n        | name | variable size - offset 88\n     */\n\n    /// @notice ERC-677 token fallback function\n    /// @dev Follow 'Register encoding' to execute a one-transaction regitration.\n    /// @param from token sender\n    /// @param value amount of tokens sent\n    /// @param data data associated with transaction\n    /// @return true if successfull\n    function tokenFallback(address from, uint value, bytes calldata data) external returns (bool) {\n        require(msg.sender == address(rif), \"Only RIF token\");\n        require(data.length > 88, \"Invalid data\");\n\n        bytes4 signature = data.toBytes4(0);\n\n        require(signature == REGISTER_SIGNATURE, \"Invalid signature\");\n\n        address nameOwner = data.toAddress(4);\n        bytes32 secret = data.toBytes32(24);\n        uint duration = data.toUint(56);\n        string memory name = data.toString(88, data.length.sub(88));\n\n        registerWithToken(name, nameOwner, secret, duration, from, value);\n\n        return true;\n    }\n}\n",
      "file": "FIFSRegistrar.sol"
    }
  ],
  "libraries": {
    "BytesUtils": "0xe9e32c20cbce0ad4f16377bd9a84554828e86a06"
  },
  "creationData": {
    "blockHash": "0xf01fee1d508390751f44d0a321902e8a9ca1c8326a99b777462ca8211c34a7d3",
    "blockNumber": 1891406,
    "transactionHash": "0xf9c26fbe4c23f6b6428b1c47a807333f767227ddaed161fb3538ff18777e919a",
    "timestamp": 1574370984
  },
  "constructorArguments": [
    "0x2acc95758f8b5f583470ba265eb685a8f45fc9d5",
    "0x45d3e4fb311982a06ba52359d44cb4f5980e0ef1",
    "0x39e00d2616e792f50ddd33bbe46e8bf55eadebee",
    "0xd09adf13e482928e47e96dd6f02aad1daf7a5a47"
  ]
}