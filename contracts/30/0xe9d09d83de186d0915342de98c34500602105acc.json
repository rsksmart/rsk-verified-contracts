{
    "address": "0xe9d09d83de186d0915342de98c34500602105acc",
    "net": {
        "id": "30",
        "name": "RSK Mainnet"
    },
    "name": "RBTCWrapperProxy",
    "settings": {
        "optimizer": {
            "enabled": false,
            "runs": 200
        }
    },
    "version": "0.5.16+commit.9c3226ce",
    "source": "pragma solidity >=0.5.0 <0.6.0;\n\n/*\n    Owned contract interface\n*/\ncontract IOwned {\n\t// this function isn't abstract since the compiler emits automatically generated getter functions as external\n\tfunction owner() public view returns (address) {\n\t\tthis;\n\t}\n\n\tfunction transferOwnership(address _newOwner) public;\n\n\tfunction acceptOwnership() public;\n}\n\n\n/*\n    ERC20 Standard Token interface\n*/\ncontract IERC20Token {\n\t// these functions aren't abstract since the compiler emits automatically generated getter functions as external\n\tfunction name() public view returns (string memory) {\n\t\tthis;\n\t}\n\n\tfunction symbol() public view returns (string memory) {\n\t\tthis;\n\t}\n\n\tfunction decimals() public view returns (uint8) {\n\t\tthis;\n\t}\n\n\tfunction totalSupply() public view returns (uint256) {\n\t\tthis;\n\t}\n\n\tfunction balanceOf(address _owner) public view returns (uint256) {\n\t\t_owner;\n\t\tthis;\n\t}\n\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n\t\t_owner;\n\t\t_spender;\n\t\tthis;\n\t}\n\n\tfunction transfer(address _to, uint256 _value) public returns (bool success);\n\n\tfunction transferFrom(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _value\n\t) public returns (bool success);\n\n\tfunction approve(address _spender, uint256 _value) public returns (bool success);\n}\n\n\n\n\n\n\n\n\n/*\n    Token Holder interface\n*/\ncontract ITokenHolder is IOwned {\n\tfunction withdrawTokens(\n\t\tIERC20Token _token,\n\t\taddress _to,\n\t\tuint256 _amount\n\t) public;\n}\n\n\n/*\n    Converter Anchor interface\n*/\ncontract IConverterAnchor is IOwned, ITokenHolder {\n\n}\n/**\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0.\n */\n\n\n\ncontract IERC20 {\n\tstring public name;\n\tuint8 public decimals;\n\tstring public symbol;\n\n\tfunction totalSupply() public view returns (uint256);\n\n\tfunction balanceOf(address _who) public view returns (uint256);\n\n\tfunction transfer(address _to, uint256 _value) public returns (bool);\n\n\tfunction allowance(address _owner, address _spender) public view returns (uint256);\n\n\tfunction transferFrom(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _value\n\t) public returns (bool);\n\n\tfunction approve(address _spender, uint256 _value) public returns (bool);\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n/**\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0.\n */\n\n\n\ninterface IWrbtc {\n\tfunction deposit() external payable;\n\n\tfunction withdraw(uint256 wad) external;\n}\n\n\n/*\n    Chainlink Price Oracle interface\n*/\ninterface IConsumerPriceOracle {\n\tfunction latestAnswer() external view returns (int256);\n\n\tfunction latestTimestamp() external view returns (uint256);\n}\n\n\n\n\n\n\n/*\n    Smart Token interface\n*/\ncontract ISmartToken is IConverterAnchor, IERC20Token {\n\tfunction disableTransfers(bool _disable) public;\n\n\tfunction issue(address _to, uint256 _amount) public;\n\n\tfunction destroy(address _from, uint256 _amount) public;\n}\n\n\n\ncontract ISovrynSwapX {\n\tfunction token() public view returns (IERC20Token) {\n\t\tthis;\n\t}\n\n\tfunction xTransfer(\n\t\tbytes32 _toBlockchain,\n\t\tbytes32 _to,\n\t\tuint256 _amount,\n\t\tuint256 _id\n\t) public;\n\n\tfunction getXTransferAmount(uint256 _xTransferId, address _for) public view returns (uint256);\n}\n\n\n\n\n\n\n/*\n    Ether Token interface\n*/\ncontract IEtherToken is IERC20Token {\n\tfunction deposit() public payable;\n\n\tfunction withdraw(uint256 _amount) public;\n\n\tfunction depositTo(address _to) public payable;\n\n\tfunction withdrawTo(address _to, uint256 _amount) public;\n}\n\n\n\ninterface ISovrynSwapNetwork {\n\tevent Conversion(\n\t\taddress indexed _smartToken,\n\t\taddress indexed _fromToken,\n\t\taddress indexed _toToken,\n\t\tuint256 _fromAmount,\n\t\tuint256 _toAmount,\n\t\taddress _trader\n\t);\n\n\tfunction setMaxAffiliateFee(uint256 _maxAffiliateFee) external;\n\n\tfunction registerEtherToken(IEtherToken _token, bool _register) external;\n\n\tfunction conversionPath(IERC20Token _sourceToken, IERC20Token _targetToken) external view returns (address[] memory);\n\n\tfunction rateByPath(IERC20Token[] calldata _path, uint256 _amount) external view returns (uint256);\n\n\tfunction convertByPath(\n\t\tIERC20Token[] calldata _path,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn,\n\t\taddress _beneficiary,\n\t\taddress _affiliateAccount,\n\t\tuint256 _affiliateFee\n\t) external payable returns (uint256);\n\n\tfunction xConvert(\n\t\tIERC20Token[] calldata _path,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn,\n\t\tbytes32 _targetBlockchain,\n\t\tbytes32 _targetAccount,\n\t\tuint256 _conversionId\n\t) external payable returns (uint256);\n\n\tfunction xConvert2(\n\t\tIERC20Token[] calldata _path,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn,\n\t\tbytes32 _targetBlockchain,\n\t\tbytes32 _targetAccount,\n\t\tuint256 _conversionId,\n\t\taddress _affiliateAccount,\n\t\tuint256 _affiliateFee\n\t) external payable returns (uint256);\n\n\tfunction completeXConversion(\n\t\tIERC20Token[] calldata _path,\n\t\tISovrynSwapX _sovrynSwapX,\n\t\tuint256 _conversionId,\n\t\tuint256 _minReturn,\n\t\taddress _beneficiary\n\t) external returns (uint256);\n\n\tfunction getReturnByPath(IERC20Token[] calldata _path, uint256 _amount) external view returns (uint256, uint256);\n\n\tfunction convert(\n\t\tIERC20Token[] calldata _path,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn\n\t) external payable returns (uint256);\n\n\tfunction convert2(\n\t\tIERC20Token[] calldata _path,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn,\n\t\taddress _affiliateAccount,\n\t\tuint256 _affiliateFee\n\t) external payable returns (uint256);\n\n\tfunction convertFor(\n\t\tIERC20Token[] calldata _path,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn,\n\t\taddress _beneficiary\n\t) external payable returns (uint256);\n\n\tfunction convertFor2(\n\t\tIERC20Token[] calldata _path,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn,\n\t\taddress _beneficiary,\n\t\taddress _affiliateAccount,\n\t\tuint256 _affiliateFee\n\t) external payable returns (uint256);\n\n\tfunction claimAndConvert(\n\t\tIERC20Token[] calldata _path,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn\n\t) external returns (uint256);\n\n\tfunction claimAndConvert2(\n\t\tIERC20Token[] calldata _path,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn,\n\t\taddress _affiliateAccount,\n\t\tuint256 _affiliateFee\n\t) external returns (uint256);\n\n\tfunction claimAndConvertFor(\n\t\tIERC20Token[] calldata _path,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn,\n\t\taddress _beneficiary\n\t) external returns (uint256);\n\n\tfunction claimAndConvertFor2(\n\t\tIERC20Token[] calldata _path,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn,\n\t\taddress _beneficiary,\n\t\taddress _affiliateAccount,\n\t\tuint256 _affiliateFee\n\t) external returns (uint256);\n}\n\n\n\n\n\n\ninterface ILiquidityPoolV2Converter {\n\tevent DynamicFeeFactorUpdate(uint256 _prevFactor, uint256 _newFactor);\n\n\tfunction converterType() external pure returns (uint16);\n\n\tfunction isActive() external view returns (bool);\n\n\tfunction amplificationFactor() external pure returns (uint8);\n\n\tfunction activate(\n\t\tIERC20Token _primaryReserveToken,\n\t\tIConsumerPriceOracle _primaryReserveOracle,\n\t\tIConsumerPriceOracle _secondaryReserveOracle\n\t) external;\n\n\tfunction setDynamicFeeFactor(uint256) external;\n\n\tfunction reserveStakedBalance(IERC20Token _reserveToken) external view returns (uint256);\n\n\tfunction reserveAmplifiedBalance(IERC20Token _reserveToken) external view returns (uint256);\n\n\tfunction setReserveStakedBalance(IERC20Token _reserveToken, uint256 _balance) external;\n\n\tfunction setMaxStakedBalances(uint256 _reserve1MaxStakedBalance, uint256 _reserve2MaxStakedBalance) external;\n\n\tfunction disableMaxStakedBalances() external;\n\n\tfunction poolToken(IERC20Token _reserveToken) external view returns (ISmartToken);\n\n\tfunction liquidationLimit(ISmartToken _poolToken) external view returns (uint256);\n\n\tfunction addReserve(IERC20Token _token, uint32 _weight) external;\n\n\tfunction effectiveTokensRate() external view returns (uint256, uint256);\n\n\tfunction effectiveReserveWeights() external view returns (uint256, uint256);\n\n\tfunction targetAmountAndFee(\n\t\tIERC20Token _sourceToken,\n\t\tIERC20Token _targetToken,\n\t\tuint256 _amount\n\t) external view returns (uint256, uint256);\n\n\tfunction addLiquidity(\n\t\tIERC20Token _reserveToken,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn\n\t) external payable returns (uint256);\n\n\tfunction removeLiquidity(\n\t\tISmartToken _poolToken,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn\n\t) external returns (uint256);\n\n\tfunction removeLiquidityReturnAndFee(ISmartToken _poolToken, uint256 _amount) external view returns (uint256, uint256);\n}\n\n\n/**\n * @dev Library for basic math operations with overflow/underflow protection\n */\nlibrary SafeMath {\n\t/**\n\t * @dev returns the sum of _x and _y, reverts if the calculation overflows\n\t *\n\t * @param _x   value 1\n\t * @param _y   value 2\n\t *\n\t * @return sum\n\t */\n\tfunction add(uint256 _x, uint256 _y) internal pure returns (uint256) {\n\t\tuint256 z = _x + _y;\n\t\trequire(z >= _x, \"ERR_OVERFLOW\");\n\t\treturn z;\n\t}\n\n\t/**\n\t * @dev returns the difference of _x minus _y, reverts if the calculation underflows\n\t *\n\t * @param _x   minuend\n\t * @param _y   subtrahend\n\t *\n\t * @return difference\n\t */\n\tfunction sub(uint256 _x, uint256 _y) internal pure returns (uint256) {\n\t\trequire(_x >= _y, \"ERR_UNDERFLOW\");\n\t\treturn _x - _y;\n\t}\n\n\t/**\n\t * @dev returns the product of multiplying _x by _y, reverts if the calculation overflows\n\t *\n\t * @param _x   factor 1\n\t * @param _y   factor 2\n\t *\n\t * @return product\n\t */\n\tfunction mul(uint256 _x, uint256 _y) internal pure returns (uint256) {\n\t\t// gas optimization\n\t\tif (_x == 0) return 0;\n\n\t\tuint256 z = _x * _y;\n\t\trequire(z / _x == _y, \"ERR_OVERFLOW\");\n\t\treturn z;\n\t}\n\n\t/**\n\t * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n\t *\n\t * @param _x   dividend\n\t * @param _y   divisor\n\t *\n\t * @return quotient\n\t */\n\tfunction div(uint256 _x, uint256 _y) internal pure returns (uint256) {\n\t\trequire(_y > 0, \"ERR_DIVIDE_BY_ZERO\");\n\t\tuint256 c = _x / _y;\n\t\treturn c;\n\t}\n}\n\n\n\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n\t/**\n\t * @dev Returns true if `account` is a contract.\n\t *\n\t * [IMPORTANT]\n\t * ====\n\t * It is unsafe to assume that an address for which this function returns\n\t * false is an externally-owned account (EOA) and not a contract.\n\t *\n\t * Among others, `isContract` will return false for the following\n\t * types of addresses:\n\t *\n\t *  - an externally-owned account\n\t *  - a contract in construction\n\t *  - an address where a contract will be created\n\t *  - an address where a contract lived, but was destroyed\n\t * ====\n\t */\n\tfunction isContract(address account) internal view returns (bool) {\n\t\t// According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\t\t// and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\t\t// for accounts without code, i.e. `keccak256('')`\n\t\tbytes32 codehash;\n\t\tbytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tcodehash := extcodehash(account)\n\t\t}\n\t\treturn (codehash != accountHash && codehash != 0x0);\n\t}\n\n\t/**\n\t * @dev Converts an `address` into `address payable`. Note that this is\n\t * simply a type cast: the actual underlying value is not changed.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction toPayable(address account) internal pure returns (address payable) {\n\t\treturn address(uint160(account));\n\t}\n\n\t/**\n\t * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n\t * `recipient`, forwarding all available gas and reverting on errors.\n\t *\n\t * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n\t * of certain opcodes, possibly making contracts go over the 2300 gas limit\n\t * imposed by `transfer`, making them unable to receive funds via\n\t * `transfer`. {sendValue} removes this limitation.\n\t *\n\t * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n\t *\n\t * IMPORTANT: because control is transferred to `recipient`, care must be\n\t * taken to not create reentrancy vulnerabilities. Consider using\n\t * {ReentrancyGuard} or the\n\t * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction sendValue(address recipient, uint256 amount) internal {\n\t\trequire(address(this).balance >= amount, \"Address: insufficient balance\");\n\n\t\t// solhint-disable-next-line avoid-call-value\n\t\t(bool success, ) = recipient.call.value(amount)(\"\");\n\t\trequire(success, \"Address: unable to send value, recipient may have reverted\");\n\t}\n}\n\n\n/**\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0.\n */\n\n\n\n\n\n\ncontract IWrbtcERC20 is IWrbtc, IERC20 {}\n\n\n\r\n\r\n\r\n\r\n/**\r\n  * @dev Liquidity Pool v1 Converter\r\n  *\r\n  * The liquidity pool v1 converter is a specialized version of a converter that manages\r\n  * a classic SovrynSwap liquidity pool.\r\n  *\r\n  * Even though classic pools can have many reserves, the most common configuration of\r\n  * the pool has 2 reserves with 50%/50% weights.\r\n*/\r\ninterface ILiquidityPoolV1Converter {\r\n    /**\r\n      * @dev triggered after a conversion with new price data\r\n      * deprecated, use `TokenRateUpdate` from version 28 and up\r\n      *\r\n      * @param  _connectorToken     reserve token\r\n      * @param  _tokenSupply        smart token supply\r\n      * @param  _connectorBalance   reserve balance\r\n      * @param  _connectorWeight    reserve weight\r\n    */\r\n    event PriceDataUpdate(\r\n        address indexed _connectorToken,\r\n        uint256 _tokenSupply,\r\n        uint256 _connectorBalance,\r\n        uint32 _connectorWeight\r\n    );\r\n\r\n    /**\r\n      * @dev returns the converter type\r\n      *\r\n      * @return see the converter types in the the main contract doc\r\n    */\r\n    function converterType() external pure returns (uint16);\r\n\r\n    /**\r\n      * @dev accepts ownership of the anchor after an ownership transfer\r\n      * also activates the converter\r\n      * can only be called by the contract owner\r\n      * note that prior to version 28, you should use 'acceptTokenOwnership' instead\r\n    */\r\n    function acceptAnchorOwnership() external;\r\n\r\n    /**\r\n      * @dev returns the expected target amount of converting one reserve to another along with the fee\r\n      *\r\n      * @param _sourceToken contract address of the source reserve token\r\n      * @param _targetToken contract address of the target reserve token\r\n      * @param _amount      amount of tokens received from the user\r\n      *\r\n      * @return expected target amount\r\n      * @return expected fee\r\n    */\r\n    function targetAmountAndFee(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount) external view returns (uint256, uint256);\r\n\r\n\r\n    /**\r\n      * @dev increases the pool's liquidity and mints new shares in the pool to the caller\r\n      * note that prior to version 28, you should use 'fund' instead\r\n      *\r\n      * @param _reserveTokens   address of each reserve token\r\n      * @param _reserveAmounts  amount of each reserve token\r\n      * @param _minReturn       token minimum return-amount\r\n    */\r\n    function addLiquidity(IERC20Token[] calldata _reserveTokens, uint256[] calldata _reserveAmounts, uint256 _minReturn) external payable;\r\n\r\n    /**\r\n      * @dev decreases the pool's liquidity and burns the caller's shares in the pool\r\n      * note that prior to version 28, you should use 'liquidate' instead\r\n      *\r\n      * @param _amount                  token amount\r\n      * @param _reserveTokens           address of each reserve token\r\n      * @param _reserveMinReturnAmounts minimum return-amount of each reserve token\r\n    */\r\n    function removeLiquidity(uint256 _amount, IERC20Token[] calldata _reserveTokens, uint256[] calldata _reserveMinReturnAmounts) external;\r\n\r\n    /**\r\n      * @dev increases the pool's liquidity and mints new shares in the pool to the caller\r\n      * for example, if the caller increases the supply by 10%,\r\n      * then it will cost an amount equal to 10% of each reserve token balance\r\n      * note that starting from version 28, you should use 'addLiquidity' instead\r\n      *\r\n      * @param _amount  amount to increase the supply by (in the pool token)\r\n    */\r\n    function fund(uint256 _amount) external payable;\r\n\r\n    /**\r\n      * @dev decreases the pool's liquidity and burns the caller's shares in the pool\r\n      * for example, if the holder sells 10% of the supply,\r\n      * then they will receive 10% of each reserve token balance in return\r\n      * note that starting from version 28, you should use 'removeLiquidity' instead\r\n      *\r\n      * @param _amount  amount to liquidate (in the pool token)\r\n    */\r\n    function liquidate(uint256 _amount) external;\r\n\r\n    /**\r\n      * @dev calculates the number of decimal digits in a given value\r\n      *\r\n      * @param _x   value (assumed positive)\r\n      * @return the number of decimal digits in the given value\r\n    */\r\n    function decimalLength(uint256 _x) external pure returns (uint256);\r\n\r\n    /**\r\n      * @dev calculates the nearest integer to a given quotient\r\n      *\r\n      * @param _n   quotient numerator\r\n      * @param _d   quotient denominator\r\n      * @return the nearest integer to the given quotient\r\n    */\r\n    function roundDiv(uint256 _n, uint256 _d) external pure returns (uint256);\r\n\r\n    /**\r\n      * @dev calculates the average number of decimal digits in a given list of values\r\n      *\r\n      * @param _values  list of values (each of which assumed positive)\r\n      * @return the average number of decimal digits in the given list of values\r\n    */\r\n    function geometricMean(uint256[] calldata _values) external pure returns (uint256);\r\n\r\n    /**\r\n      * @dev deprecated since version 28, backward compatibility - use only for earlier versions\r\n    */\r\n    function token() external view returns (IConverterAnchor);\r\n}\r\n\n\n\n\n\n\ncontract RBTCWrapperProxy {\n    \n    using Address for address;\n    using SafeMath for uint256;\n\n    bytes32 internal constant SOVRYNSWAP_FORMULA = \"SovrynSwapFormula\";\n\n    address public wrbtcTokenAddress;\n    address public sovrynSwapNetworkAddress;\n    \n    /**\n     * @dev triggered after liquidity is added\n     *\n     * @param  _provider           liquidity provider\n     * @param  _reserveAmount      provided reserve token amount\n     * @param  _poolTokenAmount    minted pool token amount\n     */\n    event LiquidityAdded(\n        address indexed _provider,\n        uint256 _reserveAmount,\n        uint256 _poolTokenAmount\n    );\n\n    /**\n     * @dev triggered after liquidity is added to LiquidityPoolConverter V1\n     *\n     * @param  _provider           liquidity provider\n     * @param  _reserveTokens      provided reserve token\n     * @param  _reserveAmounts      provided reserve token amount\n     * @param  _poolTokenAmount    minted pool token amount\n     */\n    event LiquidityAddedToV1(\n        address indexed _provider,\n        IERC20Token[] _reserveTokens, \n        uint256[] _reserveAmounts, \n        uint256 _poolTokenAmount\n    );\n\n    /**\n     * @dev triggered after liquidity is removed\n     *\n     * @param  _provider           liquidity provider\n     * @param  _reserveAmount      added reserve token amount\n     * @param  _poolTokenAmount    burned pool token amount\n     */\n    event LiquidityRemoved(\n        address indexed _provider,\n        uint256 _reserveAmount,\n        uint256 _poolTokenAmount\n    );\n\n    /**\n     * @dev triggered after liquidity is removed from LiquidityPoolConverter V1\n     *\n     * @param  _provider          liquidity provider\n     * @param  _reserveTokens     added reserve tokens\n     * @param  _reserveAmounts    added reserve token amounts\n     */\n    event LiquidityRemovedFromV1(\n        address indexed _provider,\n        IERC20Token[] _reserveTokens,\n        uint256[] _reserveAmounts\n    );\n\n    /**\n     * @dev triggered after liquidity is removed\n     *\n     * @param _beneficiary          account that will receive the conversion result or 0x0 to send the result to the sender account\n     * @param _sourceTokenAmount    amount to convert from, in the source token\n     * @param _targetTokenAmount    amount of tokens received from the conversion, in the target token\n     * @param _path                 conversion path between two tokens in the network\n     */\n    event TokenConverted(\n        address indexed _beneficiary,\n        uint256 indexed _sourceTokenAmount,\n        uint256 indexed _targetTokenAmount,\n        IERC20Token[] _path\n    );\n\n    /**\n     * @dev To check if ddress is contract address \n     */\n    modifier checkAddress(address address_) {\n        require(address_.isContract(), \"The address is not a contract\");\n        _;\n    }\n    \n    constructor(\n        address _wrbtcTokenAddress, \n        address _sovrynSwapNetworkAddress\n    ) \n        public \n        checkAddress(_wrbtcTokenAddress) \n        checkAddress(_sovrynSwapNetworkAddress) \n    {\n        wrbtcTokenAddress = _wrbtcTokenAddress;\n        sovrynSwapNetworkAddress = _sovrynSwapNetworkAddress;\n    }\n\n    function() external payable {\n        require(wrbtcTokenAddress == msg.sender, \"Only can receive rBTC from WRBTC contract\");\n    }\n\n    /**\n     * @dev  \n     * The process:\n     * 1.Accepts RBTC\n     * 2.Sends RBTC to WRBTC contract in order to wrap RBTC to WRBTC\n     * 3.Calls 'addLiquidity' on LiquidityPoolConverter contract\n     * 4.Transfers pool tokens to user\n     * \n     * @param _liquidityPoolConverterAddress    address of LiquidityPoolConverter contract\n     * @param _amount                           amount of liquidity to add\n     * @param _minReturn                        minimum return-amount of reserve tokens\n     *\n     * @return amount of pool tokens minted\n     */\n    function addLiquidity(\n        address _liquidityPoolConverterAddress, \n        uint256 _amount, \n        uint256 _minReturn\n    )  \n        public\n        payable\n        checkAddress(_liquidityPoolConverterAddress)\n        returns(uint256) \n    {\n        require(_amount == msg.value, \"The provided amount should be identical to msg.value\");\n\n        ILiquidityPoolV2Converter _liquidityPoolConverter = ILiquidityPoolV2Converter(_liquidityPoolConverterAddress);\n        ISmartToken _poolToken = _liquidityPoolConverter.poolToken(IERC20Token(wrbtcTokenAddress));\n\n        IWrbtcERC20(wrbtcTokenAddress).deposit.value(_amount)();\n\n        bool successOfApprove = IWrbtcERC20(wrbtcTokenAddress).approve(_liquidityPoolConverterAddress, _amount);\n        require(successOfApprove);\n\n        uint256 poolTokenAmount = _liquidityPoolConverter.addLiquidity(IERC20Token(wrbtcTokenAddress), _amount, _minReturn);\n        \n        bool successOfTransfer = _poolToken.transfer(msg.sender, poolTokenAmount);\n        require(successOfTransfer);\n\n        emit LiquidityAdded(msg.sender, _amount, poolTokenAmount);\n\n        return poolTokenAmount;\n    }\n\n    /**\n     * @dev  \n     * The process:\n     * 1.Accepts RBTC\n     * 2.Sends RBTC to WRBTC contract in order to wrap RBTC to WRBTC\n     * 3.Accepts reserve token and approve LiquidityPoolConverter to transfer\n     * 4.Calls 'addLiquidity' on LiquidityPoolConverter contract\n     * 5.Transfers pool tokens to user\n     * \n     * @param _liquidityPoolConverterAddress    address of LiquidityPoolConverter contract\n     * @param _reserveTokens                    address of each reserve token. The first element should be the address of WRBTC\n     * @param _reserveAmounts                   amount of each reserve token. The first element should be the amount of RBTC\n     * @param _minReturn                        minimum return-amount of reserve tokens\n     *\n     * @return amount of pool tokens minted\n     */\n    function addLiquidityToV1(\n        address _liquidityPoolConverterAddress,\n        IERC20Token[] memory _reserveTokens, \n        uint256[] memory _reserveAmounts, \n        uint256 _minReturn\n    )  \n        public\n        payable\n        checkAddress(_liquidityPoolConverterAddress)\n        returns(uint256) \n    {\n        uint256 amountOfRBTC = _reserveAmounts[0];\n\n        require(address(_reserveTokens[0]) == wrbtcTokenAddress, \"The first reserve token must be WRBTC\");\n        require(amountOfRBTC == msg.value, \"The provided amount of RBTC should be identical to msg.value\");\n\n        bool successOfTransfer;\n        bool successOfApprove;\n\n        IWrbtcERC20(wrbtcTokenAddress).deposit.value(amountOfRBTC)();\n        successOfApprove = IWrbtcERC20(wrbtcTokenAddress).approve(_liquidityPoolConverterAddress, amountOfRBTC);\n        require(successOfApprove, \"Failed to approve converter to transfer WRBTC\");\n        \n        for (uint256 i = 1; i < _reserveTokens.length; i++) {\n            IERC20Token reserveToken = _reserveTokens[i];\n            uint256 reserveAmount = _reserveAmounts[i];\n            successOfTransfer = IERC20Token(reserveToken).transferFrom(msg.sender, address(this), reserveAmount);\n            require(successOfTransfer, \"Failed to transfer reserve token from user\");\n            successOfApprove = IERC20Token(reserveToken).approve(_liquidityPoolConverterAddress, reserveAmount);\n            require(successOfApprove, \"Failed to approve converter to transfer reserve token\");\n        }\n\n        ILiquidityPoolV1Converter _liquidityPoolConverter = ILiquidityPoolV1Converter(_liquidityPoolConverterAddress);\n        ISmartToken _poolToken = ISmartToken(address(_liquidityPoolConverter.token()));\n        uint256 poolTokenAmountBefore = _poolToken.balanceOf(address(this));\n        _liquidityPoolConverter.addLiquidity(_reserveTokens, _reserveAmounts, _minReturn);\n        uint256 poolTokenAmountAfter = _poolToken.balanceOf(address(this));\n        uint256 poolTokenAmount = poolTokenAmountAfter.sub(poolTokenAmountBefore);\n        \n        successOfTransfer = _poolToken.transfer(msg.sender, poolTokenAmount);\n        require(successOfTransfer, \"Failed to transfer pool token to user\");\n\n        emit LiquidityAddedToV1(msg.sender, _reserveTokens, _reserveAmounts, poolTokenAmount);\n\n        return poolTokenAmount;\n    }\n    \n    /**\n     * @notice \n     * Before calling this function to remove liquidity, users need approve this contract to be able to spend or transfer their pool tokens\n     *\n     * @dev  \n     * The process:     \n     * 1.Transfers pool tokens to this contract\n     * 2.Calls 'removeLiquidity' on LiquidityPoolConverter contract\n     * 3.Calls 'withdraw' on WRBTC contract in order to unwrap WRBTC to RBTC\n     * 4.Sneds RBTC to user\n     * \n     * @param _liquidityPoolConverterAddress    address of LiquidityPoolConverter contract\n     * @param _amount                           amount of pool tokens to burn\n     * @param _minReturn                        minimum return-amount of reserve tokens\n     * \n     * @return amount of liquidity removed also WRBTC unwrapped to RBTC\n     */\n    function removeLiquidity(\n        address _liquidityPoolConverterAddress, \n        uint256 _amount, \n        uint256 _minReturn\n    )   \n        public \n        checkAddress(_liquidityPoolConverterAddress)\n        returns(uint256) \n    {\n        ILiquidityPoolV2Converter _liquidityPoolConverter = ILiquidityPoolV2Converter(_liquidityPoolConverterAddress);\n        ISmartToken _poolToken = _liquidityPoolConverter.poolToken(IERC20Token(wrbtcTokenAddress));\n\n        bool successOfTransferFrom = _poolToken.transferFrom(msg.sender, address(this), _amount);\n        require(successOfTransferFrom);\n\n        uint256 reserveAmount = _liquidityPoolConverter.removeLiquidity(_poolToken, _amount, _minReturn);\n        \n        IWrbtcERC20(wrbtcTokenAddress).withdraw(reserveAmount);\n        \n        (bool successOfSendRBTC,) = msg.sender.call.value(reserveAmount)(\"\");\n        require(successOfSendRBTC, \"Failed to send RBTC to user\");\n\n        emit LiquidityRemoved(msg.sender, reserveAmount, _amount);\n\n        return reserveAmount;\n    }\n\n    /**\n     * @notice \n     * Before calling this function to remove liquidity, users need approve this contract to be able to spend or transfer their pool tokens\n     *\n     * @dev  \n     * The process:     \n     * 1.Transfers pool tokens to this contract\n     * 2.Calls 'removeLiquidity' on LiquidityPoolConverter contract\n     * 3.Calls 'withdraw' on WRBTC contract in order to unwrap WRBTC to RBTC\n     * 4.Sneds RBTC and/or other reserve tokens to user\n     * \n     * @param _liquidityPoolConverterAddress    address of LiquidityPoolConverter contract\n     * @param _amount                           amount of pool tokens to burn\n     * @param _reserveTokens                    address of each reserve token. The first element should be the address of WRBTC\n     * @param _reserveMinReturnAmounts          minimum return-amount of each reserve token. The first element should be the minimum return-amount of WRBTC\n     */\n    function removeLiquidityFromV1(\n        address _liquidityPoolConverterAddress,\n        uint256 _amount, \n        IERC20Token[] memory _reserveTokens, \n        uint256[] memory _reserveMinReturnAmounts\n    )   \n        public \n        checkAddress(_liquidityPoolConverterAddress)\n    {\n        require(_amount > 0, \"The amount should larger than zero\");\n        require(address(_reserveTokens[0]) == wrbtcTokenAddress, \"The first reserve token must be WRBTC\");\n\n        uint256[] memory reserveAmounts = new uint256[](_reserveTokens.length);\n        ILiquidityPoolV1Converter _liquidityPoolConverter = ILiquidityPoolV1Converter(_liquidityPoolConverterAddress);\n        ISmartToken _poolToken = ISmartToken(address(_liquidityPoolConverter.token()));\n\n        bool successOfTransferFrom = _poolToken.transferFrom(msg.sender, address(this), _amount);\n        require(successOfTransferFrom);\n\n        uint256 lengthOfToken = _reserveTokens.length;\n        IERC20Token reserveToken;\n        uint256[] memory reserveAmountBefore = new uint256[](lengthOfToken);\n        for (uint256 i = 0; i < lengthOfToken; i++) {\n            reserveToken = _reserveTokens[i];\n            reserveAmountBefore[i] = reserveToken.balanceOf(address(this));\n        }\n\n        _liquidityPoolConverter.removeLiquidity(_amount, _reserveTokens, _reserveMinReturnAmounts);\n\n        uint256 reserveAmount;\n        bool successOfTransfer;\n        for (uint256 i = 1; i < lengthOfToken; i++) {\n            reserveToken = _reserveTokens[i];\n\n            reserveAmount = reserveToken.balanceOf(address(this)).sub(reserveAmountBefore[i]); \n            require(reserveAmount >= _reserveMinReturnAmounts[i], \"ERR_ZERO_TARGET_AMOUNT\");\n            reserveAmounts[i] = reserveAmount;\n\n            successOfTransfer = IERC20Token(reserveToken).transfer(msg.sender, reserveAmount);\n            require(successOfTransfer, \"Failed to transfer reserve token to user\");\n        }\n\n        uint256 wrbtcAmount = _reserveTokens[0].balanceOf(address(this)).sub(reserveAmountBefore[0]);\n        require(wrbtcAmount >= _reserveMinReturnAmounts[0], \"ERR_ZERO_TARGET_AMOUNT\");\n        reserveAmounts[0] = wrbtcAmount;\n        IWrbtcERC20(wrbtcTokenAddress).withdraw(wrbtcAmount);\n        (bool successOfSendRBTC,) = msg.sender.call.value(wrbtcAmount)(\"\");\n        require(successOfSendRBTC, \"Failed to send RBTC to user\");\n\n        emit LiquidityRemovedFromV1(msg.sender, _reserveTokens, reserveAmounts);\n    }\n    \n    /**\n     * @notice\n     * Before calling this function to swap token to RBTC, users need approve this contract to be able to spend or transfer their tokens\n     *\n     * @param _path         conversion path between two tokens in the network\n     * @param _amount       amount to convert from, in the source token\n     * @param _minReturn    if the conversion results in an amount smaller than the minimum return - it is cancelled, must be greater than zero\n     * \n     * @return amount of tokens received from the conversion\n     */\n    function convertByPath(\n        IERC20Token[] memory _path,\n        uint256 _amount, \n        uint256 _minReturn\n    ) \n        public \n        payable\n        returns(uint256) \n    {    \n        ISovrynSwapNetwork _sovrynSwapNetwork =  ISovrynSwapNetwork(sovrynSwapNetworkAddress);\n  \n        if (msg.value != 0) {\n            require(_path[0] == IERC20Token(wrbtcTokenAddress), \"Value may only be sent for WRBTC transfers\");\n            require(_amount == msg.value, \"The provided amount should be identical to msg.value\");\n\n            IWrbtcERC20(wrbtcTokenAddress).deposit.value(_amount)();\n\n            bool successOfApprove = IWrbtcERC20(wrbtcTokenAddress).approve(sovrynSwapNetworkAddress, _amount);\n            require(successOfApprove);\n\n            uint256 _targetTokenAmount = _sovrynSwapNetwork.convertByPath(_path, _amount, _minReturn, msg.sender, address(0), 0);\n\n            emit TokenConverted(msg.sender, _amount, _targetTokenAmount, _path);\n\n            return _targetTokenAmount;\n        }\n        else {\n            require(_path[_path.length-1] == IERC20Token(wrbtcTokenAddress), \"It only could be swapped to WRBTC\");\n            \n            IERC20Token _token = IERC20Token(_path[0]);\n\n            bool successOfTransferFrom = _token.transferFrom(msg.sender, address(this), _amount);\n            require(successOfTransferFrom);\n\n            bool successOfApprove = _token.approve(sovrynSwapNetworkAddress, _amount);\n            require(successOfApprove);\n                 \n            uint256 _targetTokenAmount = _sovrynSwapNetwork.convertByPath(_path, _amount, _minReturn, address(this), address(0), 0);\n\n            IWrbtcERC20(wrbtcTokenAddress).withdraw(_targetTokenAmount);\n\n            (bool successOfSendRBTC,) = msg.sender.call.value(_targetTokenAmount)(\"\");\n            require(successOfSendRBTC, \"Failed to send RBTC to user\");\n\n            emit TokenConverted(msg.sender, _amount, _targetTokenAmount, _path);\n\n            return _targetTokenAmount;\n        }        \n    }\n}\n\n\n",
    "imports": [
        {
            "name": "RBTCWrapperProxy_flat.sol",
            "contents": "pragma solidity >=0.5.0 <0.6.0;\n\n/*\n    Owned contract interface\n*/\ncontract IOwned {\n\t// this function isn't abstract since the compiler emits automatically generated getter functions as external\n\tfunction owner() public view returns (address) {\n\t\tthis;\n\t}\n\n\tfunction transferOwnership(address _newOwner) public;\n\n\tfunction acceptOwnership() public;\n}\n\n\n/*\n    ERC20 Standard Token interface\n*/\ncontract IERC20Token {\n\t// these functions aren't abstract since the compiler emits automatically generated getter functions as external\n\tfunction name() public view returns (string memory) {\n\t\tthis;\n\t}\n\n\tfunction symbol() public view returns (string memory) {\n\t\tthis;\n\t}\n\n\tfunction decimals() public view returns (uint8) {\n\t\tthis;\n\t}\n\n\tfunction totalSupply() public view returns (uint256) {\n\t\tthis;\n\t}\n\n\tfunction balanceOf(address _owner) public view returns (uint256) {\n\t\t_owner;\n\t\tthis;\n\t}\n\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n\t\t_owner;\n\t\t_spender;\n\t\tthis;\n\t}\n\n\tfunction transfer(address _to, uint256 _value) public returns (bool success);\n\n\tfunction transferFrom(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _value\n\t) public returns (bool success);\n\n\tfunction approve(address _spender, uint256 _value) public returns (bool success);\n}\n\n\n\n\n\n\n\n\n/*\n    Token Holder interface\n*/\ncontract ITokenHolder is IOwned {\n\tfunction withdrawTokens(\n\t\tIERC20Token _token,\n\t\taddress _to,\n\t\tuint256 _amount\n\t) public;\n}\n\n\n/*\n    Converter Anchor interface\n*/\ncontract IConverterAnchor is IOwned, ITokenHolder {\n\n}\n/**\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0.\n */\n\n\n\ncontract IERC20 {\n\tstring public name;\n\tuint8 public decimals;\n\tstring public symbol;\n\n\tfunction totalSupply() public view returns (uint256);\n\n\tfunction balanceOf(address _who) public view returns (uint256);\n\n\tfunction transfer(address _to, uint256 _value) public returns (bool);\n\n\tfunction allowance(address _owner, address _spender) public view returns (uint256);\n\n\tfunction transferFrom(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _value\n\t) public returns (bool);\n\n\tfunction approve(address _spender, uint256 _value) public returns (bool);\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n/**\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0.\n */\n\n\n\ninterface IWrbtc {\n\tfunction deposit() external payable;\n\n\tfunction withdraw(uint256 wad) external;\n}\n\n\n/*\n    Chainlink Price Oracle interface\n*/\ninterface IConsumerPriceOracle {\n\tfunction latestAnswer() external view returns (int256);\n\n\tfunction latestTimestamp() external view returns (uint256);\n}\n\n\n\n\n\n\n/*\n    Smart Token interface\n*/\ncontract ISmartToken is IConverterAnchor, IERC20Token {\n\tfunction disableTransfers(bool _disable) public;\n\n\tfunction issue(address _to, uint256 _amount) public;\n\n\tfunction destroy(address _from, uint256 _amount) public;\n}\n\n\n\ncontract ISovrynSwapX {\n\tfunction token() public view returns (IERC20Token) {\n\t\tthis;\n\t}\n\n\tfunction xTransfer(\n\t\tbytes32 _toBlockchain,\n\t\tbytes32 _to,\n\t\tuint256 _amount,\n\t\tuint256 _id\n\t) public;\n\n\tfunction getXTransferAmount(uint256 _xTransferId, address _for) public view returns (uint256);\n}\n\n\n\n\n\n\n/*\n    Ether Token interface\n*/\ncontract IEtherToken is IERC20Token {\n\tfunction deposit() public payable;\n\n\tfunction withdraw(uint256 _amount) public;\n\n\tfunction depositTo(address _to) public payable;\n\n\tfunction withdrawTo(address _to, uint256 _amount) public;\n}\n\n\n\ninterface ISovrynSwapNetwork {\n\tevent Conversion(\n\t\taddress indexed _smartToken,\n\t\taddress indexed _fromToken,\n\t\taddress indexed _toToken,\n\t\tuint256 _fromAmount,\n\t\tuint256 _toAmount,\n\t\taddress _trader\n\t);\n\n\tfunction setMaxAffiliateFee(uint256 _maxAffiliateFee) external;\n\n\tfunction registerEtherToken(IEtherToken _token, bool _register) external;\n\n\tfunction conversionPath(IERC20Token _sourceToken, IERC20Token _targetToken) external view returns (address[] memory);\n\n\tfunction rateByPath(IERC20Token[] calldata _path, uint256 _amount) external view returns (uint256);\n\n\tfunction convertByPath(\n\t\tIERC20Token[] calldata _path,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn,\n\t\taddress _beneficiary,\n\t\taddress _affiliateAccount,\n\t\tuint256 _affiliateFee\n\t) external payable returns (uint256);\n\n\tfunction xConvert(\n\t\tIERC20Token[] calldata _path,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn,\n\t\tbytes32 _targetBlockchain,\n\t\tbytes32 _targetAccount,\n\t\tuint256 _conversionId\n\t) external payable returns (uint256);\n\n\tfunction xConvert2(\n\t\tIERC20Token[] calldata _path,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn,\n\t\tbytes32 _targetBlockchain,\n\t\tbytes32 _targetAccount,\n\t\tuint256 _conversionId,\n\t\taddress _affiliateAccount,\n\t\tuint256 _affiliateFee\n\t) external payable returns (uint256);\n\n\tfunction completeXConversion(\n\t\tIERC20Token[] calldata _path,\n\t\tISovrynSwapX _sovrynSwapX,\n\t\tuint256 _conversionId,\n\t\tuint256 _minReturn,\n\t\taddress _beneficiary\n\t) external returns (uint256);\n\n\tfunction getReturnByPath(IERC20Token[] calldata _path, uint256 _amount) external view returns (uint256, uint256);\n\n\tfunction convert(\n\t\tIERC20Token[] calldata _path,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn\n\t) external payable returns (uint256);\n\n\tfunction convert2(\n\t\tIERC20Token[] calldata _path,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn,\n\t\taddress _affiliateAccount,\n\t\tuint256 _affiliateFee\n\t) external payable returns (uint256);\n\n\tfunction convertFor(\n\t\tIERC20Token[] calldata _path,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn,\n\t\taddress _beneficiary\n\t) external payable returns (uint256);\n\n\tfunction convertFor2(\n\t\tIERC20Token[] calldata _path,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn,\n\t\taddress _beneficiary,\n\t\taddress _affiliateAccount,\n\t\tuint256 _affiliateFee\n\t) external payable returns (uint256);\n\n\tfunction claimAndConvert(\n\t\tIERC20Token[] calldata _path,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn\n\t) external returns (uint256);\n\n\tfunction claimAndConvert2(\n\t\tIERC20Token[] calldata _path,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn,\n\t\taddress _affiliateAccount,\n\t\tuint256 _affiliateFee\n\t) external returns (uint256);\n\n\tfunction claimAndConvertFor(\n\t\tIERC20Token[] calldata _path,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn,\n\t\taddress _beneficiary\n\t) external returns (uint256);\n\n\tfunction claimAndConvertFor2(\n\t\tIERC20Token[] calldata _path,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn,\n\t\taddress _beneficiary,\n\t\taddress _affiliateAccount,\n\t\tuint256 _affiliateFee\n\t) external returns (uint256);\n}\n\n\n\n\n\n\ninterface ILiquidityPoolV2Converter {\n\tevent DynamicFeeFactorUpdate(uint256 _prevFactor, uint256 _newFactor);\n\n\tfunction converterType() external pure returns (uint16);\n\n\tfunction isActive() external view returns (bool);\n\n\tfunction amplificationFactor() external pure returns (uint8);\n\n\tfunction activate(\n\t\tIERC20Token _primaryReserveToken,\n\t\tIConsumerPriceOracle _primaryReserveOracle,\n\t\tIConsumerPriceOracle _secondaryReserveOracle\n\t) external;\n\n\tfunction setDynamicFeeFactor(uint256) external;\n\n\tfunction reserveStakedBalance(IERC20Token _reserveToken) external view returns (uint256);\n\n\tfunction reserveAmplifiedBalance(IERC20Token _reserveToken) external view returns (uint256);\n\n\tfunction setReserveStakedBalance(IERC20Token _reserveToken, uint256 _balance) external;\n\n\tfunction setMaxStakedBalances(uint256 _reserve1MaxStakedBalance, uint256 _reserve2MaxStakedBalance) external;\n\n\tfunction disableMaxStakedBalances() external;\n\n\tfunction poolToken(IERC20Token _reserveToken) external view returns (ISmartToken);\n\n\tfunction liquidationLimit(ISmartToken _poolToken) external view returns (uint256);\n\n\tfunction addReserve(IERC20Token _token, uint32 _weight) external;\n\n\tfunction effectiveTokensRate() external view returns (uint256, uint256);\n\n\tfunction effectiveReserveWeights() external view returns (uint256, uint256);\n\n\tfunction targetAmountAndFee(\n\t\tIERC20Token _sourceToken,\n\t\tIERC20Token _targetToken,\n\t\tuint256 _amount\n\t) external view returns (uint256, uint256);\n\n\tfunction addLiquidity(\n\t\tIERC20Token _reserveToken,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn\n\t) external payable returns (uint256);\n\n\tfunction removeLiquidity(\n\t\tISmartToken _poolToken,\n\t\tuint256 _amount,\n\t\tuint256 _minReturn\n\t) external returns (uint256);\n\n\tfunction removeLiquidityReturnAndFee(ISmartToken _poolToken, uint256 _amount) external view returns (uint256, uint256);\n}\n\n\n/**\n * @dev Library for basic math operations with overflow/underflow protection\n */\nlibrary SafeMath {\n\t/**\n\t * @dev returns the sum of _x and _y, reverts if the calculation overflows\n\t *\n\t * @param _x   value 1\n\t * @param _y   value 2\n\t *\n\t * @return sum\n\t */\n\tfunction add(uint256 _x, uint256 _y) internal pure returns (uint256) {\n\t\tuint256 z = _x + _y;\n\t\trequire(z >= _x, \"ERR_OVERFLOW\");\n\t\treturn z;\n\t}\n\n\t/**\n\t * @dev returns the difference of _x minus _y, reverts if the calculation underflows\n\t *\n\t * @param _x   minuend\n\t * @param _y   subtrahend\n\t *\n\t * @return difference\n\t */\n\tfunction sub(uint256 _x, uint256 _y) internal pure returns (uint256) {\n\t\trequire(_x >= _y, \"ERR_UNDERFLOW\");\n\t\treturn _x - _y;\n\t}\n\n\t/**\n\t * @dev returns the product of multiplying _x by _y, reverts if the calculation overflows\n\t *\n\t * @param _x   factor 1\n\t * @param _y   factor 2\n\t *\n\t * @return product\n\t */\n\tfunction mul(uint256 _x, uint256 _y) internal pure returns (uint256) {\n\t\t// gas optimization\n\t\tif (_x == 0) return 0;\n\n\t\tuint256 z = _x * _y;\n\t\trequire(z / _x == _y, \"ERR_OVERFLOW\");\n\t\treturn z;\n\t}\n\n\t/**\n\t * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n\t *\n\t * @param _x   dividend\n\t * @param _y   divisor\n\t *\n\t * @return quotient\n\t */\n\tfunction div(uint256 _x, uint256 _y) internal pure returns (uint256) {\n\t\trequire(_y > 0, \"ERR_DIVIDE_BY_ZERO\");\n\t\tuint256 c = _x / _y;\n\t\treturn c;\n\t}\n}\n\n\n\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n\t/**\n\t * @dev Returns true if `account` is a contract.\n\t *\n\t * [IMPORTANT]\n\t * ====\n\t * It is unsafe to assume that an address for which this function returns\n\t * false is an externally-owned account (EOA) and not a contract.\n\t *\n\t * Among others, `isContract` will return false for the following\n\t * types of addresses:\n\t *\n\t *  - an externally-owned account\n\t *  - a contract in construction\n\t *  - an address where a contract will be created\n\t *  - an address where a contract lived, but was destroyed\n\t * ====\n\t */\n\tfunction isContract(address account) internal view returns (bool) {\n\t\t// According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\t\t// and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\t\t// for accounts without code, i.e. `keccak256('')`\n\t\tbytes32 codehash;\n\t\tbytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tcodehash := extcodehash(account)\n\t\t}\n\t\treturn (codehash != accountHash && codehash != 0x0);\n\t}\n\n\t/**\n\t * @dev Converts an `address` into `address payable`. Note that this is\n\t * simply a type cast: the actual underlying value is not changed.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction toPayable(address account) internal pure returns (address payable) {\n\t\treturn address(uint160(account));\n\t}\n\n\t/**\n\t * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n\t * `recipient`, forwarding all available gas and reverting on errors.\n\t *\n\t * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n\t * of certain opcodes, possibly making contracts go over the 2300 gas limit\n\t * imposed by `transfer`, making them unable to receive funds via\n\t * `transfer`. {sendValue} removes this limitation.\n\t *\n\t * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n\t *\n\t * IMPORTANT: because control is transferred to `recipient`, care must be\n\t * taken to not create reentrancy vulnerabilities. Consider using\n\t * {ReentrancyGuard} or the\n\t * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction sendValue(address recipient, uint256 amount) internal {\n\t\trequire(address(this).balance >= amount, \"Address: insufficient balance\");\n\n\t\t// solhint-disable-next-line avoid-call-value\n\t\t(bool success, ) = recipient.call.value(amount)(\"\");\n\t\trequire(success, \"Address: unable to send value, recipient may have reverted\");\n\t}\n}\n\n\n/**\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0.\n */\n\n\n\n\n\n\ncontract IWrbtcERC20 is IWrbtc, IERC20 {}\n\n\n\r\n\r\n\r\n\r\n/**\r\n  * @dev Liquidity Pool v1 Converter\r\n  *\r\n  * The liquidity pool v1 converter is a specialized version of a converter that manages\r\n  * a classic SovrynSwap liquidity pool.\r\n  *\r\n  * Even though classic pools can have many reserves, the most common configuration of\r\n  * the pool has 2 reserves with 50%/50% weights.\r\n*/\r\ninterface ILiquidityPoolV1Converter {\r\n    /**\r\n      * @dev triggered after a conversion with new price data\r\n      * deprecated, use `TokenRateUpdate` from version 28 and up\r\n      *\r\n      * @param  _connectorToken     reserve token\r\n      * @param  _tokenSupply        smart token supply\r\n      * @param  _connectorBalance   reserve balance\r\n      * @param  _connectorWeight    reserve weight\r\n    */\r\n    event PriceDataUpdate(\r\n        address indexed _connectorToken,\r\n        uint256 _tokenSupply,\r\n        uint256 _connectorBalance,\r\n        uint32 _connectorWeight\r\n    );\r\n\r\n    /**\r\n      * @dev returns the converter type\r\n      *\r\n      * @return see the converter types in the the main contract doc\r\n    */\r\n    function converterType() external pure returns (uint16);\r\n\r\n    /**\r\n      * @dev accepts ownership of the anchor after an ownership transfer\r\n      * also activates the converter\r\n      * can only be called by the contract owner\r\n      * note that prior to version 28, you should use 'acceptTokenOwnership' instead\r\n    */\r\n    function acceptAnchorOwnership() external;\r\n\r\n    /**\r\n      * @dev returns the expected target amount of converting one reserve to another along with the fee\r\n      *\r\n      * @param _sourceToken contract address of the source reserve token\r\n      * @param _targetToken contract address of the target reserve token\r\n      * @param _amount      amount of tokens received from the user\r\n      *\r\n      * @return expected target amount\r\n      * @return expected fee\r\n    */\r\n    function targetAmountAndFee(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount) external view returns (uint256, uint256);\r\n\r\n\r\n    /**\r\n      * @dev increases the pool's liquidity and mints new shares in the pool to the caller\r\n      * note that prior to version 28, you should use 'fund' instead\r\n      *\r\n      * @param _reserveTokens   address of each reserve token\r\n      * @param _reserveAmounts  amount of each reserve token\r\n      * @param _minReturn       token minimum return-amount\r\n    */\r\n    function addLiquidity(IERC20Token[] calldata _reserveTokens, uint256[] calldata _reserveAmounts, uint256 _minReturn) external payable;\r\n\r\n    /**\r\n      * @dev decreases the pool's liquidity and burns the caller's shares in the pool\r\n      * note that prior to version 28, you should use 'liquidate' instead\r\n      *\r\n      * @param _amount                  token amount\r\n      * @param _reserveTokens           address of each reserve token\r\n      * @param _reserveMinReturnAmounts minimum return-amount of each reserve token\r\n    */\r\n    function removeLiquidity(uint256 _amount, IERC20Token[] calldata _reserveTokens, uint256[] calldata _reserveMinReturnAmounts) external;\r\n\r\n    /**\r\n      * @dev increases the pool's liquidity and mints new shares in the pool to the caller\r\n      * for example, if the caller increases the supply by 10%,\r\n      * then it will cost an amount equal to 10% of each reserve token balance\r\n      * note that starting from version 28, you should use 'addLiquidity' instead\r\n      *\r\n      * @param _amount  amount to increase the supply by (in the pool token)\r\n    */\r\n    function fund(uint256 _amount) external payable;\r\n\r\n    /**\r\n      * @dev decreases the pool's liquidity and burns the caller's shares in the pool\r\n      * for example, if the holder sells 10% of the supply,\r\n      * then they will receive 10% of each reserve token balance in return\r\n      * note that starting from version 28, you should use 'removeLiquidity' instead\r\n      *\r\n      * @param _amount  amount to liquidate (in the pool token)\r\n    */\r\n    function liquidate(uint256 _amount) external;\r\n\r\n    /**\r\n      * @dev calculates the number of decimal digits in a given value\r\n      *\r\n      * @param _x   value (assumed positive)\r\n      * @return the number of decimal digits in the given value\r\n    */\r\n    function decimalLength(uint256 _x) external pure returns (uint256);\r\n\r\n    /**\r\n      * @dev calculates the nearest integer to a given quotient\r\n      *\r\n      * @param _n   quotient numerator\r\n      * @param _d   quotient denominator\r\n      * @return the nearest integer to the given quotient\r\n    */\r\n    function roundDiv(uint256 _n, uint256 _d) external pure returns (uint256);\r\n\r\n    /**\r\n      * @dev calculates the average number of decimal digits in a given list of values\r\n      *\r\n      * @param _values  list of values (each of which assumed positive)\r\n      * @return the average number of decimal digits in the given list of values\r\n    */\r\n    function geometricMean(uint256[] calldata _values) external pure returns (uint256);\r\n\r\n    /**\r\n      * @dev deprecated since version 28, backward compatibility - use only for earlier versions\r\n    */\r\n    function token() external view returns (IConverterAnchor);\r\n}\r\n\n\n\n\n\n\ncontract RBTCWrapperProxy {\n    \n    using Address for address;\n    using SafeMath for uint256;\n\n    bytes32 internal constant SOVRYNSWAP_FORMULA = \"SovrynSwapFormula\";\n\n    address public wrbtcTokenAddress;\n    address public sovrynSwapNetworkAddress;\n    \n    /**\n     * @dev triggered after liquidity is added\n     *\n     * @param  _provider           liquidity provider\n     * @param  _reserveAmount      provided reserve token amount\n     * @param  _poolTokenAmount    minted pool token amount\n     */\n    event LiquidityAdded(\n        address indexed _provider,\n        uint256 _reserveAmount,\n        uint256 _poolTokenAmount\n    );\n\n    /**\n     * @dev triggered after liquidity is added to LiquidityPoolConverter V1\n     *\n     * @param  _provider           liquidity provider\n     * @param  _reserveTokens      provided reserve token\n     * @param  _reserveAmounts      provided reserve token amount\n     * @param  _poolTokenAmount    minted pool token amount\n     */\n    event LiquidityAddedToV1(\n        address indexed _provider,\n        IERC20Token[] _reserveTokens, \n        uint256[] _reserveAmounts, \n        uint256 _poolTokenAmount\n    );\n\n    /**\n     * @dev triggered after liquidity is removed\n     *\n     * @param  _provider           liquidity provider\n     * @param  _reserveAmount      added reserve token amount\n     * @param  _poolTokenAmount    burned pool token amount\n     */\n    event LiquidityRemoved(\n        address indexed _provider,\n        uint256 _reserveAmount,\n        uint256 _poolTokenAmount\n    );\n\n    /**\n     * @dev triggered after liquidity is removed from LiquidityPoolConverter V1\n     *\n     * @param  _provider          liquidity provider\n     * @param  _reserveTokens     added reserve tokens\n     * @param  _reserveAmounts    added reserve token amounts\n     */\n    event LiquidityRemovedFromV1(\n        address indexed _provider,\n        IERC20Token[] _reserveTokens,\n        uint256[] _reserveAmounts\n    );\n\n    /**\n     * @dev triggered after liquidity is removed\n     *\n     * @param _beneficiary          account that will receive the conversion result or 0x0 to send the result to the sender account\n     * @param _sourceTokenAmount    amount to convert from, in the source token\n     * @param _targetTokenAmount    amount of tokens received from the conversion, in the target token\n     * @param _path                 conversion path between two tokens in the network\n     */\n    event TokenConverted(\n        address indexed _beneficiary,\n        uint256 indexed _sourceTokenAmount,\n        uint256 indexed _targetTokenAmount,\n        IERC20Token[] _path\n    );\n\n    /**\n     * @dev To check if ddress is contract address \n     */\n    modifier checkAddress(address address_) {\n        require(address_.isContract(), \"The address is not a contract\");\n        _;\n    }\n    \n    constructor(\n        address _wrbtcTokenAddress, \n        address _sovrynSwapNetworkAddress\n    ) \n        public \n        checkAddress(_wrbtcTokenAddress) \n        checkAddress(_sovrynSwapNetworkAddress) \n    {\n        wrbtcTokenAddress = _wrbtcTokenAddress;\n        sovrynSwapNetworkAddress = _sovrynSwapNetworkAddress;\n    }\n\n    function() external payable {\n        require(wrbtcTokenAddress == msg.sender, \"Only can receive rBTC from WRBTC contract\");\n    }\n\n    /**\n     * @dev  \n     * The process:\n     * 1.Accepts RBTC\n     * 2.Sends RBTC to WRBTC contract in order to wrap RBTC to WRBTC\n     * 3.Calls 'addLiquidity' on LiquidityPoolConverter contract\n     * 4.Transfers pool tokens to user\n     * \n     * @param _liquidityPoolConverterAddress    address of LiquidityPoolConverter contract\n     * @param _amount                           amount of liquidity to add\n     * @param _minReturn                        minimum return-amount of reserve tokens\n     *\n     * @return amount of pool tokens minted\n     */\n    function addLiquidity(\n        address _liquidityPoolConverterAddress, \n        uint256 _amount, \n        uint256 _minReturn\n    )  \n        public\n        payable\n        checkAddress(_liquidityPoolConverterAddress)\n        returns(uint256) \n    {\n        require(_amount == msg.value, \"The provided amount should be identical to msg.value\");\n\n        ILiquidityPoolV2Converter _liquidityPoolConverter = ILiquidityPoolV2Converter(_liquidityPoolConverterAddress);\n        ISmartToken _poolToken = _liquidityPoolConverter.poolToken(IERC20Token(wrbtcTokenAddress));\n\n        IWrbtcERC20(wrbtcTokenAddress).deposit.value(_amount)();\n\n        bool successOfApprove = IWrbtcERC20(wrbtcTokenAddress).approve(_liquidityPoolConverterAddress, _amount);\n        require(successOfApprove);\n\n        uint256 poolTokenAmount = _liquidityPoolConverter.addLiquidity(IERC20Token(wrbtcTokenAddress), _amount, _minReturn);\n        \n        bool successOfTransfer = _poolToken.transfer(msg.sender, poolTokenAmount);\n        require(successOfTransfer);\n\n        emit LiquidityAdded(msg.sender, _amount, poolTokenAmount);\n\n        return poolTokenAmount;\n    }\n\n    /**\n     * @dev  \n     * The process:\n     * 1.Accepts RBTC\n     * 2.Sends RBTC to WRBTC contract in order to wrap RBTC to WRBTC\n     * 3.Accepts reserve token and approve LiquidityPoolConverter to transfer\n     * 4.Calls 'addLiquidity' on LiquidityPoolConverter contract\n     * 5.Transfers pool tokens to user\n     * \n     * @param _liquidityPoolConverterAddress    address of LiquidityPoolConverter contract\n     * @param _reserveTokens                    address of each reserve token. The first element should be the address of WRBTC\n     * @param _reserveAmounts                   amount of each reserve token. The first element should be the amount of RBTC\n     * @param _minReturn                        minimum return-amount of reserve tokens\n     *\n     * @return amount of pool tokens minted\n     */\n    function addLiquidityToV1(\n        address _liquidityPoolConverterAddress,\n        IERC20Token[] memory _reserveTokens, \n        uint256[] memory _reserveAmounts, \n        uint256 _minReturn\n    )  \n        public\n        payable\n        checkAddress(_liquidityPoolConverterAddress)\n        returns(uint256) \n    {\n        uint256 amountOfRBTC = _reserveAmounts[0];\n\n        require(address(_reserveTokens[0]) == wrbtcTokenAddress, \"The first reserve token must be WRBTC\");\n        require(amountOfRBTC == msg.value, \"The provided amount of RBTC should be identical to msg.value\");\n\n        bool successOfTransfer;\n        bool successOfApprove;\n\n        IWrbtcERC20(wrbtcTokenAddress).deposit.value(amountOfRBTC)();\n        successOfApprove = IWrbtcERC20(wrbtcTokenAddress).approve(_liquidityPoolConverterAddress, amountOfRBTC);\n        require(successOfApprove, \"Failed to approve converter to transfer WRBTC\");\n        \n        for (uint256 i = 1; i < _reserveTokens.length; i++) {\n            IERC20Token reserveToken = _reserveTokens[i];\n            uint256 reserveAmount = _reserveAmounts[i];\n            successOfTransfer = IERC20Token(reserveToken).transferFrom(msg.sender, address(this), reserveAmount);\n            require(successOfTransfer, \"Failed to transfer reserve token from user\");\n            successOfApprove = IERC20Token(reserveToken).approve(_liquidityPoolConverterAddress, reserveAmount);\n            require(successOfApprove, \"Failed to approve converter to transfer reserve token\");\n        }\n\n        ILiquidityPoolV1Converter _liquidityPoolConverter = ILiquidityPoolV1Converter(_liquidityPoolConverterAddress);\n        ISmartToken _poolToken = ISmartToken(address(_liquidityPoolConverter.token()));\n        uint256 poolTokenAmountBefore = _poolToken.balanceOf(address(this));\n        _liquidityPoolConverter.addLiquidity(_reserveTokens, _reserveAmounts, _minReturn);\n        uint256 poolTokenAmountAfter = _poolToken.balanceOf(address(this));\n        uint256 poolTokenAmount = poolTokenAmountAfter.sub(poolTokenAmountBefore);\n        \n        successOfTransfer = _poolToken.transfer(msg.sender, poolTokenAmount);\n        require(successOfTransfer, \"Failed to transfer pool token to user\");\n\n        emit LiquidityAddedToV1(msg.sender, _reserveTokens, _reserveAmounts, poolTokenAmount);\n\n        return poolTokenAmount;\n    }\n    \n    /**\n     * @notice \n     * Before calling this function to remove liquidity, users need approve this contract to be able to spend or transfer their pool tokens\n     *\n     * @dev  \n     * The process:     \n     * 1.Transfers pool tokens to this contract\n     * 2.Calls 'removeLiquidity' on LiquidityPoolConverter contract\n     * 3.Calls 'withdraw' on WRBTC contract in order to unwrap WRBTC to RBTC\n     * 4.Sneds RBTC to user\n     * \n     * @param _liquidityPoolConverterAddress    address of LiquidityPoolConverter contract\n     * @param _amount                           amount of pool tokens to burn\n     * @param _minReturn                        minimum return-amount of reserve tokens\n     * \n     * @return amount of liquidity removed also WRBTC unwrapped to RBTC\n     */\n    function removeLiquidity(\n        address _liquidityPoolConverterAddress, \n        uint256 _amount, \n        uint256 _minReturn\n    )   \n        public \n        checkAddress(_liquidityPoolConverterAddress)\n        returns(uint256) \n    {\n        ILiquidityPoolV2Converter _liquidityPoolConverter = ILiquidityPoolV2Converter(_liquidityPoolConverterAddress);\n        ISmartToken _poolToken = _liquidityPoolConverter.poolToken(IERC20Token(wrbtcTokenAddress));\n\n        bool successOfTransferFrom = _poolToken.transferFrom(msg.sender, address(this), _amount);\n        require(successOfTransferFrom);\n\n        uint256 reserveAmount = _liquidityPoolConverter.removeLiquidity(_poolToken, _amount, _minReturn);\n        \n        IWrbtcERC20(wrbtcTokenAddress).withdraw(reserveAmount);\n        \n        (bool successOfSendRBTC,) = msg.sender.call.value(reserveAmount)(\"\");\n        require(successOfSendRBTC, \"Failed to send RBTC to user\");\n\n        emit LiquidityRemoved(msg.sender, reserveAmount, _amount);\n\n        return reserveAmount;\n    }\n\n    /**\n     * @notice \n     * Before calling this function to remove liquidity, users need approve this contract to be able to spend or transfer their pool tokens\n     *\n     * @dev  \n     * The process:     \n     * 1.Transfers pool tokens to this contract\n     * 2.Calls 'removeLiquidity' on LiquidityPoolConverter contract\n     * 3.Calls 'withdraw' on WRBTC contract in order to unwrap WRBTC to RBTC\n     * 4.Sneds RBTC and/or other reserve tokens to user\n     * \n     * @param _liquidityPoolConverterAddress    address of LiquidityPoolConverter contract\n     * @param _amount                           amount of pool tokens to burn\n     * @param _reserveTokens                    address of each reserve token. The first element should be the address of WRBTC\n     * @param _reserveMinReturnAmounts          minimum return-amount of each reserve token. The first element should be the minimum return-amount of WRBTC\n     */\n    function removeLiquidityFromV1(\n        address _liquidityPoolConverterAddress,\n        uint256 _amount, \n        IERC20Token[] memory _reserveTokens, \n        uint256[] memory _reserveMinReturnAmounts\n    )   \n        public \n        checkAddress(_liquidityPoolConverterAddress)\n    {\n        require(_amount > 0, \"The amount should larger than zero\");\n        require(address(_reserveTokens[0]) == wrbtcTokenAddress, \"The first reserve token must be WRBTC\");\n\n        uint256[] memory reserveAmounts = new uint256[](_reserveTokens.length);\n        ILiquidityPoolV1Converter _liquidityPoolConverter = ILiquidityPoolV1Converter(_liquidityPoolConverterAddress);\n        ISmartToken _poolToken = ISmartToken(address(_liquidityPoolConverter.token()));\n\n        bool successOfTransferFrom = _poolToken.transferFrom(msg.sender, address(this), _amount);\n        require(successOfTransferFrom);\n\n        uint256 lengthOfToken = _reserveTokens.length;\n        IERC20Token reserveToken;\n        uint256[] memory reserveAmountBefore = new uint256[](lengthOfToken);\n        for (uint256 i = 0; i < lengthOfToken; i++) {\n            reserveToken = _reserveTokens[i];\n            reserveAmountBefore[i] = reserveToken.balanceOf(address(this));\n        }\n\n        _liquidityPoolConverter.removeLiquidity(_amount, _reserveTokens, _reserveMinReturnAmounts);\n\n        uint256 reserveAmount;\n        bool successOfTransfer;\n        for (uint256 i = 1; i < lengthOfToken; i++) {\n            reserveToken = _reserveTokens[i];\n\n            reserveAmount = reserveToken.balanceOf(address(this)).sub(reserveAmountBefore[i]); \n            require(reserveAmount >= _reserveMinReturnAmounts[i], \"ERR_ZERO_TARGET_AMOUNT\");\n            reserveAmounts[i] = reserveAmount;\n\n            successOfTransfer = IERC20Token(reserveToken).transfer(msg.sender, reserveAmount);\n            require(successOfTransfer, \"Failed to transfer reserve token to user\");\n        }\n\n        uint256 wrbtcAmount = _reserveTokens[0].balanceOf(address(this)).sub(reserveAmountBefore[0]);\n        require(wrbtcAmount >= _reserveMinReturnAmounts[0], \"ERR_ZERO_TARGET_AMOUNT\");\n        reserveAmounts[0] = wrbtcAmount;\n        IWrbtcERC20(wrbtcTokenAddress).withdraw(wrbtcAmount);\n        (bool successOfSendRBTC,) = msg.sender.call.value(wrbtcAmount)(\"\");\n        require(successOfSendRBTC, \"Failed to send RBTC to user\");\n\n        emit LiquidityRemovedFromV1(msg.sender, _reserveTokens, reserveAmounts);\n    }\n    \n    /**\n     * @notice\n     * Before calling this function to swap token to RBTC, users need approve this contract to be able to spend or transfer their tokens\n     *\n     * @param _path         conversion path between two tokens in the network\n     * @param _amount       amount to convert from, in the source token\n     * @param _minReturn    if the conversion results in an amount smaller than the minimum return - it is cancelled, must be greater than zero\n     * \n     * @return amount of tokens received from the conversion\n     */\n    function convertByPath(\n        IERC20Token[] memory _path,\n        uint256 _amount, \n        uint256 _minReturn\n    ) \n        public \n        payable\n        returns(uint256) \n    {    \n        ISovrynSwapNetwork _sovrynSwapNetwork =  ISovrynSwapNetwork(sovrynSwapNetworkAddress);\n  \n        if (msg.value != 0) {\n            require(_path[0] == IERC20Token(wrbtcTokenAddress), \"Value may only be sent for WRBTC transfers\");\n            require(_amount == msg.value, \"The provided amount should be identical to msg.value\");\n\n            IWrbtcERC20(wrbtcTokenAddress).deposit.value(_amount)();\n\n            bool successOfApprove = IWrbtcERC20(wrbtcTokenAddress).approve(sovrynSwapNetworkAddress, _amount);\n            require(successOfApprove);\n\n            uint256 _targetTokenAmount = _sovrynSwapNetwork.convertByPath(_path, _amount, _minReturn, msg.sender, address(0), 0);\n\n            emit TokenConverted(msg.sender, _amount, _targetTokenAmount, _path);\n\n            return _targetTokenAmount;\n        }\n        else {\n            require(_path[_path.length-1] == IERC20Token(wrbtcTokenAddress), \"It only could be swapped to WRBTC\");\n            \n            IERC20Token _token = IERC20Token(_path[0]);\n\n            bool successOfTransferFrom = _token.transferFrom(msg.sender, address(this), _amount);\n            require(successOfTransferFrom);\n\n            bool successOfApprove = _token.approve(sovrynSwapNetworkAddress, _amount);\n            require(successOfApprove);\n                 \n            uint256 _targetTokenAmount = _sovrynSwapNetwork.convertByPath(_path, _amount, _minReturn, address(this), address(0), 0);\n\n            IWrbtcERC20(wrbtcTokenAddress).withdraw(_targetTokenAmount);\n\n            (bool successOfSendRBTC,) = msg.sender.call.value(_targetTokenAmount)(\"\");\n            require(successOfSendRBTC, \"Failed to send RBTC to user\");\n\n            emit TokenConverted(msg.sender, _amount, _targetTokenAmount, _path);\n\n            return _targetTokenAmount;\n        }        \n    }\n}\n\n\n",
            "file": "RBTCWrapperProxy_flat.sol"
        }
    ],
    "libraries": {},
    "constructorArguments": [
        "0x542fda317318ebf1d3deaf76e0b632741a7e677d",
        "0x98ace08d2b759a265ae326f010496bcd63c15afc"
    ],
    "creationData": {
        "blockHash": "0x256e4f1ac407af1535c6b532a29713748c71fc2461eef77cae75650c891834e5",
        "blockNumber": 3245026,
        "transactionHash": "0x8b68b52a2944105e26cbaf7a69dc880bf84c9bb1e396f41df96a2a125c7b718b",
        "timestamp": 1617719504
    }
}