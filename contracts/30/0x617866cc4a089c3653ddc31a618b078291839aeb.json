{
    "address": "0x617866cc4a089c3653ddc31a618b078291839aeb",
    "net": {
        "id": "30",
        "name": "RSK Mainnet"
    },
    "name": "DevelopmentFund",
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        }
    },
    "version": "0.5.17+commit.d19bba13",
    "source": "pragma solidity ^0.5.17;\n\nimport \"../../openzeppelin/SafeMath.sol\";\nimport \"../../interfaces/IERC20.sol\";\n\n/**\n *  @title A holding contract for Sovryn Development Fund.\n *  @author Franklin Richards\n *  @notice You can use this contract for timed token release from Dev Fund.\n */\ncontract DevelopmentFund {\n\tusing SafeMath for uint256;\n\n\t/* Storage */\n\n\t/// @notice The SOV token contract.\n\tIERC20 public SOV;\n\n\t/// @notice The current contract status.\n\tenum Status { Deployed, Active, Expired }\n\tStatus public status;\n\n\t/// @notice The owner of the locked tokens (usually Governance).\n\taddress public lockedTokenOwner;\n\t/// @notice The owner of the unlocked tokens (usually MultiSig).\n\taddress public unlockedTokenOwner;\n\t/// @notice The emergency transfer wallet/contract.\n\taddress public safeVault;\n\t/// @notice The new locked token owner waiting to be approved.\n\taddress public newLockedTokenOwner;\n\n\t/// @notice The last token release timestamp or the time of contract creation.\n\tuint256 public lastReleaseTime;\n\n\t/// @notice The release duration array in seconds.\n\tuint256[] public releaseDuration;\n\t/// @notice The release token amount.\n\tuint256[] public releaseTokenAmount;\n\n\t/* Events */\n\n\t/// @notice Emitted when the contract is activated.\n\tevent DevelopmentFundActivated();\n\n\t/// @notice Emitted when the contract is expired due to total token transfer.\n\tevent DevelopmentFundExpired();\n\n\t/// @notice Emitted when a new locked owner is added to the contract.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _newLockedOwner The address which is added as the new locked owner.\n\t/// @dev Can only be initiated by the current locked owner.\n\tevent NewLockedOwnerAdded(address indexed _initiator, address indexed _newLockedOwner);\n\n\t/// @notice Emitted when a new locked owner is approved to the contract.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _oldLockedOwner The address of the previous locked owner.\n\t/// @param _newLockedOwner The address which is added as the new locked owner.\n\t/// @dev Can only be initiated by the current unlocked owner.\n\tevent NewLockedOwnerApproved(address indexed _initiator, address indexed _oldLockedOwner, address indexed _newLockedOwner);\n\n\t/// @notice Emitted when a new unlocked owner is updated in the contract.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _newUnlockedOwner The address which is updated as the new unlocked owner.\n\t/// @dev Can only be initiated by the current locked owner.\n\tevent UnlockedOwnerUpdated(address indexed _initiator, address indexed _newUnlockedOwner);\n\n\t/// @notice Emitted when a new token deposit is done.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _amount The total amount of token deposited.\n\tevent TokenDeposit(address indexed _initiator, uint256 _amount);\n\n\t/// @notice Emitted when a new release schedule is created.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _releaseCount The number of releases planned in the schedule.\n\tevent TokenReleaseChanged(address indexed _initiator, uint256 _releaseCount);\n\n\t/// @notice Emitted when a unlocked owner transfers all the tokens to a safe vault.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _receiver The address which receives this token withdrawed.\n\t/// @param _amount The total amount of token transferred.\n\t/// @dev This is done in an emergency situation only to a predetermined wallet by locked token owner.\n\tevent LockedTokenTransferByUnlockedOwner(address indexed _initiator, address indexed _receiver, uint256 _amount);\n\n\t/// @notice Emitted when a unlocked owner withdraws the released tokens.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _amount The total amount of token withdrawed.\n\t/// @param _releaseCount The total number of releases done based on duration.\n\tevent UnlockedTokenWithdrawalByUnlockedOwner(address indexed _initiator, uint256 _amount, uint256 _releaseCount);\n\n\t/// @notice Emitted when a locked owner transfers all the tokens to a receiver.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _receiver The address which receives this token transfer.\n\t/// @param _amount The total amount of token transferred.\n\t/// @dev This is done only by locked token owner.\n\tevent LockedTokenTransferByLockedOwner(address indexed _initiator, address indexed _receiver, uint256 _amount);\n\n\t/* Modifiers */\n\n\tmodifier onlyLockedTokenOwner() {\n\t\trequire(msg.sender == lockedTokenOwner, \"Only Locked Token Owner can call this.\");\n\t\t_;\n\t}\n\n\tmodifier onlyUnlockedTokenOwner() {\n\t\trequire(msg.sender == unlockedTokenOwner, \"Only Unlocked Token Owner can call this.\");\n\t\t_;\n\t}\n\n\tmodifier checkStatus(Status s) {\n\t\trequire(status == s, \"The contract is not in the right state.\");\n\t\t_;\n\t}\n\n\t/* Functions */\n\n\t/**\n\t * @notice Setup the required parameters.\n\t * @param _SOV The SOV token address.\n\t * @param _lockedTokenOwner The owner of the locked tokens & contract.\n\t * @param _safeVault The emergency wallet/contract to transfer token.\n\t * @param _unlockedTokenOwner The owner of the unlocked tokens.\n\t * @param _lastReleaseTime If the last release time is to be changed, zero if no change required.\n\t * @param _releaseDuration The time duration between each release calculated from `lastReleaseTime` in seconds.\n\t * @param _releaseTokenAmount The amount of token to be released in each duration/interval.\n\t * @dev Initial release schedule should be verified, error will result in either redeployment or calling changeTokenReleaseSchedule() after init() along with token transfer.\n\t */\n\tconstructor(\n\t\taddress _SOV,\n\t\taddress _lockedTokenOwner,\n\t\taddress _safeVault,\n\t\taddress _unlockedTokenOwner,\n\t\tuint256 _lastReleaseTime,\n\t\tuint256[] memory _releaseDuration,\n\t\tuint256[] memory _releaseTokenAmount\n\t) public {\n\t\trequire(_SOV != address(0), \"Invalid SOV Address.\");\n\t\trequire(_lockedTokenOwner != address(0), \"Locked token & contract owner address invalid.\");\n\t\trequire(_safeVault != address(0), \"Safe Vault address invalid.\");\n\t\trequire(_unlockedTokenOwner != address(0), \"Unlocked token address invalid.\");\n\n\t\tSOV = IERC20(_SOV);\n\t\tlockedTokenOwner = _lockedTokenOwner;\n\t\tsafeVault = _safeVault;\n\t\tunlockedTokenOwner = _unlockedTokenOwner;\n\n\t\tlastReleaseTime = _lastReleaseTime;\n\t\t/// If last release time passed is zero, then current time stamp will be used as the last release time.\n\t\tif (_lastReleaseTime == 0) {\n\t\t\tlastReleaseTime = block.timestamp;\n\t\t}\n\n\t\t/// Checking if the schedule duration and token allocation length matches.\n\t\trequire(_releaseDuration.length == _releaseTokenAmount.length, \"Release Schedule does not match.\");\n\n\t\t/// Finally we update the token release schedule.\n\t\treleaseDuration = _releaseDuration;\n\t\treleaseTokenAmount = _releaseTokenAmount;\n\t}\n\n\t/**\n\t * @notice This function is called once after deployment for token transfer based on schedule.\n\t * @dev Without calling this function, the contract will not work.\n\t */\n\tfunction init() public checkStatus(Status.Deployed) {\n\t\tuint256[] memory _releaseTokenAmount = releaseTokenAmount;\n\t\trequire(_releaseTokenAmount.length != 0, \"Release Schedule not set.\");\n\n\t\t/// Getting the current release schedule total token amount.\n\t\tuint256 _releaseTotalTokenAmount;\n\t\tfor (uint256 amountIndex = 0; amountIndex < _releaseTokenAmount.length; amountIndex++) {\n\t\t\t_releaseTotalTokenAmount = _releaseTotalTokenAmount.add(_releaseTokenAmount[amountIndex]);\n\t\t}\n\n\t\tbool txStatus = SOV.transferFrom(msg.sender, address(this), _releaseTotalTokenAmount);\n\t\trequire(txStatus, \"Not enough token sent to change release schedule.\");\n\n\t\tstatus = Status.Active;\n\n\t\temit DevelopmentFundActivated();\n\t}\n\n\t/**\n\t * @notice Update Locked Token Owner.\n\t * @param _newLockedTokenOwner The owner of the locked tokens & contract.\n\t */\n\tfunction updateLockedTokenOwner(address _newLockedTokenOwner) public onlyLockedTokenOwner checkStatus(Status.Active) {\n\t\trequire(_newLockedTokenOwner != address(0), \"New locked token owner address invalid.\");\n\n\t\tnewLockedTokenOwner = _newLockedTokenOwner;\n\n\t\temit NewLockedOwnerAdded(msg.sender, _newLockedTokenOwner);\n\t}\n\n\t/**\n\t * @notice Approve Locked Token Owner.\n\t * @dev This approval is an added security to avoid development fund takeover by a compromised locked token owner.\n\t */\n\tfunction approveLockedTokenOwner() public onlyUnlockedTokenOwner checkStatus(Status.Active) {\n\t\trequire(newLockedTokenOwner != address(0), \"No new locked owner added.\");\n\n\t\temit NewLockedOwnerApproved(msg.sender, lockedTokenOwner, newLockedTokenOwner);\n\n\t\tlockedTokenOwner = newLockedTokenOwner;\n\n\t\tnewLockedTokenOwner = address(0);\n\t}\n\n\t/**\n\t * @notice Update Unlocked Token Owner.\n\t * @param _newUnlockedTokenOwner The new unlocked token owner.\n\t */\n\tfunction updateUnlockedTokenOwner(address _newUnlockedTokenOwner) public onlyLockedTokenOwner checkStatus(Status.Active) {\n\t\trequire(_newUnlockedTokenOwner != address(0), \"New unlocked token owner address invalid.\");\n\n\t\tunlockedTokenOwner = _newUnlockedTokenOwner;\n\n\t\temit UnlockedOwnerUpdated(msg.sender, _newUnlockedTokenOwner);\n\t}\n\n\t/**\n\t * @notice Deposit tokens to this contract.\n\t * @param _amount the amount of tokens deposited.\n\t * @dev These tokens can be withdrawn/transferred any time by the lockedTokenOwner.\n\t */\n\tfunction depositTokens(uint256 _amount) public checkStatus(Status.Active) {\n\t\trequire(_amount > 0, \"Amount needs to be bigger than zero.\");\n\n\t\tbool txStatus = SOV.transferFrom(msg.sender, address(this), _amount);\n\t\trequire(txStatus, \"Token transfer was not successful.\");\n\n\t\temit TokenDeposit(msg.sender, _amount);\n\t}\n\n\t/**\n\t * @notice Change the Token release schedule. It creates a completely new schedule, and does not append on the previous one.\n\t * @param _newLastReleaseTime If the last release time is to be changed, zero if no change required.\n\t * @param _releaseDuration The time duration between each release calculated from `lastReleaseTime` in seconds.\n\t * @param _releaseTokenAmount The amount of token to be released in each duration/interval.\n\t * @dev _releaseDuration and _releaseTokenAmount should be specified in reverse order of release.\n\t */\n\tfunction changeTokenReleaseSchedule(\n\t\tuint256 _newLastReleaseTime,\n\t\tuint256[] memory _releaseDuration,\n\t\tuint256[] memory _releaseTokenAmount\n\t) public onlyLockedTokenOwner checkStatus(Status.Active) {\n\t\t/// Checking if the schedule duration and token allocation length matches.\n\t\trequire(_releaseDuration.length == _releaseTokenAmount.length, \"Release Schedule does not match.\");\n\n\t\t/// If the last release time has to be changed, then you can pass a new one here.\n\t\t/// Or else, the duration of release will be calculated based on this timestamp.\n\t\t/// Even a future timestamp can be mentioned here.\n\t\tif (_newLastReleaseTime != 0) {\n\t\t\tlastReleaseTime = _newLastReleaseTime;\n\t\t}\n\n\t\t/// Checking if the contract have enough token balance for the release.\n\t\tuint256 _releaseTotalTokenAmount;\n\t\tfor (uint256 amountIndex = 0; amountIndex < _releaseTokenAmount.length; amountIndex++) {\n\t\t\t_releaseTotalTokenAmount = _releaseTotalTokenAmount.add(_releaseTokenAmount[amountIndex]);\n\t\t}\n\n\t\t/// Getting the current token balance of the contract.\n\t\tuint256 remainingTokens = SOV.balanceOf(address(this));\n\n\t\t/// If the token balance is not sufficient, then we transfer the change to contract.\n\t\tif (remainingTokens < _releaseTotalTokenAmount) {\n\t\t\tbool txStatus = SOV.transferFrom(msg.sender, address(this), _releaseTotalTokenAmount.sub(remainingTokens));\n\t\t\trequire(txStatus, \"Not enough token sent to change release schedule.\");\n\t\t} else if (remainingTokens > _releaseTotalTokenAmount) {\n\t\t\t/// If there are more tokens than required, send the extra tokens back.\n\t\t\tbool txStatus = SOV.transfer(msg.sender, remainingTokens.sub(_releaseTotalTokenAmount));\n\t\t\trequire(txStatus, \"Token not received by the Locked Owner.\");\n\t\t}\n\n\t\t/// Finally we update the token release schedule.\n\t\treleaseDuration = _releaseDuration;\n\t\treleaseTokenAmount = _releaseTokenAmount;\n\n\t\temit TokenReleaseChanged(msg.sender, _releaseDuration.length);\n\t}\n\n\t/**\n\t * @notice Transfers all of the remaining tokens in an emergency situation.\n\t * @dev This could be called when governance or development fund might be compromised.\n\t */\n\tfunction transferTokensByUnlockedTokenOwner() public onlyUnlockedTokenOwner checkStatus(Status.Active) {\n\t\tuint256 remainingTokens = SOV.balanceOf(address(this));\n\t\tbool txStatus = SOV.transfer(safeVault, remainingTokens);\n\t\trequire(txStatus, \"Token transfer was not successful. Check receiver address.\");\n\t\tstatus = Status.Expired;\n\n\t\temit LockedTokenTransferByUnlockedOwner(msg.sender, safeVault, remainingTokens);\n\t\temit DevelopmentFundExpired();\n\t}\n\n\t/**\n\t * @notice Withdraws all unlocked/released token.\n\t * @param _amount The amount to be withdrawn.\n\t */\n\tfunction withdrawTokensByUnlockedTokenOwner(uint256 _amount) public onlyUnlockedTokenOwner checkStatus(Status.Active) {\n\t\trequire(_amount > 0, \"Zero can't be withdrawn.\");\n\n\t\tuint256 count; /// To know how many elements to be removed from the release schedule.\n\t\tuint256 amount = _amount; /// To know the total amount to be transferred.\n\t\tuint256 newLastReleaseTimeMemory = lastReleaseTime; /// Better to use memory than storage.\n\t\tuint256 releaseLength = releaseDuration.length.sub(1); /// Also checks if there are any elements in the release schedule.\n\n\t\t/// Getting the amount of tokens, the number of releases and calculating the total duration.\n\t\twhile (amount > 0 && newLastReleaseTimeMemory.add(releaseDuration[releaseLength]) < block.timestamp) {\n\t\t\tif (amount >= releaseTokenAmount[releaseLength]) {\n\t\t\t\tamount = amount.sub(releaseTokenAmount[releaseLength]);\n\t\t\t\tnewLastReleaseTimeMemory = newLastReleaseTimeMemory.add(releaseDuration[releaseLength]);\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\t/// This will be the last case, if correct amount is passed.\n\t\t\t\treleaseTokenAmount[releaseLength] = releaseTokenAmount[releaseLength].sub(amount);\n\t\t\t\tamount = 0;\n\t\t\t}\n\t\t\treleaseLength--;\n\t\t}\n\n\t\t/// Checking to see if atleast a single schedule was reached or not.\n\t\trequire(count > 0 || amount == 0, \"No release schedule reached.\");\n\n\t\t/// If locked token owner tries to send a higher amount that schedule\n\t\tuint256 value = _amount.sub(amount);\n\n\t\t/// Now clearing up the release schedule.\n\t\treleaseDuration.length -= count;\n\t\treleaseTokenAmount.length -= count;\n\n\t\t/// Updating the last release time.\n\t\tlastReleaseTime = newLastReleaseTimeMemory;\n\n\t\t/// Sending the amount to unlocked token owner.\n\t\tbool txStatus = SOV.transfer(msg.sender, value);\n\t\trequire(txStatus, \"Token transfer was not successful. Check receiver address.\");\n\n\t\temit UnlockedTokenWithdrawalByUnlockedOwner(msg.sender, value, count);\n\t}\n\n\t/**\n\t * @notice Transfers all of the remaining tokens by the owner maybe for an upgrade.\n\t * @dev This could be called when the current development fund has to be upgraded.\n\t * @param _receiver The address which receives this token transfer.\n\t */\n\tfunction transferTokensByLockedTokenOwner(address _receiver) public onlyLockedTokenOwner checkStatus(Status.Active) {\n\t\tuint256 remainingTokens = SOV.balanceOf(address(this));\n\t\tbool txStatus = SOV.transfer(_receiver, remainingTokens);\n\t\trequire(txStatus, \"Token transfer was not successful. Check receiver address.\");\n\t\tstatus = Status.Expired;\n\n\t\temit LockedTokenTransferByLockedOwner(msg.sender, _receiver, remainingTokens);\n\t\temit DevelopmentFundExpired();\n\t}\n\n\t/* Getter Functions */\n\n\t/**\n\t * @notice Function to read the current token release duration.\n\t * @return _currentReleaseDuration The current release duration.\n\t */\n\tfunction getReleaseDuration() public view returns (uint256[] memory _releaseTokenDuration) {\n\t\treturn releaseDuration;\n\t}\n\n\t/**\n\t * @notice Function to read the current token release amount.\n\t * @return _currentReleaseTokenAmount The current release token amount.\n\t */\n\tfunction getReleaseTokenAmount() public view returns (uint256[] memory _currentReleaseTokenAmount) {\n\t\treturn releaseTokenAmount;\n\t}\n}\n",
    "imports": [
        {
            "name": "DevelopmentFund.sol",
            "contents": "pragma solidity ^0.5.17;\n\nimport \"../../openzeppelin/SafeMath.sol\";\nimport \"../../interfaces/IERC20.sol\";\n\n/**\n *  @title A holding contract for Sovryn Development Fund.\n *  @author Franklin Richards\n *  @notice You can use this contract for timed token release from Dev Fund.\n */\ncontract DevelopmentFund {\n\tusing SafeMath for uint256;\n\n\t/* Storage */\n\n\t/// @notice The SOV token contract.\n\tIERC20 public SOV;\n\n\t/// @notice The current contract status.\n\tenum Status { Deployed, Active, Expired }\n\tStatus public status;\n\n\t/// @notice The owner of the locked tokens (usually Governance).\n\taddress public lockedTokenOwner;\n\t/// @notice The owner of the unlocked tokens (usually MultiSig).\n\taddress public unlockedTokenOwner;\n\t/// @notice The emergency transfer wallet/contract.\n\taddress public safeVault;\n\t/// @notice The new locked token owner waiting to be approved.\n\taddress public newLockedTokenOwner;\n\n\t/// @notice The last token release timestamp or the time of contract creation.\n\tuint256 public lastReleaseTime;\n\n\t/// @notice The release duration array in seconds.\n\tuint256[] public releaseDuration;\n\t/// @notice The release token amount.\n\tuint256[] public releaseTokenAmount;\n\n\t/* Events */\n\n\t/// @notice Emitted when the contract is activated.\n\tevent DevelopmentFundActivated();\n\n\t/// @notice Emitted when the contract is expired due to total token transfer.\n\tevent DevelopmentFundExpired();\n\n\t/// @notice Emitted when a new locked owner is added to the contract.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _newLockedOwner The address which is added as the new locked owner.\n\t/// @dev Can only be initiated by the current locked owner.\n\tevent NewLockedOwnerAdded(address indexed _initiator, address indexed _newLockedOwner);\n\n\t/// @notice Emitted when a new locked owner is approved to the contract.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _oldLockedOwner The address of the previous locked owner.\n\t/// @param _newLockedOwner The address which is added as the new locked owner.\n\t/// @dev Can only be initiated by the current unlocked owner.\n\tevent NewLockedOwnerApproved(address indexed _initiator, address indexed _oldLockedOwner, address indexed _newLockedOwner);\n\n\t/// @notice Emitted when a new unlocked owner is updated in the contract.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _newUnlockedOwner The address which is updated as the new unlocked owner.\n\t/// @dev Can only be initiated by the current locked owner.\n\tevent UnlockedOwnerUpdated(address indexed _initiator, address indexed _newUnlockedOwner);\n\n\t/// @notice Emitted when a new token deposit is done.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _amount The total amount of token deposited.\n\tevent TokenDeposit(address indexed _initiator, uint256 _amount);\n\n\t/// @notice Emitted when a new release schedule is created.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _releaseCount The number of releases planned in the schedule.\n\tevent TokenReleaseChanged(address indexed _initiator, uint256 _releaseCount);\n\n\t/// @notice Emitted when a unlocked owner transfers all the tokens to a safe vault.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _receiver The address which receives this token withdrawed.\n\t/// @param _amount The total amount of token transferred.\n\t/// @dev This is done in an emergency situation only to a predetermined wallet by locked token owner.\n\tevent LockedTokenTransferByUnlockedOwner(address indexed _initiator, address indexed _receiver, uint256 _amount);\n\n\t/// @notice Emitted when a unlocked owner withdraws the released tokens.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _amount The total amount of token withdrawed.\n\t/// @param _releaseCount The total number of releases done based on duration.\n\tevent UnlockedTokenWithdrawalByUnlockedOwner(address indexed _initiator, uint256 _amount, uint256 _releaseCount);\n\n\t/// @notice Emitted when a locked owner transfers all the tokens to a receiver.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _receiver The address which receives this token transfer.\n\t/// @param _amount The total amount of token transferred.\n\t/// @dev This is done only by locked token owner.\n\tevent LockedTokenTransferByLockedOwner(address indexed _initiator, address indexed _receiver, uint256 _amount);\n\n\t/* Modifiers */\n\n\tmodifier onlyLockedTokenOwner() {\n\t\trequire(msg.sender == lockedTokenOwner, \"Only Locked Token Owner can call this.\");\n\t\t_;\n\t}\n\n\tmodifier onlyUnlockedTokenOwner() {\n\t\trequire(msg.sender == unlockedTokenOwner, \"Only Unlocked Token Owner can call this.\");\n\t\t_;\n\t}\n\n\tmodifier checkStatus(Status s) {\n\t\trequire(status == s, \"The contract is not in the right state.\");\n\t\t_;\n\t}\n\n\t/* Functions */\n\n\t/**\n\t * @notice Setup the required parameters.\n\t * @param _SOV The SOV token address.\n\t * @param _lockedTokenOwner The owner of the locked tokens & contract.\n\t * @param _safeVault The emergency wallet/contract to transfer token.\n\t * @param _unlockedTokenOwner The owner of the unlocked tokens.\n\t * @param _lastReleaseTime If the last release time is to be changed, zero if no change required.\n\t * @param _releaseDuration The time duration between each release calculated from `lastReleaseTime` in seconds.\n\t * @param _releaseTokenAmount The amount of token to be released in each duration/interval.\n\t * @dev Initial release schedule should be verified, error will result in either redeployment or calling changeTokenReleaseSchedule() after init() along with token transfer.\n\t */\n\tconstructor(\n\t\taddress _SOV,\n\t\taddress _lockedTokenOwner,\n\t\taddress _safeVault,\n\t\taddress _unlockedTokenOwner,\n\t\tuint256 _lastReleaseTime,\n\t\tuint256[] memory _releaseDuration,\n\t\tuint256[] memory _releaseTokenAmount\n\t) public {\n\t\trequire(_SOV != address(0), \"Invalid SOV Address.\");\n\t\trequire(_lockedTokenOwner != address(0), \"Locked token & contract owner address invalid.\");\n\t\trequire(_safeVault != address(0), \"Safe Vault address invalid.\");\n\t\trequire(_unlockedTokenOwner != address(0), \"Unlocked token address invalid.\");\n\n\t\tSOV = IERC20(_SOV);\n\t\tlockedTokenOwner = _lockedTokenOwner;\n\t\tsafeVault = _safeVault;\n\t\tunlockedTokenOwner = _unlockedTokenOwner;\n\n\t\tlastReleaseTime = _lastReleaseTime;\n\t\t/// If last release time passed is zero, then current time stamp will be used as the last release time.\n\t\tif (_lastReleaseTime == 0) {\n\t\t\tlastReleaseTime = block.timestamp;\n\t\t}\n\n\t\t/// Checking if the schedule duration and token allocation length matches.\n\t\trequire(_releaseDuration.length == _releaseTokenAmount.length, \"Release Schedule does not match.\");\n\n\t\t/// Finally we update the token release schedule.\n\t\treleaseDuration = _releaseDuration;\n\t\treleaseTokenAmount = _releaseTokenAmount;\n\t}\n\n\t/**\n\t * @notice This function is called once after deployment for token transfer based on schedule.\n\t * @dev Without calling this function, the contract will not work.\n\t */\n\tfunction init() public checkStatus(Status.Deployed) {\n\t\tuint256[] memory _releaseTokenAmount = releaseTokenAmount;\n\t\trequire(_releaseTokenAmount.length != 0, \"Release Schedule not set.\");\n\n\t\t/// Getting the current release schedule total token amount.\n\t\tuint256 _releaseTotalTokenAmount;\n\t\tfor (uint256 amountIndex = 0; amountIndex < _releaseTokenAmount.length; amountIndex++) {\n\t\t\t_releaseTotalTokenAmount = _releaseTotalTokenAmount.add(_releaseTokenAmount[amountIndex]);\n\t\t}\n\n\t\tbool txStatus = SOV.transferFrom(msg.sender, address(this), _releaseTotalTokenAmount);\n\t\trequire(txStatus, \"Not enough token sent to change release schedule.\");\n\n\t\tstatus = Status.Active;\n\n\t\temit DevelopmentFundActivated();\n\t}\n\n\t/**\n\t * @notice Update Locked Token Owner.\n\t * @param _newLockedTokenOwner The owner of the locked tokens & contract.\n\t */\n\tfunction updateLockedTokenOwner(address _newLockedTokenOwner) public onlyLockedTokenOwner checkStatus(Status.Active) {\n\t\trequire(_newLockedTokenOwner != address(0), \"New locked token owner address invalid.\");\n\n\t\tnewLockedTokenOwner = _newLockedTokenOwner;\n\n\t\temit NewLockedOwnerAdded(msg.sender, _newLockedTokenOwner);\n\t}\n\n\t/**\n\t * @notice Approve Locked Token Owner.\n\t * @dev This approval is an added security to avoid development fund takeover by a compromised locked token owner.\n\t */\n\tfunction approveLockedTokenOwner() public onlyUnlockedTokenOwner checkStatus(Status.Active) {\n\t\trequire(newLockedTokenOwner != address(0), \"No new locked owner added.\");\n\n\t\temit NewLockedOwnerApproved(msg.sender, lockedTokenOwner, newLockedTokenOwner);\n\n\t\tlockedTokenOwner = newLockedTokenOwner;\n\n\t\tnewLockedTokenOwner = address(0);\n\t}\n\n\t/**\n\t * @notice Update Unlocked Token Owner.\n\t * @param _newUnlockedTokenOwner The new unlocked token owner.\n\t */\n\tfunction updateUnlockedTokenOwner(address _newUnlockedTokenOwner) public onlyLockedTokenOwner checkStatus(Status.Active) {\n\t\trequire(_newUnlockedTokenOwner != address(0), \"New unlocked token owner address invalid.\");\n\n\t\tunlockedTokenOwner = _newUnlockedTokenOwner;\n\n\t\temit UnlockedOwnerUpdated(msg.sender, _newUnlockedTokenOwner);\n\t}\n\n\t/**\n\t * @notice Deposit tokens to this contract.\n\t * @param _amount the amount of tokens deposited.\n\t * @dev These tokens can be withdrawn/transferred any time by the lockedTokenOwner.\n\t */\n\tfunction depositTokens(uint256 _amount) public checkStatus(Status.Active) {\n\t\trequire(_amount > 0, \"Amount needs to be bigger than zero.\");\n\n\t\tbool txStatus = SOV.transferFrom(msg.sender, address(this), _amount);\n\t\trequire(txStatus, \"Token transfer was not successful.\");\n\n\t\temit TokenDeposit(msg.sender, _amount);\n\t}\n\n\t/**\n\t * @notice Change the Token release schedule. It creates a completely new schedule, and does not append on the previous one.\n\t * @param _newLastReleaseTime If the last release time is to be changed, zero if no change required.\n\t * @param _releaseDuration The time duration between each release calculated from `lastReleaseTime` in seconds.\n\t * @param _releaseTokenAmount The amount of token to be released in each duration/interval.\n\t * @dev _releaseDuration and _releaseTokenAmount should be specified in reverse order of release.\n\t */\n\tfunction changeTokenReleaseSchedule(\n\t\tuint256 _newLastReleaseTime,\n\t\tuint256[] memory _releaseDuration,\n\t\tuint256[] memory _releaseTokenAmount\n\t) public onlyLockedTokenOwner checkStatus(Status.Active) {\n\t\t/// Checking if the schedule duration and token allocation length matches.\n\t\trequire(_releaseDuration.length == _releaseTokenAmount.length, \"Release Schedule does not match.\");\n\n\t\t/// If the last release time has to be changed, then you can pass a new one here.\n\t\t/// Or else, the duration of release will be calculated based on this timestamp.\n\t\t/// Even a future timestamp can be mentioned here.\n\t\tif (_newLastReleaseTime != 0) {\n\t\t\tlastReleaseTime = _newLastReleaseTime;\n\t\t}\n\n\t\t/// Checking if the contract have enough token balance for the release.\n\t\tuint256 _releaseTotalTokenAmount;\n\t\tfor (uint256 amountIndex = 0; amountIndex < _releaseTokenAmount.length; amountIndex++) {\n\t\t\t_releaseTotalTokenAmount = _releaseTotalTokenAmount.add(_releaseTokenAmount[amountIndex]);\n\t\t}\n\n\t\t/// Getting the current token balance of the contract.\n\t\tuint256 remainingTokens = SOV.balanceOf(address(this));\n\n\t\t/// If the token balance is not sufficient, then we transfer the change to contract.\n\t\tif (remainingTokens < _releaseTotalTokenAmount) {\n\t\t\tbool txStatus = SOV.transferFrom(msg.sender, address(this), _releaseTotalTokenAmount.sub(remainingTokens));\n\t\t\trequire(txStatus, \"Not enough token sent to change release schedule.\");\n\t\t} else if (remainingTokens > _releaseTotalTokenAmount) {\n\t\t\t/// If there are more tokens than required, send the extra tokens back.\n\t\t\tbool txStatus = SOV.transfer(msg.sender, remainingTokens.sub(_releaseTotalTokenAmount));\n\t\t\trequire(txStatus, \"Token not received by the Locked Owner.\");\n\t\t}\n\n\t\t/// Finally we update the token release schedule.\n\t\treleaseDuration = _releaseDuration;\n\t\treleaseTokenAmount = _releaseTokenAmount;\n\n\t\temit TokenReleaseChanged(msg.sender, _releaseDuration.length);\n\t}\n\n\t/**\n\t * @notice Transfers all of the remaining tokens in an emergency situation.\n\t * @dev This could be called when governance or development fund might be compromised.\n\t */\n\tfunction transferTokensByUnlockedTokenOwner() public onlyUnlockedTokenOwner checkStatus(Status.Active) {\n\t\tuint256 remainingTokens = SOV.balanceOf(address(this));\n\t\tbool txStatus = SOV.transfer(safeVault, remainingTokens);\n\t\trequire(txStatus, \"Token transfer was not successful. Check receiver address.\");\n\t\tstatus = Status.Expired;\n\n\t\temit LockedTokenTransferByUnlockedOwner(msg.sender, safeVault, remainingTokens);\n\t\temit DevelopmentFundExpired();\n\t}\n\n\t/**\n\t * @notice Withdraws all unlocked/released token.\n\t * @param _amount The amount to be withdrawn.\n\t */\n\tfunction withdrawTokensByUnlockedTokenOwner(uint256 _amount) public onlyUnlockedTokenOwner checkStatus(Status.Active) {\n\t\trequire(_amount > 0, \"Zero can't be withdrawn.\");\n\n\t\tuint256 count; /// To know how many elements to be removed from the release schedule.\n\t\tuint256 amount = _amount; /// To know the total amount to be transferred.\n\t\tuint256 newLastReleaseTimeMemory = lastReleaseTime; /// Better to use memory than storage.\n\t\tuint256 releaseLength = releaseDuration.length.sub(1); /// Also checks if there are any elements in the release schedule.\n\n\t\t/// Getting the amount of tokens, the number of releases and calculating the total duration.\n\t\twhile (amount > 0 && newLastReleaseTimeMemory.add(releaseDuration[releaseLength]) < block.timestamp) {\n\t\t\tif (amount >= releaseTokenAmount[releaseLength]) {\n\t\t\t\tamount = amount.sub(releaseTokenAmount[releaseLength]);\n\t\t\t\tnewLastReleaseTimeMemory = newLastReleaseTimeMemory.add(releaseDuration[releaseLength]);\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\t/// This will be the last case, if correct amount is passed.\n\t\t\t\treleaseTokenAmount[releaseLength] = releaseTokenAmount[releaseLength].sub(amount);\n\t\t\t\tamount = 0;\n\t\t\t}\n\t\t\treleaseLength--;\n\t\t}\n\n\t\t/// Checking to see if atleast a single schedule was reached or not.\n\t\trequire(count > 0 || amount == 0, \"No release schedule reached.\");\n\n\t\t/// If locked token owner tries to send a higher amount that schedule\n\t\tuint256 value = _amount.sub(amount);\n\n\t\t/// Now clearing up the release schedule.\n\t\treleaseDuration.length -= count;\n\t\treleaseTokenAmount.length -= count;\n\n\t\t/// Updating the last release time.\n\t\tlastReleaseTime = newLastReleaseTimeMemory;\n\n\t\t/// Sending the amount to unlocked token owner.\n\t\tbool txStatus = SOV.transfer(msg.sender, value);\n\t\trequire(txStatus, \"Token transfer was not successful. Check receiver address.\");\n\n\t\temit UnlockedTokenWithdrawalByUnlockedOwner(msg.sender, value, count);\n\t}\n\n\t/**\n\t * @notice Transfers all of the remaining tokens by the owner maybe for an upgrade.\n\t * @dev This could be called when the current development fund has to be upgraded.\n\t * @param _receiver The address which receives this token transfer.\n\t */\n\tfunction transferTokensByLockedTokenOwner(address _receiver) public onlyLockedTokenOwner checkStatus(Status.Active) {\n\t\tuint256 remainingTokens = SOV.balanceOf(address(this));\n\t\tbool txStatus = SOV.transfer(_receiver, remainingTokens);\n\t\trequire(txStatus, \"Token transfer was not successful. Check receiver address.\");\n\t\tstatus = Status.Expired;\n\n\t\temit LockedTokenTransferByLockedOwner(msg.sender, _receiver, remainingTokens);\n\t\temit DevelopmentFundExpired();\n\t}\n\n\t/* Getter Functions */\n\n\t/**\n\t * @notice Function to read the current token release duration.\n\t * @return _currentReleaseDuration The current release duration.\n\t */\n\tfunction getReleaseDuration() public view returns (uint256[] memory _releaseTokenDuration) {\n\t\treturn releaseDuration;\n\t}\n\n\t/**\n\t * @notice Function to read the current token release amount.\n\t * @return _currentReleaseTokenAmount The current release token amount.\n\t */\n\tfunction getReleaseTokenAmount() public view returns (uint256[] memory _currentReleaseTokenAmount) {\n\t\treturn releaseTokenAmount;\n\t}\n}\n",
            "file": "DevelopmentFund.sol"
        },
        {
            "name": "SafeMath.sol",
            "contents": "pragma solidity >=0.5.0 <0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n\t/**\n\t * @dev Returns the addition of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `+` operator.\n\t *\n\t * Requirements:\n\t * - Addition cannot overflow.\n\t */\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\trequire(c >= a, \"SafeMath: addition overflow\");\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t * - Subtraction cannot overflow.\n\t */\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn sub(a, b, \"SafeMath: subtraction overflow\");\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t * - Subtraction cannot overflow.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction sub(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\trequire(b <= a, errorMessage);\n\t\tuint256 c = a - b;\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the multiplication of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `*` operator.\n\t *\n\t * Requirements:\n\t * - Multiplication cannot overflow.\n\t */\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\t\t// benefit is lost if 'b' is also tested.\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 c = a * b;\n\t\trequire(c / a == b, \"SafeMath: multiplication overflow\");\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers. Reverts on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn div(a, b, \"SafeMath: division by zero\");\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction div(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\t// Solidity only automatically asserts when dividing by 0\n\t\trequire(b > 0, errorMessage);\n\t\tuint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn mod(a, b, \"SafeMath: modulo by zero\");\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts with custom message when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction mod(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\trequire(b != 0, errorMessage);\n\t\treturn a % b;\n\t}\n\n\tfunction min256(uint256 _a, uint256 _b) internal pure returns (uint256) {\n\t\treturn _a < _b ? _a : _b;\n\t}\n}\n"
        },
        {
            "name": "IERC20.sol",
            "contents": "/**\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0.\n */\n\npragma solidity >=0.5.0 <0.6.0;\n\ncontract IERC20 {\n\tstring public name;\n\tuint8 public decimals;\n\tstring public symbol;\n\n\tfunction totalSupply() public view returns (uint256);\n\n\tfunction balanceOf(address _who) public view returns (uint256);\n\n\tfunction transfer(address _to, uint256 _value) public returns (bool);\n\n\tfunction allowance(address _owner, address _spender) public view returns (uint256);\n\n\tfunction transferFrom(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _value\n\t) public returns (bool);\n\n\tfunction approve(address _spender, uint256 _value) public returns (bool);\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
        }
    ],
    "libraries": {},
    "encodedConstructorArguments": "000000000000000000000000efc78fc7d48b64958315949279ba181c2114abbd000000000000000000000000924f5ad34698fd20c90fe5d5a8a0abd3b42dc71100000000000000000000000005f4f068df59a5aa7911f57ce4f41ebfbcb8e247000000000000000000000000967c84b731679e36a344002b8e3ce50620a7f69f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000880000000000000000000000000000000000000000000000000000000000000003c0000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d00000000000000000000000000000000000000000000000000000000000000003c000000000000000000000000000000000000000000000ec48577df9917c70000000000000000000000000000000000000000000000000ec48577df9917c70000000000000000000000000000000000000000000000000ec48577df9917c70000000000000000000000000000000000000000000000000ec48577df9917c70000000000000000000000000000000000000000000000000ec48577df9917c70000000000000000000000000000000000000000000000000ec48577df9917c70000000000000000000000000000000000000000000000000ec48577df9917c70000000000000000000000000000000000000000000000000ec48577df9917c70000000000000000000000000000000000000000000000000ec48577df9917c70000000000000000000000000000000000000000000000000ec48577df9917c70000000000000000000000000000000000000000000000000ec48577df9917c70000000000000000000000000000000000000000000000000ec48577df9917c70000000000000000000000000000000000000000000000000ec48577df9917c70000000000000000000000000000000000000000000000000ec48577df9917c70000000000000000000000000000000000000000000000000ec48577df9917c70000000000000000000000000000000000000000000000000ec48577df9917c70000000000000000000000000000000000000000000000000ec48577df9917c70000000000000000000000000000000000000000000000000ec48577df9917c70000000000000000000000000000000000000000000000000ec48577df9917c70000000000000000000000000000000000000000000000000ec48577df9917c70000000000000000000000000000000000000000000000000ec48577df9917c70000000000000000000000000000000000000000000000000ec48577df9917c70000000000000000000000000000000000000000000000000ec48577df9917c70000000000000000000000000000000000000000000000000ec48577df9917c70000000000000000000000000000000000000000000000001d890b1346249f4f0000000000000000000000000000000000000000000000001d890b1346249f4f0000000000000000000000000000000000000000000000001d890b1346249f4f0000000000000000000000000000000000000000000000001d890b1346249f4f0000000000000000000000000000000000000000000000001d890b1346249f4f0000000000000000000000000000000000000000000000001d890b1346249f4f0000000000000000000000000000000000000000000000001d890b1346249f4f0000000000000000000000000000000000000000000000001d890b1346249f4f0000000000000000000000000000000000000000000000001d890b1346249f4f0000000000000000000000000000000000000000000000001d890b1346249f4f0000000000000000000000000000000000000000000000001d890b1346249f4f0000000000000000000000000000000000000000000000001d890b1346249f4f0000000000000000000000000000000000000000000000001d890b1346249f4f0000000000000000000000000000000000000000000000001d890b1346249f4f0000000000000000000000000000000000000000000000001d890b1346249f4f0000000000000000000000000000000000000000000000001d890b1346249f4f0000000000000000000000000000000000000000000000001d890b1346249f4f0000000000000000000000000000000000000000000000001d890b1346249f4f0000000000000000000000000000000000000000000000001d890b1346249f4f0000000000000000000000000000000000000000000000001d890b1346249f4f0000000000000000000000000000000000000000000000001d890b1346249f4f0000000000000000000000000000000000000000000000001d890b1346249f4f0000000000000000000000000000000000000000000000001d890b1346249f4f0000000000000000000000000000000000000000000000001d890b1346249f4f0000000000000000000000000000000000000000000000003b1216268c493e9e0000000000000000000000000000000000000000000000003b1216268c493e9e0000000000000000000000000000000000000000000000003b1216268c493e9e0000000000000000000000000000000000000000000000003b1216268c493e9e0000000000000000000000000000000000000000000000003b1216268c493e9e0000000000000000000000000000000000000000000000003b1216268c493e9e0000000000000000000000000000000000000000000000003b1216268c493e9e0000000000000000000000000000000000000000000000003b1216268c493e9e0000000000000000000000000000000000000000000000003b1216268c493e9e0000000000000000000000000000000000000000000000003b1216268c493e9e0000000000000000000000000000000000000000000000003b1216268c493e9e0000000000000000000000000000000000000000000000003b1216268c493e9e0000",
    "creationData": {
        "blockHash": "0x866a36fd31b069154a06cbcf8ccef62ba65035c217147ee5db7ed6d4977d89f4",
        "blockNumber": 3100302,
        "transactionHash": "0xe85850ce055b822177b18c4bd1380963509d886236d91d13dc6d84332c6779bc",
        "timestamp": 1613126942
    }
}