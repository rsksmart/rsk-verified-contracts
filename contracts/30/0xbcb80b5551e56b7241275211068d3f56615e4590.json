{
    "address": "0xbcb80b5551e56b7241275211068d3f56615e4590",
    "net": {
        "id": "30",
        "name": "RSK Mainnet"
    },
    "name": "ProxyMoCMedianizer",
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": "100"
        },
        "evmVersion": "byzantium"
    },
    "version": "0.5.8+commit.23d335f2",
    "source": "// SPDX-License-Identifier: \n// File: areopagus/contracts/Governance/ChangeContract.sol\n\npragma solidity 0.5.8;\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n\n  /**\n    @notice Override this function with a recipe of the changes to be done when this ChangeContract\n    is executed\n   */\n  function execute() external;\n}\n\n// File: areopagus/contracts/Governance/IGovernor.sol\n\npragma solidity 0.5.8;\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor{\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @dev This function should be protected somehow to only execute changes that\n    benefit the system. This decision process is independent of this architechture\n    therefore is independent of this interface too\n    @param changeContract Address of the contract that will execute the changes\n   */\n  function executeChange(ChangeContract changeContract) external;\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @param _changer Address of the contract that will execute the changes\n   */\n  function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n// File: zos-lib/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.6.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: areopagus/contracts/Governance/Governed.sol\n\npragma solidity 0.5.8;\n\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed is Initializable {\n\n  /**\n    @notice The address of the contract which governs this one\n   */\n  IGovernor public governor;\n\n  string constant private NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n  /**\n    @notice Modifier that protects the function\n    @dev You should use this modifier in any function that should be called through\n    the governance system\n   */\n  modifier onlyAuthorizedChanger() {\n    checkIfAuthorizedChanger();\n    _;\n  }\n\n  /**\n    @notice Initialize the contract with the basic settings\n    @dev This initialize replaces the constructor but it is not called automatically.\n    It is necessary because of the upgradeability of the contracts\n    @param _governor Governor address\n   */\n  function initialize(address _governor) public initializer {\n    governor = IGovernor(_governor);\n  }\n\n  /**\n    @notice Change the contract's governor. Should be called through the old governance system\n    @param newIGovernor New governor address\n   */\n  function changeIGovernor(IGovernor newIGovernor) public onlyAuthorizedChanger {\n    governor = newIGovernor;\n  }\n\n  /**\n    @notice Checks if the msg sender is an authorized changer, reverts otherwise\n   */\n  function checkIfAuthorizedChanger() internal view {\n    require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/IMoCMedianizer.sol\n\npragma solidity 0.5.8;\n\n/**\n * @dev Interface of MoC Medianizer, compatible with MOC.\n */\ninterface IMoCMedianizer {\n  function poke() external;\n  function read() external view returns (bytes32);\n  function peek() external view returns (bytes32, bool);\n  function compute() external view returns (bytes32, bool);\n}\n\n// File: contracts/ProxyMoCMedianizer.sol\n\npragma solidity 0.5.8;\n\n\n\n\ncontract ProxyMoCMedianizer is Governed {\n  address public medianizer;\n\n  /**\n    @notice Checks that _address is not zero; fails otherwise\n    @param _address Address to be checked\n  */\n  modifier isValidAddress(address _address, string memory message) {\n    require(_address != address(0), message);\n    _;\n  }\n\n  function initialize(\n    address _medianizer,\n    address _governor\n  )\n    public\n    initializer\n    isValidAddress(_medianizer, \"medianizer cannot be null\")\n    isValidAddress(_governor, \"governor cannot be null\")\n  {\n    medianizer = _medianizer;\n    Governed.initialize(_governor);\n  }\n\n  function peek() external view returns (bytes32, bool) {\n    IMoCMedianizer imedianizer = IMoCMedianizer(medianizer);\n    return imedianizer.peek();\n  }\n\n  function setMedianizer(address _newMedianizer) public onlyAuthorizedChanger {\n    require(_newMedianizer != address(0), \"Medianizer cannot be null\");\n    medianizer = _newMedianizer;\n  }\n\n}\n",
    "imports": [
        {
            "name": "ProxyMoCMedianizer_flat.sol",
            "contents": "// SPDX-License-Identifier: \n// File: areopagus/contracts/Governance/ChangeContract.sol\n\npragma solidity 0.5.8;\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n\n  /**\n    @notice Override this function with a recipe of the changes to be done when this ChangeContract\n    is executed\n   */\n  function execute() external;\n}\n\n// File: areopagus/contracts/Governance/IGovernor.sol\n\npragma solidity 0.5.8;\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor{\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @dev This function should be protected somehow to only execute changes that\n    benefit the system. This decision process is independent of this architechture\n    therefore is independent of this interface too\n    @param changeContract Address of the contract that will execute the changes\n   */\n  function executeChange(ChangeContract changeContract) external;\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @param _changer Address of the contract that will execute the changes\n   */\n  function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n// File: zos-lib/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.6.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: areopagus/contracts/Governance/Governed.sol\n\npragma solidity 0.5.8;\n\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed is Initializable {\n\n  /**\n    @notice The address of the contract which governs this one\n   */\n  IGovernor public governor;\n\n  string constant private NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n  /**\n    @notice Modifier that protects the function\n    @dev You should use this modifier in any function that should be called through\n    the governance system\n   */\n  modifier onlyAuthorizedChanger() {\n    checkIfAuthorizedChanger();\n    _;\n  }\n\n  /**\n    @notice Initialize the contract with the basic settings\n    @dev This initialize replaces the constructor but it is not called automatically.\n    It is necessary because of the upgradeability of the contracts\n    @param _governor Governor address\n   */\n  function initialize(address _governor) public initializer {\n    governor = IGovernor(_governor);\n  }\n\n  /**\n    @notice Change the contract's governor. Should be called through the old governance system\n    @param newIGovernor New governor address\n   */\n  function changeIGovernor(IGovernor newIGovernor) public onlyAuthorizedChanger {\n    governor = newIGovernor;\n  }\n\n  /**\n    @notice Checks if the msg sender is an authorized changer, reverts otherwise\n   */\n  function checkIfAuthorizedChanger() internal view {\n    require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/IMoCMedianizer.sol\n\npragma solidity 0.5.8;\n\n/**\n * @dev Interface of MoC Medianizer, compatible with MOC.\n */\ninterface IMoCMedianizer {\n  function poke() external;\n  function read() external view returns (bytes32);\n  function peek() external view returns (bytes32, bool);\n  function compute() external view returns (bytes32, bool);\n}\n\n// File: contracts/ProxyMoCMedianizer.sol\n\npragma solidity 0.5.8;\n\n\n\n\ncontract ProxyMoCMedianizer is Governed {\n  address public medianizer;\n\n  /**\n    @notice Checks that _address is not zero; fails otherwise\n    @param _address Address to be checked\n  */\n  modifier isValidAddress(address _address, string memory message) {\n    require(_address != address(0), message);\n    _;\n  }\n\n  function initialize(\n    address _medianizer,\n    address _governor\n  )\n    public\n    initializer\n    isValidAddress(_medianizer, \"medianizer cannot be null\")\n    isValidAddress(_governor, \"governor cannot be null\")\n  {\n    medianizer = _medianizer;\n    Governed.initialize(_governor);\n  }\n\n  function peek() external view returns (bytes32, bool) {\n    IMoCMedianizer imedianizer = IMoCMedianizer(medianizer);\n    return imedianizer.peek();\n  }\n\n  function setMedianizer(address _newMedianizer) public onlyAuthorizedChanger {\n    require(_newMedianizer != address(0), \"Medianizer cannot be null\");\n    medianizer = _newMedianizer;\n  }\n\n}\n",
            "file": "ProxyMoCMedianizer_flat.sol"
        }
    ],
    "libraries": {},
    "creationData": {
        "blockHash": "0xe652c5639718ac8f68a1bc332eac9b1f2bfbd68fea07b64392362028c801189a",
        "blockNumber": 3339337,
        "transactionHash": "0x5528fde50d0c443b1a3781c565fc71b9e3d672d4e76c6b704367ade8eff18da0",
        "timestamp": 1620668071
    }
}