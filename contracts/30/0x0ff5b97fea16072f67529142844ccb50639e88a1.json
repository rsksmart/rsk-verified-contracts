{
  "address": "0x0ff5b97fea16072f67529142844ccb50639e88a1",
  "net": {
    "id": "30",
    "name": "RSK Mainnet"
  },
  "name": "ExchangeFirewall",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "byzantium"
  },
  "version": "0.5.9+commit.e560f70d",
  "source": "pragma solidity ^0.5.4;\n\n/**\n * Modified https://github.com/OpenZeppelin/zeppelin-solidity\n */\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner, \"Only the owner can call this function.\");\n    _;\n  }\n\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    owner = newOwner;\n  }\n\n}\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"Overflow while multiplying\");\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0, \"Cannot divide by zero\"); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, \"Negative result while substracting\");\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"Overflow while adding\");\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, \"Remainder of division by zero is undefined\");\n    return a % b;\n  }\n}\n\n\n\n/**\n * Internal interface for the minting of tokens.\n */\ncontract Mintable {\n\n  /**\n   * @dev Mints tokens for an account\n   * This function should emit the Minted event.\n   */\n  function mintInternal(address receiver, uint amount) internal;\n\n  /** Token supply got increased and a new owner received these tokens */\n  event Minted(address receiver, uint amount);\n}\n\n// Interface for burning tokens\ncontract Burnable {\n  // @dev Destroys tokens for an account\n  // @param account Account whose tokens are destroyed\n  // @param value Amount of tokens to destroy\n  function burnTokens(address account, uint value) internal;\n  event Burned(address account, uint value);\n}\n\n/**\n * Interface for the standard token.\n * Based on https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n */\ncontract EIP20Token {\n\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool success);\n  function transferFrom(address from, address to, uint256 value) public returns (bool success);\n  function approve(address spender, uint256 value) public returns (bool success);\n  function allowance(address owner, address spender) public view returns (uint256 remaining);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  /**\n  ** Optional functions\n  *\n  function name() public view returns (string name);\n  function symbol() public view returns (string symbol);\n  function decimals() public view returns (uint8 decimals);\n  *\n  **/\n\n}\n\n/**\n * @title Exchange token\n * @dev Implementation of the EIP20 standard token (also known as ERC20 token) extended to support\n *      some exchange operations.\n */\ncontract ExchangeToken is EIP20Token, Burnable, Mintable {\n  using SafeMath for uint256;\n\n  uint256 private total_supply;\n  mapping(address => uint256) private balances;\n  mapping(address => mapping (address => uint256)) private allowed;\n  string public name;\n  string public symbol;\n  uint8 constant public decimals = 2;\n  Configuration public configuration_contract;\n  bool internal initialized;\n\n  /**\n   * @dev Provides an initializer to the Proxy account.\n   */\n  function initialize(string memory token_name, string memory token_symbol, address configuration) public {\n    require(initialized == false, \"The contract is already initialized\");\n    initialized = true;\n    name = token_name;\n    symbol = token_symbol;\n    setConfigurationContract(configuration);\n  }\n\n  /**\n   * @dev Implements EIP20 totalSupply interface.\n   * @return The total amount of tokens in circulation.\n   */\n  function totalSupply() public view returns (uint256) {\n    return total_supply;\n  }\n\n  function transfer_internal(address from, address to, uint256 value) internal returns (bool) {\n    balances[from] = balances[from].sub(value);\n    balances[to] = balances[to].add(value);\n    emit Transfer(from, to, value);\n    return true;\n  }\n\n  /**\n   * @dev transfer token for a specified address\n   * @param to The address to transfer to.\n   * @param value The amount to be transferred.\n   */\n  function transfer(address to, uint256 value) public returns (bool success) {\n    return transfer_internal(msg.sender, to, value);\n  }\n\n  /**\n   * @dev Gets the balance of the specified address.\n   * @param account The address whose balance is to be queried.\n   * @return An uint256 representing the amount owned by the passed address.\n   */\n  function balanceOf(address account) public view returns (uint256 balance) {\n    return balances[account];\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param from The address which you want to send tokens from\n   * @param to The address which you want to transfer to\n   * @param value The amount of tokens to be transferred\n   */\n  function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n    uint256 allowance = allowed[from][msg.sender];\n    allowed[from][msg.sender] = allowance.sub(value);\n\n    return transfer_internal(from, to, value);\n  }\n\n  /**\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * @param spender The address which will spend the funds.\n   * @param value The amount of tokens to be spent.\n   */\n  function approve(address spender, uint256 value) public returns (bool success) {\n    // To change the approve amount you first have to reduce the addresses'\n    //  allowance to zero by calling `approve(spender, 0)` if it is not\n    //  already 0 to mitigate the race condition described here:\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    require (value == 0 || allowed[msg.sender][spender] == 0, \"Previous allowance value is not zero\");\n\n    allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\n   * @param account address The address which owns the funds.\n   * @param spender address The address which will spend the funds.\n   * @return A uint256 specifing the amount of tokens still avaible for the spender.\n   */\n  function allowance(address account, address spender) public view returns (uint256 remaining) {\n    return allowed[account][spender];\n  }\n\n  /**\n   * Atomic increment of approved spending\n   *\n   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   */\n  function addApproval(address spender, uint256 addedValue) public returns (bool success) {\n    uint256 oldValue = allowed[msg.sender][spender];\n    allowed[msg.sender][spender] = oldValue.add(addedValue);\n    emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\n    return true;\n  }\n\n  /**\n   * Atomic decrement of approved spending.\n   *\n   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   */\n  function subApproval(address spender, uint256 subtractedValue) public returns (bool success) {\n    uint256 oldVal = allowed[msg.sender][spender];\n\n    if (subtractedValue > oldVal) {\n      allowed[msg.sender][spender] = 0;\n    } else {\n      allowed[msg.sender][spender] = oldVal.sub(subtractedValue);\n    }\n    emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\n    return true;\n  }\n\n  /**\n   * @dev Provides an internal function for destroying tokens. Useful for upgrades.\n   */\n  function burnTokens(address account, uint256 value) internal {\n    total_supply = total_supply.sub(value);\n    balances[account] = balances[account].sub(value);\n    emit Burned(account, value);\n    emit Transfer(account, address(0), value);\n  }\n\n  /**\n   * @dev Provides an internal minting function.\n   */\n  function mintInternal(address receiver, uint256 amount) internal {\n    total_supply = total_supply.add(amount);\n    balances[receiver] = balances[receiver].add(amount);\n    emit Minted(receiver, amount);\n    emit Transfer(address(0), receiver, amount);\n  }\n\n  /**\n   * @dev Internal getter for the exchange property.\n   */\n  function getExchangeContract() internal view returns (address) {\n    return configuration_contract.exchangeContract();\n  }\n\n  /**\n   * @dev Internal setter for the configuration contract property.\n   */\n  function setConfigurationContract(address configuration) internal {\n    require(configuration != address(0), \"Configuration address should be valid.\");\n    configuration_contract = Configuration(configuration);\n  }\n\n}\n\n\ncontract ExchangeFirewall is Ownable {\n\n  struct TokenInformation {\n    uint256 token_to_usd;\n    uint256 usd_to_token;\n    uint256 last_update;\n  }\n\n  mapping(bytes32 => bool) public suspended_tokens;\n\n  event Suspended(address token);\n  event Resumed(address token);\n\n  /**\n  * @dev This interface allows adaptive stateful firewalls.\n  *      It isn't specified as view to allow for adaptive stateful firewalls.\n  *      Please note that implementing an adaptive firewall is a delicate task, easily subject to denial of service issues.\n  */\n  function isExchangeAllowed(address exchange_requester, ExchangeToken from, uint256 amount, ExchangeToken to) external returns (bool) {\n    return wouldAllowExchange(exchange_requester, from, amount, to);\n  }\n\n  /**\n   * @dev This function is called to check a particular exchange operation and allow it or block it.\n   */\n  function wouldAllowExchange(address /*exchange_requester*/, ExchangeToken from, uint256 /*amount*/, ExchangeToken to) public view returns (bool) {\n    Exchange exch = Exchange(msg.sender);\n    string memory from_symbol = from.symbol();\n    string memory to_symbol = to.symbol();\n    TokenInformation memory from_info = getTokenRegistration(exch, from_symbol);\n    TokenInformation memory to_info = getTokenRegistration(exch, to_symbol);\n    bool is_suspended = suspended_tokens[keccak256(abi.encodePacked(from_symbol))] || suspended_tokens[keccak256(abi.encodePacked(to_symbol))];\n    return !(is_suspended || from_info.last_update + 8 hours < now || to_info.last_update + 8 hours < now);\n  }\n\n  /**\n   * @dev Get registered token information using its symbol as key.\n   */\n  function getTokenRegistration(Exchange exchange, string memory token_symbol) private view returns (TokenInformation memory) {\n    ( , uint256 token_to_usd, uint256 usd_to_token, uint256 last_update) = exchange.getRegisteredToken(token_symbol);\n    return TokenInformation({ token_to_usd: token_to_usd,\n                              usd_to_token: usd_to_token,\n                              last_update: last_update });\n  }\n\n  /**\n   * @dev Suspends tokens so they can't be used in exchange operations.\n   */\n  function suspendTokens(ExchangeToken[] calldata tokens) external onlyOwner {\n    for (uint256 i = 0; i < tokens.length; i++) {\n      suspended_tokens[keccak256(abi.encodePacked(tokens[i].symbol()))] = true;\n      emit Suspended(address(tokens[i]));\n    }\n  }\n\n  /**\n   * @dev Allows tokens so they can be used in exchange operations once again.\n   */\n  function resumeTokens(ExchangeToken[] calldata tokens) external onlyOwner {\n    for (uint256 i = 0; i < tokens.length; i++) {\n      suspended_tokens[keccak256(abi.encodePacked(tokens[i].symbol()))] = false;\n      emit Resumed(address(tokens[i]));\n    }\n  }\n\n}\n\n\n\n\n\n\n\n\n\n\n\ncontract OwnedExchangeToken is ExchangeToken, Ownable {\n\n  // Used for identifying the token version (useful to check if upgrade succeeded)\n  uint256 public constant VERSION = 1;\n\n  // Used for the processing of user burn messages\n  mapping(address => mapping(uint256 => bool)) private used_nonces;\n\n  event BurnMessageProcessed(address user, uint256 nonce, uint256 amount, bool success, bytes return_data);\n\n  /**\n   * @dev Initializes the storage. Useful for proxied contract instantiation.\n   *      If this contract is to be used without a proxy, consider moving this logic to the constructor instead.\n   */\n  function initialize(string memory token_name, string memory token_symbol, address configuration, address initialOwner) public {\n    require(initialized == false, \"The contract is already initialized\");\n    ExchangeToken.initialize(token_name, token_symbol, configuration);\n    owner = initialOwner;\n  }\n\n  /**\n   * @dev Allows both the owner of this contract, and the exchange to mint tokens.\n   */\n  function mint(address to, uint256 value) public onlyOwnerOrExchange {\n    mintInternal(to, value);\n  }\n\n  /**\n   * @dev Allows anyone to burn their own tokens.\n   */\n  function burn(uint256 value) public {\n    burnTokens(msg.sender, value);\n  }\n\n  /**\n   * @dev Allows the exchange to burn tokens on behalf of someone.\n   */\n  function burnFrom(address to, uint256 value) public onlyExchangeOrSelf {\n    burnTokens(to, value);\n  }\n\n  /**\n   * @dev Allows the configuration contract to transfer its role to another contract.\n   */\n  function updateConfigurationContract(address configuration) public {\n    require(msg.sender == address(configuration_contract),\n            \"Only the configuration contract can update the configuration contract address.\");\n    setConfigurationContract(configuration);\n  }\n\n  modifier onlyOwnerOrExchange() {\n    require(msg.sender == getExchangeContract() || msg.sender == owner, \"Only owner or the exchange contract can call this function.\");\n    _;\n  }\n\n  modifier onlyExchangeOrSelf() {\n    require(msg.sender == getExchangeContract() || msg.sender == address(this),\n            \"Only the exchange or token contract can call this function.\");\n    _;\n  }\n\n  /**\n   * @dev Allows users to sign messages stating their intent to burn tokens have them published by the exchange operator.\n   */\n  function processUserBurnMessages(uint256[] memory amounts, uint256[] memory nonces, bytes32[] memory sigs_r,\n                                   bytes32[] memory sigs_s, uint8[] memory sigs_v) public onlyOwner {\n    require(amounts.length == nonces.length && nonces.length == sigs_r.length &&\n            sigs_r.length == sigs_s.length && sigs_s.length == sigs_v.length, \"Inconsistent message data.\");\n\n    for (uint256 i = 0; i < amounts.length; i++) {\n      executeBurnMessage(nonces[i], amounts[i], sigs_r[i], sigs_s[i], sigs_v[i]);\n    }\n  }\n\n  /**\n   * @dev Implements the processing of a single user burn message.\n   */\n  function executeBurnMessage(uint256 nonce, uint256 amount,\n                              bytes32 sig_r, bytes32 sig_s, uint8 sig_v) private {\n    bytes32 hash = keccak256(abi.encodePacked(\"Xapo v1 Token Burn:\", nonce, amount, address(this)));\n    address user = ecrecover(hash, sig_v, sig_r, sig_s);\n    bool success = false;\n    bytes memory return_data = \"Nonce already used\";\n    if (!used_nonces[user][nonce]) {\n      used_nonces[user][nonce] = true;\n\n      (success, return_data) = address(this).call(abi.encodeWithSignature(\"burnFrom(address,uint256)\", user, amount));\n    }\n\n    emit BurnMessageProcessed(user, nonce, amount, success, return_data);\n  }\n}\n\ncontract Configuration is Ownable {\n  address public exchangeContract;\n\n  constructor(address exchange) public {\n    exchangeContract = exchange;\n  }\n\n  /**\n   * @dev Allows the owner to set the new exchange address.\n   */\n  function setExchangeContract(address new_exchange) public onlyOwner {\n    require(new_exchange != address(0));\n    exchangeContract = new_exchange;\n  }\n\n  /**\n   * @dev Allows the owner to change the configuration contract of multiple tokens at once.\n   * Changing the configuration contract of a token is an irreversible operation.\n   */\n  function updateTokensToUseNewConfiguration(OwnedExchangeToken[] memory tokens_to_update, address new_configuration) public onlyOwner {\n    for (uint i = 0; i < tokens_to_update.length; i++) {\n      tokens_to_update[i].updateConfigurationContract(new_configuration);\n    }\n  }\n\n}\n\n\ncontract Exchange is Ownable {\n\n  using SafeMath for uint256;\n\n  struct TokenRegistration {\n    bool registered;\n    OwnedExchangeToken token_contract;\n    uint256 token_to_usd;\n    uint256 usd_to_token;\n    uint256 last_update_timestamp;\n    uint256 index;\n  }\n\n  // Used for identifying the token version (useful to check if upgrade succeeded)\n  uint256 public constant VERSION = 1;\n\n  ExchangeFirewall public firewall;\n\n  event Exchanged(string from_symbol, uint256 from_amount, string to_symbol, uint256 to_amount);\n\n  // We use the hash of the token symbol as key\n  mapping(bytes32 => TokenRegistration) registered_tokens;\n\n  // Array of registered token keys\n  bytes32[] iterable_tokens;\n\n  bool initialized = false;\n\n  uint256 private constant RATE_DECIMALS = 20;\n  uint256 private constant RATE_TO_TOKEN_AMOUNT = 10 ** (2 * RATE_DECIMALS);\n\n  /**\n   * @dev Used to initialize the proxy account storage\n   */\n  function initialize(address new_owner) public {\n    require(!initialized);\n    initialized = true;\n    owner = new_owner;\n  }\n\n  /**\n   * @dev Exchanges one token for another.\n   * Will revert in case of the resulting exchange overflows the max capacity of uint256\n   * Firewall must be set before any exchange attempt\n   * Note that the max exchange amount is restricted by the size of the exchange rate between tokens\n   */\n  function exchange(string memory from_symbol, uint256 amount, string memory to_symbol, uint256 minimum_expected) public {\n    require(address(firewall) != address(0), \"Firewall has not been set yet.\");\n    TokenRegistration storage from_token = getRegisteredTokenFromStorage(from_symbol);\n    TokenRegistration storage to_token = getRegisteredTokenFromStorage(to_symbol);\n    require(from_token.registered && to_token.registered,\n            \"At least one of the tokens is not registered in the exchange.\");\n\n    OwnedExchangeToken from_contract = from_token.token_contract;\n    OwnedExchangeToken to_contract = to_token.token_contract;\n\n    uint256 due_tokens = calculateDueTokens(from_token, to_token, amount);\n    require(due_tokens > 0, \"Exchange would result in no tokens.\");\n    require(due_tokens >= minimum_expected, \"Exchange would result in less than minimum expected.\");\n\n    require(firewall.isExchangeAllowed(msg.sender, from_contract, amount, to_contract),\n            \"Exchange was rejected by the firewall policy.\");\n\n    from_contract.burnFrom(msg.sender, amount);\n    to_contract.mint(msg.sender, due_tokens);\n\n    emit Exchanged(from_symbol, amount, to_symbol, due_tokens);\n  }\n\n\n  /**\n   * @dev Calculates the amount of tokens according to the registered rates.\n   */\n  function calculateDueTokens(TokenRegistration storage from, TokenRegistration storage to,\n                              uint256 amount) private view returns (uint256) {\n    // Rates have a precision of 20 decimals.\n    return amount.mul(from.token_to_usd).mul(to.usd_to_token).div(RATE_TO_TOKEN_AMOUNT);\n  }\n\n  /**\n   * @dev Estimates the result of the exchange operation.\n   */\n  function estimateExchange(string memory from_symbol, uint256 amount,\n                            string memory to_symbol) public view returns (uint256) {\n    TokenRegistration storage from = getRegisteredTokenFromStorage(from_symbol);\n    TokenRegistration storage to = getRegisteredTokenFromStorage(to_symbol);\n\n    uint256 due_tokens = 0;\n    if (address(firewall) != address(0) && firewall.wouldAllowExchange(msg.sender, from.token_contract, amount, to.token_contract)) {\n      due_tokens = calculateDueTokens(from, to, amount);\n    }\n    return due_tokens;\n  }\n\n  /**\n   * @dev Registers new token pairs. Already registered symbols cannot be overwritten.\n   */\n  function registerTokenRate(OwnedExchangeToken token, uint256 from_token_to_usd,\n                             uint256 from_usd_to_token) public onlyOwner {\n    require(address(token) != address(0), \"Token address should be valid.\");\n    require(from_token_to_usd > 0 &&\n            from_usd_to_token > 0,\n            \"Ratios should be non zero.\");\n\n    uint token_index;\n    // We hash the symbol to use as key\n    bytes32 token_key = keccak256(abi.encodePacked(token.symbol()));\n    require(!registered_tokens[token_key].registered, \"The token is already registered.\");\n\n    token_index = iterable_tokens.push(token_key).sub(1);\n\n    TokenRegistration memory registration = TokenRegistration({\n      registered: true,\n      token_contract: token,\n      token_to_usd: from_token_to_usd,\n      usd_to_token: from_usd_to_token,\n      last_update_timestamp: now,\n      index: token_index\n    });\n\n    registered_tokens[token_key] = registration;\n  }\n\n  /**\n   * @dev Registers new token pairs. Already registered symbols cannot be overwritten.\n   */\n  function registerTokenRates(OwnedExchangeToken[] memory tokens, uint256[] memory from_token_to_usd,\n                              uint256[] memory from_usd_to_token) public onlyOwner {\n    require(tokens.length == from_token_to_usd.length &&\n            from_token_to_usd.length == from_usd_to_token.length,\n            \"The length of all arrays should be the same.\");\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      registerTokenRate(tokens[i], from_token_to_usd[i], from_usd_to_token[i]);\n    }\n  }\n\n  /**\n   * @dev Deregisters an existing token pair.\n   */\n  function deregisterToken(string memory token_symbol) public onlyOwner {\n    bytes32 token_key = keccak256(abi.encodePacked(token_symbol));\n    require(registered_tokens[token_key].registered, \"Token symbol is not registered in the exchange.\");\n\n    uint256 index = registered_tokens[token_key].index;\n    // Can't delete through a storage pointer.\n    delete registered_tokens[token_key];\n\n    if (iterable_tokens.length > 1 && index < iterable_tokens.length.sub(1)) {\n      bytes32 moved_key = iterable_tokens[iterable_tokens.length.sub(1)];\n      iterable_tokens[index] = moved_key;\n\n      TokenRegistration storage moved_token = registered_tokens[moved_key];\n      // This should be a valid token registration\n      require(moved_token.registered, \"Dangling reference to unknown token.\");\n      // Update index of the moved key.\n      moved_token.index = index;\n    }\n    iterable_tokens.length = iterable_tokens.length.sub(1);\n  }\n\n  /**\n   * @dev Deregisters some existing token pairs.\n   */\n  function deregisterTokens(OwnedExchangeToken[] calldata tokens) external onlyOwner {\n    for (uint256 i = 0; i < tokens.length; i++) {\n      deregisterToken(tokens[i].symbol());\n    }\n  }\n\n  /**\n   * @dev This function allows updates to existing exchange rates of token pairs.\n   */\n  function updateTokenRate(string memory token_symbol, uint256 from_token_to_usd,\n                           uint256 from_usd_to_token) public onlyOwner {\n    require(from_token_to_usd > 0 && from_usd_to_token > 0,\n            \"Ratios should be non zero.\");\n\n    TokenRegistration storage registered_token = getRegisteredTokenFromStorage(token_symbol);\n    registered_token.token_to_usd = from_token_to_usd;\n    registered_token.usd_to_token = from_usd_to_token;\n    registered_token.last_update_timestamp = now;\n  }\n\n  /**\n   * @dev This function allows updates to existing exchange rates of token pairs.\n   */\n  function updateTokenRates(OwnedExchangeToken[] memory tokens, uint256[] memory from_token_to_usd,\n                            uint256[] memory from_usd_to_token) public onlyOwner {\n    require(tokens.length == from_token_to_usd.length &&\n            from_token_to_usd.length == from_usd_to_token.length,\n            \"The length of all input arrays should be the same.\");\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      updateTokenRate(tokens[i].symbol(), from_token_to_usd[i], from_usd_to_token[i]);\n    }\n  }\n\n  /**\n   * @dev Mint tokens.\n   */\n  function mintToken(string memory token_symbol, uint256 amount, address destination) public onlyOwner {\n    TokenRegistration storage registered_token = getRegisteredTokenFromStorage(token_symbol);\n    registered_token.token_contract.mint(destination, amount);\n  }\n\n  /**\n   * @dev Mint tokens in batch.\n   */\n  function mintTokens(OwnedExchangeToken[] memory tokens, uint256[] memory amounts,\n                      address[] memory destinations) public onlyOwner {\n    require(tokens.length == amounts.length && amounts.length == destinations.length,\n            \"The length of all arrays should be the same.\");\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      mintToken(tokens[i].symbol(), amounts[i], destinations[i]);\n    }\n  }\n\n  /**\n   * @dev Set new exchange firewall.\n   */\n  function setNewFirewall(ExchangeFirewall newFirewall) public onlyOwner {\n    require(address(newFirewall) != address(0), \"Firewall address should be valid.\");\n    firewall = newFirewall;\n  }\n\n  /**\n   * @dev Get registered token information using its symbol as key.\n   */\n  function getRegisteredToken(string calldata token_symbol) external view\n  returns (address token_contract, uint256 token_to_usd,\n           uint256 usd_to_token, uint256 last_update_timestamp) {\n    TokenRegistration memory registered_token = getRegisteredTokenFromStorage(token_symbol);\n    token_contract = address(registered_token.token_contract);\n    token_to_usd = registered_token.token_to_usd;\n    usd_to_token = registered_token.usd_to_token;\n    last_update_timestamp = registered_token.last_update_timestamp;\n  }\n\n  /**\n   * @dev Get registered token information using the hash of its symbol as key.\n   */\n  function getRegisteredTokenByHash(bytes32 token_key) external view\n  returns (address token_contract, uint256 token_to_usd,\n           uint256 usd_to_token, uint256 last_update_timestamp) {\n    TokenRegistration memory registered_token = registered_tokens[token_key];\n    token_contract = address(registered_token.token_contract);\n    token_to_usd = registered_token.token_to_usd;\n    usd_to_token = registered_token.usd_to_token;\n    last_update_timestamp = registered_token.last_update_timestamp;\n  }\n\n  /**\n   * @dev Allows iteration of the mapping of registered tokens.\n   */\n  function tokenByIndex(uint256 index) external view returns (bytes32) {\n    return iterable_tokens[index];\n  }\n\n  /**\n   * @dev Allows iteration of the mapping of registered tokens.\n   */\n  function tokenCount() external view returns (uint256) {\n    return iterable_tokens.length;\n  }\n\n  /**\n   * @dev Internal registered token getter.\n   */\n  function getRegisteredTokenFromStorage(string memory token_symbol) private view returns (TokenRegistration storage) {\n    bytes32 token_key = keccak256(abi.encodePacked(token_symbol));\n    TokenRegistration storage registered_token = registered_tokens[token_key];\n    require(registered_token.registered, \"Token symbol is not registered in the exchange.\");\n    return registered_token;\n  }\n}\n",
  "imports": [
    {
      "name": "ExchangeFirewall_flat.sol",
      "contents": "pragma solidity ^0.5.4;\n\n/**\n * Modified https://github.com/OpenZeppelin/zeppelin-solidity\n */\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner, \"Only the owner can call this function.\");\n    _;\n  }\n\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    owner = newOwner;\n  }\n\n}\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"Overflow while multiplying\");\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0, \"Cannot divide by zero\"); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, \"Negative result while substracting\");\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"Overflow while adding\");\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, \"Remainder of division by zero is undefined\");\n    return a % b;\n  }\n}\n\n\n\n/**\n * Internal interface for the minting of tokens.\n */\ncontract Mintable {\n\n  /**\n   * @dev Mints tokens for an account\n   * This function should emit the Minted event.\n   */\n  function mintInternal(address receiver, uint amount) internal;\n\n  /** Token supply got increased and a new owner received these tokens */\n  event Minted(address receiver, uint amount);\n}\n\n// Interface for burning tokens\ncontract Burnable {\n  // @dev Destroys tokens for an account\n  // @param account Account whose tokens are destroyed\n  // @param value Amount of tokens to destroy\n  function burnTokens(address account, uint value) internal;\n  event Burned(address account, uint value);\n}\n\n/**\n * Interface for the standard token.\n * Based on https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n */\ncontract EIP20Token {\n\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool success);\n  function transferFrom(address from, address to, uint256 value) public returns (bool success);\n  function approve(address spender, uint256 value) public returns (bool success);\n  function allowance(address owner, address spender) public view returns (uint256 remaining);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  /**\n  ** Optional functions\n  *\n  function name() public view returns (string name);\n  function symbol() public view returns (string symbol);\n  function decimals() public view returns (uint8 decimals);\n  *\n  **/\n\n}\n\n/**\n * @title Exchange token\n * @dev Implementation of the EIP20 standard token (also known as ERC20 token) extended to support\n *      some exchange operations.\n */\ncontract ExchangeToken is EIP20Token, Burnable, Mintable {\n  using SafeMath for uint256;\n\n  uint256 private total_supply;\n  mapping(address => uint256) private balances;\n  mapping(address => mapping (address => uint256)) private allowed;\n  string public name;\n  string public symbol;\n  uint8 constant public decimals = 2;\n  Configuration public configuration_contract;\n  bool internal initialized;\n\n  /**\n   * @dev Provides an initializer to the Proxy account.\n   */\n  function initialize(string memory token_name, string memory token_symbol, address configuration) public {\n    require(initialized == false, \"The contract is already initialized\");\n    initialized = true;\n    name = token_name;\n    symbol = token_symbol;\n    setConfigurationContract(configuration);\n  }\n\n  /**\n   * @dev Implements EIP20 totalSupply interface.\n   * @return The total amount of tokens in circulation.\n   */\n  function totalSupply() public view returns (uint256) {\n    return total_supply;\n  }\n\n  function transfer_internal(address from, address to, uint256 value) internal returns (bool) {\n    balances[from] = balances[from].sub(value);\n    balances[to] = balances[to].add(value);\n    emit Transfer(from, to, value);\n    return true;\n  }\n\n  /**\n   * @dev transfer token for a specified address\n   * @param to The address to transfer to.\n   * @param value The amount to be transferred.\n   */\n  function transfer(address to, uint256 value) public returns (bool success) {\n    return transfer_internal(msg.sender, to, value);\n  }\n\n  /**\n   * @dev Gets the balance of the specified address.\n   * @param account The address whose balance is to be queried.\n   * @return An uint256 representing the amount owned by the passed address.\n   */\n  function balanceOf(address account) public view returns (uint256 balance) {\n    return balances[account];\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param from The address which you want to send tokens from\n   * @param to The address which you want to transfer to\n   * @param value The amount of tokens to be transferred\n   */\n  function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n    uint256 allowance = allowed[from][msg.sender];\n    allowed[from][msg.sender] = allowance.sub(value);\n\n    return transfer_internal(from, to, value);\n  }\n\n  /**\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * @param spender The address which will spend the funds.\n   * @param value The amount of tokens to be spent.\n   */\n  function approve(address spender, uint256 value) public returns (bool success) {\n    // To change the approve amount you first have to reduce the addresses'\n    //  allowance to zero by calling `approve(spender, 0)` if it is not\n    //  already 0 to mitigate the race condition described here:\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    require (value == 0 || allowed[msg.sender][spender] == 0, \"Previous allowance value is not zero\");\n\n    allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\n   * @param account address The address which owns the funds.\n   * @param spender address The address which will spend the funds.\n   * @return A uint256 specifing the amount of tokens still avaible for the spender.\n   */\n  function allowance(address account, address spender) public view returns (uint256 remaining) {\n    return allowed[account][spender];\n  }\n\n  /**\n   * Atomic increment of approved spending\n   *\n   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   */\n  function addApproval(address spender, uint256 addedValue) public returns (bool success) {\n    uint256 oldValue = allowed[msg.sender][spender];\n    allowed[msg.sender][spender] = oldValue.add(addedValue);\n    emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\n    return true;\n  }\n\n  /**\n   * Atomic decrement of approved spending.\n   *\n   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   */\n  function subApproval(address spender, uint256 subtractedValue) public returns (bool success) {\n    uint256 oldVal = allowed[msg.sender][spender];\n\n    if (subtractedValue > oldVal) {\n      allowed[msg.sender][spender] = 0;\n    } else {\n      allowed[msg.sender][spender] = oldVal.sub(subtractedValue);\n    }\n    emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\n    return true;\n  }\n\n  /**\n   * @dev Provides an internal function for destroying tokens. Useful for upgrades.\n   */\n  function burnTokens(address account, uint256 value) internal {\n    total_supply = total_supply.sub(value);\n    balances[account] = balances[account].sub(value);\n    emit Burned(account, value);\n    emit Transfer(account, address(0), value);\n  }\n\n  /**\n   * @dev Provides an internal minting function.\n   */\n  function mintInternal(address receiver, uint256 amount) internal {\n    total_supply = total_supply.add(amount);\n    balances[receiver] = balances[receiver].add(amount);\n    emit Minted(receiver, amount);\n    emit Transfer(address(0), receiver, amount);\n  }\n\n  /**\n   * @dev Internal getter for the exchange property.\n   */\n  function getExchangeContract() internal view returns (address) {\n    return configuration_contract.exchangeContract();\n  }\n\n  /**\n   * @dev Internal setter for the configuration contract property.\n   */\n  function setConfigurationContract(address configuration) internal {\n    require(configuration != address(0), \"Configuration address should be valid.\");\n    configuration_contract = Configuration(configuration);\n  }\n\n}\n\n\ncontract ExchangeFirewall is Ownable {\n\n  struct TokenInformation {\n    uint256 token_to_usd;\n    uint256 usd_to_token;\n    uint256 last_update;\n  }\n\n  mapping(bytes32 => bool) public suspended_tokens;\n\n  event Suspended(address token);\n  event Resumed(address token);\n\n  /**\n  * @dev This interface allows adaptive stateful firewalls.\n  *      It isn't specified as view to allow for adaptive stateful firewalls.\n  *      Please note that implementing an adaptive firewall is a delicate task, easily subject to denial of service issues.\n  */\n  function isExchangeAllowed(address exchange_requester, ExchangeToken from, uint256 amount, ExchangeToken to) external returns (bool) {\n    return wouldAllowExchange(exchange_requester, from, amount, to);\n  }\n\n  /**\n   * @dev This function is called to check a particular exchange operation and allow it or block it.\n   */\n  function wouldAllowExchange(address /*exchange_requester*/, ExchangeToken from, uint256 /*amount*/, ExchangeToken to) public view returns (bool) {\n    Exchange exch = Exchange(msg.sender);\n    string memory from_symbol = from.symbol();\n    string memory to_symbol = to.symbol();\n    TokenInformation memory from_info = getTokenRegistration(exch, from_symbol);\n    TokenInformation memory to_info = getTokenRegistration(exch, to_symbol);\n    bool is_suspended = suspended_tokens[keccak256(abi.encodePacked(from_symbol))] || suspended_tokens[keccak256(abi.encodePacked(to_symbol))];\n    return !(is_suspended || from_info.last_update + 8 hours < now || to_info.last_update + 8 hours < now);\n  }\n\n  /**\n   * @dev Get registered token information using its symbol as key.\n   */\n  function getTokenRegistration(Exchange exchange, string memory token_symbol) private view returns (TokenInformation memory) {\n    ( , uint256 token_to_usd, uint256 usd_to_token, uint256 last_update) = exchange.getRegisteredToken(token_symbol);\n    return TokenInformation({ token_to_usd: token_to_usd,\n                              usd_to_token: usd_to_token,\n                              last_update: last_update });\n  }\n\n  /**\n   * @dev Suspends tokens so they can't be used in exchange operations.\n   */\n  function suspendTokens(ExchangeToken[] calldata tokens) external onlyOwner {\n    for (uint256 i = 0; i < tokens.length; i++) {\n      suspended_tokens[keccak256(abi.encodePacked(tokens[i].symbol()))] = true;\n      emit Suspended(address(tokens[i]));\n    }\n  }\n\n  /**\n   * @dev Allows tokens so they can be used in exchange operations once again.\n   */\n  function resumeTokens(ExchangeToken[] calldata tokens) external onlyOwner {\n    for (uint256 i = 0; i < tokens.length; i++) {\n      suspended_tokens[keccak256(abi.encodePacked(tokens[i].symbol()))] = false;\n      emit Resumed(address(tokens[i]));\n    }\n  }\n\n}\n\n\n\n\n\n\n\n\n\n\n\ncontract OwnedExchangeToken is ExchangeToken, Ownable {\n\n  // Used for identifying the token version (useful to check if upgrade succeeded)\n  uint256 public constant VERSION = 1;\n\n  // Used for the processing of user burn messages\n  mapping(address => mapping(uint256 => bool)) private used_nonces;\n\n  event BurnMessageProcessed(address user, uint256 nonce, uint256 amount, bool success, bytes return_data);\n\n  /**\n   * @dev Initializes the storage. Useful for proxied contract instantiation.\n   *      If this contract is to be used without a proxy, consider moving this logic to the constructor instead.\n   */\n  function initialize(string memory token_name, string memory token_symbol, address configuration, address initialOwner) public {\n    require(initialized == false, \"The contract is already initialized\");\n    ExchangeToken.initialize(token_name, token_symbol, configuration);\n    owner = initialOwner;\n  }\n\n  /**\n   * @dev Allows both the owner of this contract, and the exchange to mint tokens.\n   */\n  function mint(address to, uint256 value) public onlyOwnerOrExchange {\n    mintInternal(to, value);\n  }\n\n  /**\n   * @dev Allows anyone to burn their own tokens.\n   */\n  function burn(uint256 value) public {\n    burnTokens(msg.sender, value);\n  }\n\n  /**\n   * @dev Allows the exchange to burn tokens on behalf of someone.\n   */\n  function burnFrom(address to, uint256 value) public onlyExchangeOrSelf {\n    burnTokens(to, value);\n  }\n\n  /**\n   * @dev Allows the configuration contract to transfer its role to another contract.\n   */\n  function updateConfigurationContract(address configuration) public {\n    require(msg.sender == address(configuration_contract),\n            \"Only the configuration contract can update the configuration contract address.\");\n    setConfigurationContract(configuration);\n  }\n\n  modifier onlyOwnerOrExchange() {\n    require(msg.sender == getExchangeContract() || msg.sender == owner, \"Only owner or the exchange contract can call this function.\");\n    _;\n  }\n\n  modifier onlyExchangeOrSelf() {\n    require(msg.sender == getExchangeContract() || msg.sender == address(this),\n            \"Only the exchange or token contract can call this function.\");\n    _;\n  }\n\n  /**\n   * @dev Allows users to sign messages stating their intent to burn tokens have them published by the exchange operator.\n   */\n  function processUserBurnMessages(uint256[] memory amounts, uint256[] memory nonces, bytes32[] memory sigs_r,\n                                   bytes32[] memory sigs_s, uint8[] memory sigs_v) public onlyOwner {\n    require(amounts.length == nonces.length && nonces.length == sigs_r.length &&\n            sigs_r.length == sigs_s.length && sigs_s.length == sigs_v.length, \"Inconsistent message data.\");\n\n    for (uint256 i = 0; i < amounts.length; i++) {\n      executeBurnMessage(nonces[i], amounts[i], sigs_r[i], sigs_s[i], sigs_v[i]);\n    }\n  }\n\n  /**\n   * @dev Implements the processing of a single user burn message.\n   */\n  function executeBurnMessage(uint256 nonce, uint256 amount,\n                              bytes32 sig_r, bytes32 sig_s, uint8 sig_v) private {\n    bytes32 hash = keccak256(abi.encodePacked(\"Xapo v1 Token Burn:\", nonce, amount, address(this)));\n    address user = ecrecover(hash, sig_v, sig_r, sig_s);\n    bool success = false;\n    bytes memory return_data = \"Nonce already used\";\n    if (!used_nonces[user][nonce]) {\n      used_nonces[user][nonce] = true;\n\n      (success, return_data) = address(this).call(abi.encodeWithSignature(\"burnFrom(address,uint256)\", user, amount));\n    }\n\n    emit BurnMessageProcessed(user, nonce, amount, success, return_data);\n  }\n}\n\ncontract Configuration is Ownable {\n  address public exchangeContract;\n\n  constructor(address exchange) public {\n    exchangeContract = exchange;\n  }\n\n  /**\n   * @dev Allows the owner to set the new exchange address.\n   */\n  function setExchangeContract(address new_exchange) public onlyOwner {\n    require(new_exchange != address(0));\n    exchangeContract = new_exchange;\n  }\n\n  /**\n   * @dev Allows the owner to change the configuration contract of multiple tokens at once.\n   * Changing the configuration contract of a token is an irreversible operation.\n   */\n  function updateTokensToUseNewConfiguration(OwnedExchangeToken[] memory tokens_to_update, address new_configuration) public onlyOwner {\n    for (uint i = 0; i < tokens_to_update.length; i++) {\n      tokens_to_update[i].updateConfigurationContract(new_configuration);\n    }\n  }\n\n}\n\n\ncontract Exchange is Ownable {\n\n  using SafeMath for uint256;\n\n  struct TokenRegistration {\n    bool registered;\n    OwnedExchangeToken token_contract;\n    uint256 token_to_usd;\n    uint256 usd_to_token;\n    uint256 last_update_timestamp;\n    uint256 index;\n  }\n\n  // Used for identifying the token version (useful to check if upgrade succeeded)\n  uint256 public constant VERSION = 1;\n\n  ExchangeFirewall public firewall;\n\n  event Exchanged(string from_symbol, uint256 from_amount, string to_symbol, uint256 to_amount);\n\n  // We use the hash of the token symbol as key\n  mapping(bytes32 => TokenRegistration) registered_tokens;\n\n  // Array of registered token keys\n  bytes32[] iterable_tokens;\n\n  bool initialized = false;\n\n  uint256 private constant RATE_DECIMALS = 20;\n  uint256 private constant RATE_TO_TOKEN_AMOUNT = 10 ** (2 * RATE_DECIMALS);\n\n  /**\n   * @dev Used to initialize the proxy account storage\n   */\n  function initialize(address new_owner) public {\n    require(!initialized);\n    initialized = true;\n    owner = new_owner;\n  }\n\n  /**\n   * @dev Exchanges one token for another.\n   * Will revert in case of the resulting exchange overflows the max capacity of uint256\n   * Firewall must be set before any exchange attempt\n   * Note that the max exchange amount is restricted by the size of the exchange rate between tokens\n   */\n  function exchange(string memory from_symbol, uint256 amount, string memory to_symbol, uint256 minimum_expected) public {\n    require(address(firewall) != address(0), \"Firewall has not been set yet.\");\n    TokenRegistration storage from_token = getRegisteredTokenFromStorage(from_symbol);\n    TokenRegistration storage to_token = getRegisteredTokenFromStorage(to_symbol);\n    require(from_token.registered && to_token.registered,\n            \"At least one of the tokens is not registered in the exchange.\");\n\n    OwnedExchangeToken from_contract = from_token.token_contract;\n    OwnedExchangeToken to_contract = to_token.token_contract;\n\n    uint256 due_tokens = calculateDueTokens(from_token, to_token, amount);\n    require(due_tokens > 0, \"Exchange would result in no tokens.\");\n    require(due_tokens >= minimum_expected, \"Exchange would result in less than minimum expected.\");\n\n    require(firewall.isExchangeAllowed(msg.sender, from_contract, amount, to_contract),\n            \"Exchange was rejected by the firewall policy.\");\n\n    from_contract.burnFrom(msg.sender, amount);\n    to_contract.mint(msg.sender, due_tokens);\n\n    emit Exchanged(from_symbol, amount, to_symbol, due_tokens);\n  }\n\n\n  /**\n   * @dev Calculates the amount of tokens according to the registered rates.\n   */\n  function calculateDueTokens(TokenRegistration storage from, TokenRegistration storage to,\n                              uint256 amount) private view returns (uint256) {\n    // Rates have a precision of 20 decimals.\n    return amount.mul(from.token_to_usd).mul(to.usd_to_token).div(RATE_TO_TOKEN_AMOUNT);\n  }\n\n  /**\n   * @dev Estimates the result of the exchange operation.\n   */\n  function estimateExchange(string memory from_symbol, uint256 amount,\n                            string memory to_symbol) public view returns (uint256) {\n    TokenRegistration storage from = getRegisteredTokenFromStorage(from_symbol);\n    TokenRegistration storage to = getRegisteredTokenFromStorage(to_symbol);\n\n    uint256 due_tokens = 0;\n    if (address(firewall) != address(0) && firewall.wouldAllowExchange(msg.sender, from.token_contract, amount, to.token_contract)) {\n      due_tokens = calculateDueTokens(from, to, amount);\n    }\n    return due_tokens;\n  }\n\n  /**\n   * @dev Registers new token pairs. Already registered symbols cannot be overwritten.\n   */\n  function registerTokenRate(OwnedExchangeToken token, uint256 from_token_to_usd,\n                             uint256 from_usd_to_token) public onlyOwner {\n    require(address(token) != address(0), \"Token address should be valid.\");\n    require(from_token_to_usd > 0 &&\n            from_usd_to_token > 0,\n            \"Ratios should be non zero.\");\n\n    uint token_index;\n    // We hash the symbol to use as key\n    bytes32 token_key = keccak256(abi.encodePacked(token.symbol()));\n    require(!registered_tokens[token_key].registered, \"The token is already registered.\");\n\n    token_index = iterable_tokens.push(token_key).sub(1);\n\n    TokenRegistration memory registration = TokenRegistration({\n      registered: true,\n      token_contract: token,\n      token_to_usd: from_token_to_usd,\n      usd_to_token: from_usd_to_token,\n      last_update_timestamp: now,\n      index: token_index\n    });\n\n    registered_tokens[token_key] = registration;\n  }\n\n  /**\n   * @dev Registers new token pairs. Already registered symbols cannot be overwritten.\n   */\n  function registerTokenRates(OwnedExchangeToken[] memory tokens, uint256[] memory from_token_to_usd,\n                              uint256[] memory from_usd_to_token) public onlyOwner {\n    require(tokens.length == from_token_to_usd.length &&\n            from_token_to_usd.length == from_usd_to_token.length,\n            \"The length of all arrays should be the same.\");\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      registerTokenRate(tokens[i], from_token_to_usd[i], from_usd_to_token[i]);\n    }\n  }\n\n  /**\n   * @dev Deregisters an existing token pair.\n   */\n  function deregisterToken(string memory token_symbol) public onlyOwner {\n    bytes32 token_key = keccak256(abi.encodePacked(token_symbol));\n    require(registered_tokens[token_key].registered, \"Token symbol is not registered in the exchange.\");\n\n    uint256 index = registered_tokens[token_key].index;\n    // Can't delete through a storage pointer.\n    delete registered_tokens[token_key];\n\n    if (iterable_tokens.length > 1 && index < iterable_tokens.length.sub(1)) {\n      bytes32 moved_key = iterable_tokens[iterable_tokens.length.sub(1)];\n      iterable_tokens[index] = moved_key;\n\n      TokenRegistration storage moved_token = registered_tokens[moved_key];\n      // This should be a valid token registration\n      require(moved_token.registered, \"Dangling reference to unknown token.\");\n      // Update index of the moved key.\n      moved_token.index = index;\n    }\n    iterable_tokens.length = iterable_tokens.length.sub(1);\n  }\n\n  /**\n   * @dev Deregisters some existing token pairs.\n   */\n  function deregisterTokens(OwnedExchangeToken[] calldata tokens) external onlyOwner {\n    for (uint256 i = 0; i < tokens.length; i++) {\n      deregisterToken(tokens[i].symbol());\n    }\n  }\n\n  /**\n   * @dev This function allows updates to existing exchange rates of token pairs.\n   */\n  function updateTokenRate(string memory token_symbol, uint256 from_token_to_usd,\n                           uint256 from_usd_to_token) public onlyOwner {\n    require(from_token_to_usd > 0 && from_usd_to_token > 0,\n            \"Ratios should be non zero.\");\n\n    TokenRegistration storage registered_token = getRegisteredTokenFromStorage(token_symbol);\n    registered_token.token_to_usd = from_token_to_usd;\n    registered_token.usd_to_token = from_usd_to_token;\n    registered_token.last_update_timestamp = now;\n  }\n\n  /**\n   * @dev This function allows updates to existing exchange rates of token pairs.\n   */\n  function updateTokenRates(OwnedExchangeToken[] memory tokens, uint256[] memory from_token_to_usd,\n                            uint256[] memory from_usd_to_token) public onlyOwner {\n    require(tokens.length == from_token_to_usd.length &&\n            from_token_to_usd.length == from_usd_to_token.length,\n            \"The length of all input arrays should be the same.\");\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      updateTokenRate(tokens[i].symbol(), from_token_to_usd[i], from_usd_to_token[i]);\n    }\n  }\n\n  /**\n   * @dev Mint tokens.\n   */\n  function mintToken(string memory token_symbol, uint256 amount, address destination) public onlyOwner {\n    TokenRegistration storage registered_token = getRegisteredTokenFromStorage(token_symbol);\n    registered_token.token_contract.mint(destination, amount);\n  }\n\n  /**\n   * @dev Mint tokens in batch.\n   */\n  function mintTokens(OwnedExchangeToken[] memory tokens, uint256[] memory amounts,\n                      address[] memory destinations) public onlyOwner {\n    require(tokens.length == amounts.length && amounts.length == destinations.length,\n            \"The length of all arrays should be the same.\");\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      mintToken(tokens[i].symbol(), amounts[i], destinations[i]);\n    }\n  }\n\n  /**\n   * @dev Set new exchange firewall.\n   */\n  function setNewFirewall(ExchangeFirewall newFirewall) public onlyOwner {\n    require(address(newFirewall) != address(0), \"Firewall address should be valid.\");\n    firewall = newFirewall;\n  }\n\n  /**\n   * @dev Get registered token information using its symbol as key.\n   */\n  function getRegisteredToken(string calldata token_symbol) external view\n  returns (address token_contract, uint256 token_to_usd,\n           uint256 usd_to_token, uint256 last_update_timestamp) {\n    TokenRegistration memory registered_token = getRegisteredTokenFromStorage(token_symbol);\n    token_contract = address(registered_token.token_contract);\n    token_to_usd = registered_token.token_to_usd;\n    usd_to_token = registered_token.usd_to_token;\n    last_update_timestamp = registered_token.last_update_timestamp;\n  }\n\n  /**\n   * @dev Get registered token information using the hash of its symbol as key.\n   */\n  function getRegisteredTokenByHash(bytes32 token_key) external view\n  returns (address token_contract, uint256 token_to_usd,\n           uint256 usd_to_token, uint256 last_update_timestamp) {\n    TokenRegistration memory registered_token = registered_tokens[token_key];\n    token_contract = address(registered_token.token_contract);\n    token_to_usd = registered_token.token_to_usd;\n    usd_to_token = registered_token.usd_to_token;\n    last_update_timestamp = registered_token.last_update_timestamp;\n  }\n\n  /**\n   * @dev Allows iteration of the mapping of registered tokens.\n   */\n  function tokenByIndex(uint256 index) external view returns (bytes32) {\n    return iterable_tokens[index];\n  }\n\n  /**\n   * @dev Allows iteration of the mapping of registered tokens.\n   */\n  function tokenCount() external view returns (uint256) {\n    return iterable_tokens.length;\n  }\n\n  /**\n   * @dev Internal registered token getter.\n   */\n  function getRegisteredTokenFromStorage(string memory token_symbol) private view returns (TokenRegistration storage) {\n    bytes32 token_key = keccak256(abi.encodePacked(token_symbol));\n    TokenRegistration storage registered_token = registered_tokens[token_key];\n    require(registered_token.registered, \"Token symbol is not registered in the exchange.\");\n    return registered_token;\n  }\n}\n",
      "file": "ExchangeFirewall_flat.sol"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x63eb352cf58b985a456113c9bcded534e51a7cab9daebfba107501163327ffb7",
    "blockNumber": 1964471,
    "transactionHash": "0xc07eb6b2777cc5569a9c116a343c0a2396be9f09db6d8415ef335ce40f675cde",
    "timestamp": 1576699563
  }
}