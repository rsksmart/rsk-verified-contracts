{
  "address": "0xcce9dad3a431a43d57a27a4623b6bc1f97e530fe",
  "net": {
    "id": "30",
    "name": "RSK Mainnet"
  },
  "name": "BlockableGovernor",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": "1"
    },
    "evmVersion": "byzantium"
  },
  "version": "0.5.8+commit.23d335f2",
  "source": "pragma solidity 0.5.8;\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n\n  /**\n    @notice Override this function with a recipe of the changes to be done when this ChangeContract\n    is executed\n   */\n  function execute() external;\n}\n\n\n\n\n\n\n\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable is Initializable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    function initialize(address sender) public initializer {\n        _owner = sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    uint256[50] private ______gap;\n}\n\n\n\n\n\n/**\n * @title Helps contracts guard against reentrancy attacks.\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\n * @dev If you mark a function `nonReentrant`, you should also\n * mark it `external`.\n */\ncontract ReentrancyGuard is Initializable {\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    function initialize() public initializer {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter);\n    }\n\n    uint256[50] private ______gap;\n}\n\n\n\n\n\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor{\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @dev This function should be protected somehow to only execute changes that\n    benefit the system. This decision process is independent of this architechture\n    therefore is independent of this interface too\n    @param changeContract Address of the contract that will execute the changes\n   */\n  function executeChange(ChangeContract changeContract) external;\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @param _changer Address of the contract that will execute the changes\n   */\n  function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n\n/**\n  @title Governor\n  @notice Basic governor that handles its governed contracts changes\n  through trusting an external address\n  */\ncontract Governor is ReentrancyGuard, Ownable, IGovernor {\n\n  address private currentChangeContract;\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @param changeContract Address of the contract that will execute the changes\n   */\n  function executeChange(ChangeContract changeContract) external {\n    _executeChange(changeContract);\n  }\n\n\n  /**\n    @notice Returns true if the _changer address is currently authorized to make\n    changes within the system\n    @param _changer Address of the contract that will be tested\n   */\n  function isAuthorizedChanger(address _changer) external view returns (bool) {\n    return _isAuthorizedChanger(_changer);\n  }\n\n\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @param changeContract Address of the contract that will execute the changes\n   */\n  function _executeChange(ChangeContract changeContract) internal nonReentrant onlyOwner {\n    enableChangeContract(changeContract);\n    changeContract.execute();\n    disableChangeContract();\n  }\n\n  /**\n    @notice Returns true if the _changer address is currently authorized to make\n    changes within the system\n    @param _changer Address of the contract that will be tested\n   */\n  function _isAuthorizedChanger(address _changer) internal view returns (bool) {\n    return currentChangeContract == _changer;\n  }\n\n  /**\n    @notice Authorize the changeContract address to make changes\n    @param changeContract Address of the contract that will be authorized\n   */\n  function enableChangeContract(ChangeContract changeContract) internal {\n    currentChangeContract = address(changeContract);\n  }\n\n  /**\n    @notice UNAuthorize the currentChangeContract address to make changes\n   */\n  function disableChangeContract() internal {\n    currentChangeContract = address(0x0);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n\n\n\n\n/**\n  @title Blockable\n  @notice Base contract to be able to define a blockable contract. The blocked contract\n  is blocked until a certain date. That date cannot be changed while the contract is blocked so\n  it is guaranteed that you will be blocked until that date\n  */\ncontract Blockable is Initializable {\n\n  string constant private NOT_AUTHORIZED_TO_BLOCK = \"not_authorized_to_block\";\n  string constant private BLOCKED = \"blocked\";\n  string constant private THRESHOLD_TOO_LOW = \"threshold_too_low\";\n\n  uint256 public unblockDate;\n\n  /**\n    @notice Disables functions that should be disabled when the governor is blocked\n   */\n  modifier notBlocked() {\n    require(!isBlocked(), BLOCKED);\n    _;\n  }\n\n  /**\n    @notice Returns true if no change can be executed in the current block\n   */\n  function isBlocked() public view returns (bool) {\n    // solium-disable-next-line security/no-block-members\n    return now < unblockDate;\n  }\n\n  /**\n    @notice Initialize the contract with the basic settings\n    @dev This initialize replaces the constructor but it is not called automatically.\n    It is necessary because of the upgradeability of the contracts\n    @param _firstUnblockDate Timestamp of the first threshold that should be passed before the governor is active\n      again\n   */\n  function initialize(uint256 _firstUnblockDate) public initializer {\n    unblockDate = _firstUnblockDate;\n  }\n\n\n  /**\n    @notice Defines which addresses are authorized to Block and which are not\n    @dev Should be defined by subclasses\n    @param who Address that is being asked for\n   */\n  function isAuthorizedToBlock(address who) public view returns(bool);\n  /**\n    @notice Blocks the governor until unblockAt\n    @dev The new threshold should be big enough to block the governor after the tx and the contract should not be blocked, but that is enforced\n    in the executeChange function which ALWAYS should be called before calling this function because it is the only one authorizing a changer\n    @param newUnblockDate Timestamp of the next threshold that should be passed before the governor is active\n      again\n   */\n  function blockUntil(uint256 newUnblockDate) public notBlocked {\n    require(isAuthorizedToBlock(msg.sender), NOT_AUTHORIZED_TO_BLOCK);\n    // solium-disable-next-line security/no-block-members\n    require(now < newUnblockDate, THRESHOLD_TOO_LOW);\n    unblockDate = newUnblockDate;\n  }\n\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n\n/**\n  @title BlockableGovernor\n  @notice Basic governor that handles its governed contracts changes\n  through trusting an external address and can be blocked until a given threshold\n  */\ncontract BlockableGovernor is Governor, Blockable {\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @param changeContract Address of the contract that will execute the changes\n   */\n  function executeChange(ChangeContract changeContract) external notBlocked {\n    super._executeChange(changeContract);\n  }\n\n  /**\n    @notice Initialize the contract with the basic settings\n    @dev This initialize replaces the constructor but it is not called automatically.\n    It is necessary because of the upgradeability of the contracts\n    @param _owner Address enabled to determine which changes should be run\n    @param _firstUnblockDate Timestamp of the first threshold that should be passed before the governor is active\n      again\n   */\n  function initialize(address _owner, uint256 _firstUnblockDate) public initializer {\n    super.initialize(_owner);\n    Blockable.initialize(_firstUnblockDate);\n  }\n\n\n  /**\n    @notice Defines which addresses are authorized to Block and which are not; in this case, the changes that come through the governor\n    @param who Address that is being asked for\n   */\n  function isAuthorizedToBlock(address who) public view returns(bool) {\n    return _isAuthorizedChanger(who);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n",
  "imports": [
    {
      "name": "BlockableGovernor_flat.sol",
      "contents": "pragma solidity 0.5.8;\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n\n  /**\n    @notice Override this function with a recipe of the changes to be done when this ChangeContract\n    is executed\n   */\n  function execute() external;\n}\n\n\n\n\n\n\n\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable is Initializable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    function initialize(address sender) public initializer {\n        _owner = sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    uint256[50] private ______gap;\n}\n\n\n\n\n\n/**\n * @title Helps contracts guard against reentrancy attacks.\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\n * @dev If you mark a function `nonReentrant`, you should also\n * mark it `external`.\n */\ncontract ReentrancyGuard is Initializable {\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    function initialize() public initializer {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter);\n    }\n\n    uint256[50] private ______gap;\n}\n\n\n\n\n\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor{\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @dev This function should be protected somehow to only execute changes that\n    benefit the system. This decision process is independent of this architechture\n    therefore is independent of this interface too\n    @param changeContract Address of the contract that will execute the changes\n   */\n  function executeChange(ChangeContract changeContract) external;\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @param _changer Address of the contract that will execute the changes\n   */\n  function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n\n/**\n  @title Governor\n  @notice Basic governor that handles its governed contracts changes\n  through trusting an external address\n  */\ncontract Governor is ReentrancyGuard, Ownable, IGovernor {\n\n  address private currentChangeContract;\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @param changeContract Address of the contract that will execute the changes\n   */\n  function executeChange(ChangeContract changeContract) external {\n    _executeChange(changeContract);\n  }\n\n\n  /**\n    @notice Returns true if the _changer address is currently authorized to make\n    changes within the system\n    @param _changer Address of the contract that will be tested\n   */\n  function isAuthorizedChanger(address _changer) external view returns (bool) {\n    return _isAuthorizedChanger(_changer);\n  }\n\n\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @param changeContract Address of the contract that will execute the changes\n   */\n  function _executeChange(ChangeContract changeContract) internal nonReentrant onlyOwner {\n    enableChangeContract(changeContract);\n    changeContract.execute();\n    disableChangeContract();\n  }\n\n  /**\n    @notice Returns true if the _changer address is currently authorized to make\n    changes within the system\n    @param _changer Address of the contract that will be tested\n   */\n  function _isAuthorizedChanger(address _changer) internal view returns (bool) {\n    return currentChangeContract == _changer;\n  }\n\n  /**\n    @notice Authorize the changeContract address to make changes\n    @param changeContract Address of the contract that will be authorized\n   */\n  function enableChangeContract(ChangeContract changeContract) internal {\n    currentChangeContract = address(changeContract);\n  }\n\n  /**\n    @notice UNAuthorize the currentChangeContract address to make changes\n   */\n  function disableChangeContract() internal {\n    currentChangeContract = address(0x0);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n\n\n\n\n/**\n  @title Blockable\n  @notice Base contract to be able to define a blockable contract. The blocked contract\n  is blocked until a certain date. That date cannot be changed while the contract is blocked so\n  it is guaranteed that you will be blocked until that date\n  */\ncontract Blockable is Initializable {\n\n  string constant private NOT_AUTHORIZED_TO_BLOCK = \"not_authorized_to_block\";\n  string constant private BLOCKED = \"blocked\";\n  string constant private THRESHOLD_TOO_LOW = \"threshold_too_low\";\n\n  uint256 public unblockDate;\n\n  /**\n    @notice Disables functions that should be disabled when the governor is blocked\n   */\n  modifier notBlocked() {\n    require(!isBlocked(), BLOCKED);\n    _;\n  }\n\n  /**\n    @notice Returns true if no change can be executed in the current block\n   */\n  function isBlocked() public view returns (bool) {\n    // solium-disable-next-line security/no-block-members\n    return now < unblockDate;\n  }\n\n  /**\n    @notice Initialize the contract with the basic settings\n    @dev This initialize replaces the constructor but it is not called automatically.\n    It is necessary because of the upgradeability of the contracts\n    @param _firstUnblockDate Timestamp of the first threshold that should be passed before the governor is active\n      again\n   */\n  function initialize(uint256 _firstUnblockDate) public initializer {\n    unblockDate = _firstUnblockDate;\n  }\n\n\n  /**\n    @notice Defines which addresses are authorized to Block and which are not\n    @dev Should be defined by subclasses\n    @param who Address that is being asked for\n   */\n  function isAuthorizedToBlock(address who) public view returns(bool);\n  /**\n    @notice Blocks the governor until unblockAt\n    @dev The new threshold should be big enough to block the governor after the tx and the contract should not be blocked, but that is enforced\n    in the executeChange function which ALWAYS should be called before calling this function because it is the only one authorizing a changer\n    @param newUnblockDate Timestamp of the next threshold that should be passed before the governor is active\n      again\n   */\n  function blockUntil(uint256 newUnblockDate) public notBlocked {\n    require(isAuthorizedToBlock(msg.sender), NOT_AUTHORIZED_TO_BLOCK);\n    // solium-disable-next-line security/no-block-members\n    require(now < newUnblockDate, THRESHOLD_TOO_LOW);\n    unblockDate = newUnblockDate;\n  }\n\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n\n/**\n  @title BlockableGovernor\n  @notice Basic governor that handles its governed contracts changes\n  through trusting an external address and can be blocked until a given threshold\n  */\ncontract BlockableGovernor is Governor, Blockable {\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @param changeContract Address of the contract that will execute the changes\n   */\n  function executeChange(ChangeContract changeContract) external notBlocked {\n    super._executeChange(changeContract);\n  }\n\n  /**\n    @notice Initialize the contract with the basic settings\n    @dev This initialize replaces the constructor but it is not called automatically.\n    It is necessary because of the upgradeability of the contracts\n    @param _owner Address enabled to determine which changes should be run\n    @param _firstUnblockDate Timestamp of the first threshold that should be passed before the governor is active\n      again\n   */\n  function initialize(address _owner, uint256 _firstUnblockDate) public initializer {\n    super.initialize(_owner);\n    Blockable.initialize(_firstUnblockDate);\n  }\n\n\n  /**\n    @notice Defines which addresses are authorized to Block and which are not; in this case, the changes that come through the governor\n    @param who Address that is being asked for\n   */\n  function isAuthorizedToBlock(address who) public view returns(bool) {\n    return _isAuthorizedChanger(who);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n",
      "file": "BlockableGovernor_flat.sol"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x9aa99c1285e87d3e1f16335ee5d04485d705ef2dc53cafe1b259d554f0268a44",
    "blockNumber": 1764571,
    "transactionHash": "0xd49daffcfcb7eae4e1c5d9028dfa12b878ccab17cdab2ea629172c66cd726319",
    "timestamp": 1570236104
  }
}