{
  "address": "0x1867670c5eee8a850462ffb5d7b5f4eb25b0ffab",
  "net": {
    "id": "30",
    "name": "RSK Mainnet"
  },
  "name": "SubdomainBatchRegistrar",
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "metadata",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ]
      }
    }
  },
  "version": "0.5.12+commit.7709ece9",
  "source": "pragma solidity ^0.5.3;\n\nimport \"./testing/AbstractAddrResolver.sol\";\nimport \"@rsksmart/rns-registry/contracts/AbstractRNS.sol\";\n\ncontract SubdomainBatchRegistrar {\n    AbstractRNS private rns;\n\n    mapping (bytes32 => address) public nodeOwner;\n    mapping (bytes32 => mapping (address => bool)) public approvedToRegister;\n\n    event Claim(bytes32 node, address owner);\n    event Approve(bytes32 node, address approved, bool approval);\n\n    modifier onlyNodeOwner (bytes32 node) {\n        require(msg.sender == nodeOwner[node], \"Only node owner\");\n        _;\n    }\n\n    modifier onlyApprovedToRegister (bytes32 node) {\n        require(approvedToRegister[node][msg.sender], \"Only approved to register\");\n        _;\n    }\n\n    constructor (AbstractRNS _rns) public {\n        rns = _rns;\n    }\n\n    /// @notice Claim a domain to use for batch registration.\n    /// @dev Claim must be executed before transfering the rns domain.\n    /// @dev Use recover to revert the ownership transfer.\n    /// @dev This will also set owner as allowed registrant.\n    /// @param node The root node to execute batch registrations for.\n    function claim (bytes32 node) external {\n        require(rns.owner(node) == msg.sender, \"Only RNS owner\");\n\n        nodeOwner[node] = msg.sender;\n        approvedToRegister[node][msg.sender] = true;\n\n        emit Claim(node, msg.sender);\n    }\n\n    /***************/\n    /* Registrants */\n    /***************/\n\n    // Registrants can execute subdomain batch registration\n    // for the root node. After claming the node, the owner\n    // can manager registrants.\n\n    /// @notice Add registrant.\n    /// @dev Only node owner.\n    /// @param node Node that the new registant can register subdomains for.\n    /// @param registrant The registrant to be added.\n    function addRegistrant(bytes32 node, address registrant) external onlyNodeOwner(node) {\n        setApproval(node, registrant, true);\n    }\n\n    /// @notice Remove registrant.\n    /// @dev Only node owner.\n    /// @param node Node that the registant cannot register subdomains for.\n    /// @param registrant The registrant to be removed.\n    function removeRegistrant(bytes32 node, address registrant) external onlyNodeOwner(node) {\n        setApproval(node, registrant, false);\n    }\n\n    function setApproval(bytes32 node, address registrant, bool approval) internal onlyNodeOwner(node) {\n        approvedToRegister[node][registrant] = approval;\n        emit Approve(node, registrant, approval);\n    }\n\n    /// @notice Return if a given account can registers subdomains for a given node.\n    /// @param node Node to query the approval for.\n    /// @param registrant The registrant to query for.\n    /// @return True if the registrant can register subnodes for node.\n    function isRegistrant(bytes32 node, address registrant) public view returns (bool) {\n        return approvedToRegister[node][registrant];\n    }\n\n    /// @notice Recover rns node ownership.\n    /// @dev Only node owner.\n    /// @param node Node to recover ownership of.\n    function recover(bytes32 node) external onlyNodeOwner(node) {\n        rns.setOwner(node, nodeOwner[node]);\n    }\n\n    /****************/\n    /* Registration */\n    /****************/\n\n    /// @notice Sets subdomains owners and addr resolutions for given names.\n    /// @dev Only approved to register.\n    /// @dev rootNode must be owned by this contract.\n    /// @dev Sets same address for addr and owner for each subnode.\n    /// @param rootNode Parent of all subdomains.\n    /// @param labels The array of labels to register.\n    /// @param addrs The owner and addr resolution for matching index labels.\n    function register\n        (bytes32 rootNode, bytes32[] calldata labels, address[] calldata addrs)\n        external\n        onlyApprovedToRegister(rootNode)\n    {\n        require(labels.length == addrs.length, \"Labels and addrs should contain same amount of elements\");\n\n        bytes32 node;\n        bytes32 label;\n        address addr;\n\n        AbstractAddrResolver resolver;\n        resolver = AbstractAddrResolver(rns.resolver(rootNode));\n\n        for (uint i = 0; i < labels.length; i++) {\n            label = labels[i];\n            addr = addrs[i];\n            node = keccak256(abi.encodePacked(rootNode, label));\n\n            rns.setSubnodeOwner(rootNode, label, address(this));\n            resolver.setAddr(node, addr);\n            rns.setOwner(node, addr);\n        }\n    }\n}\n",
  "imports": [
    {
      "name": "SubdomainBatchRegistrar.sol",
      "contents": "pragma solidity ^0.5.3;\n\nimport \"./testing/AbstractAddrResolver.sol\";\nimport \"@rsksmart/rns-registry/contracts/AbstractRNS.sol\";\n\ncontract SubdomainBatchRegistrar {\n    AbstractRNS private rns;\n\n    mapping (bytes32 => address) public nodeOwner;\n    mapping (bytes32 => mapping (address => bool)) public approvedToRegister;\n\n    event Claim(bytes32 node, address owner);\n    event Approve(bytes32 node, address approved, bool approval);\n\n    modifier onlyNodeOwner (bytes32 node) {\n        require(msg.sender == nodeOwner[node], \"Only node owner\");\n        _;\n    }\n\n    modifier onlyApprovedToRegister (bytes32 node) {\n        require(approvedToRegister[node][msg.sender], \"Only approved to register\");\n        _;\n    }\n\n    constructor (AbstractRNS _rns) public {\n        rns = _rns;\n    }\n\n    /// @notice Claim a domain to use for batch registration.\n    /// @dev Claim must be executed before transfering the rns domain.\n    /// @dev Use recover to revert the ownership transfer.\n    /// @dev This will also set owner as allowed registrant.\n    /// @param node The root node to execute batch registrations for.\n    function claim (bytes32 node) external {\n        require(rns.owner(node) == msg.sender, \"Only RNS owner\");\n\n        nodeOwner[node] = msg.sender;\n        approvedToRegister[node][msg.sender] = true;\n\n        emit Claim(node, msg.sender);\n    }\n\n    /***************/\n    /* Registrants */\n    /***************/\n\n    // Registrants can execute subdomain batch registration\n    // for the root node. After claming the node, the owner\n    // can manager registrants.\n\n    /// @notice Add registrant.\n    /// @dev Only node owner.\n    /// @param node Node that the new registant can register subdomains for.\n    /// @param registrant The registrant to be added.\n    function addRegistrant(bytes32 node, address registrant) external onlyNodeOwner(node) {\n        setApproval(node, registrant, true);\n    }\n\n    /// @notice Remove registrant.\n    /// @dev Only node owner.\n    /// @param node Node that the registant cannot register subdomains for.\n    /// @param registrant The registrant to be removed.\n    function removeRegistrant(bytes32 node, address registrant) external onlyNodeOwner(node) {\n        setApproval(node, registrant, false);\n    }\n\n    function setApproval(bytes32 node, address registrant, bool approval) internal onlyNodeOwner(node) {\n        approvedToRegister[node][registrant] = approval;\n        emit Approve(node, registrant, approval);\n    }\n\n    /// @notice Return if a given account can registers subdomains for a given node.\n    /// @param node Node to query the approval for.\n    /// @param registrant The registrant to query for.\n    /// @return True if the registrant can register subnodes for node.\n    function isRegistrant(bytes32 node, address registrant) public view returns (bool) {\n        return approvedToRegister[node][registrant];\n    }\n\n    /// @notice Recover rns node ownership.\n    /// @dev Only node owner.\n    /// @param node Node to recover ownership of.\n    function recover(bytes32 node) external onlyNodeOwner(node) {\n        rns.setOwner(node, nodeOwner[node]);\n    }\n\n    /****************/\n    /* Registration */\n    /****************/\n\n    /// @notice Sets subdomains owners and addr resolutions for given names.\n    /// @dev Only approved to register.\n    /// @dev rootNode must be owned by this contract.\n    /// @dev Sets same address for addr and owner for each subnode.\n    /// @param rootNode Parent of all subdomains.\n    /// @param labels The array of labels to register.\n    /// @param addrs The owner and addr resolution for matching index labels.\n    function register\n        (bytes32 rootNode, bytes32[] calldata labels, address[] calldata addrs)\n        external\n        onlyApprovedToRegister(rootNode)\n    {\n        require(labels.length == addrs.length, \"Labels and addrs should contain same amount of elements\");\n\n        bytes32 node;\n        bytes32 label;\n        address addr;\n\n        AbstractAddrResolver resolver;\n        resolver = AbstractAddrResolver(rns.resolver(rootNode));\n\n        for (uint i = 0; i < labels.length; i++) {\n            label = labels[i];\n            addr = addrs[i];\n            node = keccak256(abi.encodePacked(rootNode, label));\n\n            rns.setSubnodeOwner(rootNode, label, address(this));\n            resolver.setAddr(node, addr);\n            rns.setOwner(node, addr);\n        }\n    }\n}\n",
      "file": "SubdomainBatchRegistrar.sol"
    },
    {
      "name": "AbstractAddrResolver.sol",
      "contents": "pragma solidity ^0.5.3;\n\nimport \"./AbstractResolver.sol\";\n\ncontract AbstractAddrResolver is AbstractResolver {\n    function addr(bytes32 node) public view returns (address ret);\n    function setAddr(bytes32 node, address addrValue) public;\n\n    event AddrChanged(bytes32 indexed node, address addr);\n}\n"
    },
    {
      "name": "AbstractResolver.sol",
      "contents": "pragma solidity ^0.5.3;\n\ncontract AbstractResolver {\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool);\n}\n"
    },
    {
      "name": "PublicResolver.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"@rsksmart/rns-registry/contracts/AbstractRNS.sol\";\n\n/**\n * A simple resolver anyone can use; only allows the owner of a node to set its\n * address.\n */\ncontract PublicResolver {\n    AbstractRNS rns;\n    mapping(bytes32=>address) addresses;\n    mapping(bytes32=>bytes32) hashes;\n\n    modifier only_owner(bytes32 node) {\n        require(rns.owner(node) == msg.sender);\n        _;\n    }\n\n    /**\n     * Constructor.\n     * @param rnsAddr The RNS registrar contract.\n     */\n    constructor(AbstractRNS rnsAddr) public {\n        rns = rnsAddr;\n    }\n\n    /**\n     * Fallback function.\n     */\n    function() payable external {\n        revert();\n    }\n\n    /**\n     * Returns true if the specified node has the specified record type.\n     * @param node The RNS node to query.\n     * @param kind The record type name, as specified in EIP137.\n     * @return True if this resolver has a record of the provided type on the\n     *         provided node.\n     */\n    function has(bytes32 node, bytes32 kind) public view returns (bool) {\n        return  (kind == \"addr\" && addresses[node] != address(0)) ||\n        (kind == \"hash\" && hashes[node] != 0);\n    }\n\n    /**\n     * Returns true if the resolver implements the interface specified by the provided hash.\n     * @param interfaceID The ID of the interface to check for.\n     * @return True if the contract implements the requested interface.\n     */\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\n        return interfaceID == 0x3b3b57de || interfaceID == 0xd8389dc5;\n    }\n\n    /**\n     * Returns the address associated with an RNS node.\n     * @param node The RNS node to query.\n     * @return The associated address.\n     */\n    function addr(bytes32 node) public view returns (address) {\n        return addresses[node];\n    }\n\n    /**\n     * Sets the address associated with an RNS node.\n     * May only be called by the owner of that node in the RNS registry.\n     * @param node The node to update.\n     * @param addrValue The address to set.\n     */\n    function setAddr(bytes32 node, address addrValue) public only_owner(node) {\n        addresses[node] = addrValue;\n    }\n\n    /**\n     * Returns the content hash associated with an RNS node.\n     * Note that this resource type is not standardized, and will likely change\n     * in future to a resource type based on multihash.\n     * @param node The RNS node to query.\n     * @return The associated content hash.\n     */\n    function content(bytes32 node) public view returns (bytes32) {\n        return hashes[node];\n    }\n\n    /**\n     * Sets the content hash associated with an RNS node.\n     * May only be called by the owner of that node in the RNS registry.\n     * Note that this resource type is not standardized, and will likely change\n     * in future to a resource type based on multihash.\n     * @param node The node to update.\n     * @param hash The content hash to set\n     */\n    function setContent(bytes32 node, bytes32 hash) public only_owner(node) {\n        hashes[node] = hash;\n    }\n}\n"
    },
    {
      "name": "AbstractRNS.sol",
      "contents": "pragma solidity ^0.5.0;\n\ncontract AbstractRNS {\n    function owner(bytes32 node) public view returns(address);\n    function resolver(bytes32 node) public view returns(address);\n    function ttl(bytes32 node) public view returns(uint64);\n    function setOwner(bytes32 node, address ownerAddress) public;\n    function setSubnodeOwner(bytes32 node, bytes32 label, address ownerAddress) public;\n    function setResolver(bytes32 node, address resolverAddress) public;\n    function setTTL(bytes32 node, uint64 ttlValue) public;\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address ownerAddress);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address ownerAddress);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolverAddress);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttlValue);\n}\n"
    },
    {
      "name": "RNS.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport './AbstractRNS.sol';\n\n/// @title RNS Registry\ncontract RNS is AbstractRNS {\n    struct Record {\n        address owner;\n        address resolver;\n        uint64 ttl;\n    }\n\n    mapping(bytes32=>Record) records;\n\n    modifier only_owner(bytes32 node) {\n        require(records[node].owner == msg.sender);\n        _;\n    }\n\n    constructor() public {\n        records[bytes32(0)].owner = msg.sender;\n    }\n\n    /// @notice Returns the current owner of a domain.\n    /// @param node namehash of the domain.\n    /// @return The owner of the domain.\n    function owner(bytes32 node) public view returns (address) {\n        return records[node].owner;\n    }\n\n    /// @notice Returns the current resolver of a domain.\n    /// @param node namehash of the domain.\n    /// @return The resolver of the domain.\n    function resolver(bytes32 node) public view returns (address) {\n        return records[node].resolver;\n    }\n\n    /// @notice Returns the time to live of a domain and any records\n    /// associated with it.\n    /// @param node namehash of the domain.\n    /// @return The ttl of the domain.\n    function ttl(bytes32 node) public view returns (uint64) {\n        return records[node].ttl;\n    }\n\n    /// @notice Transfers ownership of a domain.\n    /// @dev Only owner of the node.\n    /// @param node namehash of the domain to transfer ownership of.\n    /// @param ownerAddress The new owner.\n    function setOwner(bytes32 node, address ownerAddress) public only_owner(node) {\n        emit Transfer(node, ownerAddress);\n        records[node].owner = ownerAddress;\n    }\n\n    /// @notice Transfers ownership of label.node subdomain.\n    /// @dev Only owner of the parent domain.\n    /// @param node namehash of the parent domain.\n    /// @param label keccak256 of the label specifying the subnode.\n    /// @param ownerAddress The new owner.\n    function setSubnodeOwner(bytes32 node, bytes32 label, address ownerAddress) public only_owner(node) {\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\n        emit NewOwner(node, label, ownerAddress);\n        records[subnode].owner = ownerAddress;\n\n        emit NewResolver(subnode, records[node].resolver);\n        records[subnode].resolver = records[node].resolver;\n    }\n\n    /// @notice Sets the resolver of a given node.\n    /// @dev Only owner of the node.\n    /// @param node namehash of the domain to set the resolver of.\n    /// @param resolverAddress The new resolver.\n    function setResolver(bytes32 node, address resolverAddress) public only_owner(node) {\n        emit NewResolver(node, resolverAddress);\n        records[node].resolver = resolverAddress;\n    }\n\n    /// @notice Sets the time to live of a given node.\n    /// @dev Only owner of the node.\n    /// @param node namehash of the domain to set the ttl of.\n    /// @param ttlValue The new ttl.\n    function setTTL(bytes32 node, uint64 ttlValue) public only_owner(node) {\n        emit NewTTL(node, ttlValue);\n        records[node].ttl = ttlValue;\n    }\n\n    /// @notice Sets the root node resolver.\n    /// @dev Only owner of the root node.\n    /// @param _resolver The new resolver.\n    function setDefaultResolver(address _resolver) public only_owner(0) {\n        records[bytes32(0)].resolver = _resolver;\n    }\n}\n"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x3788b24daec15dedfb33db012641f77a16dafb84b486c44d5f4c8e35bea2bcb9",
    "blockNumber": 1976128,
    "transactionHash": "0x884c81e7a0954996933ff23e7fb04bd580b20b13cb80eeeb7bc07b784a9872bd",
    "timestamp": 1577080214
  },
  "constructorArguments": [
    "0xcb868aeabd31e2b66f74e9a55cf064abb31a4ad5"
  ]
}