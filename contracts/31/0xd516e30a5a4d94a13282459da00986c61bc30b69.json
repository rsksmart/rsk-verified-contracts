{
  "address": "0xd516e30a5a4d94a13282459da00986c61bc30b69",
  "net": {
    "id": "31",
    "name": "RSK Testnet"
  },
  "name": "GrantsProgram",
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "evmVersion": "byzantium",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "metadata",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ]
      }
    }
  },
  "version": "0.6.10+commit.00c0fcaf",
  "source": "// File: contracts/BytesLib.sol\n\n// SPDX-License-Identifier: MIT\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.5.0 <0.7.0;\n\nlibrary BytesLib {\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= (_start + 1), \"Read out of bounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= (_start + 32), \"Read out of bounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n}\n\n// File: contracts/GrantsProgram.sol\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n\ncontract GrantsProgram {\n    event MemberEnabled(address indexed memberAddress);\n    event MemberDisabled(address indexed memberAddress);\n    event FundsReceived(uint256 amount);\n    event FederatorPaid(address indexed fedAddress, uint256 amount);\n    event LogWithdrawal(address sender);\n\n    mapping(address => bool) public bannedAddressesMap;\n    uint256 public lastPaid;\n    address public authorized;\n    uint256 public periodLength;\n    uint256 public amountToPay;\n    mapping(address => uint256) public federatorLastPaid;\n    bytes[] public fedsPubKeys;\n\n    constructor(address _authorized, uint256 _periodLength, uint256 _amountToPay, bytes[] memory _fedsPubKeys) public {\n        require(_authorized != address(0), \"GrantsProgram: Authorized address can't be null\");\n        require(_periodLength != 0, \"GrantsProgram: Period lenght must be greater than 0\");\n        require(_amountToPay > 0, \"GrantsProgram: Amount to pay must be greater than 0\");\n\n        authorized = _authorized;\n        periodLength = _periodLength;\n        amountToPay = _amountToPay;\n        fedsPubKeys = _fedsPubKeys;\n    }\n\n    modifier onlyAuthorized() {\n        require(msg.sender == authorized, \"GrantsProgram: Not authorized\");\n        _;\n    }\n\n    receive() external payable {\n        emit FundsReceived(msg.value);\n    }\n\n    function updatePeriodLength(uint256 newPeriodLength) external onlyAuthorized {\n        periodLength = newPeriodLength;\n    }\n\n    function updateAmountToPay(uint256 newAmountToPay) external onlyAuthorized {\n        amountToPay = newAmountToPay;\n    }\n\n    function updateFedsPubKeys(bytes[] memory newFedsPubKeys) external onlyAuthorized {\n        fedsPubKeys = newFedsPubKeys;\n    }\n\n    function disableMember(address member) external onlyAuthorized {\n        if (bannedAddressesMap[member] == false) {\n            bannedAddressesMap[member] = true;\n            emit MemberDisabled(member);\n        }\n    }\n\n    function enableMember(address member) external onlyAuthorized {\n        if (bannedAddressesMap[member] == true) {\n            delete bannedAddressesMap[member];\n            emit MemberEnabled(member);\n        }\n    }\n\n    function getRequiredFunds() external view returns (uint256) {\n        return fedsPubKeys.length * amountToPay;\n    }\n\n    function payToFederation() external {\n        require(address(this).balance >= this.getRequiredFunds(), \"GrantsProgram: Not enough funds for paying to all federators\");\n\n        uint256 federationSize = fedsPubKeys.length;\n\n        for (uint256 i = 0; i < federationSize; i++) {\n            address payable fedAddress = getAddressFromPublicKey(fedsPubKeys[i]);\n\n            if (!bannedAddressesMap[fedAddress] && block.timestamp >= federatorLastPaid[fedAddress] + periodLength) {\n                fedAddress.transfer(amountToPay);\n                federatorLastPaid[fedAddress] = block.timestamp;\n                emit FederatorPaid(fedAddress, amountToPay);\n            }\n        }\n    }\n\n    function getAddressFromPublicKey(bytes memory fedPubKey) public view returns (address payable) {\n        bytes memory decompressedPublicKey = this.decompressPublicKey(fedPubKey);\n        return payable(address(uint160(uint256(keccak256(abi.encodePacked(decompressedPublicKey))))));\n    }\n\n    function withdrawFunds(address payable recoverAddress) external onlyAuthorized {\n        recoverAddress.transfer(address(this).balance);\n        emit LogWithdrawal(msg.sender);\n    }\n\n    function decompressPublicKey(bytes memory fedPubKey) public pure returns (bytes memory) {\n        uint8 firstByte = BytesLib.toUint8(fedPubKey, 0);\n        require(firstByte == 2 || firstByte == 3, \"GrantsProgram: Provided public key is not compressed\");\n        \n        uint8 compressedPrefix = firstByte == 2 ? 0 : 1;\n        uint256 x = BytesLib.toUint256(fedPubKey, 1);\n        uint256 p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\n        uint256 y2 = addmod(mulmod(x, mulmod(x, x, p), p), 7, p);\n        uint256 y_ = expmod(y2, (p + 1) / 4, p);\n        uint256 cmp = compressedPrefix ^ (y_ & 1);\n        return abi.encodePacked(x, (cmp == 0) ? y_ : p - y_);\n    }\n\n    function expmod(uint256 b, uint256 e, uint256 m) internal pure returns (uint256 r) {\n        if (b == 0) return 0;\n        if (e == 0) return 1;\n        if (m == 0) revert();\n        r = 1;\n        uint256 bit = 2**255;\n        assembly {\n            for {} gt(bit, 0) {} {\n                r := mulmod(mulmod(r, r, m),exp(b, iszero(iszero(and(e, bit)))),m)\n                r := mulmod(mulmod(r, r, m), exp(b, iszero(iszero(and(e, div(bit, 2))))), m)\n                r := mulmod(mulmod(r, r, m), exp(b, iszero(iszero(and(e, div(bit, 4))))), m)\n                r := mulmod(mulmod(r, r, m), exp(b, iszero(iszero(and(e, div(bit, 8))))),m)\n                bit := div(bit, 16)\n            }\n        }\n    }\n}\n",
  "imports": [
    {
      "name": "GrantsProgramFlat.sol",
      "contents": "// File: contracts/BytesLib.sol\n\n// SPDX-License-Identifier: MIT\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.5.0 <0.7.0;\n\nlibrary BytesLib {\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= (_start + 1), \"Read out of bounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= (_start + 32), \"Read out of bounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n}\n\n// File: contracts/GrantsProgram.sol\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n\ncontract GrantsProgram {\n    event MemberEnabled(address indexed memberAddress);\n    event MemberDisabled(address indexed memberAddress);\n    event FundsReceived(uint256 amount);\n    event FederatorPaid(address indexed fedAddress, uint256 amount);\n    event LogWithdrawal(address sender);\n\n    mapping(address => bool) public bannedAddressesMap;\n    uint256 public lastPaid;\n    address public authorized;\n    uint256 public periodLength;\n    uint256 public amountToPay;\n    mapping(address => uint256) public federatorLastPaid;\n    bytes[] public fedsPubKeys;\n\n    constructor(address _authorized, uint256 _periodLength, uint256 _amountToPay, bytes[] memory _fedsPubKeys) public {\n        require(_authorized != address(0), \"GrantsProgram: Authorized address can't be null\");\n        require(_periodLength != 0, \"GrantsProgram: Period lenght must be greater than 0\");\n        require(_amountToPay > 0, \"GrantsProgram: Amount to pay must be greater than 0\");\n\n        authorized = _authorized;\n        periodLength = _periodLength;\n        amountToPay = _amountToPay;\n        fedsPubKeys = _fedsPubKeys;\n    }\n\n    modifier onlyAuthorized() {\n        require(msg.sender == authorized, \"GrantsProgram: Not authorized\");\n        _;\n    }\n\n    receive() external payable {\n        emit FundsReceived(msg.value);\n    }\n\n    function updatePeriodLength(uint256 newPeriodLength) external onlyAuthorized {\n        periodLength = newPeriodLength;\n    }\n\n    function updateAmountToPay(uint256 newAmountToPay) external onlyAuthorized {\n        amountToPay = newAmountToPay;\n    }\n\n    function updateFedsPubKeys(bytes[] memory newFedsPubKeys) external onlyAuthorized {\n        fedsPubKeys = newFedsPubKeys;\n    }\n\n    function disableMember(address member) external onlyAuthorized {\n        if (bannedAddressesMap[member] == false) {\n            bannedAddressesMap[member] = true;\n            emit MemberDisabled(member);\n        }\n    }\n\n    function enableMember(address member) external onlyAuthorized {\n        if (bannedAddressesMap[member] == true) {\n            delete bannedAddressesMap[member];\n            emit MemberEnabled(member);\n        }\n    }\n\n    function getRequiredFunds() external view returns (uint256) {\n        return fedsPubKeys.length * amountToPay;\n    }\n\n    function payToFederation() external {\n        require(address(this).balance >= this.getRequiredFunds(), \"GrantsProgram: Not enough funds for paying to all federators\");\n\n        uint256 federationSize = fedsPubKeys.length;\n\n        for (uint256 i = 0; i < federationSize; i++) {\n            address payable fedAddress = getAddressFromPublicKey(fedsPubKeys[i]);\n\n            if (!bannedAddressesMap[fedAddress] && block.timestamp >= federatorLastPaid[fedAddress] + periodLength) {\n                fedAddress.transfer(amountToPay);\n                federatorLastPaid[fedAddress] = block.timestamp;\n                emit FederatorPaid(fedAddress, amountToPay);\n            }\n        }\n    }\n\n    function getAddressFromPublicKey(bytes memory fedPubKey) public view returns (address payable) {\n        bytes memory decompressedPublicKey = this.decompressPublicKey(fedPubKey);\n        return payable(address(uint160(uint256(keccak256(abi.encodePacked(decompressedPublicKey))))));\n    }\n\n    function withdrawFunds(address payable recoverAddress) external onlyAuthorized {\n        recoverAddress.transfer(address(this).balance);\n        emit LogWithdrawal(msg.sender);\n    }\n\n    function decompressPublicKey(bytes memory fedPubKey) public pure returns (bytes memory) {\n        uint8 firstByte = BytesLib.toUint8(fedPubKey, 0);\n        require(firstByte == 2 || firstByte == 3, \"GrantsProgram: Provided public key is not compressed\");\n        \n        uint8 compressedPrefix = firstByte == 2 ? 0 : 1;\n        uint256 x = BytesLib.toUint256(fedPubKey, 1);\n        uint256 p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\n        uint256 y2 = addmod(mulmod(x, mulmod(x, x, p), p), 7, p);\n        uint256 y_ = expmod(y2, (p + 1) / 4, p);\n        uint256 cmp = compressedPrefix ^ (y_ & 1);\n        return abi.encodePacked(x, (cmp == 0) ? y_ : p - y_);\n    }\n\n    function expmod(uint256 b, uint256 e, uint256 m) internal pure returns (uint256 r) {\n        if (b == 0) return 0;\n        if (e == 0) return 1;\n        if (m == 0) revert();\n        r = 1;\n        uint256 bit = 2**255;\n        assembly {\n            for {} gt(bit, 0) {} {\n                r := mulmod(mulmod(r, r, m),exp(b, iszero(iszero(and(e, bit)))),m)\n                r := mulmod(mulmod(r, r, m), exp(b, iszero(iszero(and(e, div(bit, 2))))), m)\n                r := mulmod(mulmod(r, r, m), exp(b, iszero(iszero(and(e, div(bit, 4))))), m)\n                r := mulmod(mulmod(r, r, m), exp(b, iszero(iszero(and(e, div(bit, 8))))),m)\n                bit := div(bit, 16)\n            }\n        }\n    }\n}\n",
      "file": "GrantsProgramFlat.sol"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0xda47997f2267e22609011255a29316a67800c96aaa34b65d58d794e9792905cd",
    "blockNumber": 1024216,
    "transactionHash": "0x8772695bed5cb7742a15f65e36dea98353294528cc27db5cd003a5bee65dfafe",
    "timestamp": 1595250235
  },
  "constructorArguments": [
    "0x5f69a411d06835ca41365d6f475b3dbe8c04a55c",
    "3600",
    "10000000000000000",
    [
      "0x02afc230c2d355b1a577682b07bc2646041b5d0177af0f98395a46018da699b6da",
      "0x0344a3c38cd59afcba3edcebe143e025574594b001700dec41e59409bdbd0f2a09",
      "0x034844a99cd7028aa319476674cc381df006628be71bc5593b8b5fdb32bb42ef85",
      "0x039a060badbeb24bee49eb2063f616c0f0f0765d4ca646b20a88ce828f259fcdb9"
    ]
  ]
}