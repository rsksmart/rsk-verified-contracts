{
    "address": "0xe09c213d17182989792dc057e419226a3eec6913",
    "net": {
        "id": "31",
        "name": "RSK Testnet"
    },
    "name": "MultiSigWallet",
    "settings": {
        "optimizer": {
            "enabled": false,
            "runs": 200
        }
    },
    "version": "0.5.17+commit.d19bba13",
    "source": "pragma solidity ^0.5.17;\r\n\r\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\r\n/// @author Stefan George - <stefan.george@consensys.net>\r\ncontract MultiSigWallet {\r\n\t/*\r\n\t *  Events\r\n\t */\r\n\tevent Confirmation(address indexed sender, uint256 indexed transactionId);\r\n\tevent Revocation(address indexed sender, uint256 indexed transactionId);\r\n\tevent Submission(uint256 indexed transactionId);\r\n\tevent Execution(uint256 indexed transactionId);\r\n\tevent ExecutionFailure(uint256 indexed transactionId);\r\n\tevent Deposit(address indexed sender, uint256 value);\r\n\tevent OwnerAddition(address indexed owner);\r\n\tevent OwnerRemoval(address indexed owner);\r\n\tevent RequirementChange(uint256 required);\r\n\r\n\t/*\r\n\t *  Constants\r\n\t */\r\n\tuint256 public constant MAX_OWNER_COUNT = 50;\r\n\r\n\t/*\r\n\t *  Storage\r\n\t */\r\n\tmapping(uint256 => Transaction) public transactions;\r\n\tmapping(uint256 => mapping(address => bool)) public confirmations;\r\n\tmapping(address => bool) public isOwner;\r\n\taddress[] public owners;\r\n\tuint256 public required;\r\n\tuint256 public transactionCount;\r\n\r\n\tstruct Transaction {\r\n\t\taddress destination;\r\n\t\tuint256 value;\r\n\t\tbytes data;\r\n\t\tbool executed;\r\n\t}\r\n\r\n\t/*\r\n\t *  Modifiers\r\n\t */\r\n\tmodifier onlyWallet() {\r\n\t\trequire(msg.sender == address(this));\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier ownerDoesNotExist(address owner) {\r\n\t\trequire(!isOwner[owner]);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier ownerExists(address owner) {\r\n\t\trequire(isOwner[owner]);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier transactionExists(uint256 transactionId) {\r\n\t\trequire(transactions[transactionId].destination != address(0));\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier confirmed(uint256 transactionId, address owner) {\r\n\t\trequire(confirmations[transactionId][owner]);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier notConfirmed(uint256 transactionId, address owner) {\r\n\t\trequire(!confirmations[transactionId][owner]);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier notExecuted(uint256 transactionId) {\r\n\t\trequire(!transactions[transactionId].executed);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier notNull(address _address) {\r\n\t\trequire(_address != address(0));\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier validRequirement(uint256 ownerCount, uint256 _required) {\r\n\t\trequire(ownerCount <= MAX_OWNER_COUNT && _required <= ownerCount && _required != 0 && ownerCount != 0);\r\n\t\t_;\r\n\t}\r\n\r\n\t/// @dev Fallback function allows to deposit ether.\r\n\tfunction() external payable {\r\n\t\tif (msg.value > 0) emit Deposit(msg.sender, msg.value);\r\n\t}\r\n\r\n\t/*\r\n\t * Public functions\r\n\t */\r\n\t/// @dev Contract constructor sets initial owners and required number of confirmations.\r\n\t/// @param _owners List of initial owners.\r\n\t/// @param _required Number of required confirmations.\r\n\tconstructor(address[] memory _owners, uint256 _required) public validRequirement(_owners.length, _required) {\r\n\t\tfor (uint256 i = 0; i < _owners.length; i++) {\r\n\t\t\trequire(!isOwner[_owners[i]] && _owners[i] != address(0));\r\n\t\t\tisOwner[_owners[i]] = true;\r\n\t\t}\r\n\t\towners = _owners;\r\n\t\trequired = _required;\r\n\t}\r\n\r\n\t/// @dev Allows to add a new owner. Transaction has to be sent by wallet.\r\n\t/// @param owner Address of new owner.\r\n\tfunction addOwner(address owner)\r\n\t\tpublic\r\n\t\tonlyWallet\r\n\t\townerDoesNotExist(owner)\r\n\t\tnotNull(owner)\r\n\t\tvalidRequirement(owners.length + 1, required)\r\n\t{\r\n\t\tisOwner[owner] = true;\r\n\t\towners.push(owner);\r\n\t\temit OwnerAddition(owner);\r\n\t}\r\n\r\n\t/// @dev Allows to remove an owner. Transaction has to be sent by wallet.\r\n\t/// @param owner Address of owner.\r\n\tfunction removeOwner(address owner) public onlyWallet ownerExists(owner) {\r\n\t\tisOwner[owner] = false;\r\n\t\tfor (uint256 i = 0; i < owners.length - 1; i++)\r\n\t\t\tif (owners[i] == owner) {\r\n\t\t\t\towners[i] = owners[owners.length - 1];\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\towners.length -= 1;\r\n\t\tif (required > owners.length) changeRequirement(owners.length);\r\n\t\temit OwnerRemoval(owner);\r\n\t}\r\n\r\n\t/// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\r\n\t/// @param owner Address of owner to be replaced.\r\n\t/// @param newOwner Address of new owner.\r\n\tfunction replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) {\r\n\t\tfor (uint256 i = 0; i < owners.length; i++)\r\n\t\t\tif (owners[i] == owner) {\r\n\t\t\t\towners[i] = newOwner;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\tisOwner[owner] = false;\r\n\t\tisOwner[newOwner] = true;\r\n\t\temit OwnerRemoval(owner);\r\n\t\temit OwnerAddition(newOwner);\r\n\t}\r\n\r\n\t/// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\r\n\t/// @param _required Number of required confirmations.\r\n\tfunction changeRequirement(uint256 _required) public onlyWallet validRequirement(owners.length, _required) {\r\n\t\trequired = _required;\r\n\t\temit RequirementChange(_required);\r\n\t}\r\n\r\n\t/// @dev Allows an owner to submit and confirm a transaction.\r\n\t/// @param destination Transaction target address.\r\n\t/// @param value Transaction ether value.\r\n\t/// @param data Transaction data payload.\r\n\t/// @return Returns transaction ID.\r\n\tfunction submitTransaction(\r\n\t\taddress destination,\r\n\t\tuint256 value,\r\n\t\tbytes memory data\r\n\t) public returns (uint256 transactionId) {\r\n\t\ttransactionId = addTransaction(destination, value, data);\r\n\t\tconfirmTransaction(transactionId);\r\n\t}\r\n\r\n\t/// @dev Allows an owner to confirm a transaction.\r\n\t/// @param transactionId Transaction ID.\r\n\tfunction confirmTransaction(uint256 transactionId)\r\n\t\tpublic\r\n\t\townerExists(msg.sender)\r\n\t\ttransactionExists(transactionId)\r\n\t\tnotConfirmed(transactionId, msg.sender)\r\n\t{\r\n\t\tconfirmations[transactionId][msg.sender] = true;\r\n\t\temit Confirmation(msg.sender, transactionId);\r\n\t\texecuteTransaction(transactionId);\r\n\t}\r\n\r\n\t/// @dev Allows an owner to revoke a confirmation for a transaction.\r\n\t/// @param transactionId Transaction ID.\r\n\tfunction revokeConfirmation(uint256 transactionId)\r\n\t\tpublic\r\n\t\townerExists(msg.sender)\r\n\t\tconfirmed(transactionId, msg.sender)\r\n\t\tnotExecuted(transactionId)\r\n\t{\r\n\t\tconfirmations[transactionId][msg.sender] = false;\r\n\t\temit Revocation(msg.sender, transactionId);\r\n\t}\r\n\r\n\t/// @dev Allows anyone to execute a confirmed transaction.\r\n\t/// @param transactionId Transaction ID.\r\n\tfunction executeTransaction(uint256 transactionId)\r\n\t\tpublic\r\n\t\townerExists(msg.sender)\r\n\t\tconfirmed(transactionId, msg.sender)\r\n\t\tnotExecuted(transactionId)\r\n\t{\r\n\t\tif (isConfirmed(transactionId)) {\r\n\t\t\tTransaction storage txn = transactions[transactionId];\r\n\t\t\ttxn.executed = true;\r\n\t\t\tif (external_call(txn.destination, txn.value, txn.data.length, txn.data)) emit Execution(transactionId);\r\n\t\t\telse {\r\n\t\t\t\temit ExecutionFailure(transactionId);\r\n\t\t\t\ttxn.executed = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// call has been separated into its own function in order to take advantage\r\n\t// of the Solidity's code generator to produce a loop that copies tx.data into memory.\r\n\tfunction external_call(\r\n\t\taddress destination,\r\n\t\tuint256 value,\r\n\t\tuint256 dataLength,\r\n\t\tbytes memory data\r\n\t) internal returns (bool) {\r\n\t\tbool result;\r\n\t\tassembly {\r\n\t\t\tlet x := mload(0x40) // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\r\n\t\t\tlet d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\r\n\t\t\tresult := call(\r\n\t\t\t\tsub(gas, 34710), // 34710 is the value that solidity is currently emitting\r\n\t\t\t\t// It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\r\n\t\t\t\t// callNewAccountGas (25000, in case the destination address does not exist and needs creating)\r\n\t\t\t\tdestination,\r\n\t\t\t\tvalue,\r\n\t\t\t\td,\r\n\t\t\t\tdataLength, // Size of the input (in bytes) - this is what fixes the padding problem\r\n\t\t\t\tx,\r\n\t\t\t\t0 // Output is ignored, therefore the output size is zero\r\n\t\t\t)\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/// @dev Returns the confirmation status of a transaction.\r\n\t/// @param transactionId Transaction ID.\r\n\t/// @return Confirmation status.\r\n\tfunction isConfirmed(uint256 transactionId) public view returns (bool) {\r\n\t\tuint256 count = 0;\r\n\t\tfor (uint256 i = 0; i < owners.length; i++) {\r\n\t\t\tif (confirmations[transactionId][owners[i]]) count += 1;\r\n\t\t\tif (count == required) return true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/*\r\n\t * Internal functions\r\n\t */\r\n\t/// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\n\t/// @param destination Transaction target address.\r\n\t/// @param value Transaction ether value.\r\n\t/// @param data Transaction data payload.\r\n\t/// @return Returns transaction ID.\r\n\tfunction addTransaction(\r\n\t\taddress destination,\r\n\t\tuint256 value,\r\n\t\tbytes memory data\r\n\t) internal notNull(destination) returns (uint256 transactionId) {\r\n\t\ttransactionId = transactionCount;\r\n\t\ttransactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false });\r\n\t\ttransactionCount += 1;\r\n\t\temit Submission(transactionId);\r\n\t}\r\n\r\n\t/*\r\n\t * Web3 call functions\r\n\t */\r\n\t/// @dev Returns number of confirmations of a transaction.\r\n\t/// @param transactionId Transaction ID.\r\n\t/// @return Number of confirmations.\r\n\tfunction getConfirmationCount(uint256 transactionId) public view returns (uint256 count) {\r\n\t\tfor (uint256 i = 0; i < owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1;\r\n\t}\r\n\r\n\t/// @dev Returns total number of transactions after filers are applied.\r\n\t/// @param pending Include pending transactions.\r\n\t/// @param executed Include executed transactions.\r\n\t/// @return Total number of transactions after filters are applied.\r\n\tfunction getTransactionCount(bool pending, bool executed) public view returns (uint256 count) {\r\n\t\tfor (uint256 i = 0; i < transactionCount; i++)\r\n\t\t\tif ((pending && !transactions[i].executed) || (executed && transactions[i].executed)) count += 1;\r\n\t}\r\n\r\n\t/// @dev Returns list of owners.\r\n\t/// @return List of owner addresses.\r\n\tfunction getOwners() public view returns (address[] memory) {\r\n\t\treturn owners;\r\n\t}\r\n\r\n\t/// @dev Returns array with owner addresses, which confirmed transaction.\r\n\t/// @param transactionId Transaction ID.\r\n\t/// @return Returns array of owner addresses.\r\n\tfunction getConfirmations(uint256 transactionId) public view returns (address[] memory _confirmations) {\r\n\t\taddress[] memory confirmationsTemp = new address[](owners.length);\r\n\t\tuint256 count = 0;\r\n\t\tuint256 i;\r\n\t\tfor (i = 0; i < owners.length; i++)\r\n\t\t\tif (confirmations[transactionId][owners[i]]) {\r\n\t\t\t\tconfirmationsTemp[count] = owners[i];\r\n\t\t\t\tcount += 1;\r\n\t\t\t}\r\n\t\t_confirmations = new address[](count);\r\n\t\tfor (i = 0; i < count; i++) _confirmations[i] = confirmationsTemp[i];\r\n\t}\r\n\r\n\t/// @dev Returns list of transaction IDs in defined range.\r\n\t/// @param from Index start position of transaction array.\r\n\t/// @param to Index end position of transaction array.\r\n\t/// @param pending Include pending transactions.\r\n\t/// @param executed Include executed transactions.\r\n\t/// @return Returns array of transaction IDs.\r\n\tfunction getTransactionIds(\r\n\t\tuint256 from,\r\n\t\tuint256 to,\r\n\t\tbool pending,\r\n\t\tbool executed\r\n\t) public view returns (uint256[] memory _transactionIds) {\r\n\t\tuint256[] memory transactionIdsTemp = new uint256[](transactionCount);\r\n\t\tuint256 count = 0;\r\n\t\tuint256 i;\r\n\t\tfor (i = 0; i < transactionCount; i++)\r\n\t\t\tif ((pending && !transactions[i].executed) || (executed && transactions[i].executed)) {\r\n\t\t\t\ttransactionIdsTemp[count] = i;\r\n\t\t\t\tcount += 1;\r\n\t\t\t}\r\n\t\t_transactionIds = new uint256[](to - from);\r\n\t\tfor (i = from; i < to; i++) _transactionIds[i - from] = transactionIdsTemp[i];\r\n\t}\r\n}",
    "imports": [
        {
            "name": "ContestTreasury.sol",
            "contents": "pragma solidity ^0.5.17;\r\n\r\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\r\n/// @author Stefan George - <stefan.george@consensys.net>\r\ncontract MultiSigWallet {\r\n\t/*\r\n\t *  Events\r\n\t */\r\n\tevent Confirmation(address indexed sender, uint256 indexed transactionId);\r\n\tevent Revocation(address indexed sender, uint256 indexed transactionId);\r\n\tevent Submission(uint256 indexed transactionId);\r\n\tevent Execution(uint256 indexed transactionId);\r\n\tevent ExecutionFailure(uint256 indexed transactionId);\r\n\tevent Deposit(address indexed sender, uint256 value);\r\n\tevent OwnerAddition(address indexed owner);\r\n\tevent OwnerRemoval(address indexed owner);\r\n\tevent RequirementChange(uint256 required);\r\n\r\n\t/*\r\n\t *  Constants\r\n\t */\r\n\tuint256 public constant MAX_OWNER_COUNT = 50;\r\n\r\n\t/*\r\n\t *  Storage\r\n\t */\r\n\tmapping(uint256 => Transaction) public transactions;\r\n\tmapping(uint256 => mapping(address => bool)) public confirmations;\r\n\tmapping(address => bool) public isOwner;\r\n\taddress[] public owners;\r\n\tuint256 public required;\r\n\tuint256 public transactionCount;\r\n\r\n\tstruct Transaction {\r\n\t\taddress destination;\r\n\t\tuint256 value;\r\n\t\tbytes data;\r\n\t\tbool executed;\r\n\t}\r\n\r\n\t/*\r\n\t *  Modifiers\r\n\t */\r\n\tmodifier onlyWallet() {\r\n\t\trequire(msg.sender == address(this));\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier ownerDoesNotExist(address owner) {\r\n\t\trequire(!isOwner[owner]);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier ownerExists(address owner) {\r\n\t\trequire(isOwner[owner]);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier transactionExists(uint256 transactionId) {\r\n\t\trequire(transactions[transactionId].destination != address(0));\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier confirmed(uint256 transactionId, address owner) {\r\n\t\trequire(confirmations[transactionId][owner]);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier notConfirmed(uint256 transactionId, address owner) {\r\n\t\trequire(!confirmations[transactionId][owner]);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier notExecuted(uint256 transactionId) {\r\n\t\trequire(!transactions[transactionId].executed);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier notNull(address _address) {\r\n\t\trequire(_address != address(0));\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier validRequirement(uint256 ownerCount, uint256 _required) {\r\n\t\trequire(ownerCount <= MAX_OWNER_COUNT && _required <= ownerCount && _required != 0 && ownerCount != 0);\r\n\t\t_;\r\n\t}\r\n\r\n\t/// @dev Fallback function allows to deposit ether.\r\n\tfunction() external payable {\r\n\t\tif (msg.value > 0) emit Deposit(msg.sender, msg.value);\r\n\t}\r\n\r\n\t/*\r\n\t * Public functions\r\n\t */\r\n\t/// @dev Contract constructor sets initial owners and required number of confirmations.\r\n\t/// @param _owners List of initial owners.\r\n\t/// @param _required Number of required confirmations.\r\n\tconstructor(address[] memory _owners, uint256 _required) public validRequirement(_owners.length, _required) {\r\n\t\tfor (uint256 i = 0; i < _owners.length; i++) {\r\n\t\t\trequire(!isOwner[_owners[i]] && _owners[i] != address(0));\r\n\t\t\tisOwner[_owners[i]] = true;\r\n\t\t}\r\n\t\towners = _owners;\r\n\t\trequired = _required;\r\n\t}\r\n\r\n\t/// @dev Allows to add a new owner. Transaction has to be sent by wallet.\r\n\t/// @param owner Address of new owner.\r\n\tfunction addOwner(address owner)\r\n\t\tpublic\r\n\t\tonlyWallet\r\n\t\townerDoesNotExist(owner)\r\n\t\tnotNull(owner)\r\n\t\tvalidRequirement(owners.length + 1, required)\r\n\t{\r\n\t\tisOwner[owner] = true;\r\n\t\towners.push(owner);\r\n\t\temit OwnerAddition(owner);\r\n\t}\r\n\r\n\t/// @dev Allows to remove an owner. Transaction has to be sent by wallet.\r\n\t/// @param owner Address of owner.\r\n\tfunction removeOwner(address owner) public onlyWallet ownerExists(owner) {\r\n\t\tisOwner[owner] = false;\r\n\t\tfor (uint256 i = 0; i < owners.length - 1; i++)\r\n\t\t\tif (owners[i] == owner) {\r\n\t\t\t\towners[i] = owners[owners.length - 1];\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\towners.length -= 1;\r\n\t\tif (required > owners.length) changeRequirement(owners.length);\r\n\t\temit OwnerRemoval(owner);\r\n\t}\r\n\r\n\t/// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\r\n\t/// @param owner Address of owner to be replaced.\r\n\t/// @param newOwner Address of new owner.\r\n\tfunction replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) {\r\n\t\tfor (uint256 i = 0; i < owners.length; i++)\r\n\t\t\tif (owners[i] == owner) {\r\n\t\t\t\towners[i] = newOwner;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\tisOwner[owner] = false;\r\n\t\tisOwner[newOwner] = true;\r\n\t\temit OwnerRemoval(owner);\r\n\t\temit OwnerAddition(newOwner);\r\n\t}\r\n\r\n\t/// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\r\n\t/// @param _required Number of required confirmations.\r\n\tfunction changeRequirement(uint256 _required) public onlyWallet validRequirement(owners.length, _required) {\r\n\t\trequired = _required;\r\n\t\temit RequirementChange(_required);\r\n\t}\r\n\r\n\t/// @dev Allows an owner to submit and confirm a transaction.\r\n\t/// @param destination Transaction target address.\r\n\t/// @param value Transaction ether value.\r\n\t/// @param data Transaction data payload.\r\n\t/// @return Returns transaction ID.\r\n\tfunction submitTransaction(\r\n\t\taddress destination,\r\n\t\tuint256 value,\r\n\t\tbytes memory data\r\n\t) public returns (uint256 transactionId) {\r\n\t\ttransactionId = addTransaction(destination, value, data);\r\n\t\tconfirmTransaction(transactionId);\r\n\t}\r\n\r\n\t/// @dev Allows an owner to confirm a transaction.\r\n\t/// @param transactionId Transaction ID.\r\n\tfunction confirmTransaction(uint256 transactionId)\r\n\t\tpublic\r\n\t\townerExists(msg.sender)\r\n\t\ttransactionExists(transactionId)\r\n\t\tnotConfirmed(transactionId, msg.sender)\r\n\t{\r\n\t\tconfirmations[transactionId][msg.sender] = true;\r\n\t\temit Confirmation(msg.sender, transactionId);\r\n\t\texecuteTransaction(transactionId);\r\n\t}\r\n\r\n\t/// @dev Allows an owner to revoke a confirmation for a transaction.\r\n\t/// @param transactionId Transaction ID.\r\n\tfunction revokeConfirmation(uint256 transactionId)\r\n\t\tpublic\r\n\t\townerExists(msg.sender)\r\n\t\tconfirmed(transactionId, msg.sender)\r\n\t\tnotExecuted(transactionId)\r\n\t{\r\n\t\tconfirmations[transactionId][msg.sender] = false;\r\n\t\temit Revocation(msg.sender, transactionId);\r\n\t}\r\n\r\n\t/// @dev Allows anyone to execute a confirmed transaction.\r\n\t/// @param transactionId Transaction ID.\r\n\tfunction executeTransaction(uint256 transactionId)\r\n\t\tpublic\r\n\t\townerExists(msg.sender)\r\n\t\tconfirmed(transactionId, msg.sender)\r\n\t\tnotExecuted(transactionId)\r\n\t{\r\n\t\tif (isConfirmed(transactionId)) {\r\n\t\t\tTransaction storage txn = transactions[transactionId];\r\n\t\t\ttxn.executed = true;\r\n\t\t\tif (external_call(txn.destination, txn.value, txn.data.length, txn.data)) emit Execution(transactionId);\r\n\t\t\telse {\r\n\t\t\t\temit ExecutionFailure(transactionId);\r\n\t\t\t\ttxn.executed = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// call has been separated into its own function in order to take advantage\r\n\t// of the Solidity's code generator to produce a loop that copies tx.data into memory.\r\n\tfunction external_call(\r\n\t\taddress destination,\r\n\t\tuint256 value,\r\n\t\tuint256 dataLength,\r\n\t\tbytes memory data\r\n\t) internal returns (bool) {\r\n\t\tbool result;\r\n\t\tassembly {\r\n\t\t\tlet x := mload(0x40) // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\r\n\t\t\tlet d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\r\n\t\t\tresult := call(\r\n\t\t\t\tsub(gas, 34710), // 34710 is the value that solidity is currently emitting\r\n\t\t\t\t// It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\r\n\t\t\t\t// callNewAccountGas (25000, in case the destination address does not exist and needs creating)\r\n\t\t\t\tdestination,\r\n\t\t\t\tvalue,\r\n\t\t\t\td,\r\n\t\t\t\tdataLength, // Size of the input (in bytes) - this is what fixes the padding problem\r\n\t\t\t\tx,\r\n\t\t\t\t0 // Output is ignored, therefore the output size is zero\r\n\t\t\t)\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/// @dev Returns the confirmation status of a transaction.\r\n\t/// @param transactionId Transaction ID.\r\n\t/// @return Confirmation status.\r\n\tfunction isConfirmed(uint256 transactionId) public view returns (bool) {\r\n\t\tuint256 count = 0;\r\n\t\tfor (uint256 i = 0; i < owners.length; i++) {\r\n\t\t\tif (confirmations[transactionId][owners[i]]) count += 1;\r\n\t\t\tif (count == required) return true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/*\r\n\t * Internal functions\r\n\t */\r\n\t/// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\n\t/// @param destination Transaction target address.\r\n\t/// @param value Transaction ether value.\r\n\t/// @param data Transaction data payload.\r\n\t/// @return Returns transaction ID.\r\n\tfunction addTransaction(\r\n\t\taddress destination,\r\n\t\tuint256 value,\r\n\t\tbytes memory data\r\n\t) internal notNull(destination) returns (uint256 transactionId) {\r\n\t\ttransactionId = transactionCount;\r\n\t\ttransactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false });\r\n\t\ttransactionCount += 1;\r\n\t\temit Submission(transactionId);\r\n\t}\r\n\r\n\t/*\r\n\t * Web3 call functions\r\n\t */\r\n\t/// @dev Returns number of confirmations of a transaction.\r\n\t/// @param transactionId Transaction ID.\r\n\t/// @return Number of confirmations.\r\n\tfunction getConfirmationCount(uint256 transactionId) public view returns (uint256 count) {\r\n\t\tfor (uint256 i = 0; i < owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1;\r\n\t}\r\n\r\n\t/// @dev Returns total number of transactions after filers are applied.\r\n\t/// @param pending Include pending transactions.\r\n\t/// @param executed Include executed transactions.\r\n\t/// @return Total number of transactions after filters are applied.\r\n\tfunction getTransactionCount(bool pending, bool executed) public view returns (uint256 count) {\r\n\t\tfor (uint256 i = 0; i < transactionCount; i++)\r\n\t\t\tif ((pending && !transactions[i].executed) || (executed && transactions[i].executed)) count += 1;\r\n\t}\r\n\r\n\t/// @dev Returns list of owners.\r\n\t/// @return List of owner addresses.\r\n\tfunction getOwners() public view returns (address[] memory) {\r\n\t\treturn owners;\r\n\t}\r\n\r\n\t/// @dev Returns array with owner addresses, which confirmed transaction.\r\n\t/// @param transactionId Transaction ID.\r\n\t/// @return Returns array of owner addresses.\r\n\tfunction getConfirmations(uint256 transactionId) public view returns (address[] memory _confirmations) {\r\n\t\taddress[] memory confirmationsTemp = new address[](owners.length);\r\n\t\tuint256 count = 0;\r\n\t\tuint256 i;\r\n\t\tfor (i = 0; i < owners.length; i++)\r\n\t\t\tif (confirmations[transactionId][owners[i]]) {\r\n\t\t\t\tconfirmationsTemp[count] = owners[i];\r\n\t\t\t\tcount += 1;\r\n\t\t\t}\r\n\t\t_confirmations = new address[](count);\r\n\t\tfor (i = 0; i < count; i++) _confirmations[i] = confirmationsTemp[i];\r\n\t}\r\n\r\n\t/// @dev Returns list of transaction IDs in defined range.\r\n\t/// @param from Index start position of transaction array.\r\n\t/// @param to Index end position of transaction array.\r\n\t/// @param pending Include pending transactions.\r\n\t/// @param executed Include executed transactions.\r\n\t/// @return Returns array of transaction IDs.\r\n\tfunction getTransactionIds(\r\n\t\tuint256 from,\r\n\t\tuint256 to,\r\n\t\tbool pending,\r\n\t\tbool executed\r\n\t) public view returns (uint256[] memory _transactionIds) {\r\n\t\tuint256[] memory transactionIdsTemp = new uint256[](transactionCount);\r\n\t\tuint256 count = 0;\r\n\t\tuint256 i;\r\n\t\tfor (i = 0; i < transactionCount; i++)\r\n\t\t\tif ((pending && !transactions[i].executed) || (executed && transactions[i].executed)) {\r\n\t\t\t\ttransactionIdsTemp[count] = i;\r\n\t\t\t\tcount += 1;\r\n\t\t\t}\r\n\t\t_transactionIds = new uint256[](to - from);\r\n\t\tfor (i = from; i < to; i++) _transactionIds[i - from] = transactionIdsTemp[i];\r\n\t}\r\n}",
            "file": "ContestTreasury.sol"
        }
    ],
    "libraries": {},
    "encodedConstructorArguments": "0x0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000050000000000000000000000007be508451cd748ba55dcbe75c8067f9420909b49000000000000000000000000fc2540acc553622ef1fd0223763767b438478a410000000000000000000000002b1e9a304189205506a24661dce9c47b64dd2ae0000000000000000000000000d7d9a7de795cd55f70bf1e49b8d51d5d3478097c00000000000000000000000007ce1f1c59eb99b9b8bfa06a98171858af3cf53f",
    "creationData": {
        "blockHash": "0xa0a3df2c4cb2b0df813bf369743e91ed16e42c808bc07c4204f80bb0da59a1f8",
        "blockNumber": 1748989,
        "transactionHash": "0x0856e50786a81e78ee1c7e40490b54bfff97dcfd483fdf68eb27d3b276add711",
        "timestamp": 1617913212
    }
}