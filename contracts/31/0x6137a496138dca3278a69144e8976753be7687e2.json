{
    "address": "0x6137a496138dca3278a69144e8976753be7687e2",
    "net": {
        "id": "31",
        "name": "RSK Testnet"
    },
    "name": "MoCConverter",
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": "1"
        },
        "evmVersion": "byzantium"
    },
    "version": "0.5.8+commit.23d335f2",
    "source": "\n// File: contracts/interface/IMoCState.sol\n\npragma solidity 0.5.8;\n\ninterface IMoCState {\n\n     /******STATE MACHINE*********/\n    enum States {\n        // State 0\n        Liquidated,\n        // State 1\n        BProDiscount,\n        // State 2\n        BelowCobj,\n        // State 3\n        AboveCobj\n    }\n\n\n    function addToRbtcInSystem(uint256 btcAmount) external;\n\n    function subtractRbtcFromSystem(uint256 btcAmount) external;\n\n    function coverage(bytes32 bucket) external view returns(uint256);\n\n    function getRbtcRemainder() external view returns(uint256);\n\n    function liq() external view returns(uint256);\n\n    function state() external view returns(States);\n\n    function peg() external view returns(uint256);\n\n    function dayBlockSpan() external view returns(uint256);\n\n    function getBitcoinPrice() external view returns(uint256);\n\n    function getMoCPrice() external view returns(uint256);\n\n    function getProtected() external view returns(uint256);\n\n    function globalCoverage() external view returns(uint256);\n\n    function getMoCVendors() external view returns(address);\n\n    function getMoCToken() external view returns(address);\n\n    function nextState() external;\n\n    function maxBProWithDiscount() external view returns(uint256);\n\n    function absoluteMaxBPro() external view returns(uint256);\n\n    function absoluteMaxDoc() external view returns(uint256);\n\n    function freeDoc() external view returns(uint256);\n\n    function bproTecPrice() external view returns(uint256);\n\n    function bproSpotDiscountRate() external view returns(uint256);\n\n    function bproDiscountPrice() external view returns(uint256);\n\n    function bucketBProTecPrice(bytes32 bucket) external view returns(uint256);\n\n    function currentAbundanceRatio() external view returns(uint256);\n\n    function abundanceRatio(uint256 doc0) external view returns(uint256);\n\n    function daysToSettlement() external view returns(uint256);\n\n    function leverage(bytes32 bucket) external view returns(uint256);\n\n    function getBucketNBTC(bytes32 bucket) external view returns(uint256);\n\n    function getLiquidationPrice() external view returns(uint256);\n\n    function maxBProxBtcValue(bytes32 bucket) external view returns(uint256);\n\n    function bucketBProTecPriceHelper(bytes32 bucket) external view returns(uint256);\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n// File: contracts/MoCHelperLib.sol\n\npragma solidity 0.5.8;\n\n\nlibrary MoCHelperLib {\n\n  struct MocLibConfig {\n    uint256 reservePrecision;\n    uint256 dayPrecision;\n    uint256 mocPrecision;\n  }\n\n  using SafeMath for uint256;\n\n  uint256 constant UINT256_MAX = ~uint256(0);\n\n  /**\n    @dev Returns max uint256 value constant.\n    @return max uint256 value constant\n  */\n  function getMaxInt(MocLibConfig storage /*config*/) public pure returns(uint256) {\n    return UINT256_MAX;\n  }\n\n  /**\n    @dev Calculates average interest using integral function: T =  Rate = a * (x ** b) + c\n    @param tMax maxInterestRate [using mocPrecision]\n    @param power factor [using noPrecision]\n    @param tMin minInterestRate C0 doc amount [using mocPrecision]\n    @param abRat1 initial abundance ratio [using mocPrecision]\n    @param abRat2 final abundance ratio [using mocPrecision]\n    @return average interest rate [using mocPrecision]\n  */\n  function inrateAvg(MocLibConfig storage config, uint256 tMax, uint256 power, uint256 tMin, uint256 abRat1, uint256 abRat2)\n  public view returns(uint256) {\n    require(tMax > tMin, \"Max inrate should be bigger than Min inrate\");\n    uint256 abRat1Comp = config.mocPrecision.sub(abRat1);\n    uint256 abRat2Comp = config.mocPrecision.sub(abRat2);\n\n    if (abRat1 == abRat2) {\n      return potential(config, tMax, power, tMin, abRat1Comp);\n    }\n    else if (abRat2 < abRat1) {\n      return avgInt(config, tMax, power, tMin, abRat1Comp, abRat2Comp);\n    }\n    else {\n      return avgInt(config, tMax, power, tMin, abRat2Comp, abRat1Comp);\n    }\n  }\n\n  /**\n    @dev Calculates spot interest rate that BProx owners should pay to BPro owners: Rate = tMax * (abRatio ** power) + tMin\n    @param tMin min interest rate [using mocPrecision]\n    @param power power to use in the formula [using NoPrecision]\n    @param tMax max interest rate [using mocPrecision]\n    @param abRatio bucket C0  abundance Ratio [using mocPrecision]\n   */\n  function spotInrate(\n    MocLibConfig storage config, uint256 tMax, uint256 power, uint256 tMin, uint256 abRatio\n  ) public view returns(uint256) {\n    uint256 abRatioComp = config.mocPrecision.sub(abRatio);\n\n    return potential(config, tMax, power, tMin, abRatioComp);\n  }\n\n  /**\n    @dev Calculates potential interests function with given parameters: Rate = a * (x ** b) + c\n    @param a maxInterestRate [using mocPrecision]\n    @param b factor [using NoPrecision]\n    @param c minInterestRate C0 doc amount [using mocPrecision]\n    @param value global doc amount [using mocPrecision]\n  */\n  function potential(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value)\n  public view returns(uint256) {\n    // value ** b\n    // [MOC] ** [] = [MOC]\n    uint256 aux1 = pow(value, b, config.mocPrecision);\n    // (a * aux1) + c\n    // [MOC] [MOC] / [MOC] + [MOC] = [MOC]\n    return a.mul(aux1).div(config.mocPrecision).add(c);\n  }\n\n  /**\n    @dev Calculates average of the integral function:\n     T = (\n              (c * xf + ((a * (xf ** (b + 1))) / (b + 1))) -\n              (c * xi + ((a * (xi ** (b + 1))) / (b + 1)))\n             ) / (xf - xi)\n    @param a maxInterestRate [using mocPrecision]\n    @param b factor [using NoPrecision]\n    @param c minInterestRate C0 doc amount [using mocPrecision]\n    @param value1 value to put in the function [using mocPrecision]\n    @param value2 value to put in the function [using mocPrecision]\n    @return average interest rate [using mocPrecision]\n  */\n  function avgInt(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value1, uint256 value2)\n  public view returns(uint256) {\n    // value2 - value1\n    // [MOC]\n    uint256 diff = value2.sub(value1);\n    // ((c * (1 - value1) + ((a * ((1 - value1) ** (b + 1))) / (b + 1)))\n    uint256 intV1 = integral(config, a, b, c, value1);\n    // ((c * (1 - value2) + ((a * ((1 - value2) ** (b + 1))) / (b + 1)))\n    uint256 intV2 = integral(config,  a, b, c, value2);\n    // (secOp - first) / diff\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\n    return intV2.sub(intV1).div(diff);\n  }\n\n  /**\n    @dev Calculates integral of the exponential function: T = c * (value) + (a * value ** (b + 1)) / (b + 1))\n    @param a maxInterestRate [using mocPrecision]\n    @param b factor [using NoPrecision]\n    @param c minInterestRate C0 doc amount [using mocPrecision]\n    @param value value to put in the function [using mocPrecision]\n    @return integration result [using mocPrecision]\n  */\n  function integral(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value)\n  public view returns(uint256) {\n    // b + 1\n    // [NONE]\n    uint256 b2 = b.add(1);\n    // c * value\n    // [MOC][MOC]\n    uint256 firstOp = c.mul(value);\n    // [MOC]\n    uint256 pow = pow(value, b2, config.mocPrecision);\n    // (a * value ** b2) / b2)\n    // [MOC][MOC]\n    uint256 secOp = a.mul(pow).div(b2);\n    // (firstOp + secOp)\n    // [MOC][MOC] + [MOC][MOC] = [MOC][MOC]\n    return firstOp.add(secOp);\n  }\n\n  /**\n  * @dev Relation between docs in bucket 0 and Doc total supply\n  * @param doc0 doc count in bucket 0 [using mocPrecision]\n  * @param doct total doc supply [using mocPrecision]\n  * @return abundance ratio [using mocPrecision]\n  */\n  function abundanceRatio(MocLibConfig storage config, uint256 doc0, uint256 doct)\n  public view returns(uint256) {\n    if (doct == 0) {\n      return config.mocPrecision;\n    }\n    // [DOC] [MOC] / [DOC] = [MOC]\n    return doc0.mul(config.mocPrecision).div(doct);\n  }\n\n  /**\n    @dev Returns the Ratio to apply to BPro Price in discount situations: SpotDiscountRate = TPD * (utpdu - cob) / (uptdu -liq)\n    @param bproLiqDiscountRate Discount rate applied at Liquidation level coverage [using mocPrecision]\n    @param liq Liquidation coverage threshold [using mocPrecision]\n    @param utpdu Discount coverage threshold [using mocPrecision]\n    @param cov Actual global Coverage threshold [using mocPrecision]\n    @return Spot discount rate [using mocPrecision]\n  */\n  function bproSpotDiscountRate(\n    MocLibConfig storage libConfig, uint256 bproLiqDiscountRate,\n    uint256 liq, uint256 utpdu, uint256 cov\n  ) public view returns(uint256) {\n    require(bproLiqDiscountRate < libConfig.mocPrecision, \"Discount rate should be lower than 1\");\n\n    if (cov >= utpdu) {\n      return 0;\n    }\n\n    // utpdu - liq\n    // [MOC] - [MOC] = [MOC]\n    uint256 utpduLiqDiff = utpdu.sub(liq);\n\n    // utpdu - cov\n    // [MOC] - [MOC] = [MOC]\n    uint256 utpduCovDiff = utpdu.sub(cov);\n\n    // TPD * utpduCovDiff / utpduLiqDiff\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    return bproLiqDiscountRate.mul(utpduCovDiff).div(utpduLiqDiff);\n  }\n\n  /**\n    @dev Max amount of BPro to available with discount: MaxBProWithDiscount = (uTPDU * nDOC * PEG - (nBTC * B)) / (TPusd * TPD)\n    @param nB Total BTC amount [using reservePrecision]\n    @param nDoc DOC amount [using mocPrecision]\n    @param utpdu Discount coverage threshold [using mocPrecision]\n    @param peg peg value\n    @param btcPrice BTC price [using mocPrecision]\n    @param bproUsdPrice bproUsdPrice [using mocPrecision]\n    @param spotDiscount spot discount [using mocPrecision]\n    @return Total BPro amount [using mocPrecision]\n  */\n  function maxBProWithDiscount(\n    MocLibConfig storage libConfig, uint256 nB, uint256 nDoc, uint256 utpdu,\n    uint256 peg, uint256 btcPrice, uint256 bproUsdPrice, uint256 spotDiscount\n  ) public view returns(uint256)  {\n    require(spotDiscount < libConfig.mocPrecision, \"Discount Rate should be lower than 1\");\n\n    if (spotDiscount == 0) {\n      return 0;\n    }\n\n    // nBTC * B\n    // [RES] * [MOC] / [RES] = [MOC]\n    uint256 nbUsdValue = nB.mul(btcPrice).div(libConfig.reservePrecision);\n\n    // (TPusd * (1 - TPD))\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 bproDiscountPrice = bproUsdPrice.mul(libConfig.mocPrecision.sub(spotDiscount))\n      .div(libConfig.mocPrecision);\n\n    return maxBProWithDiscountAux(libConfig, nbUsdValue, nDoc, utpdu, peg, bproDiscountPrice);\n  }\n\n  /**\n    @dev Max amount of BPro to available with discount: MaxBProWithDiscount = (uTPDU * nDOC * PEG - (nBTC * B)) / (TPusd * TPD)\n    @param nbUsdValue Total amount of BTC in USD [using mocPrecision]\n    @param nDoc DOC amount [using mocPrecision]\n    @param utpdu Discount coverage threshold [using mocPrecision]\n    @param bproDiscountPrice bproUsdPrice with discount applied [using mocPrecision]\n    @param peg peg value\n    @return Total BPro amount [using mocPrecision]\n  */\n  function maxBProWithDiscountAux(\n    MocLibConfig storage libConfig, uint256 nbUsdValue, uint256 nDoc,\n    uint256 utpdu, uint256 peg, uint256 bproDiscountPrice\n  ) internal view returns(uint256) {\n\n    // uTPDU * nDOC * PEG\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 coverageUSDAmount = utpdu.mul(nDoc).mul(peg).div(libConfig.mocPrecision);\n\n    // This case only occurs with Coverage below 1\n    if (coverageUSDAmount <= nbUsdValue) {\n      return 0;\n    }\n\n    // ([MOC] - [MOC]) * [RES] / [MOC] = [RES]\n    return coverageUSDAmount.sub(nbUsdValue).mul(libConfig.reservePrecision).div(bproDiscountPrice);\n  }\n\n  /**\n    @dev Calculates Locked bitcoin\n    @param btcPrice BTC price [using mocPrecision]\n    @param nDoc Docs amount [using mocPrecision]\n    @param peg peg value\n    @return Locked bitcoin [using reservePrecision]\n  */\n  function lockedBitcoin(\n    MocLibConfig storage libConfig, uint256 btcPrice, uint256 nDoc, uint256 peg\n  ) public view returns(uint256) {\n    return nDoc.mul(peg).mul(libConfig.reservePrecision).div(btcPrice);\n  }\n\n  /**\n    @dev Calculates price at liquidation event as a relation between the doc total supply\n    and the amount of RBTC available to distribute\n    @param rbtcAmount RBTC to distribute [using reservePrecision]\n    @param nDoc Docs amount [using mocPrecision]\n    @return Price at liquidation event [using mocPrecision]\n  */\n  function liquidationPrice(MocLibConfig storage libConfig, uint256 rbtcAmount, uint256 nDoc)\n  public view returns(uint256) {\n    // [MOC] * [RES] / [RES]\n    return nDoc.mul(libConfig.reservePrecision).div(rbtcAmount);\n  }\n\n  /**\n    @dev Calculates BPro BTC price: TPbtc = (nB-LB) / nTP\n    @param nB Total BTC amount [using reservePrecision]\n    @param lb Locked bitcoins amount [using reservePrecision]\n    @param nTP BPro amount [using mocPrecision]\n    @return BPro BTC price [using reservePrecision]\n  */\n  function bproTecPrice(MocLibConfig storage libConfig, uint256 nB, uint256 lb, uint256 nTP)\n    public view returns(uint256) {\n    // Liquidation happens before this condition turns true\n    if (nB < lb) {\n      return 0;\n    }\n\n    if (nTP == 0) {\n      return libConfig.mocPrecision;\n    }\n    // ([RES] - [RES]) * [MOC] / [MOC]\n    return nB.sub(lb).mul(libConfig.mocPrecision).div(nTP);\n  }\n\n  /**\n    @dev Calculates BPro BTC price: BProxInBPro = bproxTecPrice / bproPrice\n    @param bproxTecPrice BProx BTC price [using reservePrecision]\n    @param bproPrice Trog BTC price [using reservePrecision]\n    @return BProx price in BPro [using mocPrecision]\n  */\n  function bproxBProPrice(\n    MocLibConfig storage libConfig, uint256 bproxTecPrice, uint256 bproPrice\n  ) public view returns(uint256) {\n    // [RES] * [MOC] / [RES] = [MOC]\n    return bproxTecPrice.mul(libConfig.mocPrecision).div(bproPrice);\n  }\n\n  /**\n    @dev Returns a new value with the discountRate applied: TPbtc = (price)* (1 - discountRate)\n    @param price Price [using SomePrecision]\n    @param discountRate Discount rate to apply [using mocPrecision]\n    @return Price with discount applied [using SomePrecision]\n  */\n  function applyDiscountRate(MocLibConfig storage libConfig, uint256 price, uint256 discountRate)\n    public view returns(uint256) {\n\n    uint256 discountCoeff = libConfig.mocPrecision.sub(discountRate);\n\n    return price.mul(discountCoeff).div(libConfig.mocPrecision);\n  }\n\n  /**\n    @dev Returns the amount of interest to pay: TPbtc = price * interestRate\n    @param value Cost to apply interest [using SomePrecision]\n    @param interestRate Interest rate to apply [using mocPrecision]\n    @return Interest cost based on the value and interestRate [using SomePrecision]\n  */\n  function getInterestCost(MocLibConfig storage libConfig, uint256 value, uint256 interestRate)\n    public view returns(uint256) {\n    // [ORIGIN] * [MOC] / [MOC] = [ORIGIN]\n    return value.mul(interestRate).div(libConfig.mocPrecision);\n  }\n\n  /**\n    @dev Calculates Coverage: Coverage = nB / LB\n    @param nB Total BTC amount [using reservePrecision]\n    @param lB Locked bitcoins amount [using reservePrecision]\n    @return Coverage [using mocPrecision]\n  */\n  function coverage(MocLibConfig storage libConfig, uint256 nB, uint256 lB) public view\n    returns(uint256) {\n    if (lB == 0) {\n      return UINT256_MAX;\n    }\n\n    return nB.mul(libConfig.mocPrecision).div(lB);\n  }\n\n /**\n    @dev Calculates Leverage from Coverage: Leverage = C / (C - 1)\n    @param cov Coverage [using mocPrecision]\n    @return Leverage [using mocPrecision]\n  */\n  function leverageFromCoverage(MocLibConfig storage libConfig, uint256 cov)\n  public view returns(uint256) {\n    if (cov == UINT256_MAX) {\n      return libConfig.mocPrecision;\n    }\n\n    if (cov <= libConfig.mocPrecision) {\n      return UINT256_MAX;\n    }\n\n    return cov.mul(libConfig.mocPrecision).div(cov.sub(libConfig.mocPrecision));\n  }\n\n /**\n    @dev Calculates Leverage: Leverage = nB / (nB - lB)\n    @param nB Total BTC amount [using reservePrecision]\n    @param lB Locked bitcoins amount [using reservePrecision]\n    @return Leverage [using mocPrecision]\n  */\n  function leverage(MocLibConfig storage libConfig, uint256 nB,uint256 lB)\n  public view returns(uint256) {\n    if (lB == 0) {\n      return libConfig.mocPrecision;\n    }\n\n    if (nB <= lB) {\n      return UINT256_MAX;\n    }\n\n    return nB.mul(libConfig.mocPrecision).div(nB.sub(lB));\n  }\n\n  /**\n    @dev Price in BTC of the amount of Docs\n    @param amount Total BTC amount [using reservePrecision]\n    @param btcPrice BTC price [using mocPrecision]\n    @return Total value [using reservePrecision]\n  */\n  function docsBtcValue(\n    MocLibConfig storage libConfig, uint256 amount,uint256 peg, uint256 btcPrice\n  ) public view returns(uint256) {\n    require(btcPrice > 0,\"Bitcoin price should be more than zero\");\n    require(libConfig.reservePrecision > 0, \"Precision should be more than zero\");\n    //Total = amount / satoshi price\n    //Total = amount / (btcPrice / precision)\n    // [RES] * [MOC] / [MOC]\n    uint256 docBtcTotal = amount.mul(libConfig.mocPrecision).mul(peg).div(btcPrice);\n\n    return docBtcTotal;\n  }\n\n /**\n    @dev Price in RBTC of the amount of BPros\n    @param bproAmount amount of BPro [using mocPrecision]\n    @param bproBtcPrice BPro price in RBTC [using reservePrecision]\n    @return Total value [using reservePrecision]\n  */\n  function bproBtcValue(MocLibConfig storage libConfig, uint256 bproAmount, uint256 bproBtcPrice)\n    public view returns(uint256) {\n    require(libConfig.reservePrecision > 0, \"Precision should be more than zero\");\n\n    // [MOC] * [RES] / [MOC] =  [RES]\n    uint256 bproBtcTotal = bproAmount.mul(bproBtcPrice).div(libConfig.mocPrecision);\n\n    return bproBtcTotal;\n  }\n\n  /**\n    @dev Max amount of Docs to issue: MaxDoc = ((nB*B)-(Cobj*B/Bcons*nDoc*PEG))/(PEG*(Cobj*B/BCons-1))\n    @param nB Total BTC amount [using reservePrecision]\n    @param cobj Target Coverage [using mocPrecision]\n    @param nDoc DOC amount [using mocPrecision]\n    @param peg peg value\n    @param btcPrice BTC price [using mocPrecision]\n    @param bCons BTC conservative price [using mocPrecision]\n    @return Total Docs amount [using mocPrecision]\n  */\n  function maxDoc(\n    MocLibConfig storage libConfig, uint256 nB,\n    uint256 cobj, uint256 nDoc, uint256 peg, uint256 btcPrice, uint256 bCons\n  ) public view returns(uint256) {\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\n\n    // If cobj is less than 1, just return zero\n    if (cobj < libConfig.mocPrecision)\n      return 0;\n\n    // Cobj * B / BCons\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 adjCobj = cobj.mul(btcPrice).div(bCons);\n\n    return maxDocAux(libConfig, nB, adjCobj, nDoc, peg, btcPrice);\n  }\n\n  function maxDocAux(MocLibConfig storage libConfig, uint256 nB, uint256 adjCobj, uint256 nDoc, uint256 peg, uint256 btcPrice)\n  internal view returns(uint256) {\n    // (nB*B)\n    // [RES] [MOC] [MOC] / [RES] = [MOC] [MOC]\n    uint256 firstOperand = nB.mul(btcPrice).mul(libConfig.mocPrecision).div(libConfig.reservePrecision);\n    // (adjCobj*nDoc*PEG)\n    // [MOC] [MOC]\n    uint256 secOperand = adjCobj.mul(nDoc).mul(peg);\n    // (PEG*(adjCobj-1)\n    // [MOC]\n    uint256 denom = adjCobj.sub(libConfig.mocPrecision).mul(peg);\n\n    if (firstOperand <= secOperand)\n      return 0;\n\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\n    return (firstOperand.sub(secOperand)).div(denom);\n  }\n\n  /**\n    @dev Max amount of BPro to redeem: MaxBPro = ((nB*B)-(Cobj*nDoc*PEG))/TPusd\n    @param nB Total BTC amount [using reservePrecision]\n    @param cobj Target Coverage [using mocPrecision]\n    @param nDoc Target Coverage [using mocPrecision]\n    @param peg peg value\n    @param btcPrice BTC price [using mocPrecision]\n    @param bCons BTC conservative price [using mocPrecision]\n    @param bproUsdPrice bproUsdPrice [using mocPrecision]\n    @return Total BPro amount [using mocPrecision]\n  */\n  function maxBPro(\n    MocLibConfig storage libConfig, uint256 nB, uint256 cobj,\n    uint256 nDoc, uint256 peg, uint256 btcPrice, uint256 bCons, uint256 bproUsdPrice\n  ) public view returns(uint256) {\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\n\n    // Cobj * btcPrice / BCons\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 adjCobj = cobj.mul(btcPrice).div(bCons);\n    // (nB * btcPrice)\n    // [RES] * [MOC] * [MOC] / [RES] = [MOC] [MOC]\n    uint256 firstOperand = nB.mul(btcPrice)\n      .mul(libConfig.mocPrecision)\n      .div(libConfig.reservePrecision);\n    // (adjCobj * nDoc * PEG)\n    // [MOC] * [MOC]\n    uint256 secOperand = adjCobj.mul(nDoc).mul(peg);\n\n    if (firstOperand <= secOperand)\n      return 0;\n\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\n    return (firstOperand.sub(secOperand)).div(bproUsdPrice);\n  }\n\n  /**\n    @dev Calculates the total BTC price of the amount of BPros\n    @param amount Amount of BPro [using mocPrecision]\n    @param bproPrice BPro BTC Price [using reservePrecision]\n    @return BPro total value in BTC [using reservePrecision]\n  */\n  function totalBProInBtc(\n    MocLibConfig storage libConfig, uint256 amount, uint256 bproPrice\n  ) public view returns(uint256) {\n    // [RES] * [MOC] / [MOC] = [RES]\n    return bproPrice.mul(amount).div(libConfig.mocPrecision);\n  }\n\n  /**\n    @dev Calculates the equivalent in Docs of the btcAmount\n    @param btcAmount BTC  amount [using reservePrecision]\n    @param btcPrice BTC price [using mocPrecision]\n    @return Equivalent Doc amount [using mocPrecision]\n  */\n  function maxDocsWithBtc(\n    MocLibConfig storage libConfig, uint256 btcAmount, uint256 btcPrice\n  ) public view returns(uint256) {\n    // [RES] * [MOC] / [RES] = [MOC]\n    return btcAmount.mul(btcPrice).div(libConfig.reservePrecision);\n  }\n\n  /**\n    @dev Calculates the equivalent in BPro of the btcAmount\n    @param btcAmount BTC amount [using reservePrecision]\n    @param bproPrice BPro BTC price [using reservePrecision]\n    @return Equivalent Bpro amount [using mocPrecision]\n  */\n  function maxBProWithBtc(\n    MocLibConfig storage libConfig, uint256 btcAmount, uint256 bproPrice\n  ) public view returns(uint256) {\n    if (bproPrice == 0) {\n      return 0;\n    }\n\n    // [RES] * [MOC] / [RES]\n    return btcAmount.mul(libConfig.mocPrecision).div(bproPrice);\n  }\n\n  /**\n    @dev Calculates the Btc amount to move from C0 bucket to: toMove = btcAmount * (lev - 1)\n    an L bucket when a BProx minting occurs\n    @param btcAmount Total BTC amount [using reservePrecision]\n    @param lev L bucket leverage [using mocPrecision]\n    @return btc to move [using reservePrecision]\n  */\n  function bucketTransferAmount(\n    MocLibConfig storage libConfig, uint256 btcAmount, uint256 lev\n  ) public view returns(uint256) {\n    require(lev > libConfig.mocPrecision, \"Leverage should be more than 1\");\n\n    if (lev == UINT256_MAX || btcAmount == 0) {\n      return 0;\n    }\n\n    // (lev-1)\n    uint256 levSubOne = lev.sub(libConfig.mocPrecision);\n\n    // Intentionally avaoid SafeMath\n    // [RES] * [MOC]\n    uint256 transferAmount = btcAmount * levSubOne;\n    if (transferAmount / btcAmount != levSubOne)\n      return 0;\n\n    // [RES] * [MOC] / [MOC] = [RES]\n    return transferAmount.div(libConfig.mocPrecision);\n  }\n\n  /**\n    @dev Max amount of BTC allowed to be used to mint bprox: Maxbprox = nDOC/ (PEG*B*(lev-1))\n    @param nDoc number of DOC [using mocPrecision]\n    @param peg peg value\n    @param btcPrice BTC price [using mocPrecision]\n    @param lev leverage [using mocPrecision]\n    @return Max bprox BTC value [using reservePrecision]\n  */\n  function maxBProxBtcValue(\n    MocLibConfig storage libConfig, uint256 nDoc, uint256 peg, uint256 btcPrice, uint256 lev\n  ) public view returns(uint256)  {\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\n\n    if (lev <= libConfig.mocPrecision) {\n      return 0;\n    }\n    // (lev-1)\n    // [MOC]\n    uint256 levSubOne = lev.sub(libConfig.mocPrecision);\n\n    // PEG * BtcPrice\n    // [MOC]\n    uint256 pegTimesPrice = peg.mul(btcPrice);\n\n    // This intentionally avoid using safeMath to handle overflow case\n    // PEG * BtcPrice * (lev - 1)\n    // [MOC] * [MOC]\n    uint256 dividend = pegTimesPrice * levSubOne;\n\n    if (dividend / pegTimesPrice != levSubOne)\n      return 0; // INFINIT dividend means 0\n\n    // nDoc adjusted with precisions\n    // [MOC] [RES]\n    uint256 divider = nDoc.mul(libConfig.reservePrecision);\n\n    // [MOC] [RES] [MOC] / [MOC] [MOC]\n    return divider.mul(libConfig.mocPrecision).div(dividend);\n  }\n\n  /**\n    @dev Calculates the equivalent in MoC of the btcAmount\n    @param btcAmount BTC  amount\n    @param btcPrice BTC price\n    @param mocPrice MoC price\n    @return Equivalent MoC amount\n  */\n  function maxMoCWithBtc(\n    MocLibConfig storage /*libConfig*/, uint256 btcAmount, uint256 btcPrice, uint256 mocPrice\n  ) public pure returns(uint256) {\n    return btcPrice.mul(btcAmount).div(mocPrice);\n  }\n\n  /**\n    @dev Calculates the equivalent in BTC of the MoC amount\n    @param amount BTC  amount\n    @param btcPrice BTC price\n    @param mocPrice MoC price\n    @return Equivalent MoC amount\n  */\n  function mocBtcValue(\n    MocLibConfig storage /*libConfig*/, uint256 amount, uint256 btcPrice, uint256 mocPrice\n  ) public pure returns(uint256) {\n    require(btcPrice > 0,\"Bitcoin price should be more than zero\");\n    require(mocPrice > 0,\"MoC price should be more than zero\");\n\n    uint256 mocBtcTotal = amount.mul(mocPrice).div(btcPrice);\n\n    return mocBtcTotal;\n  }\n\n  /**\n    @dev Transform an address to payable address\n    @param account Address to transform to payable\n    @return Payable address for account\n  */\n  function getPayableAddress(\n    MocLibConfig storage /*libConfig*/, address account\n  ) public pure\n  returns (address payable) {\n    return address(uint160(account));\n  }\n\n  /**\n    @dev Rounding product adapted from DSMath but with custom precision\n    @param x Multiplicand\n    @param y Multiplier\n    @return Product\n  */\n  function mulr(uint x, uint y, uint256 precision) internal pure returns (uint z) {\n    return x.mul(y).add(precision.div(2)).div(precision);\n  }\n\n  /**\n    @dev Potentiation by squaring adapted from DSMath but with custom precision\n    @param x Base\n    @param n Exponent\n    @return power\n  */\n  function pow(uint256 x, uint256 n, uint256 precision) internal pure returns (uint z) {\n    uint256 x2 = x;\n    z = n % 2 != 0 ? x : precision;\n\n    for (n /= 2; n != 0; n /= 2) {\n      x2 = mulr(x2, x2, precision);\n\n      if (n % 2 != 0) {\n        z = mulr(z, x2, precision);\n      }\n    }\n  }\n}\n\n// File: contracts/MoCLibConnection.sol\n\npragma solidity 0.5.8;\n\n\n/**\n  @dev Interface with MocHelperLib\n */\ncontract MoCLibConnection {\n  using MoCHelperLib for MoCHelperLib.MocLibConfig;\n  MoCHelperLib.MocLibConfig internal mocLibConfig;\n\n  /*\n  * Precision getters\n  */\n  function getMocPrecision() public view returns(uint256) {\n    return mocLibConfig.mocPrecision;\n  }\n\n  function getReservePrecision() public view returns(uint256) {\n    return mocLibConfig.reservePrecision;\n  }\n\n  function getDayPrecision() public view returns(uint256) {\n    return mocLibConfig.dayPrecision;\n  }\n\n  function initializePrecisions() internal {\n    mocLibConfig = MoCHelperLib.MocLibConfig({\n      reservePrecision: 10 ** 18,\n      mocPrecision: 10 ** 18,\n      dayPrecision: 1\n    });\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: zos-lib/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.6.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: contracts/base/MoCWhitelist.sol\n\npragma solidity 0.5.8;\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCWhitelist {\n  mapping(address => bool) whitelist;\n\n  /**\n   * @dev Check if an account is whitelisted\n   * @return Bool\n   */\n  function isWhitelisted(address account)\n    public\n    view\n    returns (bool)\n  {\n    require(account != address(0), \"Account must not be 0x0\");\n    return whitelist[account];\n  }\n\n  /**\n   * @dev Add account to whitelist\n   */\n  function add(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(!isWhitelisted(account), \"Account not allowed to add accounts into white list\");\n    whitelist[account] = true;\n  }\n\n  /**\n   * @dev Remove account from whitelist\n   */\n  function remove(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(isWhitelisted(account), \"Account is not allowed to remove address from the white list\");\n\n    whitelist[account] = false;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/base/MoCConnector.sol\n\npragma solidity 0.5.8;\n\n\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCConnector is MoCWhitelist, Initializable {\n  // References\n  address payable public moc;\n  address public docToken;\n  address public bproToken;\n  address public bproxManager;\n  address public mocState;\n  address public mocConverter;\n  address public mocSettlement;\n  address public mocExchange;\n  address public mocInrate;\n  /** DEPRECATED mocBurnout **/\n  address public mocBurnout;\n\n  bool internal initialized;\n\n  /**\n    @dev Initializes the contract\n    @param mocAddress MoC contract address\n    @param docAddress DoCToken contract address\n    @param bproAddress BProToken contract address\n    @param bproxAddress BProxManager contract address\n    @param stateAddress MoCState contract address\n    @param settlementAddress MoCSettlement contract address\n    @param converterAddress MoCConverter contract address\n    @param exchangeAddress MoCExchange contract address\n    @param inrateAddress MoCInrate contract address\n    @param burnoutBookAddress (DEPRECATED) MoCBurnout contract address. DO NOT USE.\n  */\n  function initialize(\n    address payable mocAddress,\n    address docAddress,\n    address bproAddress,\n    address bproxAddress,\n    address stateAddress,\n    address settlementAddress,\n    address converterAddress,\n    address exchangeAddress,\n    address inrateAddress,\n    address burnoutBookAddress\n  ) public initializer {\n    moc = mocAddress;\n    docToken = docAddress;\n    bproToken = bproAddress;\n    bproxManager = bproxAddress;\n    mocState = stateAddress;\n    mocSettlement = settlementAddress;\n    mocConverter = converterAddress;\n    mocExchange = exchangeAddress;\n    mocInrate = inrateAddress;\n    mocBurnout = burnoutBookAddress;\n\n    // Add to Whitelist\n    add(mocAddress);\n    add(docAddress);\n    add(bproAddress);\n    add(bproxAddress);\n    add(stateAddress);\n    add(settlementAddress);\n    add(converterAddress);\n    add(exchangeAddress);\n    add(inrateAddress);\n    add(burnoutBookAddress);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/base/MoCConstants.sol\n\npragma solidity 0.5.8;\n\n/**\n * @dev Defines special constants to use along all the MoC System\n */\ncontract MoCConstants {\n  bytes32 constant public BUCKET_X2 = \"X2\";\n  bytes32 constant public BUCKET_C0 = \"C0\";\n}\n\n// File: contracts/base/MoCBase.sol\n\npragma solidity 0.5.8;\n\n\n\n\n/**\n  @dev General usefull modifiers and functions\n */\ncontract MoCBase is MoCConstants, Initializable {\n  // Contracts\n  MoCConnector public connector;\n\n  bool internal initialized;\n\n  function initializeBase(address connectorAddress) internal initializer {\n    connector = MoCConnector(connectorAddress);\n  }\n\n  modifier onlyWhitelisted(address account) {\n    require(connector.isWhitelisted(account), \"Address is not whitelisted\");\n    _;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/MoCConverter.sol\n\npragma solidity 0.5.8;\n\n\n\n\ncontract MoCConverter is MoCBase, MoCLibConnection {\n  IMoCState internal mocState;\n\n  function initialize(address connectorAddress) public initializer {\n    initializePrecisions();\n    initializeBase(connectorAddress);\n    mocState = IMoCState(connector.mocState());\n  }\n\n  /**\n  * @dev BTC equivalent for the amount of bpros given\n  * @param amount Amount of BPro to calculate the total price\n  * @return total BTC Price of the amount BPros [using reservePrecision]\n  */\n  function bproToBtc(uint256 amount) public view returns(uint256) {\n    uint256 tecPrice = mocState.bproTecPrice();\n\n    return mocLibConfig.totalBProInBtc(amount, tecPrice);\n  }\n\n  /**\n  * @dev Converts BTC to BPro\n  * @param btcAmount BTC amount\n  * @return BPro amount\n  */\n  function btcToBPro(uint256 btcAmount) public view returns(uint256) {\n    return mocLibConfig.maxBProWithBtc(btcAmount, mocState.bproTecPrice());\n  }\n\n  /**\n  * @dev BTC equivalent for the amount of bpro given applying the spotDiscountRate\n  * @param amount amount of BPro [using mocPrecision]\n  * @return BTC amount\n  */\n  function bproDiscToBtc(uint256 amount) public view returns(uint256) {\n    uint256 discountRate = mocState.bproSpotDiscountRate();\n    uint256 totalBtcValue = bproToBtc(amount);\n\n    return mocLibConfig.applyDiscountRate(totalBtcValue, discountRate);\n  }\n\n  function btcToBProDisc(uint256 btcAmount) public view returns(uint256) {\n    return mocLibConfig.maxBProWithBtc(btcAmount, mocState.bproDiscountPrice());\n  }\n\n  function docsToBtc(uint256 docAmount) public view returns(uint256) {\n    return mocLibConfig.docsBtcValue(docAmount, mocState.peg(), mocState.getBitcoinPrice());\n  }\n\n  function docsToBtcWithPrice(uint256 docAmount, uint256 btcPrice) public view returns(uint256) {\n    return mocLibConfig.docsBtcValue(docAmount, mocState.peg(), btcPrice);\n  }\n\n  function btcToDoc(uint256 btcAmount) public view returns(uint256) {\n    return mocLibConfig.maxDocsWithBtc(btcAmount, mocState.getBitcoinPrice());\n  }\n\n  function bproxToBtc(uint256 bproxAmount, bytes32 bucket) public view returns(uint256) {\n    return mocLibConfig.bproBtcValue(bproxAmount, mocState.bucketBProTecPrice(bucket));\n  }\n\n  function bproxToBtcHelper(uint256 bproxAmount, bytes32 bucket) public view returns(uint256) {\n    return mocLibConfig.bproBtcValue(bproxAmount, mocState.bucketBProTecPriceHelper(bucket));\n  }\n\n  function btcToBProx(uint256 btcAmount, bytes32 bucket) public view returns(uint256) {\n    return mocLibConfig.maxBProWithBtc(btcAmount, mocState.bucketBProTecPrice(bucket));\n  }\n\n  function btcToBProWithPrice(uint256 btcAmount, uint256 price) public view returns(uint256) {\n    return mocLibConfig.maxBProWithBtc(btcAmount, price);\n  }\n\n  function bproToBtcWithPrice(uint256 bproAmount, uint256 bproPrice) public view returns(uint256) {\n    return mocLibConfig.bproBtcValue(bproAmount, bproPrice);\n  }\n\n  function mocToBtc(uint256 mocAmount) public view returns(uint256) {\n    return mocLibConfig.mocBtcValue(mocAmount, mocState.getBitcoinPrice(), mocState.getMoCPrice());\n  }\n\n  function btcToMoC(uint256 btcAmount) public view returns(uint256) {\n    return mocLibConfig.maxMoCWithBtc(btcAmount, mocState.getBitcoinPrice(), mocState.getMoCPrice());\n  }\n\n  function mocToBtcWithPrice(uint256 mocAmount, uint256 btcPrice, uint256 mocPrice) public view returns(uint256) {\n    return mocLibConfig.mocBtcValue(mocAmount, btcPrice, mocPrice);\n  }\n\n  function btcToMoCWithPrice(uint256 btcAmount, uint256 btcPrice, uint256 mocPrice) public view returns(uint256) {\n    return mocLibConfig.maxMoCWithBtc(btcAmount, btcPrice, mocPrice);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n",
    "imports": [
        {
            "name": "MoCConverter-flat.sol",
            "contents": "\n// File: contracts/interface/IMoCState.sol\n\npragma solidity 0.5.8;\n\ninterface IMoCState {\n\n     /******STATE MACHINE*********/\n    enum States {\n        // State 0\n        Liquidated,\n        // State 1\n        BProDiscount,\n        // State 2\n        BelowCobj,\n        // State 3\n        AboveCobj\n    }\n\n\n    function addToRbtcInSystem(uint256 btcAmount) external;\n\n    function subtractRbtcFromSystem(uint256 btcAmount) external;\n\n    function coverage(bytes32 bucket) external view returns(uint256);\n\n    function getRbtcRemainder() external view returns(uint256);\n\n    function liq() external view returns(uint256);\n\n    function state() external view returns(States);\n\n    function peg() external view returns(uint256);\n\n    function dayBlockSpan() external view returns(uint256);\n\n    function getBitcoinPrice() external view returns(uint256);\n\n    function getMoCPrice() external view returns(uint256);\n\n    function getProtected() external view returns(uint256);\n\n    function globalCoverage() external view returns(uint256);\n\n    function getMoCVendors() external view returns(address);\n\n    function getMoCToken() external view returns(address);\n\n    function nextState() external;\n\n    function maxBProWithDiscount() external view returns(uint256);\n\n    function absoluteMaxBPro() external view returns(uint256);\n\n    function absoluteMaxDoc() external view returns(uint256);\n\n    function freeDoc() external view returns(uint256);\n\n    function bproTecPrice() external view returns(uint256);\n\n    function bproSpotDiscountRate() external view returns(uint256);\n\n    function bproDiscountPrice() external view returns(uint256);\n\n    function bucketBProTecPrice(bytes32 bucket) external view returns(uint256);\n\n    function currentAbundanceRatio() external view returns(uint256);\n\n    function abundanceRatio(uint256 doc0) external view returns(uint256);\n\n    function daysToSettlement() external view returns(uint256);\n\n    function leverage(bytes32 bucket) external view returns(uint256);\n\n    function getBucketNBTC(bytes32 bucket) external view returns(uint256);\n\n    function getLiquidationPrice() external view returns(uint256);\n\n    function maxBProxBtcValue(bytes32 bucket) external view returns(uint256);\n\n    function bucketBProTecPriceHelper(bytes32 bucket) external view returns(uint256);\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n// File: contracts/MoCHelperLib.sol\n\npragma solidity 0.5.8;\n\n\nlibrary MoCHelperLib {\n\n  struct MocLibConfig {\n    uint256 reservePrecision;\n    uint256 dayPrecision;\n    uint256 mocPrecision;\n  }\n\n  using SafeMath for uint256;\n\n  uint256 constant UINT256_MAX = ~uint256(0);\n\n  /**\n    @dev Returns max uint256 value constant.\n    @return max uint256 value constant\n  */\n  function getMaxInt(MocLibConfig storage /*config*/) public pure returns(uint256) {\n    return UINT256_MAX;\n  }\n\n  /**\n    @dev Calculates average interest using integral function: T =  Rate = a * (x ** b) + c\n    @param tMax maxInterestRate [using mocPrecision]\n    @param power factor [using noPrecision]\n    @param tMin minInterestRate C0 doc amount [using mocPrecision]\n    @param abRat1 initial abundance ratio [using mocPrecision]\n    @param abRat2 final abundance ratio [using mocPrecision]\n    @return average interest rate [using mocPrecision]\n  */\n  function inrateAvg(MocLibConfig storage config, uint256 tMax, uint256 power, uint256 tMin, uint256 abRat1, uint256 abRat2)\n  public view returns(uint256) {\n    require(tMax > tMin, \"Max inrate should be bigger than Min inrate\");\n    uint256 abRat1Comp = config.mocPrecision.sub(abRat1);\n    uint256 abRat2Comp = config.mocPrecision.sub(abRat2);\n\n    if (abRat1 == abRat2) {\n      return potential(config, tMax, power, tMin, abRat1Comp);\n    }\n    else if (abRat2 < abRat1) {\n      return avgInt(config, tMax, power, tMin, abRat1Comp, abRat2Comp);\n    }\n    else {\n      return avgInt(config, tMax, power, tMin, abRat2Comp, abRat1Comp);\n    }\n  }\n\n  /**\n    @dev Calculates spot interest rate that BProx owners should pay to BPro owners: Rate = tMax * (abRatio ** power) + tMin\n    @param tMin min interest rate [using mocPrecision]\n    @param power power to use in the formula [using NoPrecision]\n    @param tMax max interest rate [using mocPrecision]\n    @param abRatio bucket C0  abundance Ratio [using mocPrecision]\n   */\n  function spotInrate(\n    MocLibConfig storage config, uint256 tMax, uint256 power, uint256 tMin, uint256 abRatio\n  ) public view returns(uint256) {\n    uint256 abRatioComp = config.mocPrecision.sub(abRatio);\n\n    return potential(config, tMax, power, tMin, abRatioComp);\n  }\n\n  /**\n    @dev Calculates potential interests function with given parameters: Rate = a * (x ** b) + c\n    @param a maxInterestRate [using mocPrecision]\n    @param b factor [using NoPrecision]\n    @param c minInterestRate C0 doc amount [using mocPrecision]\n    @param value global doc amount [using mocPrecision]\n  */\n  function potential(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value)\n  public view returns(uint256) {\n    // value ** b\n    // [MOC] ** [] = [MOC]\n    uint256 aux1 = pow(value, b, config.mocPrecision);\n    // (a * aux1) + c\n    // [MOC] [MOC] / [MOC] + [MOC] = [MOC]\n    return a.mul(aux1).div(config.mocPrecision).add(c);\n  }\n\n  /**\n    @dev Calculates average of the integral function:\n     T = (\n              (c * xf + ((a * (xf ** (b + 1))) / (b + 1))) -\n              (c * xi + ((a * (xi ** (b + 1))) / (b + 1)))\n             ) / (xf - xi)\n    @param a maxInterestRate [using mocPrecision]\n    @param b factor [using NoPrecision]\n    @param c minInterestRate C0 doc amount [using mocPrecision]\n    @param value1 value to put in the function [using mocPrecision]\n    @param value2 value to put in the function [using mocPrecision]\n    @return average interest rate [using mocPrecision]\n  */\n  function avgInt(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value1, uint256 value2)\n  public view returns(uint256) {\n    // value2 - value1\n    // [MOC]\n    uint256 diff = value2.sub(value1);\n    // ((c * (1 - value1) + ((a * ((1 - value1) ** (b + 1))) / (b + 1)))\n    uint256 intV1 = integral(config, a, b, c, value1);\n    // ((c * (1 - value2) + ((a * ((1 - value2) ** (b + 1))) / (b + 1)))\n    uint256 intV2 = integral(config,  a, b, c, value2);\n    // (secOp - first) / diff\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\n    return intV2.sub(intV1).div(diff);\n  }\n\n  /**\n    @dev Calculates integral of the exponential function: T = c * (value) + (a * value ** (b + 1)) / (b + 1))\n    @param a maxInterestRate [using mocPrecision]\n    @param b factor [using NoPrecision]\n    @param c minInterestRate C0 doc amount [using mocPrecision]\n    @param value value to put in the function [using mocPrecision]\n    @return integration result [using mocPrecision]\n  */\n  function integral(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value)\n  public view returns(uint256) {\n    // b + 1\n    // [NONE]\n    uint256 b2 = b.add(1);\n    // c * value\n    // [MOC][MOC]\n    uint256 firstOp = c.mul(value);\n    // [MOC]\n    uint256 pow = pow(value, b2, config.mocPrecision);\n    // (a * value ** b2) / b2)\n    // [MOC][MOC]\n    uint256 secOp = a.mul(pow).div(b2);\n    // (firstOp + secOp)\n    // [MOC][MOC] + [MOC][MOC] = [MOC][MOC]\n    return firstOp.add(secOp);\n  }\n\n  /**\n  * @dev Relation between docs in bucket 0 and Doc total supply\n  * @param doc0 doc count in bucket 0 [using mocPrecision]\n  * @param doct total doc supply [using mocPrecision]\n  * @return abundance ratio [using mocPrecision]\n  */\n  function abundanceRatio(MocLibConfig storage config, uint256 doc0, uint256 doct)\n  public view returns(uint256) {\n    if (doct == 0) {\n      return config.mocPrecision;\n    }\n    // [DOC] [MOC] / [DOC] = [MOC]\n    return doc0.mul(config.mocPrecision).div(doct);\n  }\n\n  /**\n    @dev Returns the Ratio to apply to BPro Price in discount situations: SpotDiscountRate = TPD * (utpdu - cob) / (uptdu -liq)\n    @param bproLiqDiscountRate Discount rate applied at Liquidation level coverage [using mocPrecision]\n    @param liq Liquidation coverage threshold [using mocPrecision]\n    @param utpdu Discount coverage threshold [using mocPrecision]\n    @param cov Actual global Coverage threshold [using mocPrecision]\n    @return Spot discount rate [using mocPrecision]\n  */\n  function bproSpotDiscountRate(\n    MocLibConfig storage libConfig, uint256 bproLiqDiscountRate,\n    uint256 liq, uint256 utpdu, uint256 cov\n  ) public view returns(uint256) {\n    require(bproLiqDiscountRate < libConfig.mocPrecision, \"Discount rate should be lower than 1\");\n\n    if (cov >= utpdu) {\n      return 0;\n    }\n\n    // utpdu - liq\n    // [MOC] - [MOC] = [MOC]\n    uint256 utpduLiqDiff = utpdu.sub(liq);\n\n    // utpdu - cov\n    // [MOC] - [MOC] = [MOC]\n    uint256 utpduCovDiff = utpdu.sub(cov);\n\n    // TPD * utpduCovDiff / utpduLiqDiff\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    return bproLiqDiscountRate.mul(utpduCovDiff).div(utpduLiqDiff);\n  }\n\n  /**\n    @dev Max amount of BPro to available with discount: MaxBProWithDiscount = (uTPDU * nDOC * PEG - (nBTC * B)) / (TPusd * TPD)\n    @param nB Total BTC amount [using reservePrecision]\n    @param nDoc DOC amount [using mocPrecision]\n    @param utpdu Discount coverage threshold [using mocPrecision]\n    @param peg peg value\n    @param btcPrice BTC price [using mocPrecision]\n    @param bproUsdPrice bproUsdPrice [using mocPrecision]\n    @param spotDiscount spot discount [using mocPrecision]\n    @return Total BPro amount [using mocPrecision]\n  */\n  function maxBProWithDiscount(\n    MocLibConfig storage libConfig, uint256 nB, uint256 nDoc, uint256 utpdu,\n    uint256 peg, uint256 btcPrice, uint256 bproUsdPrice, uint256 spotDiscount\n  ) public view returns(uint256)  {\n    require(spotDiscount < libConfig.mocPrecision, \"Discount Rate should be lower than 1\");\n\n    if (spotDiscount == 0) {\n      return 0;\n    }\n\n    // nBTC * B\n    // [RES] * [MOC] / [RES] = [MOC]\n    uint256 nbUsdValue = nB.mul(btcPrice).div(libConfig.reservePrecision);\n\n    // (TPusd * (1 - TPD))\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 bproDiscountPrice = bproUsdPrice.mul(libConfig.mocPrecision.sub(spotDiscount))\n      .div(libConfig.mocPrecision);\n\n    return maxBProWithDiscountAux(libConfig, nbUsdValue, nDoc, utpdu, peg, bproDiscountPrice);\n  }\n\n  /**\n    @dev Max amount of BPro to available with discount: MaxBProWithDiscount = (uTPDU * nDOC * PEG - (nBTC * B)) / (TPusd * TPD)\n    @param nbUsdValue Total amount of BTC in USD [using mocPrecision]\n    @param nDoc DOC amount [using mocPrecision]\n    @param utpdu Discount coverage threshold [using mocPrecision]\n    @param bproDiscountPrice bproUsdPrice with discount applied [using mocPrecision]\n    @param peg peg value\n    @return Total BPro amount [using mocPrecision]\n  */\n  function maxBProWithDiscountAux(\n    MocLibConfig storage libConfig, uint256 nbUsdValue, uint256 nDoc,\n    uint256 utpdu, uint256 peg, uint256 bproDiscountPrice\n  ) internal view returns(uint256) {\n\n    // uTPDU * nDOC * PEG\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 coverageUSDAmount = utpdu.mul(nDoc).mul(peg).div(libConfig.mocPrecision);\n\n    // This case only occurs with Coverage below 1\n    if (coverageUSDAmount <= nbUsdValue) {\n      return 0;\n    }\n\n    // ([MOC] - [MOC]) * [RES] / [MOC] = [RES]\n    return coverageUSDAmount.sub(nbUsdValue).mul(libConfig.reservePrecision).div(bproDiscountPrice);\n  }\n\n  /**\n    @dev Calculates Locked bitcoin\n    @param btcPrice BTC price [using mocPrecision]\n    @param nDoc Docs amount [using mocPrecision]\n    @param peg peg value\n    @return Locked bitcoin [using reservePrecision]\n  */\n  function lockedBitcoin(\n    MocLibConfig storage libConfig, uint256 btcPrice, uint256 nDoc, uint256 peg\n  ) public view returns(uint256) {\n    return nDoc.mul(peg).mul(libConfig.reservePrecision).div(btcPrice);\n  }\n\n  /**\n    @dev Calculates price at liquidation event as a relation between the doc total supply\n    and the amount of RBTC available to distribute\n    @param rbtcAmount RBTC to distribute [using reservePrecision]\n    @param nDoc Docs amount [using mocPrecision]\n    @return Price at liquidation event [using mocPrecision]\n  */\n  function liquidationPrice(MocLibConfig storage libConfig, uint256 rbtcAmount, uint256 nDoc)\n  public view returns(uint256) {\n    // [MOC] * [RES] / [RES]\n    return nDoc.mul(libConfig.reservePrecision).div(rbtcAmount);\n  }\n\n  /**\n    @dev Calculates BPro BTC price: TPbtc = (nB-LB) / nTP\n    @param nB Total BTC amount [using reservePrecision]\n    @param lb Locked bitcoins amount [using reservePrecision]\n    @param nTP BPro amount [using mocPrecision]\n    @return BPro BTC price [using reservePrecision]\n  */\n  function bproTecPrice(MocLibConfig storage libConfig, uint256 nB, uint256 lb, uint256 nTP)\n    public view returns(uint256) {\n    // Liquidation happens before this condition turns true\n    if (nB < lb) {\n      return 0;\n    }\n\n    if (nTP == 0) {\n      return libConfig.mocPrecision;\n    }\n    // ([RES] - [RES]) * [MOC] / [MOC]\n    return nB.sub(lb).mul(libConfig.mocPrecision).div(nTP);\n  }\n\n  /**\n    @dev Calculates BPro BTC price: BProxInBPro = bproxTecPrice / bproPrice\n    @param bproxTecPrice BProx BTC price [using reservePrecision]\n    @param bproPrice Trog BTC price [using reservePrecision]\n    @return BProx price in BPro [using mocPrecision]\n  */\n  function bproxBProPrice(\n    MocLibConfig storage libConfig, uint256 bproxTecPrice, uint256 bproPrice\n  ) public view returns(uint256) {\n    // [RES] * [MOC] / [RES] = [MOC]\n    return bproxTecPrice.mul(libConfig.mocPrecision).div(bproPrice);\n  }\n\n  /**\n    @dev Returns a new value with the discountRate applied: TPbtc = (price)* (1 - discountRate)\n    @param price Price [using SomePrecision]\n    @param discountRate Discount rate to apply [using mocPrecision]\n    @return Price with discount applied [using SomePrecision]\n  */\n  function applyDiscountRate(MocLibConfig storage libConfig, uint256 price, uint256 discountRate)\n    public view returns(uint256) {\n\n    uint256 discountCoeff = libConfig.mocPrecision.sub(discountRate);\n\n    return price.mul(discountCoeff).div(libConfig.mocPrecision);\n  }\n\n  /**\n    @dev Returns the amount of interest to pay: TPbtc = price * interestRate\n    @param value Cost to apply interest [using SomePrecision]\n    @param interestRate Interest rate to apply [using mocPrecision]\n    @return Interest cost based on the value and interestRate [using SomePrecision]\n  */\n  function getInterestCost(MocLibConfig storage libConfig, uint256 value, uint256 interestRate)\n    public view returns(uint256) {\n    // [ORIGIN] * [MOC] / [MOC] = [ORIGIN]\n    return value.mul(interestRate).div(libConfig.mocPrecision);\n  }\n\n  /**\n    @dev Calculates Coverage: Coverage = nB / LB\n    @param nB Total BTC amount [using reservePrecision]\n    @param lB Locked bitcoins amount [using reservePrecision]\n    @return Coverage [using mocPrecision]\n  */\n  function coverage(MocLibConfig storage libConfig, uint256 nB, uint256 lB) public view\n    returns(uint256) {\n    if (lB == 0) {\n      return UINT256_MAX;\n    }\n\n    return nB.mul(libConfig.mocPrecision).div(lB);\n  }\n\n /**\n    @dev Calculates Leverage from Coverage: Leverage = C / (C - 1)\n    @param cov Coverage [using mocPrecision]\n    @return Leverage [using mocPrecision]\n  */\n  function leverageFromCoverage(MocLibConfig storage libConfig, uint256 cov)\n  public view returns(uint256) {\n    if (cov == UINT256_MAX) {\n      return libConfig.mocPrecision;\n    }\n\n    if (cov <= libConfig.mocPrecision) {\n      return UINT256_MAX;\n    }\n\n    return cov.mul(libConfig.mocPrecision).div(cov.sub(libConfig.mocPrecision));\n  }\n\n /**\n    @dev Calculates Leverage: Leverage = nB / (nB - lB)\n    @param nB Total BTC amount [using reservePrecision]\n    @param lB Locked bitcoins amount [using reservePrecision]\n    @return Leverage [using mocPrecision]\n  */\n  function leverage(MocLibConfig storage libConfig, uint256 nB,uint256 lB)\n  public view returns(uint256) {\n    if (lB == 0) {\n      return libConfig.mocPrecision;\n    }\n\n    if (nB <= lB) {\n      return UINT256_MAX;\n    }\n\n    return nB.mul(libConfig.mocPrecision).div(nB.sub(lB));\n  }\n\n  /**\n    @dev Price in BTC of the amount of Docs\n    @param amount Total BTC amount [using reservePrecision]\n    @param btcPrice BTC price [using mocPrecision]\n    @return Total value [using reservePrecision]\n  */\n  function docsBtcValue(\n    MocLibConfig storage libConfig, uint256 amount,uint256 peg, uint256 btcPrice\n  ) public view returns(uint256) {\n    require(btcPrice > 0,\"Bitcoin price should be more than zero\");\n    require(libConfig.reservePrecision > 0, \"Precision should be more than zero\");\n    //Total = amount / satoshi price\n    //Total = amount / (btcPrice / precision)\n    // [RES] * [MOC] / [MOC]\n    uint256 docBtcTotal = amount.mul(libConfig.mocPrecision).mul(peg).div(btcPrice);\n\n    return docBtcTotal;\n  }\n\n /**\n    @dev Price in RBTC of the amount of BPros\n    @param bproAmount amount of BPro [using mocPrecision]\n    @param bproBtcPrice BPro price in RBTC [using reservePrecision]\n    @return Total value [using reservePrecision]\n  */\n  function bproBtcValue(MocLibConfig storage libConfig, uint256 bproAmount, uint256 bproBtcPrice)\n    public view returns(uint256) {\n    require(libConfig.reservePrecision > 0, \"Precision should be more than zero\");\n\n    // [MOC] * [RES] / [MOC] =  [RES]\n    uint256 bproBtcTotal = bproAmount.mul(bproBtcPrice).div(libConfig.mocPrecision);\n\n    return bproBtcTotal;\n  }\n\n  /**\n    @dev Max amount of Docs to issue: MaxDoc = ((nB*B)-(Cobj*B/Bcons*nDoc*PEG))/(PEG*(Cobj*B/BCons-1))\n    @param nB Total BTC amount [using reservePrecision]\n    @param cobj Target Coverage [using mocPrecision]\n    @param nDoc DOC amount [using mocPrecision]\n    @param peg peg value\n    @param btcPrice BTC price [using mocPrecision]\n    @param bCons BTC conservative price [using mocPrecision]\n    @return Total Docs amount [using mocPrecision]\n  */\n  function maxDoc(\n    MocLibConfig storage libConfig, uint256 nB,\n    uint256 cobj, uint256 nDoc, uint256 peg, uint256 btcPrice, uint256 bCons\n  ) public view returns(uint256) {\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\n\n    // If cobj is less than 1, just return zero\n    if (cobj < libConfig.mocPrecision)\n      return 0;\n\n    // Cobj * B / BCons\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 adjCobj = cobj.mul(btcPrice).div(bCons);\n\n    return maxDocAux(libConfig, nB, adjCobj, nDoc, peg, btcPrice);\n  }\n\n  function maxDocAux(MocLibConfig storage libConfig, uint256 nB, uint256 adjCobj, uint256 nDoc, uint256 peg, uint256 btcPrice)\n  internal view returns(uint256) {\n    // (nB*B)\n    // [RES] [MOC] [MOC] / [RES] = [MOC] [MOC]\n    uint256 firstOperand = nB.mul(btcPrice).mul(libConfig.mocPrecision).div(libConfig.reservePrecision);\n    // (adjCobj*nDoc*PEG)\n    // [MOC] [MOC]\n    uint256 secOperand = adjCobj.mul(nDoc).mul(peg);\n    // (PEG*(adjCobj-1)\n    // [MOC]\n    uint256 denom = adjCobj.sub(libConfig.mocPrecision).mul(peg);\n\n    if (firstOperand <= secOperand)\n      return 0;\n\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\n    return (firstOperand.sub(secOperand)).div(denom);\n  }\n\n  /**\n    @dev Max amount of BPro to redeem: MaxBPro = ((nB*B)-(Cobj*nDoc*PEG))/TPusd\n    @param nB Total BTC amount [using reservePrecision]\n    @param cobj Target Coverage [using mocPrecision]\n    @param nDoc Target Coverage [using mocPrecision]\n    @param peg peg value\n    @param btcPrice BTC price [using mocPrecision]\n    @param bCons BTC conservative price [using mocPrecision]\n    @param bproUsdPrice bproUsdPrice [using mocPrecision]\n    @return Total BPro amount [using mocPrecision]\n  */\n  function maxBPro(\n    MocLibConfig storage libConfig, uint256 nB, uint256 cobj,\n    uint256 nDoc, uint256 peg, uint256 btcPrice, uint256 bCons, uint256 bproUsdPrice\n  ) public view returns(uint256) {\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\n\n    // Cobj * btcPrice / BCons\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 adjCobj = cobj.mul(btcPrice).div(bCons);\n    // (nB * btcPrice)\n    // [RES] * [MOC] * [MOC] / [RES] = [MOC] [MOC]\n    uint256 firstOperand = nB.mul(btcPrice)\n      .mul(libConfig.mocPrecision)\n      .div(libConfig.reservePrecision);\n    // (adjCobj * nDoc * PEG)\n    // [MOC] * [MOC]\n    uint256 secOperand = adjCobj.mul(nDoc).mul(peg);\n\n    if (firstOperand <= secOperand)\n      return 0;\n\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\n    return (firstOperand.sub(secOperand)).div(bproUsdPrice);\n  }\n\n  /**\n    @dev Calculates the total BTC price of the amount of BPros\n    @param amount Amount of BPro [using mocPrecision]\n    @param bproPrice BPro BTC Price [using reservePrecision]\n    @return BPro total value in BTC [using reservePrecision]\n  */\n  function totalBProInBtc(\n    MocLibConfig storage libConfig, uint256 amount, uint256 bproPrice\n  ) public view returns(uint256) {\n    // [RES] * [MOC] / [MOC] = [RES]\n    return bproPrice.mul(amount).div(libConfig.mocPrecision);\n  }\n\n  /**\n    @dev Calculates the equivalent in Docs of the btcAmount\n    @param btcAmount BTC  amount [using reservePrecision]\n    @param btcPrice BTC price [using mocPrecision]\n    @return Equivalent Doc amount [using mocPrecision]\n  */\n  function maxDocsWithBtc(\n    MocLibConfig storage libConfig, uint256 btcAmount, uint256 btcPrice\n  ) public view returns(uint256) {\n    // [RES] * [MOC] / [RES] = [MOC]\n    return btcAmount.mul(btcPrice).div(libConfig.reservePrecision);\n  }\n\n  /**\n    @dev Calculates the equivalent in BPro of the btcAmount\n    @param btcAmount BTC amount [using reservePrecision]\n    @param bproPrice BPro BTC price [using reservePrecision]\n    @return Equivalent Bpro amount [using mocPrecision]\n  */\n  function maxBProWithBtc(\n    MocLibConfig storage libConfig, uint256 btcAmount, uint256 bproPrice\n  ) public view returns(uint256) {\n    if (bproPrice == 0) {\n      return 0;\n    }\n\n    // [RES] * [MOC] / [RES]\n    return btcAmount.mul(libConfig.mocPrecision).div(bproPrice);\n  }\n\n  /**\n    @dev Calculates the Btc amount to move from C0 bucket to: toMove = btcAmount * (lev - 1)\n    an L bucket when a BProx minting occurs\n    @param btcAmount Total BTC amount [using reservePrecision]\n    @param lev L bucket leverage [using mocPrecision]\n    @return btc to move [using reservePrecision]\n  */\n  function bucketTransferAmount(\n    MocLibConfig storage libConfig, uint256 btcAmount, uint256 lev\n  ) public view returns(uint256) {\n    require(lev > libConfig.mocPrecision, \"Leverage should be more than 1\");\n\n    if (lev == UINT256_MAX || btcAmount == 0) {\n      return 0;\n    }\n\n    // (lev-1)\n    uint256 levSubOne = lev.sub(libConfig.mocPrecision);\n\n    // Intentionally avaoid SafeMath\n    // [RES] * [MOC]\n    uint256 transferAmount = btcAmount * levSubOne;\n    if (transferAmount / btcAmount != levSubOne)\n      return 0;\n\n    // [RES] * [MOC] / [MOC] = [RES]\n    return transferAmount.div(libConfig.mocPrecision);\n  }\n\n  /**\n    @dev Max amount of BTC allowed to be used to mint bprox: Maxbprox = nDOC/ (PEG*B*(lev-1))\n    @param nDoc number of DOC [using mocPrecision]\n    @param peg peg value\n    @param btcPrice BTC price [using mocPrecision]\n    @param lev leverage [using mocPrecision]\n    @return Max bprox BTC value [using reservePrecision]\n  */\n  function maxBProxBtcValue(\n    MocLibConfig storage libConfig, uint256 nDoc, uint256 peg, uint256 btcPrice, uint256 lev\n  ) public view returns(uint256)  {\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\n\n    if (lev <= libConfig.mocPrecision) {\n      return 0;\n    }\n    // (lev-1)\n    // [MOC]\n    uint256 levSubOne = lev.sub(libConfig.mocPrecision);\n\n    // PEG * BtcPrice\n    // [MOC]\n    uint256 pegTimesPrice = peg.mul(btcPrice);\n\n    // This intentionally avoid using safeMath to handle overflow case\n    // PEG * BtcPrice * (lev - 1)\n    // [MOC] * [MOC]\n    uint256 dividend = pegTimesPrice * levSubOne;\n\n    if (dividend / pegTimesPrice != levSubOne)\n      return 0; // INFINIT dividend means 0\n\n    // nDoc adjusted with precisions\n    // [MOC] [RES]\n    uint256 divider = nDoc.mul(libConfig.reservePrecision);\n\n    // [MOC] [RES] [MOC] / [MOC] [MOC]\n    return divider.mul(libConfig.mocPrecision).div(dividend);\n  }\n\n  /**\n    @dev Calculates the equivalent in MoC of the btcAmount\n    @param btcAmount BTC  amount\n    @param btcPrice BTC price\n    @param mocPrice MoC price\n    @return Equivalent MoC amount\n  */\n  function maxMoCWithBtc(\n    MocLibConfig storage /*libConfig*/, uint256 btcAmount, uint256 btcPrice, uint256 mocPrice\n  ) public pure returns(uint256) {\n    return btcPrice.mul(btcAmount).div(mocPrice);\n  }\n\n  /**\n    @dev Calculates the equivalent in BTC of the MoC amount\n    @param amount BTC  amount\n    @param btcPrice BTC price\n    @param mocPrice MoC price\n    @return Equivalent MoC amount\n  */\n  function mocBtcValue(\n    MocLibConfig storage /*libConfig*/, uint256 amount, uint256 btcPrice, uint256 mocPrice\n  ) public pure returns(uint256) {\n    require(btcPrice > 0,\"Bitcoin price should be more than zero\");\n    require(mocPrice > 0,\"MoC price should be more than zero\");\n\n    uint256 mocBtcTotal = amount.mul(mocPrice).div(btcPrice);\n\n    return mocBtcTotal;\n  }\n\n  /**\n    @dev Transform an address to payable address\n    @param account Address to transform to payable\n    @return Payable address for account\n  */\n  function getPayableAddress(\n    MocLibConfig storage /*libConfig*/, address account\n  ) public pure\n  returns (address payable) {\n    return address(uint160(account));\n  }\n\n  /**\n    @dev Rounding product adapted from DSMath but with custom precision\n    @param x Multiplicand\n    @param y Multiplier\n    @return Product\n  */\n  function mulr(uint x, uint y, uint256 precision) internal pure returns (uint z) {\n    return x.mul(y).add(precision.div(2)).div(precision);\n  }\n\n  /**\n    @dev Potentiation by squaring adapted from DSMath but with custom precision\n    @param x Base\n    @param n Exponent\n    @return power\n  */\n  function pow(uint256 x, uint256 n, uint256 precision) internal pure returns (uint z) {\n    uint256 x2 = x;\n    z = n % 2 != 0 ? x : precision;\n\n    for (n /= 2; n != 0; n /= 2) {\n      x2 = mulr(x2, x2, precision);\n\n      if (n % 2 != 0) {\n        z = mulr(z, x2, precision);\n      }\n    }\n  }\n}\n\n// File: contracts/MoCLibConnection.sol\n\npragma solidity 0.5.8;\n\n\n/**\n  @dev Interface with MocHelperLib\n */\ncontract MoCLibConnection {\n  using MoCHelperLib for MoCHelperLib.MocLibConfig;\n  MoCHelperLib.MocLibConfig internal mocLibConfig;\n\n  /*\n  * Precision getters\n  */\n  function getMocPrecision() public view returns(uint256) {\n    return mocLibConfig.mocPrecision;\n  }\n\n  function getReservePrecision() public view returns(uint256) {\n    return mocLibConfig.reservePrecision;\n  }\n\n  function getDayPrecision() public view returns(uint256) {\n    return mocLibConfig.dayPrecision;\n  }\n\n  function initializePrecisions() internal {\n    mocLibConfig = MoCHelperLib.MocLibConfig({\n      reservePrecision: 10 ** 18,\n      mocPrecision: 10 ** 18,\n      dayPrecision: 1\n    });\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: zos-lib/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.6.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: contracts/base/MoCWhitelist.sol\n\npragma solidity 0.5.8;\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCWhitelist {\n  mapping(address => bool) whitelist;\n\n  /**\n   * @dev Check if an account is whitelisted\n   * @return Bool\n   */\n  function isWhitelisted(address account)\n    public\n    view\n    returns (bool)\n  {\n    require(account != address(0), \"Account must not be 0x0\");\n    return whitelist[account];\n  }\n\n  /**\n   * @dev Add account to whitelist\n   */\n  function add(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(!isWhitelisted(account), \"Account not allowed to add accounts into white list\");\n    whitelist[account] = true;\n  }\n\n  /**\n   * @dev Remove account from whitelist\n   */\n  function remove(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(isWhitelisted(account), \"Account is not allowed to remove address from the white list\");\n\n    whitelist[account] = false;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/base/MoCConnector.sol\n\npragma solidity 0.5.8;\n\n\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCConnector is MoCWhitelist, Initializable {\n  // References\n  address payable public moc;\n  address public docToken;\n  address public bproToken;\n  address public bproxManager;\n  address public mocState;\n  address public mocConverter;\n  address public mocSettlement;\n  address public mocExchange;\n  address public mocInrate;\n  /** DEPRECATED mocBurnout **/\n  address public mocBurnout;\n\n  bool internal initialized;\n\n  /**\n    @dev Initializes the contract\n    @param mocAddress MoC contract address\n    @param docAddress DoCToken contract address\n    @param bproAddress BProToken contract address\n    @param bproxAddress BProxManager contract address\n    @param stateAddress MoCState contract address\n    @param settlementAddress MoCSettlement contract address\n    @param converterAddress MoCConverter contract address\n    @param exchangeAddress MoCExchange contract address\n    @param inrateAddress MoCInrate contract address\n    @param burnoutBookAddress (DEPRECATED) MoCBurnout contract address. DO NOT USE.\n  */\n  function initialize(\n    address payable mocAddress,\n    address docAddress,\n    address bproAddress,\n    address bproxAddress,\n    address stateAddress,\n    address settlementAddress,\n    address converterAddress,\n    address exchangeAddress,\n    address inrateAddress,\n    address burnoutBookAddress\n  ) public initializer {\n    moc = mocAddress;\n    docToken = docAddress;\n    bproToken = bproAddress;\n    bproxManager = bproxAddress;\n    mocState = stateAddress;\n    mocSettlement = settlementAddress;\n    mocConverter = converterAddress;\n    mocExchange = exchangeAddress;\n    mocInrate = inrateAddress;\n    mocBurnout = burnoutBookAddress;\n\n    // Add to Whitelist\n    add(mocAddress);\n    add(docAddress);\n    add(bproAddress);\n    add(bproxAddress);\n    add(stateAddress);\n    add(settlementAddress);\n    add(converterAddress);\n    add(exchangeAddress);\n    add(inrateAddress);\n    add(burnoutBookAddress);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/base/MoCConstants.sol\n\npragma solidity 0.5.8;\n\n/**\n * @dev Defines special constants to use along all the MoC System\n */\ncontract MoCConstants {\n  bytes32 constant public BUCKET_X2 = \"X2\";\n  bytes32 constant public BUCKET_C0 = \"C0\";\n}\n\n// File: contracts/base/MoCBase.sol\n\npragma solidity 0.5.8;\n\n\n\n\n/**\n  @dev General usefull modifiers and functions\n */\ncontract MoCBase is MoCConstants, Initializable {\n  // Contracts\n  MoCConnector public connector;\n\n  bool internal initialized;\n\n  function initializeBase(address connectorAddress) internal initializer {\n    connector = MoCConnector(connectorAddress);\n  }\n\n  modifier onlyWhitelisted(address account) {\n    require(connector.isWhitelisted(account), \"Address is not whitelisted\");\n    _;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/MoCConverter.sol\n\npragma solidity 0.5.8;\n\n\n\n\ncontract MoCConverter is MoCBase, MoCLibConnection {\n  IMoCState internal mocState;\n\n  function initialize(address connectorAddress) public initializer {\n    initializePrecisions();\n    initializeBase(connectorAddress);\n    mocState = IMoCState(connector.mocState());\n  }\n\n  /**\n  * @dev BTC equivalent for the amount of bpros given\n  * @param amount Amount of BPro to calculate the total price\n  * @return total BTC Price of the amount BPros [using reservePrecision]\n  */\n  function bproToBtc(uint256 amount) public view returns(uint256) {\n    uint256 tecPrice = mocState.bproTecPrice();\n\n    return mocLibConfig.totalBProInBtc(amount, tecPrice);\n  }\n\n  /**\n  * @dev Converts BTC to BPro\n  * @param btcAmount BTC amount\n  * @return BPro amount\n  */\n  function btcToBPro(uint256 btcAmount) public view returns(uint256) {\n    return mocLibConfig.maxBProWithBtc(btcAmount, mocState.bproTecPrice());\n  }\n\n  /**\n  * @dev BTC equivalent for the amount of bpro given applying the spotDiscountRate\n  * @param amount amount of BPro [using mocPrecision]\n  * @return BTC amount\n  */\n  function bproDiscToBtc(uint256 amount) public view returns(uint256) {\n    uint256 discountRate = mocState.bproSpotDiscountRate();\n    uint256 totalBtcValue = bproToBtc(amount);\n\n    return mocLibConfig.applyDiscountRate(totalBtcValue, discountRate);\n  }\n\n  function btcToBProDisc(uint256 btcAmount) public view returns(uint256) {\n    return mocLibConfig.maxBProWithBtc(btcAmount, mocState.bproDiscountPrice());\n  }\n\n  function docsToBtc(uint256 docAmount) public view returns(uint256) {\n    return mocLibConfig.docsBtcValue(docAmount, mocState.peg(), mocState.getBitcoinPrice());\n  }\n\n  function docsToBtcWithPrice(uint256 docAmount, uint256 btcPrice) public view returns(uint256) {\n    return mocLibConfig.docsBtcValue(docAmount, mocState.peg(), btcPrice);\n  }\n\n  function btcToDoc(uint256 btcAmount) public view returns(uint256) {\n    return mocLibConfig.maxDocsWithBtc(btcAmount, mocState.getBitcoinPrice());\n  }\n\n  function bproxToBtc(uint256 bproxAmount, bytes32 bucket) public view returns(uint256) {\n    return mocLibConfig.bproBtcValue(bproxAmount, mocState.bucketBProTecPrice(bucket));\n  }\n\n  function bproxToBtcHelper(uint256 bproxAmount, bytes32 bucket) public view returns(uint256) {\n    return mocLibConfig.bproBtcValue(bproxAmount, mocState.bucketBProTecPriceHelper(bucket));\n  }\n\n  function btcToBProx(uint256 btcAmount, bytes32 bucket) public view returns(uint256) {\n    return mocLibConfig.maxBProWithBtc(btcAmount, mocState.bucketBProTecPrice(bucket));\n  }\n\n  function btcToBProWithPrice(uint256 btcAmount, uint256 price) public view returns(uint256) {\n    return mocLibConfig.maxBProWithBtc(btcAmount, price);\n  }\n\n  function bproToBtcWithPrice(uint256 bproAmount, uint256 bproPrice) public view returns(uint256) {\n    return mocLibConfig.bproBtcValue(bproAmount, bproPrice);\n  }\n\n  function mocToBtc(uint256 mocAmount) public view returns(uint256) {\n    return mocLibConfig.mocBtcValue(mocAmount, mocState.getBitcoinPrice(), mocState.getMoCPrice());\n  }\n\n  function btcToMoC(uint256 btcAmount) public view returns(uint256) {\n    return mocLibConfig.maxMoCWithBtc(btcAmount, mocState.getBitcoinPrice(), mocState.getMoCPrice());\n  }\n\n  function mocToBtcWithPrice(uint256 mocAmount, uint256 btcPrice, uint256 mocPrice) public view returns(uint256) {\n    return mocLibConfig.mocBtcValue(mocAmount, btcPrice, mocPrice);\n  }\n\n  function btcToMoCWithPrice(uint256 btcAmount, uint256 btcPrice, uint256 mocPrice) public view returns(uint256) {\n    return mocLibConfig.maxMoCWithBtc(btcAmount, btcPrice, mocPrice);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n",
            "file": "MoCConverter-flat.sol"
        }
    ],
    "libraries": {
        "MoCHelperLib": "0xEaCcD35dFf10A0B917cDbe80B8d7237A05F9579d"
    },
    "creationData": {
        "blockHash": "0x83573534116074bbc141b9761be0e088c09c8bcc5793928d7df90b852154d89c",
        "blockNumber": 1769796,
        "transactionHash": "0xed39b5f1d1e3e8250fde6001705432571979e5a675a427242c3a013972925ba5",
        "timestamp": 1618598768
    }
}