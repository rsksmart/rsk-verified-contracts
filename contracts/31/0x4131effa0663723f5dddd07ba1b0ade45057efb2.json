{
  "address": "0x4131effa0663723f5dddd07ba1b0ade45057efb2",
  "net": {
    "id": "31",
    "name": "RSK Testnet"
  },
  "name": "Utils",
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    }
  },
  "version": "0.5.17+commit.d19bba13",
  "source": "\n// File: contracts/zeppelin/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: contracts/Utils.sol\n\npragma solidity ^0.5.0;\n\n\ncontract Utils {\n    using SafeMath for uint256;\n\n    function getTokenInfo(address tokenToUse) external view returns (uint8 decimals, uint256 granularity, string memory symbol) {\n        decimals = getDecimals(tokenToUse);\n        granularity = getGranularity(tokenToUse);\n        symbol = getSymbol(tokenToUse);\n    }\n\n    function getSymbol(address tokenToUse) public view returns (string memory symbol) {\n        //support 32 bytes or string symbol\n        (bool success, bytes memory data) = tokenToUse.staticcall(abi.encodeWithSignature(\"symbol()\"));\n        require(success, \"Utils: Token hasn't symbol()\");\n        if (data.length == 32) {\n            symbol = bytes32ToString(abi.decode(data, (bytes32)));\n        } else {\n            symbol = abi.decode(data, (string));\n        }\n        require(bytes(symbol).length > 0, \"Utils: Token empty symbol\");\n        return symbol;\n    }\n\n    function getDecimals(address tokenToUse) public view returns (uint8) {\n        //support decimals as uint256 or uint8\n        (bool success, bytes memory data) = tokenToUse.staticcall(abi.encodeWithSignature(\"decimals()\"));\n        require(success, \"Utils: No decimals\");\n        require(data.length == 32, \"Utils: Decimals not uint<M>\");\n        // uint<M>: enc(X) is the big-endian encoding of X,\n        //padded on the higher-order (left) side with zero-bytes such that the length is 32 bytes.\n        uint256 decimalsDecoded = abi.decode(data, (uint256));\n        require(decimalsDecoded <= 18, \"Utils: Decimals not in 0 to 18\");\n        return uint8(decimalsDecoded);\n    }\n\n    function getGranularity(address tokenToUse) public view returns (uint256 granularity) {\n        //support granularity if ERC777\n        (bool success, bytes memory data) = tokenToUse.staticcall(abi.encodeWithSignature(\"granularity()\"));\n        granularity = 1;\n        if(success) {\n            granularity = abi.decode(data, (uint256));\n            //Verify granularity is power of 10 to keep it compatible with ERC20 decimals\n            granularityToDecimals(granularity);\n        }\n        return granularity;\n    }\n\n    /* bytes32 (fixed-size array) to string (dynamically-sized array) */\n    function bytes32ToString(bytes32 _bytes32) internal pure returns (string memory) {\n        uint8 i = 0;\n        while(i < 32 && _bytes32[i] != 0) {\n            i++;\n        }\n        bytes memory bytesArray = new bytes(i);\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\n            bytesArray[i] = _bytes32[i];\n        }\n        return string(bytesArray);\n    }\n\n    function decimalsToGranularity(uint8 decimals) public pure returns (uint256) {\n        require(decimals <= 18, \"Utils: Decimals not in 0 to 18\");\n        return uint256(10)**(18-decimals);\n    }\n\n    function granularityToDecimals(uint256 granularity) public pure returns (uint8) {\n        if(granularity == 1) return 18;\n        if(granularity == 10) return 17;\n        if(granularity == 100) return 16;\n        if(granularity == 1000) return 15;\n        if(granularity == 10000) return 14;\n        if(granularity == 100000) return 13;\n        if(granularity == 1000000) return 12;\n        if(granularity == 10000000) return 11;\n        if(granularity == 100000000) return 10;\n        if(granularity == 1000000000) return 9;\n        if(granularity == 10000000000) return 8;\n        if(granularity == 100000000000) return 7;\n        if(granularity == 1000000000000) return 6;\n        if(granularity == 10000000000000) return 5;\n        if(granularity == 100000000000000) return 4;\n        if(granularity == 1000000000000000) return 3;\n        if(granularity == 10000000000000000) return 2;\n        if(granularity == 100000000000000000) return 1;\n        if(granularity == 1000000000000000000) return 0;\n        require(false, \"Utils: invalid granularity\");\n    }\n\n    function calculateGranularityAndAmount(uint8 decimals, uint256 granularity, uint256 amount) external pure\n        returns(uint256 calculatedGranularity, uint256 formattedAmount) {\n\n        if(decimals == 18) {\n            //tokenAddress is a ERC20 with 18 decimals should have 1 granularity\n            //tokenAddress is a ERC777 token we give the same granularity\n            calculatedGranularity = granularity;\n            formattedAmount = amount;\n        } else {\n            //tokenAddress is a ERC20 with other than 18 decimals\n            calculatedGranularity = decimalsToGranularity(decimals);\n            formattedAmount = amount.mul(calculatedGranularity);\n        }\n    }\n\n    function calculateDecimalsAndAmount(address tokenAddress, uint256 granularity, uint256 amount)\n        external view returns (uint8 calculatedDecimals, uint256 formattedAmount) {\n        uint8 tokenDecimals = getDecimals(tokenAddress);\n        //As side tokens are ERC777 we need to convert granularity to decimals\n        calculatedDecimals = granularityToDecimals(granularity);\n        require(tokenDecimals == calculatedDecimals, \"Utils: Token decimals differ from decimals obtained from granularity\");\n        formattedAmount = amount.div(granularity);\n    }\n\n}\n",
  "imports": [
    {
      "name": "utils-flattened.sol",
      "contents": "\n// File: contracts/zeppelin/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: contracts/Utils.sol\n\npragma solidity ^0.5.0;\n\n\ncontract Utils {\n    using SafeMath for uint256;\n\n    function getTokenInfo(address tokenToUse) external view returns (uint8 decimals, uint256 granularity, string memory symbol) {\n        decimals = getDecimals(tokenToUse);\n        granularity = getGranularity(tokenToUse);\n        symbol = getSymbol(tokenToUse);\n    }\n\n    function getSymbol(address tokenToUse) public view returns (string memory symbol) {\n        //support 32 bytes or string symbol\n        (bool success, bytes memory data) = tokenToUse.staticcall(abi.encodeWithSignature(\"symbol()\"));\n        require(success, \"Utils: Token hasn't symbol()\");\n        if (data.length == 32) {\n            symbol = bytes32ToString(abi.decode(data, (bytes32)));\n        } else {\n            symbol = abi.decode(data, (string));\n        }\n        require(bytes(symbol).length > 0, \"Utils: Token empty symbol\");\n        return symbol;\n    }\n\n    function getDecimals(address tokenToUse) public view returns (uint8) {\n        //support decimals as uint256 or uint8\n        (bool success, bytes memory data) = tokenToUse.staticcall(abi.encodeWithSignature(\"decimals()\"));\n        require(success, \"Utils: No decimals\");\n        require(data.length == 32, \"Utils: Decimals not uint<M>\");\n        // uint<M>: enc(X) is the big-endian encoding of X,\n        //padded on the higher-order (left) side with zero-bytes such that the length is 32 bytes.\n        uint256 decimalsDecoded = abi.decode(data, (uint256));\n        require(decimalsDecoded <= 18, \"Utils: Decimals not in 0 to 18\");\n        return uint8(decimalsDecoded);\n    }\n\n    function getGranularity(address tokenToUse) public view returns (uint256 granularity) {\n        //support granularity if ERC777\n        (bool success, bytes memory data) = tokenToUse.staticcall(abi.encodeWithSignature(\"granularity()\"));\n        granularity = 1;\n        if(success) {\n            granularity = abi.decode(data, (uint256));\n            //Verify granularity is power of 10 to keep it compatible with ERC20 decimals\n            granularityToDecimals(granularity);\n        }\n        return granularity;\n    }\n\n    /* bytes32 (fixed-size array) to string (dynamically-sized array) */\n    function bytes32ToString(bytes32 _bytes32) internal pure returns (string memory) {\n        uint8 i = 0;\n        while(i < 32 && _bytes32[i] != 0) {\n            i++;\n        }\n        bytes memory bytesArray = new bytes(i);\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\n            bytesArray[i] = _bytes32[i];\n        }\n        return string(bytesArray);\n    }\n\n    function decimalsToGranularity(uint8 decimals) public pure returns (uint256) {\n        require(decimals <= 18, \"Utils: Decimals not in 0 to 18\");\n        return uint256(10)**(18-decimals);\n    }\n\n    function granularityToDecimals(uint256 granularity) public pure returns (uint8) {\n        if(granularity == 1) return 18;\n        if(granularity == 10) return 17;\n        if(granularity == 100) return 16;\n        if(granularity == 1000) return 15;\n        if(granularity == 10000) return 14;\n        if(granularity == 100000) return 13;\n        if(granularity == 1000000) return 12;\n        if(granularity == 10000000) return 11;\n        if(granularity == 100000000) return 10;\n        if(granularity == 1000000000) return 9;\n        if(granularity == 10000000000) return 8;\n        if(granularity == 100000000000) return 7;\n        if(granularity == 1000000000000) return 6;\n        if(granularity == 10000000000000) return 5;\n        if(granularity == 100000000000000) return 4;\n        if(granularity == 1000000000000000) return 3;\n        if(granularity == 10000000000000000) return 2;\n        if(granularity == 100000000000000000) return 1;\n        if(granularity == 1000000000000000000) return 0;\n        require(false, \"Utils: invalid granularity\");\n    }\n\n    function calculateGranularityAndAmount(uint8 decimals, uint256 granularity, uint256 amount) external pure\n        returns(uint256 calculatedGranularity, uint256 formattedAmount) {\n\n        if(decimals == 18) {\n            //tokenAddress is a ERC20 with 18 decimals should have 1 granularity\n            //tokenAddress is a ERC777 token we give the same granularity\n            calculatedGranularity = granularity;\n            formattedAmount = amount;\n        } else {\n            //tokenAddress is a ERC20 with other than 18 decimals\n            calculatedGranularity = decimalsToGranularity(decimals);\n            formattedAmount = amount.mul(calculatedGranularity);\n        }\n    }\n\n    function calculateDecimalsAndAmount(address tokenAddress, uint256 granularity, uint256 amount)\n        external view returns (uint8 calculatedDecimals, uint256 formattedAmount) {\n        uint8 tokenDecimals = getDecimals(tokenAddress);\n        //As side tokens are ERC777 we need to convert granularity to decimals\n        calculatedDecimals = granularityToDecimals(granularity);\n        require(tokenDecimals == calculatedDecimals, \"Utils: Token decimals differ from decimals obtained from granularity\");\n        formattedAmount = amount.div(granularity);\n    }\n\n}\n",
      "file": "utils-flattened.sol"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x5c63353299c8c7077b4aac9ac820b75c94ac00637f837529c21276bf34a4347d",
    "blockNumber": 956296,
    "transactionHash": "0x34c1a70205269cc1335e7080dcc90629a4d4dd7b4d013e6e43f63d4860be06bc",
    "timestamp": 1592922336
  }
}