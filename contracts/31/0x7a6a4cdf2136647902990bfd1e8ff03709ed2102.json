{
  "address": "0x7a6a4cdf2136647902990bfd1e8ff03709ed2102",
  "net": {
    "id": "31",
    "name": "RSK Testnet"
  },
  "name": "Saarthi",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    }
  },
  "version": "0.7.0+commit.9e61f92b",
  "source": "/*\r\n   _____                  __  __    _ \r\n  / ___/____ _____ ______/ /_/ /_  (_)\r\n  \\__ \\/ __ `/ __ `/ ___/ __/ __ \\/ / \r\n ___/ / /_/ / /_/ / /  / /_/ / / / /  \r\n/____/\\__,_/\\__,_/_/   \\__/_/ /_/_/   \r\n                                                                            \r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity >=0.7.0 <0.8.0;\r\n// pragma experimental ABIEncoderV2;\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0; \r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Saarthi {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    struct Task {\r\n        uint256 taskID;\r\n        uint256 currentRound;\r\n        uint256 totalRounds;\r\n        uint256 cost;\r\n        string[] modelHashes;\r\n    }\r\n    \r\n    address owner;\r\n    address coordinatorAddress = address(0xBeb71662FF9c08aFeF3866f85A6591D4aeBE6e4E);\r\n\r\n    uint256 nextTaskID = 1;\r\n    mapping (uint256 => Task) public SaarthiTasks;\r\n    mapping (address => uint256[]) public UserTaskIDs;\r\n\r\n    event newTaskCreated(uint256 indexed taskID, address indexed _user, string _modelHash, uint256 _amt, uint256 _time);\r\n    event modelUpdated(uint256 indexed taskID, string _modelHash, uint256 _time);\r\n    \r\n    event donatationToFund(uint256 indexed fund_id, address indexed sender, address indexed receiver, uint256 amount);\r\n    event donatationToCampaign(address indexed sender, address indexed receiver, uint256 amount);\r\n    \r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    function updateOwner(address _newOwner) public {\r\n        require(msg.sender == owner, \"Only Owner\");\r\n        owner = _newOwner;\r\n    }\r\n\r\n    function createTask(string memory _modelHash, uint256 _rounds) public payable {\r\n        require(_rounds < 10, \"Number of Rounds should be less than 10\");\r\n        uint256 taskCost = msg.value;\r\n\r\n        Task memory newTask;\r\n        newTask = Task({\r\n            taskID: nextTaskID,\r\n            currentRound: 1,\r\n            totalRounds: _rounds,\r\n            cost: taskCost,\r\n            modelHashes: new string[](_rounds)\r\n        });\r\n        newTask.modelHashes[0] = _modelHash;\r\n        SaarthiTasks[nextTaskID] = newTask;\r\n        UserTaskIDs[msg.sender].push(nextTaskID);\r\n        emit newTaskCreated(nextTaskID, msg.sender, _modelHash, taskCost, block.timestamp);\r\n\r\n        nextTaskID = nextTaskID.add(1);\r\n    }\r\n\r\n    function updateModelForTask(uint256 _taskID,  string memory _modelHash, address payable computer) public {\r\n        require(msg.sender == coordinatorAddress, \"You are not the coordinator !\");\r\n        require(_taskID <= nextTaskID, \"Invalid Task ID\");\r\n        uint256 newRound = SaarthiTasks[_taskID].currentRound.add(1);\r\n        require(newRound <= SaarthiTasks[_taskID].totalRounds, \"All Rounds Completed\");\r\n        \r\n\r\n        SaarthiTasks[_taskID].currentRound = newRound;\r\n        SaarthiTasks[_taskID].modelHashes[newRound.sub(1)] = _modelHash;\r\n        computer.transfer(SaarthiTasks[_taskID].cost.div(SaarthiTasks[_taskID].totalRounds));\r\n        emit modelUpdated(_taskID, _modelHash, block.timestamp);\r\n\r\n    }\r\n\r\n    // function getTaskHashes(uint256 _taskID) public view returns (string[] memory) {\r\n    //     return (SaarthiTasks[_taskID].modelHashes);\r\n    // }\r\n\r\n    function getTaskCount() public view returns (uint256) {\r\n        return nextTaskID.sub(1);\r\n    }\r\n    function getTasksOfUser() public view returns (uint256[] memory) {\r\n        return UserTaskIDs[msg.sender];\r\n    }\r\n    \r\n    struct Fund {\r\n        uint256 orgID;\r\n        string orgName;\r\n        string fundName;\r\n        address payable fundAddress;\r\n        uint256 donationAmount;\r\n        uint256 donationCnt;\r\n    }\r\n    \r\n    uint256 public fundCnt = 0;\r\n    uint256 public totalDonationAmount = 0;\r\n    uint256 public totalDonationCnt = 0;\r\n    mapping (uint256 => Fund) public Funds;\r\n    \r\n    function createFund(string memory _orgName,string memory _fundName, address payable _orgAdress) public {\r\n        Fund memory newfund;\r\n        newfund = Fund({\r\n            orgID: fundCnt,\r\n            orgName: _orgName,\r\n            fundName: _fundName,\r\n            fundAddress: _orgAdress,\r\n            donationAmount:0,\r\n            donationCnt:0\r\n        });\r\n        \r\n        Funds[fundCnt] = newfund;\r\n        fundCnt = fundCnt.add(1);\r\n    }\r\n    \r\n    function donateToFund(uint256 _fundID) public payable{\r\n        require(_fundID <= fundCnt, \"Invalid Fund ID\");\r\n        \r\n        Funds[_fundID].donationAmount = Funds[_fundID].donationAmount.add(msg.value);\r\n        Funds[_fundID].donationCnt = Funds[_fundID].donationCnt.add(1);\r\n        \r\n        totalDonationAmount = totalDonationAmount.add(msg.value);\r\n        totalDonationCnt = totalDonationCnt.add(1);\r\n        \r\n        Funds[_fundID].fundAddress.transfer(msg.value);\r\n        emit donatationToFund(_fundID, msg.sender, Funds[_fundID].fundAddress, msg.value);\r\n    }\r\n    \r\n    struct User {\r\n        address payable userAddress;\r\n        address[] accessors;\r\n        uint256 recordHistoryCnt;\r\n        string[] recordHistory;\r\n        uint256 billAmount;\r\n        uint256 donationCnt;\r\n        address[] donationAddresses;\r\n        uint256[] donationAmounts;\r\n        bool hasCampaign;\r\n        string campaignData;\r\n        bool hasAllowedResearch;\r\n    }\r\n    \r\n    mapping (address => User) public Users;\r\n    uint256 public UserCnt = 0;\r\n    \r\n    function addUser() public {\r\n        // already hash a history\r\n        require(Users[msg.sender].userAddress == address(0x0), \"User Already Registered\");\r\n        \r\n        string[] memory newRecordHistory;\r\n        address[] memory newAccessors;\r\n        address[] memory newDonationAddresses;\r\n        uint256[] memory newDonationAmounts;\r\n        string memory newCampaignData;\r\n        \r\n        User memory userTemp = User({\r\n            userAddress: msg.sender,\r\n            accessors: newAccessors,\r\n            recordHistoryCnt: 0,\r\n            recordHistory: newRecordHistory,\r\n            billAmount: 0,\r\n            donationCnt: 0,\r\n            donationAddresses: newDonationAddresses,\r\n            donationAmounts: newDonationAmounts,\r\n            hasCampaign: false,\r\n            campaignData: newCampaignData,\r\n            hasAllowedResearch: false\r\n        });\r\n        \r\n        Users[msg.sender] = userTemp;\r\n        UserCnt = UserCnt.add(1);\r\n        \r\n    }\r\n    \r\n    function addRecord(string memory _recordHash) public {\r\n        // already hash a history\r\n        if(Users[msg.sender].userAddress == address(0x0)){\r\n            addUser();\r\n        }\r\n        \r\n        Users[msg.sender].recordHistoryCnt = Users[msg.sender].recordHistoryCnt.add(1);\r\n        Users[msg.sender].recordHistory.push(_recordHash);\r\n    }\r\n    \r\n    function getRecord(address _user, uint _index) public view returns (string memory records){\r\n        if (Users[_user].userAddress == address(0x0)){\r\n            string memory newRecordHistory;\r\n            return newRecordHistory;\r\n        }\r\n        \r\n        bool allowed = false;\r\n        for(uint256 ind=0; ind<Users[_user].accessors.length; ind = ind.add(1)){\r\n            if (Users[_user].accessors[ind] == msg.sender){\r\n                allowed = true;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        require( (Users[_user].userAddress == msg.sender) || allowed == true, \"Cannot Access Records\");\r\n        \r\n        return Users[_user].recordHistory[_index];\r\n        \r\n    }\r\n    \r\n    function getDonationAmounts(address _user) public view returns (uint256[] memory donationAmounts){\r\n        require(Users[_user].userAddress != address(0x0), \"Invalid User\");\r\n        return Users[_user].donationAmounts;\r\n    }\r\n    \r\n    function getDonationAddresses(address _user) public view returns (address[] memory donationAddresses){\r\n        require(Users[_user].userAddress != address(0x0), \"Invalid User\");\r\n        return Users[_user].donationAddresses;\r\n    }\r\n    \r\n    function allowAccessToUser(address _address) public {\r\n        require(Users[msg.sender].userAddress != address(0x0), \"Invalid User\");\r\n        Users[msg.sender].accessors.push(_address);\r\n    }\r\n    function allowAccessToResearch() public {\r\n        require(Users[msg.sender].userAddress != address(0x0), \"Invalid User\");\r\n        Users[msg.sender].hasAllowedResearch = true;\r\n    }\r\n    function revokeAccessToResearch() public {\r\n        require(Users[msg.sender].userAddress != address(0x0), \"Invalid User\");\r\n        Users[msg.sender].hasAllowedResearch = false;\r\n    }\r\n    \r\n    function getAccessors() public view returns(address[] memory){\r\n        require(Users[msg.sender].userAddress != address(0x0), \"Invalid User\");\r\n        \r\n        return Users[msg.sender].accessors;\r\n    }\r\n    \r\n    function donateToUser(address _user) public payable{\r\n        require(Users[_user].userAddress != address(0x0), \"Invalid User\");\r\n        \r\n        uint256 donationAmount = msg.value;\r\n        \r\n        Users[_user].donationCnt = Users[_user].donationCnt.add(1);\r\n        Users[msg.sender].donationAddresses.push(msg.sender);\r\n        Users[msg.sender].donationAmounts.push(donationAmount);\r\n        \r\n        Users[msg.sender].userAddress.transfer(donationAmount);\r\n        emit donatationToCampaign(msg.sender, Users[msg.sender].userAddress, donationAmount);\r\n    }\r\n    \r\n    function billUser(uint256 _amt) public {\r\n        require(Users[msg.sender].userAddress != address(0x0), \"Invalid User\");\r\n\r\n        Users[msg.sender].billAmount = Users[msg.sender].billAmount.add(_amt);\r\n    }\r\n    \r\n    address[] public Campaigns;\r\n    mapping (address => uint256) internal CampaignsToIndex;\r\n    uint256 public campaignCnt = 0;\r\n    \r\n    function createCampaign(string memory _campaignData) public {\r\n        require(Users[msg.sender].userAddress != address(0x0), \"Invalid User\");\r\n        require(Users[msg.sender].hasCampaign == false, \"User is already Campaigning\");\r\n        \r\n        Campaigns.push(msg.sender);\r\n        CampaignsToIndex[msg.sender] = campaignCnt;\r\n        campaignCnt = campaignCnt.add(1);\r\n        Users[msg.sender].campaignData = _campaignData;\r\n        Users[msg.sender].hasCampaign = true;\r\n    }\r\n    \r\n    function stopCampaign() public {\r\n        require(Users[msg.sender].userAddress != address(0x0), \"Invalid User\");\r\n        require(Users[msg.sender].hasCampaign == true, \"User is already Campaigning\");\r\n        \r\n        Users[msg.sender].hasCampaign = false;\r\n        delete Campaigns[CampaignsToIndex[msg.sender]];\r\n    }\r\n    \r\n    struct Report {\r\n        address userAddress;\r\n        string userName;\r\n        string location;\r\n        string file;\r\n        string details;\r\n    }\r\n    \r\n    Report[] public Reports;\r\n    uint256 public reportCnt = 0;\r\n    \r\n    function fileReport(string memory _userName, string memory _location, string memory _file, string memory _details) public {\r\n        \r\n        Report memory tempreport = Report({\r\n            userAddress:msg.sender,\r\n            userName:_userName,\r\n            location:_location,\r\n            file:_file,\r\n            details:_details\r\n        });\r\n        Reports.push(tempreport);\r\n        reportCnt = reportCnt.add(1);\r\n\r\n    }\r\n    \r\n    \r\n\r\n}\r\n",
  "imports": [
    {
      "name": "c.sol",
      "contents": "/*\r\n   _____                  __  __    _ \r\n  / ___/____ _____ ______/ /_/ /_  (_)\r\n  \\__ \\/ __ `/ __ `/ ___/ __/ __ \\/ / \r\n ___/ / /_/ / /_/ / /  / /_/ / / / /  \r\n/____/\\__,_/\\__,_/_/   \\__/_/ /_/_/   \r\n                                                                            \r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity >=0.7.0 <0.8.0;\r\n// pragma experimental ABIEncoderV2;\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0; \r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Saarthi {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    struct Task {\r\n        uint256 taskID;\r\n        uint256 currentRound;\r\n        uint256 totalRounds;\r\n        uint256 cost;\r\n        string[] modelHashes;\r\n    }\r\n    \r\n    address owner;\r\n    address coordinatorAddress = address(0xBeb71662FF9c08aFeF3866f85A6591D4aeBE6e4E);\r\n\r\n    uint256 nextTaskID = 1;\r\n    mapping (uint256 => Task) public SaarthiTasks;\r\n    mapping (address => uint256[]) public UserTaskIDs;\r\n\r\n    event newTaskCreated(uint256 indexed taskID, address indexed _user, string _modelHash, uint256 _amt, uint256 _time);\r\n    event modelUpdated(uint256 indexed taskID, string _modelHash, uint256 _time);\r\n    \r\n    event donatationToFund(uint256 indexed fund_id, address indexed sender, address indexed receiver, uint256 amount);\r\n    event donatationToCampaign(address indexed sender, address indexed receiver, uint256 amount);\r\n    \r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    function updateOwner(address _newOwner) public {\r\n        require(msg.sender == owner, \"Only Owner\");\r\n        owner = _newOwner;\r\n    }\r\n\r\n    function createTask(string memory _modelHash, uint256 _rounds) public payable {\r\n        require(_rounds < 10, \"Number of Rounds should be less than 10\");\r\n        uint256 taskCost = msg.value;\r\n\r\n        Task memory newTask;\r\n        newTask = Task({\r\n            taskID: nextTaskID,\r\n            currentRound: 1,\r\n            totalRounds: _rounds,\r\n            cost: taskCost,\r\n            modelHashes: new string[](_rounds)\r\n        });\r\n        newTask.modelHashes[0] = _modelHash;\r\n        SaarthiTasks[nextTaskID] = newTask;\r\n        UserTaskIDs[msg.sender].push(nextTaskID);\r\n        emit newTaskCreated(nextTaskID, msg.sender, _modelHash, taskCost, block.timestamp);\r\n\r\n        nextTaskID = nextTaskID.add(1);\r\n    }\r\n\r\n    function updateModelForTask(uint256 _taskID,  string memory _modelHash, address payable computer) public {\r\n        require(msg.sender == coordinatorAddress, \"You are not the coordinator !\");\r\n        require(_taskID <= nextTaskID, \"Invalid Task ID\");\r\n        uint256 newRound = SaarthiTasks[_taskID].currentRound.add(1);\r\n        require(newRound <= SaarthiTasks[_taskID].totalRounds, \"All Rounds Completed\");\r\n        \r\n\r\n        SaarthiTasks[_taskID].currentRound = newRound;\r\n        SaarthiTasks[_taskID].modelHashes[newRound.sub(1)] = _modelHash;\r\n        computer.transfer(SaarthiTasks[_taskID].cost.div(SaarthiTasks[_taskID].totalRounds));\r\n        emit modelUpdated(_taskID, _modelHash, block.timestamp);\r\n\r\n    }\r\n\r\n    // function getTaskHashes(uint256 _taskID) public view returns (string[] memory) {\r\n    //     return (SaarthiTasks[_taskID].modelHashes);\r\n    // }\r\n\r\n    function getTaskCount() public view returns (uint256) {\r\n        return nextTaskID.sub(1);\r\n    }\r\n    function getTasksOfUser() public view returns (uint256[] memory) {\r\n        return UserTaskIDs[msg.sender];\r\n    }\r\n    \r\n    struct Fund {\r\n        uint256 orgID;\r\n        string orgName;\r\n        string fundName;\r\n        address payable fundAddress;\r\n        uint256 donationAmount;\r\n        uint256 donationCnt;\r\n    }\r\n    \r\n    uint256 public fundCnt = 0;\r\n    uint256 public totalDonationAmount = 0;\r\n    uint256 public totalDonationCnt = 0;\r\n    mapping (uint256 => Fund) public Funds;\r\n    \r\n    function createFund(string memory _orgName,string memory _fundName, address payable _orgAdress) public {\r\n        Fund memory newfund;\r\n        newfund = Fund({\r\n            orgID: fundCnt,\r\n            orgName: _orgName,\r\n            fundName: _fundName,\r\n            fundAddress: _orgAdress,\r\n            donationAmount:0,\r\n            donationCnt:0\r\n        });\r\n        \r\n        Funds[fundCnt] = newfund;\r\n        fundCnt = fundCnt.add(1);\r\n    }\r\n    \r\n    function donateToFund(uint256 _fundID) public payable{\r\n        require(_fundID <= fundCnt, \"Invalid Fund ID\");\r\n        \r\n        Funds[_fundID].donationAmount = Funds[_fundID].donationAmount.add(msg.value);\r\n        Funds[_fundID].donationCnt = Funds[_fundID].donationCnt.add(1);\r\n        \r\n        totalDonationAmount = totalDonationAmount.add(msg.value);\r\n        totalDonationCnt = totalDonationCnt.add(1);\r\n        \r\n        Funds[_fundID].fundAddress.transfer(msg.value);\r\n        emit donatationToFund(_fundID, msg.sender, Funds[_fundID].fundAddress, msg.value);\r\n    }\r\n    \r\n    struct User {\r\n        address payable userAddress;\r\n        address[] accessors;\r\n        uint256 recordHistoryCnt;\r\n        string[] recordHistory;\r\n        uint256 billAmount;\r\n        uint256 donationCnt;\r\n        address[] donationAddresses;\r\n        uint256[] donationAmounts;\r\n        bool hasCampaign;\r\n        string campaignData;\r\n        bool hasAllowedResearch;\r\n    }\r\n    \r\n    mapping (address => User) public Users;\r\n    uint256 public UserCnt = 0;\r\n    \r\n    function addUser() public {\r\n        // already hash a history\r\n        require(Users[msg.sender].userAddress == address(0x0), \"User Already Registered\");\r\n        \r\n        string[] memory newRecordHistory;\r\n        address[] memory newAccessors;\r\n        address[] memory newDonationAddresses;\r\n        uint256[] memory newDonationAmounts;\r\n        string memory newCampaignData;\r\n        \r\n        User memory userTemp = User({\r\n            userAddress: msg.sender,\r\n            accessors: newAccessors,\r\n            recordHistoryCnt: 0,\r\n            recordHistory: newRecordHistory,\r\n            billAmount: 0,\r\n            donationCnt: 0,\r\n            donationAddresses: newDonationAddresses,\r\n            donationAmounts: newDonationAmounts,\r\n            hasCampaign: false,\r\n            campaignData: newCampaignData,\r\n            hasAllowedResearch: false\r\n        });\r\n        \r\n        Users[msg.sender] = userTemp;\r\n        UserCnt = UserCnt.add(1);\r\n        \r\n    }\r\n    \r\n    function addRecord(string memory _recordHash) public {\r\n        // already hash a history\r\n        if(Users[msg.sender].userAddress == address(0x0)){\r\n            addUser();\r\n        }\r\n        \r\n        Users[msg.sender].recordHistoryCnt = Users[msg.sender].recordHistoryCnt.add(1);\r\n        Users[msg.sender].recordHistory.push(_recordHash);\r\n    }\r\n    \r\n    function getRecord(address _user, uint _index) public view returns (string memory records){\r\n        if (Users[_user].userAddress == address(0x0)){\r\n            string memory newRecordHistory;\r\n            return newRecordHistory;\r\n        }\r\n        \r\n        bool allowed = false;\r\n        for(uint256 ind=0; ind<Users[_user].accessors.length; ind = ind.add(1)){\r\n            if (Users[_user].accessors[ind] == msg.sender){\r\n                allowed = true;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        require( (Users[_user].userAddress == msg.sender) || allowed == true, \"Cannot Access Records\");\r\n        \r\n        return Users[_user].recordHistory[_index];\r\n        \r\n    }\r\n    \r\n    function getDonationAmounts(address _user) public view returns (uint256[] memory donationAmounts){\r\n        require(Users[_user].userAddress != address(0x0), \"Invalid User\");\r\n        return Users[_user].donationAmounts;\r\n    }\r\n    \r\n    function getDonationAddresses(address _user) public view returns (address[] memory donationAddresses){\r\n        require(Users[_user].userAddress != address(0x0), \"Invalid User\");\r\n        return Users[_user].donationAddresses;\r\n    }\r\n    \r\n    function allowAccessToUser(address _address) public {\r\n        require(Users[msg.sender].userAddress != address(0x0), \"Invalid User\");\r\n        Users[msg.sender].accessors.push(_address);\r\n    }\r\n    function allowAccessToResearch() public {\r\n        require(Users[msg.sender].userAddress != address(0x0), \"Invalid User\");\r\n        Users[msg.sender].hasAllowedResearch = true;\r\n    }\r\n    function revokeAccessToResearch() public {\r\n        require(Users[msg.sender].userAddress != address(0x0), \"Invalid User\");\r\n        Users[msg.sender].hasAllowedResearch = false;\r\n    }\r\n    \r\n    function getAccessors() public view returns(address[] memory){\r\n        require(Users[msg.sender].userAddress != address(0x0), \"Invalid User\");\r\n        \r\n        return Users[msg.sender].accessors;\r\n    }\r\n    \r\n    function donateToUser(address _user) public payable{\r\n        require(Users[_user].userAddress != address(0x0), \"Invalid User\");\r\n        \r\n        uint256 donationAmount = msg.value;\r\n        \r\n        Users[_user].donationCnt = Users[_user].donationCnt.add(1);\r\n        Users[msg.sender].donationAddresses.push(msg.sender);\r\n        Users[msg.sender].donationAmounts.push(donationAmount);\r\n        \r\n        Users[msg.sender].userAddress.transfer(donationAmount);\r\n        emit donatationToCampaign(msg.sender, Users[msg.sender].userAddress, donationAmount);\r\n    }\r\n    \r\n    function billUser(uint256 _amt) public {\r\n        require(Users[msg.sender].userAddress != address(0x0), \"Invalid User\");\r\n\r\n        Users[msg.sender].billAmount = Users[msg.sender].billAmount.add(_amt);\r\n    }\r\n    \r\n    address[] public Campaigns;\r\n    mapping (address => uint256) internal CampaignsToIndex;\r\n    uint256 public campaignCnt = 0;\r\n    \r\n    function createCampaign(string memory _campaignData) public {\r\n        require(Users[msg.sender].userAddress != address(0x0), \"Invalid User\");\r\n        require(Users[msg.sender].hasCampaign == false, \"User is already Campaigning\");\r\n        \r\n        Campaigns.push(msg.sender);\r\n        CampaignsToIndex[msg.sender] = campaignCnt;\r\n        campaignCnt = campaignCnt.add(1);\r\n        Users[msg.sender].campaignData = _campaignData;\r\n        Users[msg.sender].hasCampaign = true;\r\n    }\r\n    \r\n    function stopCampaign() public {\r\n        require(Users[msg.sender].userAddress != address(0x0), \"Invalid User\");\r\n        require(Users[msg.sender].hasCampaign == true, \"User is already Campaigning\");\r\n        \r\n        Users[msg.sender].hasCampaign = false;\r\n        delete Campaigns[CampaignsToIndex[msg.sender]];\r\n    }\r\n    \r\n    struct Report {\r\n        address userAddress;\r\n        string userName;\r\n        string location;\r\n        string file;\r\n        string details;\r\n    }\r\n    \r\n    Report[] public Reports;\r\n    uint256 public reportCnt = 0;\r\n    \r\n    function fileReport(string memory _userName, string memory _location, string memory _file, string memory _details) public {\r\n        \r\n        Report memory tempreport = Report({\r\n            userAddress:msg.sender,\r\n            userName:_userName,\r\n            location:_location,\r\n            file:_file,\r\n            details:_details\r\n        });\r\n        Reports.push(tempreport);\r\n        reportCnt = reportCnt.add(1);\r\n\r\n    }\r\n    \r\n    \r\n\r\n}\r\n",
      "file": "c.sol"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x0ad4009653557efcc2a262fb868f92010f944397756ff65f4385b9a5a6767888",
    "blockNumber": 1313846,
    "transactionHash": "0xad217b71fe20d4295940ad6d634559126b23ee4d7ea18c930275632ab6527795",
    "timestamp": 1604402601
  }
}