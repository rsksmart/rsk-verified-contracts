{
    "address": "0x8205153fa1492dfa191395beaba3a210fedf5a60",
    "net": {
        "id": "31",
        "name": "RSK Testnet"
    },
    "name": "EscrowReward",
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        }
    },
    "version": "0.5.17+commit.d19bba13",
    "source": "pragma solidity ^0.5.17;\n\nimport \"./escrow.sol\";\n\n/**\n *  @title A reward distribution contract for Sovryn Ethereum Pool Escrow Contract.\n *  @author Franklin Richards - powerhousefrank@protonmail.com\n *  @notice Multisig can use this contract for depositing of Reward tokens based on the total token deposit.\n */\ncontract EscrowReward is Escrow {\n\tusing SafeMath for uint256;\n\n\t/* Storage */\n\n\t/// @notice The total reward tokens deposited.\n\t/// @dev Used for calculating the reward % share of users related to total deposit.\n\tuint256 public totalRewardDeposit;\n\n\t/// @notice The Reward token contract.\n\tIERC20 public rewardToken;\n\n\t/* Events */\n\n\t/// @notice Emitted when the Reward Token address is updated.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _rewardToken The address of the Reward Token Contract.\n\tevent RewardTokenUpdated(address indexed _initiator, address indexed _rewardToken);\n\n\t/// @notice Emitted when a new reward token deposit is done by Multisig.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _amount The amount of token deposited.\n\tevent RewardDepositByMultisig(address indexed _initiator, uint256 _amount);\n\n\t/// @notice Emitted when a Reward token withdraw is done by User.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _amount The amount of token withdrawed.\n\tevent RewardTokenWithdraw(address indexed _initiator, uint256 _amount);\n\n\t/* Functions */\n\n\t/**\n\t * @notice Setup the required parameters.\n\t * @param _rewardToken The Reward Token address.\n\t * @param _SOV The SOV token address.\n\t * @param _multisig The owner of the tokens & contract.\n\t * @param _releaseTime The token release time, zero if undecided.\n\t * @param _depositLimit The amount of tokens we will be accepting.\n\t */\n\tconstructor(\n\t\taddress _rewardToken,\n\t\taddress _SOV,\n\t\taddress _multisig,\n\t\tuint256 _releaseTime,\n\t\tuint256 _depositLimit\n\t) public Escrow(_SOV, _multisig, _releaseTime, _depositLimit) {\n\t\tif (_rewardToken != address(0)) {\n\t\t\trewardToken = IERC20(_rewardToken);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Set the Reward Token Address if not already done.\n\t * @param _rewardToken The Reward Token address.\n\t */\n\tfunction updateRewardToken(address _rewardToken) public onlyMultisig {\n\t\trequire(_rewardToken != address(0), \"Invalid Reward Token Address.\");\n\n\t\trewardToken = IERC20(_rewardToken);\n\n\t\temit RewardTokenUpdated(msg.sender, _rewardToken);\n\t}\n\n\t/**\n\t * @notice Deposit tokens to this contract by the Multisig.\n\t * @param _amount the amount of tokens deposited.\n\t * @dev The contract has to be approved by the multisig inorder for this function to work.\n\t */\n\tfunction depositRewardByMultisig(uint256 _amount) public onlyMultisig {\n\t\trequire(status != Status.Withdraw, \"Reward Token deposit is only allowed before User Withdraw starts.\");\n\t\trequire(_amount > 0, \"Amount needs to be bigger than zero.\");\n\n\t\tbool txStatus = rewardToken.transferFrom(msg.sender, address(this), _amount);\n\t\trequire(txStatus, \"Token transfer was not successful.\");\n\n\t\ttotalRewardDeposit = totalRewardDeposit.add(_amount);\n\n\t\temit RewardDepositByMultisig(msg.sender, _amount);\n\t}\n\n\t/**\n\t * @notice Withdraws token from the contract by User.\n\t * @dev Only works after the contract state is in Withdraw.\n\t */\n\tfunction withdrawTokensAndReward() public checkRelease checkStatus(Status.Withdraw) {\n\t\t// Reward calculation have to be done initially as the User Balance is zeroed out .\n\t\tuint256 reward = userBalances[msg.sender].mul(totalRewardDeposit).div(totalDeposit);\n\t\twithdrawTokens();\n\n\t\tbool txStatus = rewardToken.transfer(msg.sender, reward);\n\t\trequire(txStatus, \"Token transfer was not successful. Check receiver address.\");\n\n\t\temit RewardTokenWithdraw(msg.sender, reward);\n\t}\n\n\t/* Getter Functions */\n\n\t/**\n\t * @notice Function to read the reward a particular user can get.\n\t * @param _addr The address of the user whose reward is to be read.\n\t * @return reward The reward received by the user.\n\t */\n\tfunction getReward(address _addr) public view returns (uint256 reward) {\n\t\tif (userBalances[_addr].mul(totalRewardDeposit) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn userBalances[_addr].mul(totalRewardDeposit).div(totalDeposit);\n\t}\n}\n",
    "imports": [
        {
            "name": "escrowWithReward.sol",
            "contents": "pragma solidity ^0.5.17;\n\nimport \"./escrow.sol\";\n\n/**\n *  @title A reward distribution contract for Sovryn Ethereum Pool Escrow Contract.\n *  @author Franklin Richards - powerhousefrank@protonmail.com\n *  @notice Multisig can use this contract for depositing of Reward tokens based on the total token deposit.\n */\ncontract EscrowReward is Escrow {\n\tusing SafeMath for uint256;\n\n\t/* Storage */\n\n\t/// @notice The total reward tokens deposited.\n\t/// @dev Used for calculating the reward % share of users related to total deposit.\n\tuint256 public totalRewardDeposit;\n\n\t/// @notice The Reward token contract.\n\tIERC20 public rewardToken;\n\n\t/* Events */\n\n\t/// @notice Emitted when the Reward Token address is updated.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _rewardToken The address of the Reward Token Contract.\n\tevent RewardTokenUpdated(address indexed _initiator, address indexed _rewardToken);\n\n\t/// @notice Emitted when a new reward token deposit is done by Multisig.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _amount The amount of token deposited.\n\tevent RewardDepositByMultisig(address indexed _initiator, uint256 _amount);\n\n\t/// @notice Emitted when a Reward token withdraw is done by User.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _amount The amount of token withdrawed.\n\tevent RewardTokenWithdraw(address indexed _initiator, uint256 _amount);\n\n\t/* Functions */\n\n\t/**\n\t * @notice Setup the required parameters.\n\t * @param _rewardToken The Reward Token address.\n\t * @param _SOV The SOV token address.\n\t * @param _multisig The owner of the tokens & contract.\n\t * @param _releaseTime The token release time, zero if undecided.\n\t * @param _depositLimit The amount of tokens we will be accepting.\n\t */\n\tconstructor(\n\t\taddress _rewardToken,\n\t\taddress _SOV,\n\t\taddress _multisig,\n\t\tuint256 _releaseTime,\n\t\tuint256 _depositLimit\n\t) public Escrow(_SOV, _multisig, _releaseTime, _depositLimit) {\n\t\tif (_rewardToken != address(0)) {\n\t\t\trewardToken = IERC20(_rewardToken);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Set the Reward Token Address if not already done.\n\t * @param _rewardToken The Reward Token address.\n\t */\n\tfunction updateRewardToken(address _rewardToken) public onlyMultisig {\n\t\trequire(_rewardToken != address(0), \"Invalid Reward Token Address.\");\n\n\t\trewardToken = IERC20(_rewardToken);\n\n\t\temit RewardTokenUpdated(msg.sender, _rewardToken);\n\t}\n\n\t/**\n\t * @notice Deposit tokens to this contract by the Multisig.\n\t * @param _amount the amount of tokens deposited.\n\t * @dev The contract has to be approved by the multisig inorder for this function to work.\n\t */\n\tfunction depositRewardByMultisig(uint256 _amount) public onlyMultisig {\n\t\trequire(status != Status.Withdraw, \"Reward Token deposit is only allowed before User Withdraw starts.\");\n\t\trequire(_amount > 0, \"Amount needs to be bigger than zero.\");\n\n\t\tbool txStatus = rewardToken.transferFrom(msg.sender, address(this), _amount);\n\t\trequire(txStatus, \"Token transfer was not successful.\");\n\n\t\ttotalRewardDeposit = totalRewardDeposit.add(_amount);\n\n\t\temit RewardDepositByMultisig(msg.sender, _amount);\n\t}\n\n\t/**\n\t * @notice Withdraws token from the contract by User.\n\t * @dev Only works after the contract state is in Withdraw.\n\t */\n\tfunction withdrawTokensAndReward() public checkRelease checkStatus(Status.Withdraw) {\n\t\t// Reward calculation have to be done initially as the User Balance is zeroed out .\n\t\tuint256 reward = userBalances[msg.sender].mul(totalRewardDeposit).div(totalDeposit);\n\t\twithdrawTokens();\n\n\t\tbool txStatus = rewardToken.transfer(msg.sender, reward);\n\t\trequire(txStatus, \"Token transfer was not successful. Check receiver address.\");\n\n\t\temit RewardTokenWithdraw(msg.sender, reward);\n\t}\n\n\t/* Getter Functions */\n\n\t/**\n\t * @notice Function to read the reward a particular user can get.\n\t * @param _addr The address of the user whose reward is to be read.\n\t * @return reward The reward received by the user.\n\t */\n\tfunction getReward(address _addr) public view returns (uint256 reward) {\n\t\tif (userBalances[_addr].mul(totalRewardDeposit) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn userBalances[_addr].mul(totalRewardDeposit).div(totalDeposit);\n\t}\n}\n",
            "file": "escrowWithReward.sol"
        },
        {
            "name": "escrow.sol",
            "contents": "pragma solidity ^0.5.17;\n\nimport \"../openzeppelin/SafeMath.sol\";\nimport \"../interfaces/IERC20.sol\";\n\n/**\n *  @title A holding contract for Sovryn Ethereum Pool to accept SOV Token.\n *  @author Franklin Richards - powerhousefrank@protonmail.com\n *  @notice You can use this contract for deposit of SOV tokens for some time and withdraw later.\n */\ncontract Escrow {\n\tusing SafeMath for uint256;\n\n\t/* Storage */\n\n\t/// @notice The total tokens deposited.\n\t/// @dev Used for calculating the reward % share of users related to total deposit.\n\tuint256 public totalDeposit;\n\t/// @notice The release timestamp for the tokens deposited.\n\tuint256 public releaseTime;\n\t/// @notice The amount of token we would be accepting as deposit at max.\n\tuint256 public depositLimit;\n\n\t/// @notice The SOV token contract.\n\tIERC20 public SOV;\n\n\t/// @notice The multisig contract which handles the fund.\n\taddress public multisig;\n\n\t/// @notice The user balances.\n\tmapping(address => uint256) userBalances;\n\n\t/// @notice The current contract status.\n\t/// @notice Deployed - Deployed the contract.\n\t/// @notice Deposit - Time to deposit in the contract by the users.\n\t/// @notice Holding - Deposit is closed and now the holding period starts.\n\t/// @notice Withdraw - Time to withdraw in the contract by the users.\n\t/// @notice Expired - The contract is now closed completely.\n\tenum Status { Deployed, Deposit, Holding, Withdraw, Expired }\n\tStatus public status;\n\n\t/* Events */\n\n\t/// @notice Emitted when the contract deposit starts.\n\tevent EscrowActivated();\n\n\t/// @notice Emitted when the contract is put in holding state. No new token deposit accepted by User.\n\tevent EscrowInHoldingState();\n\n\t/// @notice Emitted when the contract is put in withdraw state. Users can now withdraw tokens.\n\tevent EscrowInWithdrawState();\n\n\t/// @notice Emitted when the contract is expired after withdraws are made/total token transfer.\n\tevent EscrowFundExpired();\n\n\t/// @notice Emitted when a new multisig is added to the contract.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _newMultisig The address which is added as the new multisig.\n\t/// @dev Can only be initiated by the current multisig.\n\tevent NewMultisig(address indexed _initiator, address indexed _newMultisig);\n\n\t/// @notice Emitted when the release timestamp is updated.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _releaseTimestamp The updated release timestamp for the withdraw.\n\tevent TokenReleaseUpdated(address indexed _initiator, uint256 _releaseTimestamp);\n\n\t/// @notice Emitted when the deposit limit is updated.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _depositLimit The updated deposit limit.\n\tevent TokenDepositLimitUpdated(address indexed _initiator, uint256 _depositLimit);\n\n\t/// @notice Emitted when a new token deposit is done by User.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _amount The amount of token deposited.\n\tevent TokenDeposit(address indexed _initiator, uint256 _amount);\n\n\t/// @notice Emitted when we reach the token deposit limit.\n\tevent DepositLimitReached();\n\n\t/// @notice Emitted when a token withdraw is done by Multisig.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _amount The amount of token withdrawed.\n\tevent TokenWithdrawByMultisig(address indexed _initiator, uint256 _amount);\n\n\t/// @notice Emitted when a new token deposit is done by Multisig.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _amount The amount of token deposited.\n\tevent TokenDepositByMultisig(address indexed _initiator, uint256 _amount);\n\n\t/// @notice Emitted when a token withdraw is done by User.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _amount The amount of token withdrawed.\n\tevent TokenWithdraw(address indexed _initiator, uint256 _amount);\n\n\t/* Modifiers */\n\n\tmodifier onlyMultisig() {\n\t\trequire(msg.sender == multisig, \"Only Multisig can call this.\");\n\t\t_;\n\t}\n\n\tmodifier checkStatus(Status s) {\n\t\trequire(status == s, \"The contract is not in the right state.\");\n\t\t_;\n\t}\n\n\tmodifier checkRelease() {\n\t\trequire(releaseTime != 0 && releaseTime <= block.timestamp, \"The release time has not started yet.\");\n\t\t_;\n\t}\n\n\t/* Functions */\n\n\t/**\n\t * @notice Setup the required parameters.\n\t * @param _SOV The SOV token address.\n\t * @param _multisig The owner of the tokens & contract.\n\t * @param _releaseTime The token release time, zero if undecided.\n\t * @param _depositLimit The amount of tokens we will be accepting.\n\t */\n\tconstructor(\n\t\taddress _SOV,\n\t\taddress _multisig,\n\t\tuint256 _releaseTime,\n\t\tuint256 _depositLimit\n\t) public {\n\t\trequire(_SOV != address(0), \"Invalid SOV Address.\");\n\t\trequire(_multisig != address(0), \"Locked token & contract owner address invalid.\");\n\n\t\tSOV = IERC20(_SOV);\n\t\tmultisig = _multisig;\n\n\t\treleaseTime = _releaseTime;\n\t\tdepositLimit = _depositLimit;\n\t}\n\n\t/**\n\t * @notice This function is called once after deployment for starting the deposit action.\n\t * @dev Without calling this function, the contract will not start accepting tokens.\n\t */\n\tfunction init() public onlyMultisig checkStatus(Status.Deployed) {\n\t\tstatus = Status.Deposit;\n\n\t\temit EscrowActivated();\n\t}\n\n\t/**\n\t * @notice Update Multisig.\n\t * @param _newMultisig The new owner of the tokens & contract.\n\t */\n\tfunction updateMultisig(address _newMultisig) public onlyMultisig {\n\t\trequire(_newMultisig != address(0), \"New Multisig address invalid.\");\n\n\t\tmultisig = _newMultisig;\n\n\t\temit NewMultisig(msg.sender, _newMultisig);\n\t}\n\n\t/**\n\t * @notice Update Release Timestamp.\n\t * @param _newReleaseTime The new release timestamp for token release.\n\t * @dev Zero is also a valid timestamp, if the release time is not scheduled yet.\n\t */\n\tfunction updateReleaseTimestamp(uint256 _newReleaseTime) public onlyMultisig {\n\t\treleaseTime = _newReleaseTime;\n\n\t\temit TokenReleaseUpdated(msg.sender, _newReleaseTime);\n\t}\n\n\t/**\n\t * @notice Update Deposit Limit.\n\t * @param _newDepositLimit The new deposit limit.\n\t * @dev IMPORTANT: Should not decrease than already deposited.\n\t */\n\tfunction updateDepositLimit(uint256 _newDepositLimit) public onlyMultisig {\n\t\trequire(_newDepositLimit >= totalDeposit, \"Deposit already higher than the limit trying to be set.\");\n\t\tdepositLimit = _newDepositLimit;\n\n\t\temit TokenDepositLimitUpdated(msg.sender, _newDepositLimit);\n\t}\n\n\t/**\n\t * @notice Deposit tokens to this contract by User.\n\t * @param _amount the amount of tokens deposited.\n\t * @dev The contract has to be approved by the user inorder for this function to work.\n\t * These tokens can be withdrawn/transferred during Holding State by the Multisig.\n\t */\n\tfunction depositTokens(uint256 _amount) public checkStatus(Status.Deposit) {\n\t\trequire(_amount > 0, \"Amount needs to be bigger than zero.\");\n\t\tuint256 amount = _amount;\n\n\t\tif (totalDeposit.add(_amount) >= depositLimit) {\n\t\t\tuint256 difference = totalDeposit.add(_amount).sub(depositLimit);\n\t\t\tamount = _amount.sub(difference);\n\t\t\temit DepositLimitReached();\n\t\t}\n\n\t\tbool txStatus = SOV.transferFrom(msg.sender, address(this), amount);\n\t\trequire(txStatus, \"Token transfer was not successful.\");\n\n\t\tuserBalances[msg.sender] = userBalances[msg.sender].add(amount);\n\t\ttotalDeposit = totalDeposit.add(amount);\n\n\t\temit TokenDeposit(msg.sender, amount);\n\t}\n\n\t/**\n\t * @notice Update contract state to Holding.\n\t * @dev Once called, the contract no longer accepts any more deposits.\n\t * The multisig can now withdraw tokens from the contract after the contract is in Holding State.\n\t */\n\tfunction changeStateToHolding() public onlyMultisig checkStatus(Status.Deposit) {\n\t\tstatus = Status.Holding;\n\n\t\temit EscrowInHoldingState();\n\t}\n\n\t/**\n\t * @notice Withdraws all token from the contract by Multisig.\n\t * @param _receiverAddress The address where the tokens has to be transferred. Zero address if the withdraw is to be done in Multisig.\n\t * @dev Can only be called after the token state is changed to Holding.\n\t */\n\tfunction withdrawTokensByMultisig(address _receiverAddress) public onlyMultisig checkStatus(Status.Holding) {\n\t\taddress receiverAddress = msg.sender;\n\t\tif (_receiverAddress != address(0)) {\n\t\t\treceiverAddress = _receiverAddress;\n\t\t}\n\n\t\tuint256 value = SOV.balanceOf(address(this));\n\t\t/// Sending the amount to multisig.\n\t\tbool txStatus = SOV.transfer(receiverAddress, value);\n\t\trequire(txStatus, \"Token transfer was not successful. Check receiver address.\");\n\n\t\temit TokenWithdrawByMultisig(msg.sender, value);\n\t}\n\n\t/**\n\t * @notice Deposit tokens to this contract by the Multisig.\n\t * @param _amount the amount of tokens deposited.\n\t * @dev The contract has to be approved by the multisig inorder for this function to work.\n\t * Once the token deposit is higher than the total deposits done, the contract state is changed to Withdraw.\n\t */\n\tfunction depositTokensByMultisig(uint256 _amount) public onlyMultisig checkStatus(Status.Holding) {\n\t\trequire(_amount > 0, \"Amount needs to be bigger than zero.\");\n\n\t\tbool txStatus = SOV.transferFrom(msg.sender, address(this), _amount);\n\t\trequire(txStatus, \"Token transfer was not successful.\");\n\n\t\temit TokenDepositByMultisig(msg.sender, _amount);\n\n\t\tif (SOV.balanceOf(address(this)) >= totalDeposit) {\n\t\t\tstatus = Status.Withdraw;\n\t\t\temit EscrowInWithdrawState();\n\t\t}\n\t}\n\n\t/**\n\t * @notice Withdraws token from the contract by User.\n\t * @dev Only works after the contract state is in Withdraw.\n\t */\n\tfunction withdrawTokens() public checkRelease checkStatus(Status.Withdraw) {\n\t\tuint256 amount = userBalances[msg.sender];\n\t\tuserBalances[msg.sender] = 0;\n\t\tbool txStatus = SOV.transfer(msg.sender, amount);\n\t\trequire(txStatus, \"Token transfer was not successful. Check receiver address.\");\n\n\t\temit TokenWithdraw(msg.sender, amount);\n\t}\n\n\t/* Getter Functions */\n\n\t/**\n\t * @notice Function to read the current token balance of a particular user.\n\t * @return _addr The user address whose balance has to be checked.\n\t */\n\tfunction getUserBalance(address _addr) public view returns (uint256 balance) {\n\t\treturn userBalances[_addr];\n\t}\n}\n"
        },
        {
            "name": "IERC20.sol",
            "contents": "/**\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0.\n */\n\npragma solidity >=0.5.0 <0.6.0;\n\ncontract IERC20 {\n\tstring public name;\n\tuint8 public decimals;\n\tstring public symbol;\n\n\tfunction totalSupply() public view returns (uint256);\n\n\tfunction balanceOf(address _who) public view returns (uint256);\n\n\tfunction transfer(address _to, uint256 _value) public returns (bool);\n\n\tfunction allowance(address _owner, address _spender) public view returns (uint256);\n\n\tfunction transferFrom(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _value\n\t) public returns (bool);\n\n\tfunction approve(address _spender, uint256 _value) public returns (bool);\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
        },
        {
            "name": "SafeMath.sol",
            "contents": "pragma solidity >=0.5.0 <0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n\t/**\n\t * @dev Returns the addition of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `+` operator.\n\t *\n\t * Requirements:\n\t * - Addition cannot overflow.\n\t */\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\trequire(c >= a, \"SafeMath: addition overflow\");\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t * - Subtraction cannot overflow.\n\t */\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn sub(a, b, \"SafeMath: subtraction overflow\");\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t * - Subtraction cannot overflow.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction sub(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\trequire(b <= a, errorMessage);\n\t\tuint256 c = a - b;\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the multiplication of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `*` operator.\n\t *\n\t * Requirements:\n\t * - Multiplication cannot overflow.\n\t */\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\t\t// benefit is lost if 'b' is also tested.\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 c = a * b;\n\t\trequire(c / a == b, \"SafeMath: multiplication overflow\");\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers. Reverts on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn div(a, b, \"SafeMath: division by zero\");\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction div(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\t// Solidity only automatically asserts when dividing by 0\n\t\trequire(b > 0, errorMessage);\n\t\tuint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn mod(a, b, \"SafeMath: modulo by zero\");\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts with custom message when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction mod(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\trequire(b != 0, errorMessage);\n\t\treturn a % b;\n\t}\n\n\tfunction min256(uint256 _a, uint256 _b) internal pure returns (uint256) {\n\t\treturn _a < _b ? _a : _b;\n\t}\n}\n"
        }
    ],
    "libraries": {},
    "constructorArguments": [
        "0x6a9a07972d07e58f0daf5122d11e069288a375fb",
        "0x6a9a07972d07e58f0daf5122d11e069288a375fb",
        "0x189ecd23e9e34cfc07bfc3b7f5711a23f43f8a57",
        "1622739097",
        "75000000000000000000000"
    ],
    "creationData": {
        "blockHash": "0x779391c54be13d039cbe56bd99f2a2746b6b54465d21cd2d34ecce38a0e216fe",
        "blockNumber": 1801174,
        "transactionHash": "0x9228f9f2d474cf18543c057ff398f2bfff232e336fa39bdf370a41cdeef386b5",
        "timestamp": 1619628716
    }
}