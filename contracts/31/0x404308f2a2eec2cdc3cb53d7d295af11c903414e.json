{
  "address": "0x404308f2a2eec2cdc3cb53d7d295af11c903414e",
  "net": {
    "id": "31",
    "name": "RSK Testnet"
  },
  "name": "MultiChainResolver",
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "metadata",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ]
      }
    }
  },
  "version": "0.5.12+commit.7709ece9",
  "source": "pragma solidity ^0.5.2;\n\nimport \"./AbstractRNS.sol\";\nimport \"./PublicResolver.sol\";\nimport \"./AddressHelper.sol\";\nimport \"./AbstractMultiChainResolver.sol\";\n\ncontract MultiChainResolver is AbstractMultiChainResolver {\n    AbstractRNS rns;\n    PublicResolver publicResolver;\n\n    AddressHelper addressHelper;\n\n    mapping (bytes32 => bytes32) contents;\n    mapping (bytes32 => mapping (bytes8 => ChainAddress)) chainAddresses;\n\n    bytes4 constant ADDR_SIGN = 0x3b3b57de;\n    bytes4 constant CONTENT_SIGN = 0x2dff6941;\n    bytes4 constant CHAIN_ADDR_SIGN = 0x8be4b5f6;\n\n    bytes4 constant RSK_CHAIN_ID = 0x80000089;\n\n    event ContentChanged (bytes32 node, bytes32 content);\n    event ChainMetadataChanged (bytes32 node, bytes4 chain, bytes32 metadata);\n\n    struct ChainAddress {\n        bytes32 metadata;\n        string addr;\n    }\n\n    modifier onlyOwner (bytes32 node) {\n        require(rns.owner(node) == msg.sender);\n        _;\n    }\n\n    constructor (AbstractRNS _rns, PublicResolver _publicResolver) public {\n        rns = _rns;\n        publicResolver = _publicResolver;\n        addressHelper = new AddressHelper();\n    }\n\n    function () external {\n        revert();\n    }\n\n    function supportsInterface (bytes4 interfaceId) public pure returns (bool) {\n        return ((interfaceId == ADDR_SIGN) || (interfaceId == CONTENT_SIGN) || interfaceId == (CHAIN_ADDR_SIGN));\n    }\n\n    function addr (bytes32 node) public view returns (address) {\n        string memory _addr = chainAddresses[node][RSK_CHAIN_ID].addr;\n\n        if (bytes(_addr).length > 0) {\n            return addressHelper.stringToAddress(_addr);\n        }\n\n        return publicResolver.addr(node);\n    }\n\n    function setAddr (bytes32 node, address addrValue) public onlyOwner(node) {\n        chainAddresses[node][RSK_CHAIN_ID].addr = addressHelper.addressToString(addrValue);\n        emit AddrChanged(node, addrValue);\n    }\n\n    function content (bytes32 node) public view returns (bytes32) {\n        bytes32 _content = contents[node];\n\n        if (_content != 0) {\n            return _content;\n        }\n\n        return publicResolver.content(node);\n    }\n\n    function setContent (bytes32 node, bytes32 contentValue) public onlyOwner(node) {\n        contents[node] = contentValue;\n        emit ContentChanged(node, contentValue);\n    }\n\n    function chainAddr (bytes32 node, bytes4 chain) public view returns (string memory) {\n        return chainAddresses[node][chain].addr;\n    }\n\n    function setChainAddr (bytes32 node, bytes4 chain, string memory addrValue) public onlyOwner(node) {\n        chainAddresses[node][chain].addr = addrValue;\n        if (chain == RSK_CHAIN_ID) {\n            address _addr = addressHelper.stringToAddress(addrValue);\n            emit AddrChanged(node, _addr);\n        } else {\n            emit ChainAddrChanged(node, chain, addrValue);\n        }\n    }\n\n    function chainMetadata (bytes32 node, bytes4 chain) public view returns (bytes32) {\n        return chainAddresses[node][chain].metadata;\n    }\n\n    function setChainMetadata (bytes32 node, bytes4 chain, bytes32 metadataValue) public onlyOwner(node) {\n        chainAddresses[node][chain].metadata = metadataValue;\n        emit ChainMetadataChanged(node, chain, metadataValue);\n    }\n\n    function chainAddrAndMetadata (bytes32 node, bytes4 chain) public view returns (string memory, bytes32) {\n        ChainAddress storage chainAddress = chainAddresses[node][chain];\n        return (chainAddress.addr, chainAddress.metadata);\n    }\n\n    function setChainAddrWithMetadata (bytes32 node, bytes4 chain, string memory addrValue, bytes32 metadataValue) public onlyOwner(node) {\n        setChainAddr(node, chain, addrValue);\n        setChainMetadata(node, chain, metadataValue);\n    }\n}\n",
  "imports": [
    {
      "name": "MultiChainResolver.sol",
      "contents": "pragma solidity ^0.5.2;\n\nimport \"./AbstractRNS.sol\";\nimport \"./PublicResolver.sol\";\nimport \"./AddressHelper.sol\";\nimport \"./AbstractMultiChainResolver.sol\";\n\ncontract MultiChainResolver is AbstractMultiChainResolver {\n    AbstractRNS rns;\n    PublicResolver publicResolver;\n\n    AddressHelper addressHelper;\n\n    mapping (bytes32 => bytes32) contents;\n    mapping (bytes32 => mapping (bytes8 => ChainAddress)) chainAddresses;\n\n    bytes4 constant ADDR_SIGN = 0x3b3b57de;\n    bytes4 constant CONTENT_SIGN = 0x2dff6941;\n    bytes4 constant CHAIN_ADDR_SIGN = 0x8be4b5f6;\n\n    bytes4 constant RSK_CHAIN_ID = 0x80000089;\n\n    event ContentChanged (bytes32 node, bytes32 content);\n    event ChainMetadataChanged (bytes32 node, bytes4 chain, bytes32 metadata);\n\n    struct ChainAddress {\n        bytes32 metadata;\n        string addr;\n    }\n\n    modifier onlyOwner (bytes32 node) {\n        require(rns.owner(node) == msg.sender);\n        _;\n    }\n\n    constructor (AbstractRNS _rns, PublicResolver _publicResolver) public {\n        rns = _rns;\n        publicResolver = _publicResolver;\n        addressHelper = new AddressHelper();\n    }\n\n    function () external {\n        revert();\n    }\n\n    function supportsInterface (bytes4 interfaceId) public pure returns (bool) {\n        return ((interfaceId == ADDR_SIGN) || (interfaceId == CONTENT_SIGN) || interfaceId == (CHAIN_ADDR_SIGN));\n    }\n\n    function addr (bytes32 node) public view returns (address) {\n        string memory _addr = chainAddresses[node][RSK_CHAIN_ID].addr;\n\n        if (bytes(_addr).length > 0) {\n            return addressHelper.stringToAddress(_addr);\n        }\n\n        return publicResolver.addr(node);\n    }\n\n    function setAddr (bytes32 node, address addrValue) public onlyOwner(node) {\n        chainAddresses[node][RSK_CHAIN_ID].addr = addressHelper.addressToString(addrValue);\n        emit AddrChanged(node, addrValue);\n    }\n\n    function content (bytes32 node) public view returns (bytes32) {\n        bytes32 _content = contents[node];\n\n        if (_content != 0) {\n            return _content;\n        }\n\n        return publicResolver.content(node);\n    }\n\n    function setContent (bytes32 node, bytes32 contentValue) public onlyOwner(node) {\n        contents[node] = contentValue;\n        emit ContentChanged(node, contentValue);\n    }\n\n    function chainAddr (bytes32 node, bytes4 chain) public view returns (string memory) {\n        return chainAddresses[node][chain].addr;\n    }\n\n    function setChainAddr (bytes32 node, bytes4 chain, string memory addrValue) public onlyOwner(node) {\n        chainAddresses[node][chain].addr = addrValue;\n        if (chain == RSK_CHAIN_ID) {\n            address _addr = addressHelper.stringToAddress(addrValue);\n            emit AddrChanged(node, _addr);\n        } else {\n            emit ChainAddrChanged(node, chain, addrValue);\n        }\n    }\n\n    function chainMetadata (bytes32 node, bytes4 chain) public view returns (bytes32) {\n        return chainAddresses[node][chain].metadata;\n    }\n\n    function setChainMetadata (bytes32 node, bytes4 chain, bytes32 metadataValue) public onlyOwner(node) {\n        chainAddresses[node][chain].metadata = metadataValue;\n        emit ChainMetadataChanged(node, chain, metadataValue);\n    }\n\n    function chainAddrAndMetadata (bytes32 node, bytes4 chain) public view returns (string memory, bytes32) {\n        ChainAddress storage chainAddress = chainAddresses[node][chain];\n        return (chainAddress.addr, chainAddress.metadata);\n    }\n\n    function setChainAddrWithMetadata (bytes32 node, bytes4 chain, string memory addrValue, bytes32 metadataValue) public onlyOwner(node) {\n        setChainAddr(node, chain, addrValue);\n        setChainMetadata(node, chain, metadataValue);\n    }\n}\n",
      "file": "MultiChainResolver.sol"
    },
    {
      "name": "AbstractAddrResolver.sol",
      "contents": "pragma solidity ^0.5.2;\n\nimport \"./AbstractResolver.sol\";\n\ncontract AbstractAddrResolver is AbstractResolver {\n    function addr(bytes32 node) public view returns (address ret);\n    function setAddr(bytes32 node, address addrValue) public;\n\n    event AddrChanged(bytes32 indexed node, address addr);\n}\n"
    },
    {
      "name": "AbstractMultiChainResolver.sol",
      "contents": "pragma solidity ^0.5.2;\n\nimport \"./AbstractAddrResolver.sol\";\n\ncontract AbstractMultiChainResolver is AbstractAddrResolver {\n    function chainAddr(bytes32 node, bytes4 chain) public view returns (string memory);\n    function setChainAddr(bytes32 node, bytes4 chain, string memory addrValue) public;\n\n    event ChainAddrChanged(bytes32 indexed node, bytes4 chain, string addr);\n}\n"
    },
    {
      "name": "AbstractResolver.sol",
      "contents": "pragma solidity ^0.5.2;\n\ncontract AbstractResolver {\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool);\n}\n"
    },
    {
      "name": "AbstractRNS.sol",
      "contents": "pragma solidity ^0.5.2;\n\ncontract AbstractRNS {\n    function owner(bytes32 node) public view returns(address);\n    function resolver(bytes32 node) public view returns(address);\n    function ttl(bytes32 node) public view returns(uint64);\n    function setOwner(bytes32 node, address ownerAddress) public;\n    function setSubnodeOwner(bytes32 node, bytes32 label, address ownerAddress) public;\n    function setResolver(bytes32 node, address resolverAddress) public;\n    function setTTL(bytes32 node, uint64 ttlValue) public;\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address ownerAddress);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address ownerAddress);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolverAddress);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttlValue);\n}\n"
    },
    {
      "name": "AddressHelper.sol",
      "contents": "pragma solidity ^0.5.2;\n\ncontract AddressHelper {\n    function addressToString (address data) public pure returns (string memory) {\n        bytes memory s = new bytes(42);\n        s[0] = \"0\";\n        s[1] = \"x\";\n        for (uint i = 0; i < 20; i++) {\n            byte b = byte(uint8(uint(data) / (2**(8*(19 - i)))));\n            byte hi = byte(uint8(b) / 16);\n            byte lo = byte(uint8(b) - 16 * uint8(hi));\n            s[2*i + 2] = char(hi);\n            s[2*i + 3] = char(lo);\n        }\n        return string(s);\n    }\n\n    function char (byte b) internal pure returns (byte c) {\n        if (b < 0x0A) return byte(uint8(b) + 0x30);\n        else return byte(uint8(b) + 0x57);\n    }\n\n    // source: https://github.com/riflabs/RIF-Token/blob/master/contracts/util/AddressHelper.sol\n    function stringToAddress(string memory s) public pure returns(address) {\n        bytes memory ss = bytes(s);\n\n        // it should have 40 or 42 characters\n        if (ss.length != 40 && ss.length != 42) revert();\n\n        uint r = 0;\n        uint offset = 0;\n\n        if (ss.length == 42) {\n            offset = 2;\n\n            if (ss[0] != byte('0')) revert();\n            if (ss[1] != byte('x') && ss[1] != byte('X')) revert();\n        }\n\n        uint i;\n        uint x;\n        uint v;\n\n        // loads first 32 bytes from array,\n        // skipping array length (32 bytes to skip)\n        // offset == 0x20\n        assembly { v := mload(add(0x20, ss)) }\n\n        // converts the first 32 bytes, adding to result\n        for (i = offset; i < 32; ++i) {\n            assembly { x := byte(i, v) }\n            r = r * 16 + fromHexChar(x);\n        }\n\n        // loads second 32 bytes from array,\n        // skipping array length (32 bytes to skip)\n        // and first 32 bytes\n        // offset == 0x40\n        assembly { v := mload(add(0x40, ss)) }\n\n        // converts the last 8 bytes, adding to result\n        for (i = 0; i < 8 + offset; ++i) {\n            assembly { x := byte(i, v) }\n            r = r * 16 + fromHexChar(x);\n        }\n\n        return address(r);\n    }\n\n    function fromHexChar(uint c) public pure returns (uint) {\n        if (c >= 0x30 && c <= 0x39) {\n            return c - 0x30;\n        }\n\n        if (c >= 0x61 && c <= 0x66) {\n            return 10 + c - 0x61;\n        }\n\n        if (c >= 0x41 && c <= 0x46) {\n            return 10 + c - 0x41;\n        }\n\n        // Reaching this point means the ordinal is not for a hex char.\n        revert();\n    }\n}"
    },
    {
      "name": "Migrations.sol",
      "contents": "pragma solidity >=0.4.21 <0.6.0;\n\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n"
    },
    {
      "name": "PublicResolver.sol",
      "contents": "pragma solidity ^0.5.2;\n\nimport \"./AbstractRNS.sol\";\n\n/**\n * A simple resolver anyone can use; only allows the owner of a node to set its\n * address.\n */\ncontract PublicResolver {\n    AbstractRNS rns;\n    mapping(bytes32=>address) addresses;\n    mapping(bytes32=>bytes32) hashes;\n\n    modifier only_owner(bytes32 node) {\n        require(rns.owner(node) == msg.sender);\n        _;\n    }\n\n    /**\n     * Constructor.\n     * @param rnsAddr The RNS registrar contract.\n     */\n    constructor(AbstractRNS rnsAddr) public {\n        rns = rnsAddr;\n    }\n\n    /**\n     * Fallback function.\n     */\n    function() payable external {\n        revert();\n    }\n\n    /**\n     * Returns true if the specified node has the specified record type.\n     * @param node The RNS node to query.\n     * @param kind The record type name, as specified in EIP137.\n     * @return True if this resolver has a record of the provided type on the\n     *         provided node.\n     */\n    function has(bytes32 node, bytes32 kind) public view returns (bool) {\n        return  (kind == \"addr\" && addresses[node] != address(0)) ||\n        (kind == \"hash\" && hashes[node] != 0);\n    }\n\n    /**\n     * Returns true if the resolver implements the interface specified by the provided hash.\n     * @param interfaceID The ID of the interface to check for.\n     * @return True if the contract implements the requested interface.\n     */\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\n        return interfaceID == 0x3b3b57de || interfaceID == 0xd8389dc5;\n    }\n\n    /**\n     * Returns the address associated with an RNS node.\n     * @param node The RNS node to query.\n     * @return The associated address.\n     */\n    function addr(bytes32 node) public view returns (address) {\n        return addresses[node];\n    }\n\n    /**\n     * Sets the address associated with an RNS node.\n     * May only be called by the owner of that node in the RNS registry.\n     * @param node The node to update.\n     * @param addrValue The address to set.\n     */\n    function setAddr(bytes32 node, address addrValue) public only_owner(node) {\n        addresses[node] = addrValue;\n    }\n\n    /**\n     * Returns the content hash associated with an RNS node.\n     * Note that this resource type is not standardized, and will likely change\n     * in future to a resource type based on multihash.\n     * @param node The RNS node to query.\n     * @return The associated content hash.\n     */\n    function content(bytes32 node) public view returns (bytes32) {\n        return hashes[node];\n    }\n\n    /**\n     * Sets the content hash associated with an RNS node.\n     * May only be called by the owner of that node in the RNS registry.\n     * Note that this resource type is not standardized, and will likely change\n     * in future to a resource type based on multihash.\n     * @param node The node to update.\n     * @param hash The content hash to set\n     */\n    function setContent(bytes32 node, bytes32 hash) public only_owner(node) {\n        hashes[node] = hash;\n    }\n}\n"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x7c921941463c68a2875b36ec950f9ea412e1a9f6a1c7c56daf102ed8357d6bef",
    "blockNumber": 408857,
    "transactionHash": "0x6e3752fb5e9b0eb3081f18a4338ccb2e86415d239e028e20d9b463dc006350f7",
    "timestamp": 1575041987
  },
  "constructorArguments": [
    "0x7d284aaac6e925aad802a53c0c69efe3764597b8",
    "0x1e7ae43e3503efb886104ace36051ea72b301cdf"
  ]
}