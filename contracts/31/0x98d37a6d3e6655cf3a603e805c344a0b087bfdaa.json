{
  "address": "0x98d37a6d3e6655cf3a603e805c344a0b087bfdaa",
  "net": {
    "id": "31",
    "name": "RSK Testnet"
  },
  "name": "ClubArbistar",
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "metadata",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ]
      }
    }
  },
  "version": "0.6.3+commit.8dda9521",
  "source": "pragma solidity 0.6.3;\n\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ncontract ClubArbistar is Ownable {\n    using SafeMath for uint256;\n\n    address public investor;\n    uint256 public totalROI;\n    uint256 public totalClaimedROI;\n    uint256 public monthlyROI;\n    uint256 public maxROI;\n    uint256 public lastDepositDate;\n    uint256 public lastROIClaimedDate;\n    uint16 public lockDays;\n    uint16 private constant _NUMBER_OF_DAYS_LOCKED = 365;\n    uint256 private constant _NUMBER_OF_MONTHS = 12;\n    uint256 private constant _THIRTY_DAYS = 30;\n\n    event InvestorChanged(address newInvestor);\n    event RoiDeposited(address investor, uint256 amount, uint256 totalStaked);\n    event LogDepositReceived(address sender);\n\n    constructor(address _investor, uint256 _maxROI) public payable\n    {\n        require(address(_investor) != address(0));\n        investor = _investor;\n        lockDays = _NUMBER_OF_DAYS_LOCKED;\n        maxROI = _maxROI; // IMPORTANT: maxROI in wei (eg: 1000000000000000000 == 1 ETH)\n        \n        (bool deposited) = _depositROI(); // make first deposit as the contract is deployed.\n        \n        require(deposited, \"Was not able to make deposit\");\n    }\n\n    modifier onlyInvestor () \n    {\n        require(investor == msg.sender, \"Sender is not the investor\");\n        _;\n    }\n\n    modifier isActive ()\n    {\n        require(daysPassedSince(lastDepositDate) <= _NUMBER_OF_DAYS_LOCKED, \"This contract is finished, please request your investment back\");\n        _;\n    }\n\n    modifier isFinished ()\n    {\n        require(daysPassedSince(lastDepositDate) > _NUMBER_OF_DAYS_LOCKED, \"This contract is not finished yet\");\n        _;\n    }\n\n    function _depositROI () internal returns (bool)\n    {\n        require(msg.value > 0, \"ROI value must be greater then zero\");\n        require(msg.value + totalROI <= maxROI, \"Cannot deposit more ROI then maxROI\");\n        \n        uint256 previousTotalROI = totalROI;\n        totalROI = totalROI.add(msg.value);\n        monthlyROI = totalROI.div(_NUMBER_OF_MONTHS);\n\n        lastDepositDate = now; // resets the locked days\n        \n        assert((totalROI - previousTotalROI) == msg.value); // makes sure that the value is right\n        \n        emit RoiDeposited(msg.sender, msg.value, totalROI);\n        return true;\n    }\n\n    function depositROI () external payable onlyOwner isActive returns (bool)\n    {\n        return _depositROI();\n    }\n    \n\n    function claimROI () external onlyInvestor isActive returns (uint256)\n    {\n        require(daysPassedSince(lastDepositDate) >= _THIRTY_DAYS, \"ROI claim not available yet\");\n        require(daysPassedSince(lastROIClaimedDate) >= _THIRTY_DAYS, \"ROI claim not available yet\");\n\n        uint availableClaims = daysPassedSince(lastROIClaimedDate) / _THIRTY_DAYS; // number of claims available\n        uint256 claimed = monthlyROI * availableClaims; \n\n        require(claimed <= totalROI, \"Not enough ROI to claim\");                \n        \n        (bool paid, ) = msg.sender.call.value(claimed)(\"\"); // make the payment\n        \n        require(paid, \"Transfer failed, could not make payment\");\n        \n        totalROI -= claimed; // remove claimed roi from total available\n        totalClaimedROI += claimed; // add this claim to total claimed ROI\n        lastROIClaimedDate = now; // updates da last ROI claim date to now\n        return claimed;\n    }\n\n    function claimRefund () external onlyInvestor returns (uint256)\n    {\n        bool antecipated = false;\n        \n        if (daysPassedSince(lastDepositDate) < _NUMBER_OF_DAYS_LOCKED) {\n            antecipated = true;\n        }\n    \n        return 0;\n    }\n\n    function withdraw () external onlyOwner isFinished returns (uint256)\n    {\n        (bool paid, ) = msg.sender.call.value(address(this).balance)(\"\"); // make the payment\n        require(paid, \"Transfer failed, could not make payment\");\n    }\n    \n    function changeInvestor (address newInvestor) external onlyInvestor\n    {\n        require(newInvestor != address(0), \"New investor has zero address.\");\n        investor = newInvestor;\n        emit InvestorChanged(newInvestor);\n    }\n    \n    function getBalance () external view returns ( uint256 )\n    {\n        return address(this).balance;\n    }\n    \n    function daysPassedSince (uint date) internal view returns ( uint )\n    {\n        require(date <= now, \"Cannot get days passed from a date in the future\");\n        return (now - date) / 60 / 60 / 24; \n    }\n    \n    function getDaysRemaining () external view returns ( uint )\n    {\n        return lockDays - daysPassedSince(lastDepositDate);\n    }\n\n    receive () payable external\n    { \n        require(msg.data.length == 0); \n        emit LogDepositReceived(msg.sender); \n    }\n    \n    fallback () payable external\n    { \n        require(msg.data.length == 0); \n        emit LogDepositReceived(msg.sender); \n    }\n\n}\n\n\n",
  "imports": [
    {
      "name": "ArbicorpInvestment.sol",
      "contents": "pragma solidity 0.6.3;\n\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ncontract ClubArbistar is Ownable {\n    using SafeMath for uint256;\n\n    address public investor;\n    uint256 public totalROI;\n    uint256 public totalClaimedROI;\n    uint256 public monthlyROI;\n    uint256 public maxROI;\n    uint256 public lastDepositDate;\n    uint256 public lastROIClaimedDate;\n    uint16 public lockDays;\n    uint16 private constant _NUMBER_OF_DAYS_LOCKED = 365;\n    uint256 private constant _NUMBER_OF_MONTHS = 12;\n    uint256 private constant _THIRTY_DAYS = 30;\n\n    event InvestorChanged(address newInvestor);\n    event RoiDeposited(address investor, uint256 amount, uint256 totalStaked);\n    event LogDepositReceived(address sender);\n\n    constructor(address _investor, uint256 _maxROI) public payable\n    {\n        require(address(_investor) != address(0));\n        investor = _investor;\n        lockDays = _NUMBER_OF_DAYS_LOCKED;\n        maxROI = _maxROI; // IMPORTANT: maxROI in wei (eg: 1000000000000000000 == 1 ETH)\n        \n        (bool deposited) = _depositROI(); // make first deposit as the contract is deployed.\n        \n        require(deposited, \"Was not able to make deposit\");\n    }\n\n    modifier onlyInvestor () \n    {\n        require(investor == msg.sender, \"Sender is not the investor\");\n        _;\n    }\n\n    modifier isActive ()\n    {\n        require(daysPassedSince(lastDepositDate) <= _NUMBER_OF_DAYS_LOCKED, \"This contract is finished, please request your investment back\");\n        _;\n    }\n\n    modifier isFinished ()\n    {\n        require(daysPassedSince(lastDepositDate) > _NUMBER_OF_DAYS_LOCKED, \"This contract is not finished yet\");\n        _;\n    }\n\n    function _depositROI () internal returns (bool)\n    {\n        require(msg.value > 0, \"ROI value must be greater then zero\");\n        require(msg.value + totalROI <= maxROI, \"Cannot deposit more ROI then maxROI\");\n        \n        uint256 previousTotalROI = totalROI;\n        totalROI = totalROI.add(msg.value);\n        monthlyROI = totalROI.div(_NUMBER_OF_MONTHS);\n\n        lastDepositDate = now; // resets the locked days\n        \n        assert((totalROI - previousTotalROI) == msg.value); // makes sure that the value is right\n        \n        emit RoiDeposited(msg.sender, msg.value, totalROI);\n        return true;\n    }\n\n    function depositROI () external payable onlyOwner isActive returns (bool)\n    {\n        return _depositROI();\n    }\n    \n\n    function claimROI () external onlyInvestor isActive returns (uint256)\n    {\n        require(daysPassedSince(lastDepositDate) >= _THIRTY_DAYS, \"ROI claim not available yet\");\n        require(daysPassedSince(lastROIClaimedDate) >= _THIRTY_DAYS, \"ROI claim not available yet\");\n\n        uint availableClaims = daysPassedSince(lastROIClaimedDate) / _THIRTY_DAYS; // number of claims available\n        uint256 claimed = monthlyROI * availableClaims; \n\n        require(claimed <= totalROI, \"Not enough ROI to claim\");                \n        \n        (bool paid, ) = msg.sender.call.value(claimed)(\"\"); // make the payment\n        \n        require(paid, \"Transfer failed, could not make payment\");\n        \n        totalROI -= claimed; // remove claimed roi from total available\n        totalClaimedROI += claimed; // add this claim to total claimed ROI\n        lastROIClaimedDate = now; // updates da last ROI claim date to now\n        return claimed;\n    }\n\n    function claimRefund () external onlyInvestor returns (uint256)\n    {\n        bool antecipated = false;\n        \n        if (daysPassedSince(lastDepositDate) < _NUMBER_OF_DAYS_LOCKED) {\n            antecipated = true;\n        }\n    \n        return 0;\n    }\n\n    function withdraw () external onlyOwner isFinished returns (uint256)\n    {\n        (bool paid, ) = msg.sender.call.value(address(this).balance)(\"\"); // make the payment\n        require(paid, \"Transfer failed, could not make payment\");\n    }\n    \n    function changeInvestor (address newInvestor) external onlyInvestor\n    {\n        require(newInvestor != address(0), \"New investor has zero address.\");\n        investor = newInvestor;\n        emit InvestorChanged(newInvestor);\n    }\n    \n    function getBalance () external view returns ( uint256 )\n    {\n        return address(this).balance;\n    }\n    \n    function daysPassedSince (uint date) internal view returns ( uint )\n    {\n        require(date <= now, \"Cannot get days passed from a date in the future\");\n        return (now - date) / 60 / 60 / 24; \n    }\n    \n    function getDaysRemaining () external view returns ( uint )\n    {\n        return lockDays - daysPassedSince(lastDepositDate);\n    }\n\n    receive () payable external\n    { \n        require(msg.data.length == 0); \n        emit LogDepositReceived(msg.sender); \n    }\n    \n    fallback () payable external\n    { \n        require(msg.data.length == 0); \n        emit LogDepositReceived(msg.sender); \n    }\n\n}\n\n\n",
      "file": "ArbicorpInvestment.sol"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0xf57cb02629b03bb6d9b1cee0ae4b4f4ce3b2e1232cca23042ad75f485d0ef987",
    "blockNumber": 1224151,
    "transactionHash": "0x195a2aceb114c1228879860f1cd54f0d38cfeded4a84fab1e4259a4323144d31",
    "timestamp": 1601640438
  },
  "constructorArguments": [
    "0x4ddd18d0bb4a9c2fe1f3489b62d3d68a0e31753a",
    "100000000000000000"
  ]
}