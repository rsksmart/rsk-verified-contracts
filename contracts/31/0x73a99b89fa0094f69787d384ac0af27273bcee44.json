{
    "address": "0x73a99b89fa0094f69787d384ac0af27273bcee44",
    "net": {
        "id": "31",
        "name": "RSK Testnet"
    },
    "name": "VestingFactory",
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        }
    },
    "version": "0.6.12+commit.27d51765",
    "source": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\n\ninterface IRegistry {\n    // *** Getter Methods ***\n    function getDecimal(bytes32 _key) external view returns (int232 base, int16 exp);\n\n    function getUint(bytes32 _key) external view returns (uint248);\n\n    function getString(bytes32 _key) external view returns (string memory);\n\n    function getAddress(bytes32 _key) external view returns (address);\n\n    function getBytes(bytes32 _key) external view returns (bytes memory);\n\n    function getBool(bytes32 _key) external view returns (bool);\n\n    function getInt(bytes32 _key) external view returns (int248);\n\n    // *** Setter Methods ***\n    function setDecimal(\n        bytes32 _key,\n        int232 _base,\n        int16 _exp\n    ) external;\n\n    function setUint(bytes32 _key, uint248 _value) external;\n\n    function setString(bytes32 _key, string calldata _value) external;\n\n    function setAddress(bytes32 _key, address _value) external;\n\n    function setBytes(bytes32 _key, bytes calldata _value) external;\n\n    function setBool(bytes32 _key, bool _value) external;\n\n    function setInt(bytes32 _key, int248 _value) external;\n\n    // *** Delete Methods ***\n    function deleteDecimal(bytes32 _key) external;\n\n    function deleteUint(bytes32 _key) external;\n\n    function deleteString(bytes32 _key) external;\n\n    function deleteAddress(bytes32 _key) external;\n\n    function deleteBytes(bytes32 _key) external;\n\n    function deleteBool(bytes32 _key) external;\n\n    function deleteInt(bytes32 _key) external;\n}\n\n\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n    /**\n      @notice Override this function with a recipe of the changes to be done when this ChangeContract\n      is executed\n     */\n    function execute() external;\n}\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor {\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @dev This function should be protected somehow to only execute changes that\n      benefit the system. This decision process is independent of this architechture\n      therefore is independent of this interface too\n      @param changeContract Address of the contract that will execute the changes\n     */\n    function executeChange(ChangeContract changeContract) external;\n\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @param _changer Address of the contract that will execute the changes\n     */\n    function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed {\n    /**\n      @notice The address of the contract which governs this one\n     */\n    IGovernor public governor;\n\n    string private constant NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n    /**\n      @notice Modifier that protects the function\n      @dev You should use this modifier in any function that should be called through\n      the governance system\n     */\n    modifier onlyAuthorizedChanger() {\n        require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n        _;\n    }\n\n    /**\n      @notice Initialize the contract with the basic settings\n      @dev This initialize replaces the constructor but it is not called automatically.\n      It is necessary because of the upgradeability of the contracts\n      @param _governor Governor address\n     */\n    function _initialize(IGovernor _governor) internal {\n        governor = _governor;\n    }\n\n    /**\n      @notice Change the contract's governor. Should be called through the old governance system\n      @param newIGovernor New governor address\n     */\n    function changeIGovernor(IGovernor newIGovernor) external onlyAuthorizedChanger {\n        governor = newIGovernor;\n    }\n\n    /**\n      @notice This method is used by a change contract to access the storage freely even without a setter.\n      @param data the serialized function arguments\n     */\n    function delegateCallToChanger(bytes calldata data)\n        external\n        onlyAuthorizedChanger\n        returns (bytes memory)\n    {\n        address changerContrat = msg.sender;\n        (bool success, bytes memory result) = changerContrat.delegatecall(\n            abi.encodeWithSignature(\"impersonate(bytes)\", data)\n        );\n        require(success, \"Error in delegate call\");\n        return result;\n    }\n\n    // Leave a gap betweeen inherited contracts variables in order to be\n    // able to add more variables in them later\n    uint256[50] private upgradeGap;\n}\n\n\n\ninterface IVestingMachine {\n    /// @notice Retrieve vesting parameters\n    function getParameters() external view returns (uint256[] memory, uint256[] memory);\n\n    /// @notice Mark contract as verified by holder\n    function verify() external;\n\n    /// @notice Returns current holder address\n    function getHolder() external view returns (address);\n\n    /// @notice Calls a function from target passing data\n    /// @param target Target contract to call (must be one of: staking, vesting or voting machine)\n    /// @param data Data to pass target contract\n    function callWithData(address target, bytes memory data) external;\n\n    /// @notice approve a transfer to the staking machine.\n    /// @param amount Token amount to approve\n    function approve(uint256 amount) external;\n\n    /// @notice deposit MOCs in the staking machine\n    /// @param amount Token amount to approve\n    function deposit(uint256 amount) external;\n\n    /// @notice Withdraws tokens to holder address\n    /// @param amount Tokens amount to withdraw\n    /// @return Returns true on success\n    function withdraw(uint256 amount) external returns (bool);\n\n    /// @notice Withdraws all available tokens to holder address\n    /// @return Returns true on success\n    function withdrawAll() external returns (bool);\n\n    /// @notice Minimum token amount required to be locked\n    /// @param timestamp date to check\n    function getLockedAt(uint256 timestamp) external view returns (uint256);\n\n    /// @notice Minimum token amount required to be locked\n    function getLocked() external view returns (uint256);\n\n    /// @notice Token amount available for withdrawal\n    function getAvailable() external view returns (uint256);\n\n    /// @notice Returns true after contract has been verified by holder\n    function isVerified() external view returns (bool);\n\n    /// @notice Total token balance configured\n    function getTotal() external view returns (uint256);\n\n    /// @notice Change holder address\n    /// @param newHolder the new holder (only can be called by governance)\n    function setHolder(address newHolder) external;\n\n    /// @notice Configure vesting total balance (only can be called by factory)\n    function setTotal(uint256 amount) external;\n}\n\n\ninterface IVestingFactory {\n    /// @notice Create a holder wallet\n    /// @param holder wallet's owner\n    /// @param percentages percentages allowed in each step\n    /// @param timedeltas duration of each step\n    function create(\n        address holder,\n        uint256[] memory percentages,\n        uint256[] memory timedeltas\n    ) external;\n\n    /// @notice Set the TGE time enabling holder wallets\n    function setTGE() external;\n\n    /// @notice Returns true when the TGE was configured\n    function isTGEConfigured() external view returns (bool);\n\n    /// @notice Returns the configured TGE timestamp\n    function getTGETimestamp() external view returns (uint256);\n\n    /// @notice Set a holder wallet balance\n    /// @param wallet the vesting machine\n    /// @param amount wallet balance\n    function setTotal(IVestingMachine wallet, uint256 amount) external;\n\n    /// @notice Return registry\n    function getRegistry() external view returns (IRegistry);\n\n    /// @notice Get the length of the list of vesting machines\n    function getVestingMachinesLen() external view returns (uint256);\n\n    /// @notice Get the an entry of the list of vesting machines\n    /// @param idx the index in the list\n    function getVestingMachinesEntry(uint256 idx) external view returns (address);\n}\n\n\n// prettier-ignore\n\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract ContextUpgradeSafe is Initializable {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n\n\n    }\n\n\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n\n    uint256[50] private __gap;\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract OwnableUpgradeSafe is Initializable, ContextUpgradeSafe {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n\n\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n\n    }\n\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    uint256[49] private __gap;\n}\n\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n\n\n\n/// @title This contract provides an interface for feeding prices from oracles, and\n///        get the current price. One contract must be instanced per supported coin pair,\n///        and registered through OracleManager global contract.\n/// This contract has two lists:\n/// 1) A subscribed list (EnumerableSet.AddressSet) oracles owner addresses, this list has a max size (30).\n/// 2) A selected list, EnumerableSet.AddressSet of oracles owner addresses that are selected to participate in\n/// current publication round (10 entries max size).\n///\n/// Oracles are subscribed by adding them to the subscribed oracle list. When the list is full\n/// the oracle with less stake can be removed by a new oracle that is trying to\n/// subscribe (if its stake is greater than his).\n/// On each round switch the list of selected oracles is populated with the 10 Oracles with more stake. An oracle\n/// can unsubscribe itself from the subscribed list in the middle of the round, in this case, the oracle is still\n/// listed in the selected list until the round ends.\n/// If an oracle withdraw some stake then his participation in the round is put into consideration: If the\n/// oracle ends up having less stake than the next oracle in the subscribed list (but not in the selected list) then\n/// it is removed from the selected list and the point he accumulated during the round are lost (set to zero).\n\ninterface ICoinPairPrice {\n    // getOracleOwnerAddress: Given an Oracle address return the Oracle Owner address.\n    // Used during publication, the servers sign with the oracle address, but the list of selected oracles\n    // is by oracle owner address.\n    // getOracleOwnerStake: Get the stake stored in the supporters smart-contract\n    // prettier-ignore\n    struct CoinPairPriceCallbacks {\n        function (address) external view returns (address) getOracleOwnerAddress;\n        function (address) external view returns (uint256) getOracleOwnerStake;\n    }\n\n    /// @notice subscribe an oracle to this coin pair, allowing it to be selected in the next round.\n    /// If the subscribed list is full and the current oracle has more stake than one with minimum stake in the\n    /// subscribed list, then the one with minimum stake is replaced.\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\n    /// @dev This is designed to be called from OracleManager.\n    function subscribe(address oracleOwnerAddr) external;\n\n    /// @notice Unsubscribe an oracle from this coin pair. The oracle won't be selected in the next round.\n    /// After the round end, the oracle can withdraw stake without having the risk of loosing won points.\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\n    /// @dev This is designed to be called from OracleManager.\n    function unsubscribe(address oracleOwnerAddr) external;\n\n    /// @notice Returns true if an oracle is subscribed to this contract' coin pair\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\n    /// @dev This is designed to be called from OracleManager.\n    function isSubscribed(address oracleOwnerAddr) external view returns (bool);\n\n    /// @notice Publish a price. (The message contain oracleAddresses that must be converted to owner addresses).\n    /// @param _version Version number of message format (3)\n    /// @param _coinpair The coin pair to report (must match this contract)\n    /// @param _price Price to report.\n    /// @param _votedOracle The address of the oracle voted as a publisher by the network.\n    /// @param _blockNumber The blocknumber acting as nonce to prevent replay attacks.\n    /// @param _sigV The array of V-component of Oracle signatures.\n    /// @param _sigR The array of R-component of Oracle signatures.\n    /// @param _sigS The array of S-component of Oracle signatures.\n    function publishPrice(\n        uint256 _version,\n        bytes32 _coinpair,\n        uint256 _price,\n        address _votedOracle,\n        uint256 _blockNumber,\n        uint8[] calldata _sigV,\n        bytes32[] calldata _sigR,\n        bytes32[] calldata _sigS\n    ) external;\n\n    /// @notice Publish a price without signature validation (when there is an emergecy!!!).\n    /// @param _price Price to report.\n    function emergencyPublish(uint256 _price) external;\n\n    /// @notice The oracle owner has withdrawn some stake.\n    /// Must check if the oracle is part of current round and if he lost his place with the\n    /// new stake value (the stake is global and is saved in the supporters contract).\n    /// @param oracleOwnerAddr the oracle owner that is trying to withdraw\n    function onWithdraw(address oracleOwnerAddr) external returns (uint256);\n\n    /// @notice Switch contract context to a new round. With the objective of\n    /// being a decentralized solution, this can be called by *anyone* if current\n    /// round lock period is expired.\n    /// This method search the subscribed list and choose the 10 with more stake.\n    function switchRound() external;\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS\n\n    /// @notice Return the available reward fees\n    ///\n    function getAvailableRewardFees() external view returns (uint256);\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS TO GET CURRENT PRICE\n    // MUST BE WHITELISTED\n    /// @notice Return the current price, compatible with old MOC Oracle\n    function peek() external view returns (bytes32, bool);\n\n    /// @notice Return the current price\n    function getPrice() external view returns (uint256);\n\n    ///////////////////////////////////////////////////////////////////////////////// GETTERS TO GET CURRENT PRICE END\n\n    /// @notice Return current round information\n    function getRoundInfo()\n        external\n        view\n        returns (\n            uint256 round,\n            uint256 startBlock,\n            uint256 lockPeriodTimestamp,\n            uint256 totalPoints,\n            address[] memory selectedOwners,\n            address[] memory selectedOracles\n        );\n\n    /// @notice Return round information for specific oracle\n    function getOracleRoundInfo(address addr)\n        external\n        view\n        returns (uint256 points, bool selectedInCurrentRound);\n\n    // The maximum count of oracles selected to participate each round\n    function maxOraclesPerRound() external view returns (uint256);\n\n    // The round lock period in secs\n    function roundLockPeriodSecs() external view returns (uint256);\n\n    function isOracleInCurrentRound(address oracleAddr) external view returns (bool);\n\n    /// @notice Returns the amount of oracles subscribed to this coin pair.\n    function getSubscribedOraclesLen() external view returns (uint256);\n\n    /// @notice Returns the oracle owner address that is subscribed to this coin pair\n    /// @param idx index to query.\n    function getSubscribedOracleAtIndex(uint256 idx) external view returns (address ownerAddr);\n\n    // Public variable\n    function getMaxSubscribedOraclesPerRound() external view returns (uint256);\n\n    // Public variable\n    function getCoinPair() external view returns (bytes32);\n\n    // Public variable\n    function getLastPublicationBlock() external view returns (uint256);\n\n    // Public variable\n    function getValidPricePeriodInBlocks() external view returns (uint256);\n\n    // Public variable\n    function getEmergencyPublishingPeriodInBlocks() external view returns (uint256);\n\n    // Public variable\n    function getOracleManager() external view returns (IOracleManager);\n\n    // Public variable\n    function getToken() external view returns (IERC20);\n}\n\n\n/// This contract manages the Oracle and CoinPair registration info.\n/// The Oracle python server interacts with this contract:\n/// - Coin pair registration\n/// - Oracle registration to coin pairs\n/// - Access Oracle info (oracle address + url) indexed by oracle owner address\n/// - Get the oracle information (url + the specifics of some coin pair rounds) from an oracle address\n/// - Get the oracle address from the owner address.\ninterface IOracleManager {\n    // getOracleOwnerStake: Get the stake stored in the supporters smart-contract\n    // prettier-ignore\n    struct OracleManagerCallbacks {\n        function (address) external view returns (uint256) getOracleOwnerStake;\n    }\n\n    /// @notice Register a new coin pair contract (the contract must be created separately).\n    /// Once created the coin pairs cannot be removed.\n    /// @param coinPair The bytes32-encoded coinpair string (e.g. BTCUSD)\n    /// @param addr The contract address associated to the coin pair.\n    function registerCoinPair(bytes32 coinPair, address addr) external;\n\n    /// Register an oracle in the system must be called by the oracle owner.\n    /// @notice Registers the oracle and transfer the specified caller's MOC token stake.\n    /// @param oracleOwnerAddr The address of the owner of the oracle.\n    /// @param oracleAddr Address of the Oracle to register.\n    /// @param internetName Public Internet name of this Oracle.\n    function registerOracle(\n        address oracleOwnerAddr,\n        address oracleAddr,\n        string calldata internetName\n    ) external;\n\n    /// @notice Change the oracle \"internet\" name (URI), called by the owner.\n    /// @param oracleOwnerAddr The address of the owner of the oracle.\n    /// @param name The new name to set.\n    function setOracleName(address oracleOwnerAddr, string calldata name) external;\n\n    /// @notice Change the oracle address, called by the owner.\n    /// @param oracleOwnerAddr The address of the owner of the oracle.\n    /// @param oracleAddr new value for the address of the oracle\n    function setOracleAddress(address oracleOwnerAddr, address oracleAddr) external;\n\n    /// @notice Removes the oracle registration info. Must be called by the owner\n    /// The oracle must be previously unregistered from all coin pairs.\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\n    function removeOracle(address oracleOwnerAddr) external;\n\n    /// @notice Subscribe a registered oracle to participate in the next round of a registered coin-pair.\n    /// @param oracleOwnerAddr Address of oracle owner\n    function subscribeToCoinPair(address oracleOwnerAddr, bytes32 coinPair) external;\n\n    /// @notice Unsubscribe a registered oracle from participating in rounds of a registered coin-pair.\n    /// The oracle is flagged so it is not selected in the next round.\n    /// @param oracleOwnerAddr Address of oracle owner\n    function unSubscribeFromCoinPair(address oracleOwnerAddr, bytes32 coinPair) external;\n\n    /// @notice The oracle owner did a partial withdrawal of funds\n    /// 1. The oracle address is searched by the owner address.\n    /// 2. Each coin pair to which the oracle is subscribed is consulted to:\n    ///   - Check if the new amount is enough to stay in the current round.\n    ///       If not the oracle is replaced and lost his points.\n    ///   - Get the timestamp for the round end.\n    /// The return value is the maximum timestamp from all the coin pairs.\n    /// @param oracleOwnerAddr Address of oracle owner\n    /// @return the timestamp until which the funds must be locked.\n    function onWithdraw(address oracleOwnerAddr) external returns (uint256);\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS USED BY COINPAIR\n    /// @notice Used by the coin pair to get the oracle address from the oracleOwnerAddress.\n    /// @param  oracleOwnerAddr the address of the owner of the oracle.\n    /// @return oracleAddr Address of oracle\n    function getOracleAddress(address oracleOwnerAddr) external view returns (address oracleAddr);\n\n    /// @notice Returns true if oracle is registered.\n    /// @param ownerAddr The address of the oracle's owner.\n    function isRegistered(address ownerAddr) external view returns (bool);\n\n    /// @notice Used by CoinPair\n    /// @param oracleAddr The oracle address not the owner address.\n    function getOracleOwner(address oracleAddr) external view returns (address);\n\n    /// @notice Returns the amount of owners registered.\n    function getRegisteredOraclesLen() external view returns (uint256);\n\n    /// @notice Returns the oracle name and address at index.\n    /// @param idx index to query.\n    function getRegisteredOracleAtIndex(uint256 idx)\n        external\n        view\n        returns (\n            address ownerAddr,\n            address oracleAddr,\n            string memory url\n        );\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS USED BY COINPAIR END\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS\n\n    // TODO: Check what is the minimum amount of getters the python server needs.\n\n    /// @notice Returns true if an oracle is subscribed to a coin pair\n    function isSubscribed(address oracleAddr, bytes32 coinPair) external view returns (bool);\n\n    /// @notice Return true if the oracle is registered on this coin-pair\n    /// @param oracleAddr addr The address of the Oracle check for.\n    function isOracleRegistered(address oracleAddr) external view returns (bool);\n\n    /// @notice Returns registration information for a registered Oracle.\n    /// @param oracleAddr addr The address of the Oracle to query for.\n    function getOracleRegistrationInfo(address oracleAddr)\n        external\n        view\n        returns (\n            string memory internetName,\n            uint256 stake,\n            address _owner\n        );\n\n    /// @notice Returns round information for a registered oracle in a specific coin-pair.\n    /// @param oracleAddr address of the oracle to query for.\n    /// @param coinpair The coin pair to lookup.\n    function getOracleRoundInfo(address oracleAddr, bytes32 coinpair)\n        external\n        view\n        returns (uint256 points, bool selectedInCurrentRound);\n\n    /// @notice Returns true if an oracle satisfies conditions to be removed from system.\n    /// @param oracleAddr the oracle address to lookup.\n    function canRemoveOracle(address oracleAddr) external view returns (bool);\n\n    /// @notice Get the stake in MOCs that an oracle has.\n    /// @param oracleAddr The address of the oracle.\n    function getStake(address oracleAddr) external view returns (uint256 balance);\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTER TO LIST COIN PAIRS\n\n    /// @notice Returns the count of registered coin pairs.\n    /// Keep in mind that Deleted coin-pairs will contain zeroed addresses.\n    function getCoinPairCount() external view returns (uint256);\n\n    /// @notice Returns the coin pair at index.\n    /// @param i index to query.\n    function getCoinPairAtIndex(uint256 i) external view returns (bytes32);\n\n    /// @notice Return the contract address for a specified registered coin pair.\n    /// @param coinpair Coin-pair string to lookup (e.g: BTCUSD)\n    /// @return address Address of contract or zero if does not exist or was deleted.\n    function getContractAddress(bytes32 coinpair) external view returns (address);\n\n    /// @notice Searches a coinpair in coinPairList\n    /// @param coinPair The bytes32-encoded coinpair string (e.g. BTCUSD)\n    /// @param hint Optional hint to start traversing the coinPairList array, zero is to search all the array.\n    function getCoinPairIndex(bytes32 coinPair, uint256 hint) external view returns (uint256);\n\n    function getMaxStake(address[] calldata addresses) external view returns (address, uint256);\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTER TO LIST COIN PAIRS END\n\n    // Public variable\n    function getStakingContract() external view returns (IStakingMachine);\n\n    // Public variable\n    function getMinCPSubscriptionStake() external view returns (uint256);\n}\n\n\n\ninterface IDelayMachine {\n    /// @notice Accept a deposit from an account.\n    /// @param mocs token quantity\n    /// @param expiration the expiration date for this deposit\n    /// @return id the transaction id\n    function deposit(\n        uint256 mocs,\n        address destination,\n        uint256 expiration\n    ) external returns (uint256 id);\n\n    /// @notice Cancel a transaction returning the funds to the source\n    /// @param id transaction id\n    function cancel(uint256 id) external;\n\n    /// @notice Withdraw stake, send it to the delay machine.\n    /// @param id transaction id\n    function withdraw(uint256 id) external;\n\n    /// @notice Returns the list of transaction for some account\n    /// @return ids transaction ids\n    /// @return amounts token quantity\n    /// @return expirations expiration dates\n    function getTransactions(address account)\n        external\n        view\n        returns (\n            uint256[] memory ids,\n            uint256[] memory amounts,\n            uint256[] memory expirations\n        );\n\n    /// @notice Returns the total balance in MOCs for an account\n    function getBalance(address account) external view returns (uint256);\n\n    // Public variable\n    function getToken() external view returns (IERC20);\n\n    // Public variable\n    function getLastId() external view returns (uint256);\n\n    // Public variable\n    function getSource() external view returns (address);\n}\n\n\ninterface IStakingMachine {\n    /// @notice Used by the voting machine to lock the current balance of MOCs.\n    /// @param mocHolder the moc holder whose mocs will be locked.\n    /// @param untilTimestamp timestamp until which the mocs will be locked.\n    function lockMocs(address mocHolder, uint256 untilTimestamp) external;\n\n    /// @notice Accept a deposit from an account.\n    /// Delegate to the Supporters smart contract.\n    /// @param mocs token quantity\n    /// @param destination the destination account of this deposit.\n    function deposit(uint256 mocs, address destination) external;\n\n    /// @notice Accept a deposit from an account.\n    /// @param mocs token quantity\n    /// @param destination the destination account of this deposit.\n    /// @param source the address that approved the transfer\n    function depositFrom(\n        uint256 mocs,\n        address destination,\n        address source\n    ) external;\n\n    /// @notice Withdraw stake, send it to the delay machine.\n    /// @param mocs token quantity\n    function withdraw(uint256 mocs) external;\n\n    /// @notice Reports the balance of MOCs for a specific user.\n    /// @param user user address\n    function getBalance(address user) external view returns (uint256);\n\n    /// @notice Reports the locked balance of MOCs for a specific user.\n    /// @param user user address\n    function getLockedBalance(address user) external view returns (uint256);\n\n    /// @notice Reports the balance of locked MOCs for a specific user.\n    /// Delegates to the Supporters smart contract.\n    /// @param user user address\n    /// @return amount the amount of mocs locked\n    /// @return untilTimestamp the timestamp that corresponds to the locking date.\n    function getLockingInfo(address user)\n        external\n        view\n        returns (uint256 amount, uint256 untilTimestamp);\n\n    // Public variable\n    function getSupporters() external view returns (address);\n\n    // Public variable\n    function getOracleManager() external view returns (IOracleManager);\n\n    // Public variable\n    function getMocToken() external view returns (IERC20);\n\n    // Public variable\n    function getDelayMachine() external view returns (IDelayMachine);\n\n    // Public variable\n    function getWithdrawLockTime() external view returns (uint256);\n}\n\ninterface IStakingMachineOracles {\n    /// @notice Register an oracle\n    /// @param oracleAddr address of the oracle (from which we publish prices)\n    /// @param url url used by the oracle server\n    function registerOracle(address oracleAddr, string calldata url) external;\n\n    /// @notice Change the oracle \"internet\" name (URI)\n    /// @param url The new url to set.\n    function setOracleName(string calldata url) external;\n\n    /// @notice Change the oracle address\n    /// @param oracleAddr The new oracle address\n    function setOracleAddress(address oracleAddr) external;\n\n    /// @notice Return true if the oracle is registered.\n    /// @param oracleAddr addr The address of the Oracle check for.\n    function isOracleRegistered(address oracleAddr) external view returns (bool);\n\n    /// @notice Returns true if an oracle satisfies conditions to be removed from system.\n    /// @param oracleAddr the oracle address to lookup.\n    function canRemoveOracle(address oracleAddr) external view returns (bool);\n\n    /// @notice Remove an oracle.\n    function removeOracle() external;\n\n    /// @notice Returns the count of registered coin pairs.\n    /// Keep in mind that Deleted coin-pairs will contain zeroed addresses.\n    function getCoinPairCount() external view returns (uint256);\n\n    /// @notice Returns the coin pair at index.\n    /// @param i index to query.\n    function getCoinPairAtIndex(uint256 i) external view returns (bytes32);\n\n    /// @notice Return the contract address for a specified registered coin pair.\n    /// @param coinpair Coin-pair string to lookup (e.g: BTCUSD)\n    /// @return address Address of contract or zero if does not exist or was deleted.\n    function getContractAddress(bytes32 coinpair) external view returns (address);\n\n    /// @notice Searches a coinpair in coinPairList\n    /// @param coinPair The bytes32-encoded coinpair string (e.g. BTCUSD)\n    /// @param hint Optional hint to start traversing the coinPairList array, zero is to search all the array.\n    function getCoinPairIndex(bytes32 coinPair, uint256 hint) external view returns (uint256);\n\n    /// @notice Subscribe an oracle to a coin pair.\n    /// @param coinPair coin pair to subscribe, for example BTCUSD\n    function subscribeToCoinPair(bytes32 coinPair) external;\n\n    /// @notice Unsubscribe an oracle from a coin pair.\n    /// @param coinPair coin pair to unsubscribe, for example BTCUSD\n    function unSubscribeFromCoinPair(bytes32 coinPair) external;\n\n    /// @notice Returns true if an oracle is subscribed to a coin pair\n    /// @param oracleAddr address of the oracle\n    /// @param coinPair coin pair to unsubscribe, for example BTCUSD\n    function isSubscribed(address oracleAddr, bytes32 coinPair) external view returns (bool);\n\n    /// @notice Returns the amount of owners registered.\n    /// Delegates to the Oracle Manager smart contract.\n    function getRegisteredOraclesLen() external view returns (uint256);\n\n    /// @notice Returns the oracle name and address at index.\n    /// Delegates to the Oracle Manager smart contract.\n    /// @param idx index to query.\n    function getRegisteredOracleAtIndex(uint256 idx)\n        external\n        view\n        returns (\n            address ownerAddr,\n            address oracleAddr,\n            string memory url\n        );\n}\n\n\ninterface IVotingMachine {\n    /**\n        get current contract state\n        */\n    function getState() external view returns (uint256);\n\n    /**\n        return the current voting round\n        */\n    function getVotingRound() external view returns (uint256);\n\n    /**\n    Pre Vote a proposal\n\n    @param _proposal Address of the change contract that will be executed if this vote is successful\n    */\n    function preVote(address _proposal) external;\n\n    /**\n    Vote a proposal\n\n    @param _inFavorAgainst Type of vote\n    */\n    function vote(bool _inFavorAgainst) external;\n\n    /**\n    There is a veto Condition\n\n    */\n    function vetoCondition() external;\n\n    /**\n    Veto\n    */\n    function veto() external;\n\n    function readyToPreVoteStep() external view returns (bool);\n\n    /**\n    preVoteStep\n    */\n    function preVoteStep() external;\n\n    function readyToVoteStep() external view returns (bool);\n\n    /**\n    voteStep\n    */\n    function voteStep() external;\n\n    /**\n    vetoStep\n    */\n    function vetoStep() external;\n\n    /**\n    acceptedStep\n    */\n    function acceptedStep() external;\n\n    /**\n    Get the pre-voting registered proposal count.\n    */\n    function getProposalCount() external view returns (uint256);\n\n    /**\n    Get pre-voting proposal address and information by index\n\n    @param _index Index of proposal to query.\n    */\n    function getProposalByIndex(uint256 _index)\n        external\n        view\n        returns (\n            address proposalAddress,\n            uint256 proposalVotingRound,\n            uint256 proposalVotes,\n            uint256 proposalExpirationTimeStamp\n        );\n\n    /**\n    Get voting data\n    */\n    function getVotingData()\n        external\n        view\n        returns (\n            address winnerProposal,\n            uint256 inFavorVotes,\n            uint256 againstVotes,\n            uint256 votingExpirationTime\n        );\n\n    /**\n        Get user vote\n    */\n    function getUserVote(address user)\n        external\n        view\n        returns (address voteAddress, uint256 voteRound);\n\n    /**\n    will the call to unregister be successfull?\n\n    @param _proposal Address of the change contract that will be executed if this vote is successful\n    */\n    function canUnregister(address _proposal) external view returns (bool);\n\n    /**\n    Unregister a proposal, free the assets it uses.\n\n    @param _proposal Address of the change contract that will be executed if this vote is successful\n    */\n    function unregister(address _proposal) external;\n}\n\n\n\n\n/**\n  @notice Based on heavily on EnumberableSet, but with the ability to clear all the contents.\n */\nlibrary AddressSetLib {\n    using SafeMath for uint256;\n\n    struct AddressSet {\n        // Storage of set values\n        address[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(address => uint256) _indexes;\n    }\n\n    function init() internal pure returns (AddressSet memory) {\n        return AddressSet({_values: new address[](0)});\n    }\n\n    /**\n     * @dev Removes all value from a set. O(N).\n     *\n     */\n    function clear(AddressSet storage set) internal {\n        for (uint256 i = 0; i < set._values.length; i++) {\n            delete set._indexes[set._values[i]];\n        }\n        delete set._values;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        if (!contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            address lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1;\n            // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        require(set._values.length > index, \"index out of bounds\");\n        return set._values[index];\n    }\n\n    /**\n     * @dev Returns the set contents as an array\n     */\n    function asArray(AddressSet storage set)\n        internal\n        view\n        returns (address[] memory selectedOracles)\n    {\n        return set._values;\n    }\n}\n\n// Autogenerated by registryConstants.js\n\ncontract RegistryConstants {\n    // MOC_TOKEN = keccak256(moc.token)\n    bytes32\n        public constant MOC_TOKEN = 0x4bd5e7ff929fdd1ba62a33f76e0f40e97bb35e8bf126c0d9d91ce5c69a4bc521;\n\n    // MOC_DELAY_MACHINE = keccak256(moc.delay-machine)\n    bytes32\n        public constant MOC_DELAY_MACHINE = 0x66b60892ff6e7f0da16db27046f5960fdfd6bce5c3c8c21d56ccca3236a6281b;\n\n    // MOC_STAKING_MACHINE = keccak256(moc.staking-machine)\n    bytes32\n        public constant MOC_STAKING_MACHINE = 0x3c557531fea67120f21bc7711270a96f1b8cff3dfe3dd798a8a9f09ce9b77972;\n\n    // MOC_VESTING_MACHINE = keccak256(moc.vesting-machine)\n    bytes32\n        public constant MOC_VESTING_MACHINE = 0x7dfea4fb968e2599cdb7b3028c07d0188d0f92d1d00bd95c2805523c224649dd;\n\n    // MOC_VOTING_MACHINE = keccak256(moc.voting-machine)\n    bytes32\n        public constant MOC_VOTING_MACHINE = 0xc0ded27704f62d8726fdbd83648113d9fd8cf32c09f80523d2ba523e0bbd5ba4;\n\n    // MOC_UPGRADE_DELEGATOR = keccak256(moc.upgrade-delegator)\n    bytes32\n        public constant MOC_UPGRADE_DELEGATOR = 0x631bcbb9b033f9c8d13c32cf6e60827348d77b91b58c295e87745219242cca22;\n\n    // MOC_VOTING_MACHINE_MIN_STAKE = keccak256(moc.voting-machine.minStake)\n    bytes32\n        public constant MOC_VOTING_MACHINE_MIN_STAKE = 0x580be8e098dd1016787d59c2a534bf9df9ec679a29de4c8f92dc3807f7d7d54d;\n\n    // MOC_VOTING_MACHINE_PRE_VOTE_EXPIRATION_TIME_DELTA = keccak256(moc.voting-machine.preVoteExpirationTimeDelta)\n    bytes32\n        public constant MOC_VOTING_MACHINE_PRE_VOTE_EXPIRATION_TIME_DELTA = 0x62f5dbf0c17b0df83487409f747ad2eeca5fd54c140ca59b32cf39d6f6eaf916;\n\n    // MOC_VOTING_MACHINE_MAX_PRE_PROPOSALS = keccak256(moc.voting-machine.maxPreProposals)\n    bytes32\n        public constant MOC_VOTING_MACHINE_MAX_PRE_PROPOSALS = 0xc32b9cbc59039d297e670e7c196424308c90ba4a437fa7ccd008498c934e7dbf;\n\n    // MOC_VOTING_MACHINE_PRE_VOTE_MIN_PCT_TO_WIN = keccak256(moc.voting-machine.preVoteMinPCToWin)\n    bytes32\n        public constant MOC_VOTING_MACHINE_PRE_VOTE_MIN_PCT_TO_WIN = 0x0a1b21dfd7e4f3741529cf579e2731e847d81bbf13a82d0eba6910d7ac4c1c0a;\n\n    // MOC_VOTING_MACHINE_VOTE_MIN_PCT_TO_VETO = keccak256(moc.voting-machine.voteMinPctToVeto)\n    bytes32\n        public constant MOC_VOTING_MACHINE_VOTE_MIN_PCT_TO_VETO = 0xfb2d33acd65c36f68a15f8fe41cb8c0dd1eda164ffa87c6882e685ccb1c1adfb;\n\n    // MOC_VOTING_MACHINE_VOTE_MIN_PCT_FOR_QUORUM = keccak256(moc.voting-machine.voteMinPctForQuorum)\n    bytes32\n        public constant MOC_VOTING_MACHINE_VOTE_MIN_PCT_FOR_QUORUM = 0xde1ede48948567c43c504b761af8cd6af5363fafeceb1239b3083955d809714f;\n\n    // MOC_VOTING_MACHINE_VOTE_MIN_PCT_TO_ACCEPT = keccak256(moc.voting-machine.voteMinPctToAccept)\n    bytes32\n        public constant MOC_VOTING_MACHINE_VOTE_MIN_PCT_TO_ACCEPT = 0x99f83ee0c57b325f3deafb536d55596743ff112c6ac0d853d5f4f89b75dec045;\n\n    // MOC_VOTING_MACHINE_PCT_PRECISION = keccak256(moc.voting-machine.PCTPrecision)\n    bytes32\n        public constant MOC_VOTING_MACHINE_PCT_PRECISION = 0x73ee596441ef88c207a7a9147d62f59186b4991555e37b7ce9c801f9539d1050;\n\n    // MOC_VOTING_MACHINE_VOTING_TIME_DELTA = keccak256(moc.voting-machine.votingTimeDelta)\n    bytes32\n        public constant MOC_VOTING_MACHINE_VOTING_TIME_DELTA = 0xb43ee0a5ee6dcc7115ce824e4e353526ad6e479afa4daeb78451070de942de36;\n\n    // ORACLE_MANAGER_ADDR = keccak256(MOC_ORACLE\\1\\ORACLE_MANAGER_ADDR)\n    bytes32\n        public constant ORACLE_MANAGER_ADDR = 0x16986f74674f2ed21d50b6e74e6b12bb323ff4f72364542fd5de5104f3cc3ca9;\n\n    // SUPPORTERS_ADDR = keccak256(MOC_ORACLE\\1\\SUPPORTERS_ADDR)\n    bytes32\n        public constant SUPPORTERS_ADDR = 0xe4f979504d2a7a24557a15195eb83131e7c4a66d33900454705435aa5a6ee086;\n\n    // INFO_ADDR = keccak256(MOC_ORACLE\\1\\INFO_ADDR)\n    bytes32\n        public constant INFO_ADDR = 0xda9f12e01fc92de345bb741448d36ecb967052dd7aa1670439af833c9a3d78f1;\n\n    // ORACLE_PRICE_FETCH_RATE = keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_FETCH_RATE)\n    bytes32\n        public constant ORACLE_PRICE_FETCH_RATE = 0x945f72e5d44fb0ce3b1de393d19415723b79f97ad801089d8470d1c20e15ffef;\n\n    // ORACLE_BLOCKCHAIN_INFO_INTERVAL = keccak256(MOC_ORACLE\\1\\ORACLE_BLOCKCHAIN_INFO_INTERVAL)\n    bytes32\n        public constant ORACLE_BLOCKCHAIN_INFO_INTERVAL = 0x11cfbdf601b80a575e4366f0234cc06de0c9f401fe250dd9dccfccefeedb6fc2;\n\n    // ORACLE_COIN_PAIR_LOOP_TASK_INTERVAL = keccak256(MOC_ORACLE\\1\\ORACLE_COIN_PAIR_LOOP_TASK_INTERVAL)\n    bytes32\n        public constant ORACLE_COIN_PAIR_LOOP_TASK_INTERVAL = 0x2f271dc1fa81985bda14a2d6d0d60b45191d2a2d97e636b192696a8796d654a7;\n\n    // ORACLE_MAIN_LOOP_TASK_INTERVAL = keccak256(MOC_ORACLE\\1\\ORACLE_MAIN_LOOP_TASK_INTERVAL)\n    bytes32\n        public constant ORACLE_MAIN_LOOP_TASK_INTERVAL = 0x275d8a46b817572476d2d55b41c7709dee307740bad676a9693805003a48d231;\n\n    // ORACLE_PRICE_REJECT_DELTA_PCT = keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_REJECT_DELTA_PCT)\n    bytes32\n        public constant ORACLE_PRICE_REJECT_DELTA_PCT = 0x7a3ee46ca1bd3e19089870d8d6530b083a86da93aab52efccb32d5950e2709cf;\n\n    // ORACLE_CONFIGURATION_TASK_INTERVAL = keccak256(MOC_ORACLE\\1\\ORACLE_CONFIGURATION_TASK_INTERVAL)\n    bytes32\n        public constant ORACLE_CONFIGURATION_TASK_INTERVAL = 0xb027f2006a45346de89db4c5efc53f4e05e96532d27366aff00367a394d0abc4;\n\n    // ORACLE_GATHER_SIGNATURE_TIMEOUT = keccak256(MOC_ORACLE\\1\\ORACLE_GATHER_SIGNATURE_TIMEOUT)\n    bytes32\n        public constant ORACLE_GATHER_SIGNATURE_TIMEOUT = 0xf75b08b2b912abdbb87cc459ca0b4fdc019329386ec84ab68399b0c86fed5a95;\n\n    // ORACLE_MAIN_EXECUTOR_TASK_INTERVAL = keccak256(MOC_ORACLE\\1\\ORACLE_MAIN_EXECUTOR_TASK_INTERVAL)\n    bytes32\n        public constant ORACLE_MAIN_EXECUTOR_TASK_INTERVAL = 0xb324a91be1ac0d0c4888c835aee124ca1a7caf4b73ce10aa3504e2683865d7e5;\n\n    // SCHEDULER_POOL_DELAY = keccak256(MOC_ORACLE\\1\\SCHEDULER_POOL_DELAY)\n    bytes32\n        public constant SCHEDULER_POOL_DELAY = 0x6c2abc911c0fa4c73b90c7143a9f4429749be45ebfe7b81e69b86e7ca440d811;\n\n    // SCHEDULER_ROUND_DELAY = keccak256(MOC_ORACLE\\1\\SCHEDULER_ROUND_DELAY)\n    bytes32\n        public constant SCHEDULER_ROUND_DELAY = 0xa82bea7140872d1398fa0ab5075330ab0228f4c7e381b4b6502379ffc7cdcd9f;\n\n    // ORACLE_PRICE_DIGITS = keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_DIGITS)\n    bytes32\n        public constant ORACLE_PRICE_DIGITS = 0x4cd7e3f12ee4a2db0a6ba16e03fbc31bba1048c149bbf4fc9f3c02021ec550b8;\n\n    // ORACLE_QUEUE_LEN = keccak256(MOC_ORACLE\\1\\ORACLE_QUEUE_LEN)\n    bytes32\n        public constant ORACLE_QUEUE_LEN = 0x7d32d87d65898c3cbc7e72c59d223bf61c7811e99dafafd24fb08e0a38f10914;\n\n    // MESSAGE_VERSION = keccak256(MOC_ORACLE\\1\\MESSAGE_VERSION)\n    bytes32\n        public constant MESSAGE_VERSION = 0xeafac1a2b4d4fdcc942cbdce334a88ec83387087978d039f1320d3639a0b59df;\n\n    // ORACLE_STAKE_LIMIT_MULTIPLICATOR = keccak256(MOC_ORACLE\\1\\ORACLE_STAKE_LIMIT_MULTIPLICATOR)\n    bytes32\n        public constant ORACLE_STAKE_LIMIT_MULTIPLICATOR = 0xa1e0b5b458fe661fe687da135d3340a172e262c3cb31d646a4cb5cea9b6f1790;\n\n    // ORACLE_WITHDRAW_LOCK_TIME = keccak256(MOC_ORACLE\\1\\ORACLE_WITHDRAW_LOCK_TIME)\n    bytes32\n        public constant ORACLE_WITHDRAW_LOCK_TIME = 0x5e92c359b77ace8f4933558289f577781c0713b4ff91b2d2f76c8e523e560070;\n\n    // ORACLE_PRICE_DELTA_PCT = keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_DELTA_PCT)\n    bytes32\n        public constant ORACLE_PRICE_DELTA_PCT = 0x41a2ac05b365409628009a8091d8dda06fe52fe2f1c792e651e5df7599a7a7de;\n\n    // ORACLE_PRICE_PUBLISH_BLOCKS = keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_PUBLISH_BLOCKS)\n    bytes32\n        public constant ORACLE_PRICE_PUBLISH_BLOCKS = 0x51a2be29a473202678b6cf57b717ba5d7ff671f01fdbdbfcad4e1882601b8896;\n\n    // ORACLE_ENTERING_FALLBACKS_AMOUNTS = keccak256(MOC_ORACLE\\1\\ORACLE_ENTERING_FALLBACKS_AMOUNTS)\n    bytes32\n        public constant ORACLE_ENTERING_FALLBACKS_AMOUNTS = 0xf646c455329c7af0436f9e95c59c90ce0e11bb4e3a1deff805807798696adf88;\n\n    // ORACLE_TRIGGER_VALID_PUBLICATION_BLOCKS = keccak256(MOC_ORACLE\\1\\ORACLE_TRIGGER_VALID_PUBLICATION_BLOCKS)\n    bytes32\n        public constant ORACLE_TRIGGER_VALID_PUBLICATION_BLOCKS = 0xef9006fe6663199909dfaa4ab45e3f86d6454adb7773682f356824b6b3bc6b0e;\n}\n\nlibrary RegistryConstantsLib {\n    function MOC_TOKEN() internal pure returns (bytes32) {\n        // keccak256(moc.token)\n        return 0x4bd5e7ff929fdd1ba62a33f76e0f40e97bb35e8bf126c0d9d91ce5c69a4bc521;\n    }\n\n    function MOC_DELAY_MACHINE() internal pure returns (bytes32) {\n        // keccak256(moc.delay-machine)\n        return 0x66b60892ff6e7f0da16db27046f5960fdfd6bce5c3c8c21d56ccca3236a6281b;\n    }\n\n    function MOC_STAKING_MACHINE() internal pure returns (bytes32) {\n        // keccak256(moc.staking-machine)\n        return 0x3c557531fea67120f21bc7711270a96f1b8cff3dfe3dd798a8a9f09ce9b77972;\n    }\n\n    function MOC_VESTING_MACHINE() internal pure returns (bytes32) {\n        // keccak256(moc.vesting-machine)\n        return 0x7dfea4fb968e2599cdb7b3028c07d0188d0f92d1d00bd95c2805523c224649dd;\n    }\n\n    function MOC_VOTING_MACHINE() internal pure returns (bytes32) {\n        // keccak256(moc.voting-machine)\n        return 0xc0ded27704f62d8726fdbd83648113d9fd8cf32c09f80523d2ba523e0bbd5ba4;\n    }\n\n    function MOC_UPGRADE_DELEGATOR() internal pure returns (bytes32) {\n        // keccak256(moc.upgrade-delegator)\n        return 0x631bcbb9b033f9c8d13c32cf6e60827348d77b91b58c295e87745219242cca22;\n    }\n\n    function MOC_VOTING_MACHINE_MIN_STAKE() internal pure returns (bytes32) {\n        // keccak256(moc.voting-machine.minStake)\n        return 0x580be8e098dd1016787d59c2a534bf9df9ec679a29de4c8f92dc3807f7d7d54d;\n    }\n\n    function MOC_VOTING_MACHINE_PRE_VOTE_EXPIRATION_TIME_DELTA() internal pure returns (bytes32) {\n        // keccak256(moc.voting-machine.preVoteExpirationTimeDelta)\n        return 0x62f5dbf0c17b0df83487409f747ad2eeca5fd54c140ca59b32cf39d6f6eaf916;\n    }\n\n    function MOC_VOTING_MACHINE_MAX_PRE_PROPOSALS() internal pure returns (bytes32) {\n        // keccak256(moc.voting-machine.maxPreProposals)\n        return 0xc32b9cbc59039d297e670e7c196424308c90ba4a437fa7ccd008498c934e7dbf;\n    }\n\n    function MOC_VOTING_MACHINE_PRE_VOTE_MIN_PCT_TO_WIN() internal pure returns (bytes32) {\n        // keccak256(moc.voting-machine.preVoteMinPCToWin)\n        return 0x0a1b21dfd7e4f3741529cf579e2731e847d81bbf13a82d0eba6910d7ac4c1c0a;\n    }\n\n    function MOC_VOTING_MACHINE_VOTE_MIN_PCT_TO_VETO() internal pure returns (bytes32) {\n        // keccak256(moc.voting-machine.voteMinPctToVeto)\n        return 0xfb2d33acd65c36f68a15f8fe41cb8c0dd1eda164ffa87c6882e685ccb1c1adfb;\n    }\n\n    function MOC_VOTING_MACHINE_VOTE_MIN_PCT_FOR_QUORUM() internal pure returns (bytes32) {\n        // keccak256(moc.voting-machine.voteMinPctForQuorum)\n        return 0xde1ede48948567c43c504b761af8cd6af5363fafeceb1239b3083955d809714f;\n    }\n\n    function MOC_VOTING_MACHINE_VOTE_MIN_PCT_TO_ACCEPT() internal pure returns (bytes32) {\n        // keccak256(moc.voting-machine.voteMinPctToAccept)\n        return 0x99f83ee0c57b325f3deafb536d55596743ff112c6ac0d853d5f4f89b75dec045;\n    }\n\n    function MOC_VOTING_MACHINE_PCT_PRECISION() internal pure returns (bytes32) {\n        // keccak256(moc.voting-machine.PCTPrecision)\n        return 0x73ee596441ef88c207a7a9147d62f59186b4991555e37b7ce9c801f9539d1050;\n    }\n\n    function MOC_VOTING_MACHINE_VOTING_TIME_DELTA() internal pure returns (bytes32) {\n        // keccak256(moc.voting-machine.votingTimeDelta)\n        return 0xb43ee0a5ee6dcc7115ce824e4e353526ad6e479afa4daeb78451070de942de36;\n    }\n\n    function ORACLE_MANAGER_ADDR() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_MANAGER_ADDR)\n        return 0x16986f74674f2ed21d50b6e74e6b12bb323ff4f72364542fd5de5104f3cc3ca9;\n    }\n\n    function SUPPORTERS_ADDR() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\SUPPORTERS_ADDR)\n        return 0xe4f979504d2a7a24557a15195eb83131e7c4a66d33900454705435aa5a6ee086;\n    }\n\n    function INFO_ADDR() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\INFO_ADDR)\n        return 0xda9f12e01fc92de345bb741448d36ecb967052dd7aa1670439af833c9a3d78f1;\n    }\n\n    function ORACLE_PRICE_FETCH_RATE() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_FETCH_RATE)\n        return 0x945f72e5d44fb0ce3b1de393d19415723b79f97ad801089d8470d1c20e15ffef;\n    }\n\n    function ORACLE_BLOCKCHAIN_INFO_INTERVAL() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_BLOCKCHAIN_INFO_INTERVAL)\n        return 0x11cfbdf601b80a575e4366f0234cc06de0c9f401fe250dd9dccfccefeedb6fc2;\n    }\n\n    function ORACLE_COIN_PAIR_LOOP_TASK_INTERVAL() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_COIN_PAIR_LOOP_TASK_INTERVAL)\n        return 0x2f271dc1fa81985bda14a2d6d0d60b45191d2a2d97e636b192696a8796d654a7;\n    }\n\n    function ORACLE_MAIN_LOOP_TASK_INTERVAL() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_MAIN_LOOP_TASK_INTERVAL)\n        return 0x275d8a46b817572476d2d55b41c7709dee307740bad676a9693805003a48d231;\n    }\n\n    function ORACLE_PRICE_REJECT_DELTA_PCT() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_REJECT_DELTA_PCT)\n        return 0x7a3ee46ca1bd3e19089870d8d6530b083a86da93aab52efccb32d5950e2709cf;\n    }\n\n    function ORACLE_CONFIGURATION_TASK_INTERVAL() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_CONFIGURATION_TASK_INTERVAL)\n        return 0xb027f2006a45346de89db4c5efc53f4e05e96532d27366aff00367a394d0abc4;\n    }\n\n    function ORACLE_GATHER_SIGNATURE_TIMEOUT() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_GATHER_SIGNATURE_TIMEOUT)\n        return 0xf75b08b2b912abdbb87cc459ca0b4fdc019329386ec84ab68399b0c86fed5a95;\n    }\n\n    function ORACLE_MAIN_EXECUTOR_TASK_INTERVAL() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_MAIN_EXECUTOR_TASK_INTERVAL)\n        return 0xb324a91be1ac0d0c4888c835aee124ca1a7caf4b73ce10aa3504e2683865d7e5;\n    }\n\n    function SCHEDULER_POOL_DELAY() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\SCHEDULER_POOL_DELAY)\n        return 0x6c2abc911c0fa4c73b90c7143a9f4429749be45ebfe7b81e69b86e7ca440d811;\n    }\n\n    function SCHEDULER_ROUND_DELAY() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\SCHEDULER_ROUND_DELAY)\n        return 0xa82bea7140872d1398fa0ab5075330ab0228f4c7e381b4b6502379ffc7cdcd9f;\n    }\n\n    function ORACLE_PRICE_DIGITS() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_DIGITS)\n        return 0x4cd7e3f12ee4a2db0a6ba16e03fbc31bba1048c149bbf4fc9f3c02021ec550b8;\n    }\n\n    function ORACLE_QUEUE_LEN() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_QUEUE_LEN)\n        return 0x7d32d87d65898c3cbc7e72c59d223bf61c7811e99dafafd24fb08e0a38f10914;\n    }\n\n    function MESSAGE_VERSION() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\MESSAGE_VERSION)\n        return 0xeafac1a2b4d4fdcc942cbdce334a88ec83387087978d039f1320d3639a0b59df;\n    }\n\n    function ORACLE_STAKE_LIMIT_MULTIPLICATOR() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_STAKE_LIMIT_MULTIPLICATOR)\n        return 0xa1e0b5b458fe661fe687da135d3340a172e262c3cb31d646a4cb5cea9b6f1790;\n    }\n\n    function ORACLE_WITHDRAW_LOCK_TIME() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_WITHDRAW_LOCK_TIME)\n        return 0x5e92c359b77ace8f4933558289f577781c0713b4ff91b2d2f76c8e523e560070;\n    }\n\n    function ORACLE_PRICE_DELTA_PCT() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_DELTA_PCT)\n        return 0x41a2ac05b365409628009a8091d8dda06fe52fe2f1c792e651e5df7599a7a7de;\n    }\n\n    function ORACLE_PRICE_PUBLISH_BLOCKS() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_PUBLISH_BLOCKS)\n        return 0x51a2be29a473202678b6cf57b717ba5d7ff671f01fdbdbfcad4e1882601b8896;\n    }\n\n    function ORACLE_ENTERING_FALLBACKS_AMOUNTS() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_ENTERING_FALLBACKS_AMOUNTS)\n        return 0xf646c455329c7af0436f9e95c59c90ce0e11bb4e3a1deff805807798696adf88;\n    }\n\n    function ORACLE_TRIGGER_VALID_PUBLICATION_BLOCKS() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_TRIGGER_VALID_PUBLICATION_BLOCKS)\n        return 0xef9006fe6663199909dfaa4ab45e3f86d6454adb7773682f356824b6b3bc6b0e;\n    }\n}\n\n\n/*\n    Abstract contract meant to be reused.\n*/\nlibrary VestingLib {\n    uint256 public constant PERCENTAGES_BASE = 10000;\n\n    using SafeMath for uint256;\n    using AddressSetLib for AddressSetLib.AddressSet;\n\n    // Global data\n    struct VestingData {\n        // @dev Percentages array of locked funds at a given time,\n        // percentages are in fixed point with 4 decimals,\n        // percentages should be in decreasing order.\n        // Example: percentages = [9000, 5000, 0]\n        uint256[] percentages;\n        // @dev Time deltas array when percentages become active,\n        // time deltas should sorted in increasing order,\n        // time deltas are measured from the TGE event,\n        // time deltas are expressed in seconds.\n        // Example: timedeltas = [2592000, 7776000, 15552000]\n        uint256[] timedeltas;\n        // @dev Address of holder\n        address holder;\n        // @dev Vesting Factory\n        VestingFactory vestingFactory;\n        // @dev Registry contracts\n        IRegistry registry;\n        // @dev Indicates if holder has verified the contract\n        bool verified;\n        // @dev Total vesting\n        uint256 total;\n        // @dev Contract that can be called with callWithData\n        AddressSetLib.AddressSet whitelistedContracts;\n    }\n\n    /**\n        Contract creation\n\n        @param _holder address who will able to withdraw tokens when released\n    */\n    function _initialize(\n        VestingData storage self,\n        VestingFactory _vestingFactory,\n        address _holder\n    ) internal {\n        self.holder = _holder;\n        self.verified = false;\n        require(_vestingFactory != VestingFactory(0), \"Invalid vestingFactory address\");\n        self.vestingFactory = _vestingFactory;\n        self.registry = _vestingFactory.getRegistry();\n        self.whitelistedContracts.add(address(_getDelayMachine(self)));\n        self.whitelistedContracts.add(address(_getStakingMachine(self)));\n        self.whitelistedContracts.add(address(_getVotingMachine(self)));\n    }\n\n    /**\n     * @notice Retrieve vesting parameters\n     */\n    function _getParameters(VestingData storage self)\n        internal\n        view\n        returns (uint256[] memory, uint256[] memory)\n    {\n        return (self.percentages, self.timedeltas);\n    }\n\n    /**\n     * @notice Mark contract as verified by holder\n     */\n    function _verify(VestingData storage self) internal {\n        require(msg.sender == self.holder, \"Only holder can verify contract\");\n        self.verified = true;\n    }\n\n    /**\n     * @notice Change holder address\n     * @param _newHolder the new holder\n     */\n    function _setHolder(VestingData storage self, address _newHolder) internal {\n        require(msg.sender == address(self.vestingFactory), \"Only factory can change holder\");\n        require(!_isVerified(self), \"Cannot change after verification\");\n        self.holder = _newHolder;\n    }\n\n    /**\n     * @notice Calls a function from target passing data\n     * @param target Target contract to call\n     * @param data Data to pass target contract\n     */\n    function _callWithData(\n        VestingData storage self,\n        address target,\n        bytes memory data\n    ) internal {\n        require(msg.sender == self.holder, \"Holder is required\");\n        require(self.whitelistedContracts.contains(target), \"Invalid target\");\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = target.call(data);\n        require(success, \"CallWithData failed\");\n    }\n\n    /**\n     * @notice approve a transfer to the staking machine.\n     * @param amount Token amount to approve\n     */\n    function approve(VestingData storage self, uint256 amount) internal {\n        require(msg.sender == self.holder, \"Holder is required\");\n        _approve(self, amount);\n    }\n\n    /**\n     * @notice deposit MOCs in the staking machine\n     * @param amount Token amount to approve\n     */\n    function _deposit(VestingData storage self, uint256 amount) internal {\n        require(msg.sender == self.holder, \"Holder is required\");\n        IStakingMachine stakingMachine = _getStakingMachine(self);\n        _approve(self, amount);\n        stakingMachine.deposit(amount, address(this));\n    }\n\n    /**\n     * @notice Withdraws tokens to holder address\n     * @param amount Tokens amount to withdraw\n     * @return Returns true on success\n     */\n    function _withdraw(VestingData storage self, uint256 amount) internal returns (bool) {\n        require(_isVerified(self), \"Holder should verify\");\n        require(msg.sender == self.holder, \"Holder is required\");\n        uint256 freeMocs = _getAvailable(self);\n        require(amount <= freeMocs, \"Not enough mocs to withdraw\");\n        IERC20 token = _getToken(self);\n        require(token.transfer(msg.sender, amount), \"Withdraw failed\");\n        return true;\n    }\n\n    /**\n     * @notice Withdraws all available tokens to holder address\n     * @return Returns true on success\n     */\n    function _withdrawAll(VestingData storage self) internal returns (bool) {\n        require(msg.sender == self.holder, \"Holder is required\");\n        uint256 amount = _getAvailable(self);\n        require(amount > 0, \"Not enough mocs to withdraw\");\n        IERC20 token = _getToken(self);\n        require(token.transfer(msg.sender, amount), \"Withdraw failed\");\n        return true;\n    }\n\n    /**\n     * @notice Configure vesting total balance\n     */\n    function _setTotal(VestingData storage self, uint256 amount) internal {\n        require(msg.sender == address(self.vestingFactory), \"Only factory allowed\");\n        self.total = amount;\n    }\n\n    /**\n     * @notice Token amount available for withdrawal\n     */\n    function _getAvailable(VestingData storage self) internal view returns (uint256) {\n        if (!_isWithdrawEnabled(self)) {\n            // Withdraw not enabled\n            return 0;\n        }\n        // Minimum token amount to be locked in vesting contract\n        uint256 minimumLocked = _getLocked(self);\n        // Tokens locked in outside contracts\n        uint256 lockedOutside = _getStakingBalance(self);\n        lockedOutside = lockedOutside.add(_getDelayBalance(self));\n        if (minimumLocked >= lockedOutside) {\n            minimumLocked = minimumLocked.sub(lockedOutside);\n        } else {\n            minimumLocked = 0;\n        }\n        uint256 balance = _getTokenBalance(self);\n        // Available mocs for withdrawal\n        uint256 freeMocs = 0;\n        if (balance >= minimumLocked) {\n            freeMocs = balance.sub(minimumLocked);\n        }\n        return freeMocs;\n    }\n\n    function _isVerified(VestingData storage self) internal view returns (bool) {\n        return self.verified;\n    }\n\n    /**\n     * @notice Minimum token amount required to be locked\n     */\n    function _getLocked(VestingData storage self) internal view returns (uint256) {\n        // solhint-disable-next-line not-rely-on-time\n        return _getLockedAt(self, block.timestamp);\n    }\n\n    /**\n     * @notice Minimum token amount required to be locked\n     * @param timestamp date to check\n     */\n    function _getLockedAt(VestingData storage self, uint256 timestamp)\n        internal\n        view\n        returns (uint256)\n    {\n        if (!self.vestingFactory.isTGEConfigured()) {\n            // TGE not configured yet\n            return self.total;\n        }\n        uint256 tgeTimestamp = self.vestingFactory.getTGETimestamp();\n        if (timestamp <= tgeTimestamp) {\n            // Can't withdraw at a time prior to the TGE\n            return self.total;\n        }\n        // Time deltas are base from the TGE event and they are expressed in days\n        uint256 delta = timestamp.sub(tgeTimestamp);\n        uint256 i = 0;\n        // Search i such that timedeltas[i-1] <= delta < timedeltas[i]\n        while (i < self.timedeltas.length && delta >= self.timedeltas[i]) {\n            i += 1;\n        }\n        if (i >= self.timedeltas.length) {\n            // All funds are available\n            return 0;\n        } else if (i == 0) {\n            return self.total;\n        } else {\n            return (self.total.mul(self.percentages[i - 1])).div(PERCENTAGES_BASE);\n        }\n    }\n\n    /**\n     * @notice Add an address to the whitelisted contracts\n     * @param addr address to add\n     */\n    function _addToWhitelist(VestingData storage self, address addr) internal returns (bool) {\n        require(msg.sender == address(self.vestingFactory), \"Only factory allowed\");\n        return self.whitelistedContracts.add(addr);\n    }\n\n    /**\n     * @notice Remove an address from the whitelisted contracts\n     * @param addr address to add\n     */\n    function _removeFromWhitelist(VestingData storage self, address addr) internal returns (bool) {\n        require(msg.sender == address(self.vestingFactory), \"Only factory allowed\");\n        return self.whitelistedContracts.remove(addr);\n    }\n\n    /**\n     * @notice Get the whitelisted contracts length\n     */\n    function _getWhitelistLen(VestingData storage self) internal view returns (uint256) {\n        return self.whitelistedContracts.length();\n    }\n\n    /**\n     * @notice Get the whitelisted contracts length\n     * @param idx the index in the whitelist\n     */\n    function _getWhitelistEntry(VestingData storage self, uint256 idx)\n        internal\n        view\n        returns (address)\n    {\n        return self.whitelistedContracts.at(idx);\n    }\n\n    function _updateParameters(\n        VestingData storage self,\n        uint256[] memory _percentages,\n        uint256[] memory _timedeltas\n    ) internal {\n        require(_percentages.length == _timedeltas.length, \"Arrays length should be equal\");\n        for (uint256 i = 1; i < _timedeltas.length; i += 1) {\n            require(_percentages[i - 1] >= _percentages[i], \"Percentages decreasing order\");\n            require(_timedeltas[i - 1] < _timedeltas[i], \"Time deltas increasing order\");\n        }\n        self.percentages = _percentages;\n        self.timedeltas = _timedeltas;\n    }\n\n    function _approve(VestingData storage self, uint256 amount) internal {\n        IERC20 mocToken = _getToken(self);\n        require(mocToken.approve(address(_getStakingMachine(self)), amount), \"Approve failed\");\n    }\n\n    function _getToken(VestingData storage self) internal view returns (IERC20) {\n        return IERC20(self.registry.getAddress(RegistryConstantsLib.MOC_TOKEN()));\n    }\n\n    function _getTokenBalance(VestingData storage self) internal view returns (uint256) {\n        return _getToken(self).balanceOf(address(this));\n    }\n\n    function _getDelayMachine(VestingData storage self) internal view returns (IDelayMachine) {\n        return IDelayMachine(self.registry.getAddress(RegistryConstantsLib.MOC_DELAY_MACHINE()));\n    }\n\n    function _getDelayBalance(VestingData storage self) internal view returns (uint256) {\n        return _getDelayMachine(self).getBalance(address(this));\n    }\n\n    function _getStakingMachine(VestingData storage self) internal view returns (IStakingMachine) {\n        return\n            IStakingMachine(self.registry.getAddress(RegistryConstantsLib.MOC_STAKING_MACHINE()));\n    }\n\n    function _getStakingBalance(VestingData storage self) internal view returns (uint256) {\n        return _getStakingMachine(self).getBalance(address(this));\n    }\n\n    function _getVotingMachine(VestingData storage self) internal view returns (IVotingMachine) {\n        return IVotingMachine(self.registry.getAddress(RegistryConstantsLib.MOC_VOTING_MACHINE()));\n    }\n\n    function _isWithdrawEnabled(VestingData storage self) internal view returns (bool) {\n        // solhint-disable-next-line not-rely-on-time\n        uint256 timestamp = block.timestamp;\n        return (self.vestingFactory.isTGEConfigured() &&\n            timestamp >= self.vestingFactory.getTGETimestamp());\n    }\n}\n\n\n/// @title Vesting contract\n/// @notice Release tokens following a release schedule\ncontract Vesting is IVestingMachine {\n    using SafeMath for uint256;\n    using VestingLib for VestingLib.VestingData;\n\n    VestingLib.VestingData internal vestingData;\n\n    /// @notice Create a vesting contract\n    /// @param _holder address who will able to withdraw tokens when released\n    /// @param _percentages array of token percentages locked at a date\n    /// @param _timedeltas array of date deltas from TGE when percentages are valid\n    constructor(\n        address _holder,\n        uint256[] memory _percentages,\n        uint256[] memory _timedeltas\n    ) public {\n        vestingData._initialize(VestingFactory(msg.sender), _holder);\n        vestingData._updateParameters(_percentages, _timedeltas);\n    }\n\n    /// @notice Retrieve vesting parameters\n    function getParameters() public view override returns (uint256[] memory, uint256[] memory) {\n        return vestingData._getParameters();\n    }\n\n    /// @notice Mark contract as verified by holder\n    function verify() public override {\n        vestingData._verify();\n    }\n\n    /// @notice Change holder address\n    /// @param newHolder the new holder\n    function setHolder(address newHolder) public override {\n        vestingData._setHolder(newHolder);\n    }\n\n    /// @notice Returns current holder address\n    function getHolder() public view override returns (address) {\n        return vestingData.holder;\n    }\n\n    /// @notice Calls a function from target passing data\n    /// @param target Target contract to call\n    /// @param data Data to pass target contract\n    function callWithData(address target, bytes memory data) public override {\n        vestingData._callWithData(target, data);\n    }\n\n    /// @notice approve a transfer to the staking machine.\n    /// @param amount Token amount to approve\n    function approve(uint256 amount) public override {\n        vestingData.approve(amount);\n    }\n\n    /// @notice deposit MOCs in the staking machine\n    /// @param amount Token amount to approve\n    function deposit(uint256 amount) public override {\n        vestingData._deposit(amount);\n    }\n\n    /// @notice Withdraws tokens to holder address\n    /// @param amount Tokens amount to withdraw\n    /// @return Returns true on success\n    function withdraw(uint256 amount) public override returns (bool) {\n        return vestingData._withdraw(amount);\n    }\n\n    /// @notice Withdraws all available tokens to holder address\n    /// @return Returns true on success\n    function withdrawAll() public override returns (bool) {\n        return vestingData._withdrawAll();\n    }\n\n    /// @notice Minimum token amount required to be locked\n    /// @param timestamp date to check\n    function getLockedAt(uint256 timestamp) public view override returns (uint256) {\n        return vestingData._getLockedAt(timestamp);\n    }\n\n    /// @notice Minimum token amount required to be locked\n    function getLocked() public view override returns (uint256) {\n        return vestingData._getLocked();\n    }\n\n    /// @notice Token amount available for withdrawal\n    function getAvailable() public view override returns (uint256) {\n        return vestingData._getAvailable();\n    }\n\n    /// @notice Returns true after contract has been verified by holder\n    function isVerified() public view override returns (bool) {\n        return vestingData._isVerified();\n    }\n\n    /// @notice Total token balance configured\n    function getTotal() public view override returns (uint256) {\n        return vestingData.total;\n    }\n\n    /// @notice Configure vesting total balance\n    function setTotal(uint256 amount) public override {\n        vestingData._setTotal(amount);\n    }\n\n    /// @notice Add an address to the whitelisted contracts\n    /// @param addr address to add\n    function addToWhitelist(address addr) public returns (bool) {\n        return vestingData._addToWhitelist(addr);\n    }\n\n    /// @notice Remove an address from the whitelisted contracts\n    /// @param addr address to add\n    function removeFromWhitelist(address addr) public returns (bool) {\n        return vestingData._removeFromWhitelist(addr);\n    }\n\n    /// @notice Get the whitelisted contracts length\n    function getWhitelistLen() public view returns (uint256) {\n        return vestingData._getWhitelistLen();\n    }\n\n    /// @notice Get the whitelisted contracts length\n    /// @param idx the index in the whitelist\n    function getWhitelistEntry(uint256 idx) public view returns (address) {\n        return vestingData._getWhitelistEntry(idx);\n    }\n}\n\n\ncontract VestingFactoryStorage is Initializable, Governed, OwnableUpgradeSafe {\n    using AddressSetLib for AddressSetLib.AddressSet;\n\n    /// @dev Registry to consult addresses\n    IRegistry internal registry;\n\n    /// @dev TGE timestamp\n    uint256 internal tgeTimestamp;\n\n    // @dev contract that can be called with callWithData\n    AddressSetLib.AddressSet internal vestingMachines;\n}\n\n\ncontract VestingFactory is VestingFactoryStorage, IVestingFactory {\n    event VestingCreated(address vesting, address holder);\n\n    /// @notice Contract creation\n    /// @param _governor The address of the contract which governs this one\n    /// @param _registry Registry contracts\n    function initialize(IGovernor _governor, IRegistry _registry) external initializer {\n        Governed._initialize(_governor);\n        __Ownable_init();\n        registry = _registry;\n        tgeTimestamp = 0;\n    }\n\n    /// @notice Create a holder wallet\n    /// @param holder wallet's owner\n    /// @param percentages percentages allowed in each step\n    /// @param timedeltas duration of each step\n    function create(\n        address holder,\n        uint256[] memory percentages,\n        uint256[] memory timedeltas\n    ) external override onlyOwner {\n        Vesting wallet = _createVesting(holder, percentages, timedeltas);\n        vestingMachines.add(address(wallet));\n        emit VestingCreated(address(wallet), holder);\n    }\n\n    function replaceHolder(IVestingMachine wallet, address newHolder) public onlyOwner {\n        wallet.setHolder(newHolder);\n    }\n\n    /// @notice Set the TGE time enabling holder wallets\n    function setTGE() public override onlyOwner {\n        require(tgeTimestamp == 0, \"TGE already configured\");\n        // solhint-disable-next-line not-rely-on-time\n        tgeTimestamp = block.timestamp;\n    }\n\n    /// @notice Returns true when the TGE was configured\n    function isTGEConfigured() public view override returns (bool) {\n        return tgeTimestamp > 0;\n    }\n\n    /// @notice Returns the configured TGE timestamp\n    function getTGETimestamp() public view override returns (uint256) {\n        return tgeTimestamp;\n    }\n\n    /// @notice Set a holder wallet balance\n    /// @param wallet the vesting machine\n    /// @param amount wallet balance\n    function setTotal(IVestingMachine wallet, uint256 amount) public override onlyOwner {\n        require(tgeTimestamp == 0, \"TGE already configured\");\n        wallet.setTotal(amount);\n    }\n\n    /// @notice Return registry\n    function getRegistry() public view override returns (IRegistry) {\n        return registry;\n    }\n\n    /// @notice Get the length of the list of vesting machines\n    function getVestingMachinesLen() public view override returns (uint256) {\n        return vestingMachines.length();\n    }\n\n    /// @notice Get the an entry of the list of vesting machines\n    /// @param idx the index in the list\n    function getVestingMachinesEntry(uint256 idx) public view override returns (address) {\n        return vestingMachines.at(idx);\n    }\n\n    function _createVesting(\n        address holder,\n        uint256[] memory percentages,\n        uint256[] memory timedeltas\n    ) internal returns (Vesting) {\n        return new Vesting(holder, percentages, timedeltas);\n    }\n}\n\n",
    "imports": [
        {
            "name": "VestingFactory.sol",
            "contents": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\n\ninterface IRegistry {\n    // *** Getter Methods ***\n    function getDecimal(bytes32 _key) external view returns (int232 base, int16 exp);\n\n    function getUint(bytes32 _key) external view returns (uint248);\n\n    function getString(bytes32 _key) external view returns (string memory);\n\n    function getAddress(bytes32 _key) external view returns (address);\n\n    function getBytes(bytes32 _key) external view returns (bytes memory);\n\n    function getBool(bytes32 _key) external view returns (bool);\n\n    function getInt(bytes32 _key) external view returns (int248);\n\n    // *** Setter Methods ***\n    function setDecimal(\n        bytes32 _key,\n        int232 _base,\n        int16 _exp\n    ) external;\n\n    function setUint(bytes32 _key, uint248 _value) external;\n\n    function setString(bytes32 _key, string calldata _value) external;\n\n    function setAddress(bytes32 _key, address _value) external;\n\n    function setBytes(bytes32 _key, bytes calldata _value) external;\n\n    function setBool(bytes32 _key, bool _value) external;\n\n    function setInt(bytes32 _key, int248 _value) external;\n\n    // *** Delete Methods ***\n    function deleteDecimal(bytes32 _key) external;\n\n    function deleteUint(bytes32 _key) external;\n\n    function deleteString(bytes32 _key) external;\n\n    function deleteAddress(bytes32 _key) external;\n\n    function deleteBytes(bytes32 _key) external;\n\n    function deleteBool(bytes32 _key) external;\n\n    function deleteInt(bytes32 _key) external;\n}\n\n\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n    /**\n      @notice Override this function with a recipe of the changes to be done when this ChangeContract\n      is executed\n     */\n    function execute() external;\n}\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor {\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @dev This function should be protected somehow to only execute changes that\n      benefit the system. This decision process is independent of this architechture\n      therefore is independent of this interface too\n      @param changeContract Address of the contract that will execute the changes\n     */\n    function executeChange(ChangeContract changeContract) external;\n\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @param _changer Address of the contract that will execute the changes\n     */\n    function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed {\n    /**\n      @notice The address of the contract which governs this one\n     */\n    IGovernor public governor;\n\n    string private constant NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n    /**\n      @notice Modifier that protects the function\n      @dev You should use this modifier in any function that should be called through\n      the governance system\n     */\n    modifier onlyAuthorizedChanger() {\n        require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n        _;\n    }\n\n    /**\n      @notice Initialize the contract with the basic settings\n      @dev This initialize replaces the constructor but it is not called automatically.\n      It is necessary because of the upgradeability of the contracts\n      @param _governor Governor address\n     */\n    function _initialize(IGovernor _governor) internal {\n        governor = _governor;\n    }\n\n    /**\n      @notice Change the contract's governor. Should be called through the old governance system\n      @param newIGovernor New governor address\n     */\n    function changeIGovernor(IGovernor newIGovernor) external onlyAuthorizedChanger {\n        governor = newIGovernor;\n    }\n\n    /**\n      @notice This method is used by a change contract to access the storage freely even without a setter.\n      @param data the serialized function arguments\n     */\n    function delegateCallToChanger(bytes calldata data)\n        external\n        onlyAuthorizedChanger\n        returns (bytes memory)\n    {\n        address changerContrat = msg.sender;\n        (bool success, bytes memory result) = changerContrat.delegatecall(\n            abi.encodeWithSignature(\"impersonate(bytes)\", data)\n        );\n        require(success, \"Error in delegate call\");\n        return result;\n    }\n\n    // Leave a gap betweeen inherited contracts variables in order to be\n    // able to add more variables in them later\n    uint256[50] private upgradeGap;\n}\n\n\n\ninterface IVestingMachine {\n    /// @notice Retrieve vesting parameters\n    function getParameters() external view returns (uint256[] memory, uint256[] memory);\n\n    /// @notice Mark contract as verified by holder\n    function verify() external;\n\n    /// @notice Returns current holder address\n    function getHolder() external view returns (address);\n\n    /// @notice Calls a function from target passing data\n    /// @param target Target contract to call (must be one of: staking, vesting or voting machine)\n    /// @param data Data to pass target contract\n    function callWithData(address target, bytes memory data) external;\n\n    /// @notice approve a transfer to the staking machine.\n    /// @param amount Token amount to approve\n    function approve(uint256 amount) external;\n\n    /// @notice deposit MOCs in the staking machine\n    /// @param amount Token amount to approve\n    function deposit(uint256 amount) external;\n\n    /// @notice Withdraws tokens to holder address\n    /// @param amount Tokens amount to withdraw\n    /// @return Returns true on success\n    function withdraw(uint256 amount) external returns (bool);\n\n    /// @notice Withdraws all available tokens to holder address\n    /// @return Returns true on success\n    function withdrawAll() external returns (bool);\n\n    /// @notice Minimum token amount required to be locked\n    /// @param timestamp date to check\n    function getLockedAt(uint256 timestamp) external view returns (uint256);\n\n    /// @notice Minimum token amount required to be locked\n    function getLocked() external view returns (uint256);\n\n    /// @notice Token amount available for withdrawal\n    function getAvailable() external view returns (uint256);\n\n    /// @notice Returns true after contract has been verified by holder\n    function isVerified() external view returns (bool);\n\n    /// @notice Total token balance configured\n    function getTotal() external view returns (uint256);\n\n    /// @notice Change holder address\n    /// @param newHolder the new holder (only can be called by governance)\n    function setHolder(address newHolder) external;\n\n    /// @notice Configure vesting total balance (only can be called by factory)\n    function setTotal(uint256 amount) external;\n}\n\n\ninterface IVestingFactory {\n    /// @notice Create a holder wallet\n    /// @param holder wallet's owner\n    /// @param percentages percentages allowed in each step\n    /// @param timedeltas duration of each step\n    function create(\n        address holder,\n        uint256[] memory percentages,\n        uint256[] memory timedeltas\n    ) external;\n\n    /// @notice Set the TGE time enabling holder wallets\n    function setTGE() external;\n\n    /// @notice Returns true when the TGE was configured\n    function isTGEConfigured() external view returns (bool);\n\n    /// @notice Returns the configured TGE timestamp\n    function getTGETimestamp() external view returns (uint256);\n\n    /// @notice Set a holder wallet balance\n    /// @param wallet the vesting machine\n    /// @param amount wallet balance\n    function setTotal(IVestingMachine wallet, uint256 amount) external;\n\n    /// @notice Return registry\n    function getRegistry() external view returns (IRegistry);\n\n    /// @notice Get the length of the list of vesting machines\n    function getVestingMachinesLen() external view returns (uint256);\n\n    /// @notice Get the an entry of the list of vesting machines\n    /// @param idx the index in the list\n    function getVestingMachinesEntry(uint256 idx) external view returns (address);\n}\n\n\n// prettier-ignore\n\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract ContextUpgradeSafe is Initializable {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n\n\n    }\n\n\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n\n    uint256[50] private __gap;\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract OwnableUpgradeSafe is Initializable, ContextUpgradeSafe {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n\n\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n\n    }\n\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    uint256[49] private __gap;\n}\n\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n\n\n\n/// @title This contract provides an interface for feeding prices from oracles, and\n///        get the current price. One contract must be instanced per supported coin pair,\n///        and registered through OracleManager global contract.\n/// This contract has two lists:\n/// 1) A subscribed list (EnumerableSet.AddressSet) oracles owner addresses, this list has a max size (30).\n/// 2) A selected list, EnumerableSet.AddressSet of oracles owner addresses that are selected to participate in\n/// current publication round (10 entries max size).\n///\n/// Oracles are subscribed by adding them to the subscribed oracle list. When the list is full\n/// the oracle with less stake can be removed by a new oracle that is trying to\n/// subscribe (if its stake is greater than his).\n/// On each round switch the list of selected oracles is populated with the 10 Oracles with more stake. An oracle\n/// can unsubscribe itself from the subscribed list in the middle of the round, in this case, the oracle is still\n/// listed in the selected list until the round ends.\n/// If an oracle withdraw some stake then his participation in the round is put into consideration: If the\n/// oracle ends up having less stake than the next oracle in the subscribed list (but not in the selected list) then\n/// it is removed from the selected list and the point he accumulated during the round are lost (set to zero).\n\ninterface ICoinPairPrice {\n    // getOracleOwnerAddress: Given an Oracle address return the Oracle Owner address.\n    // Used during publication, the servers sign with the oracle address, but the list of selected oracles\n    // is by oracle owner address.\n    // getOracleOwnerStake: Get the stake stored in the supporters smart-contract\n    // prettier-ignore\n    struct CoinPairPriceCallbacks {\n        function (address) external view returns (address) getOracleOwnerAddress;\n        function (address) external view returns (uint256) getOracleOwnerStake;\n    }\n\n    /// @notice subscribe an oracle to this coin pair, allowing it to be selected in the next round.\n    /// If the subscribed list is full and the current oracle has more stake than one with minimum stake in the\n    /// subscribed list, then the one with minimum stake is replaced.\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\n    /// @dev This is designed to be called from OracleManager.\n    function subscribe(address oracleOwnerAddr) external;\n\n    /// @notice Unsubscribe an oracle from this coin pair. The oracle won't be selected in the next round.\n    /// After the round end, the oracle can withdraw stake without having the risk of loosing won points.\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\n    /// @dev This is designed to be called from OracleManager.\n    function unsubscribe(address oracleOwnerAddr) external;\n\n    /// @notice Returns true if an oracle is subscribed to this contract' coin pair\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\n    /// @dev This is designed to be called from OracleManager.\n    function isSubscribed(address oracleOwnerAddr) external view returns (bool);\n\n    /// @notice Publish a price. (The message contain oracleAddresses that must be converted to owner addresses).\n    /// @param _version Version number of message format (3)\n    /// @param _coinpair The coin pair to report (must match this contract)\n    /// @param _price Price to report.\n    /// @param _votedOracle The address of the oracle voted as a publisher by the network.\n    /// @param _blockNumber The blocknumber acting as nonce to prevent replay attacks.\n    /// @param _sigV The array of V-component of Oracle signatures.\n    /// @param _sigR The array of R-component of Oracle signatures.\n    /// @param _sigS The array of S-component of Oracle signatures.\n    function publishPrice(\n        uint256 _version,\n        bytes32 _coinpair,\n        uint256 _price,\n        address _votedOracle,\n        uint256 _blockNumber,\n        uint8[] calldata _sigV,\n        bytes32[] calldata _sigR,\n        bytes32[] calldata _sigS\n    ) external;\n\n    /// @notice Publish a price without signature validation (when there is an emergecy!!!).\n    /// @param _price Price to report.\n    function emergencyPublish(uint256 _price) external;\n\n    /// @notice The oracle owner has withdrawn some stake.\n    /// Must check if the oracle is part of current round and if he lost his place with the\n    /// new stake value (the stake is global and is saved in the supporters contract).\n    /// @param oracleOwnerAddr the oracle owner that is trying to withdraw\n    function onWithdraw(address oracleOwnerAddr) external returns (uint256);\n\n    /// @notice Switch contract context to a new round. With the objective of\n    /// being a decentralized solution, this can be called by *anyone* if current\n    /// round lock period is expired.\n    /// This method search the subscribed list and choose the 10 with more stake.\n    function switchRound() external;\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS\n\n    /// @notice Return the available reward fees\n    ///\n    function getAvailableRewardFees() external view returns (uint256);\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS TO GET CURRENT PRICE\n    // MUST BE WHITELISTED\n    /// @notice Return the current price, compatible with old MOC Oracle\n    function peek() external view returns (bytes32, bool);\n\n    /// @notice Return the current price\n    function getPrice() external view returns (uint256);\n\n    ///////////////////////////////////////////////////////////////////////////////// GETTERS TO GET CURRENT PRICE END\n\n    /// @notice Return current round information\n    function getRoundInfo()\n        external\n        view\n        returns (\n            uint256 round,\n            uint256 startBlock,\n            uint256 lockPeriodTimestamp,\n            uint256 totalPoints,\n            address[] memory selectedOwners,\n            address[] memory selectedOracles\n        );\n\n    /// @notice Return round information for specific oracle\n    function getOracleRoundInfo(address addr)\n        external\n        view\n        returns (uint256 points, bool selectedInCurrentRound);\n\n    // The maximum count of oracles selected to participate each round\n    function maxOraclesPerRound() external view returns (uint256);\n\n    // The round lock period in secs\n    function roundLockPeriodSecs() external view returns (uint256);\n\n    function isOracleInCurrentRound(address oracleAddr) external view returns (bool);\n\n    /// @notice Returns the amount of oracles subscribed to this coin pair.\n    function getSubscribedOraclesLen() external view returns (uint256);\n\n    /// @notice Returns the oracle owner address that is subscribed to this coin pair\n    /// @param idx index to query.\n    function getSubscribedOracleAtIndex(uint256 idx) external view returns (address ownerAddr);\n\n    // Public variable\n    function getMaxSubscribedOraclesPerRound() external view returns (uint256);\n\n    // Public variable\n    function getCoinPair() external view returns (bytes32);\n\n    // Public variable\n    function getLastPublicationBlock() external view returns (uint256);\n\n    // Public variable\n    function getValidPricePeriodInBlocks() external view returns (uint256);\n\n    // Public variable\n    function getEmergencyPublishingPeriodInBlocks() external view returns (uint256);\n\n    // Public variable\n    function getOracleManager() external view returns (IOracleManager);\n\n    // Public variable\n    function getToken() external view returns (IERC20);\n}\n\n\n/// This contract manages the Oracle and CoinPair registration info.\n/// The Oracle python server interacts with this contract:\n/// - Coin pair registration\n/// - Oracle registration to coin pairs\n/// - Access Oracle info (oracle address + url) indexed by oracle owner address\n/// - Get the oracle information (url + the specifics of some coin pair rounds) from an oracle address\n/// - Get the oracle address from the owner address.\ninterface IOracleManager {\n    // getOracleOwnerStake: Get the stake stored in the supporters smart-contract\n    // prettier-ignore\n    struct OracleManagerCallbacks {\n        function (address) external view returns (uint256) getOracleOwnerStake;\n    }\n\n    /// @notice Register a new coin pair contract (the contract must be created separately).\n    /// Once created the coin pairs cannot be removed.\n    /// @param coinPair The bytes32-encoded coinpair string (e.g. BTCUSD)\n    /// @param addr The contract address associated to the coin pair.\n    function registerCoinPair(bytes32 coinPair, address addr) external;\n\n    /// Register an oracle in the system must be called by the oracle owner.\n    /// @notice Registers the oracle and transfer the specified caller's MOC token stake.\n    /// @param oracleOwnerAddr The address of the owner of the oracle.\n    /// @param oracleAddr Address of the Oracle to register.\n    /// @param internetName Public Internet name of this Oracle.\n    function registerOracle(\n        address oracleOwnerAddr,\n        address oracleAddr,\n        string calldata internetName\n    ) external;\n\n    /// @notice Change the oracle \"internet\" name (URI), called by the owner.\n    /// @param oracleOwnerAddr The address of the owner of the oracle.\n    /// @param name The new name to set.\n    function setOracleName(address oracleOwnerAddr, string calldata name) external;\n\n    /// @notice Change the oracle address, called by the owner.\n    /// @param oracleOwnerAddr The address of the owner of the oracle.\n    /// @param oracleAddr new value for the address of the oracle\n    function setOracleAddress(address oracleOwnerAddr, address oracleAddr) external;\n\n    /// @notice Removes the oracle registration info. Must be called by the owner\n    /// The oracle must be previously unregistered from all coin pairs.\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\n    function removeOracle(address oracleOwnerAddr) external;\n\n    /// @notice Subscribe a registered oracle to participate in the next round of a registered coin-pair.\n    /// @param oracleOwnerAddr Address of oracle owner\n    function subscribeToCoinPair(address oracleOwnerAddr, bytes32 coinPair) external;\n\n    /// @notice Unsubscribe a registered oracle from participating in rounds of a registered coin-pair.\n    /// The oracle is flagged so it is not selected in the next round.\n    /// @param oracleOwnerAddr Address of oracle owner\n    function unSubscribeFromCoinPair(address oracleOwnerAddr, bytes32 coinPair) external;\n\n    /// @notice The oracle owner did a partial withdrawal of funds\n    /// 1. The oracle address is searched by the owner address.\n    /// 2. Each coin pair to which the oracle is subscribed is consulted to:\n    ///   - Check if the new amount is enough to stay in the current round.\n    ///       If not the oracle is replaced and lost his points.\n    ///   - Get the timestamp for the round end.\n    /// The return value is the maximum timestamp from all the coin pairs.\n    /// @param oracleOwnerAddr Address of oracle owner\n    /// @return the timestamp until which the funds must be locked.\n    function onWithdraw(address oracleOwnerAddr) external returns (uint256);\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS USED BY COINPAIR\n    /// @notice Used by the coin pair to get the oracle address from the oracleOwnerAddress.\n    /// @param  oracleOwnerAddr the address of the owner of the oracle.\n    /// @return oracleAddr Address of oracle\n    function getOracleAddress(address oracleOwnerAddr) external view returns (address oracleAddr);\n\n    /// @notice Returns true if oracle is registered.\n    /// @param ownerAddr The address of the oracle's owner.\n    function isRegistered(address ownerAddr) external view returns (bool);\n\n    /// @notice Used by CoinPair\n    /// @param oracleAddr The oracle address not the owner address.\n    function getOracleOwner(address oracleAddr) external view returns (address);\n\n    /// @notice Returns the amount of owners registered.\n    function getRegisteredOraclesLen() external view returns (uint256);\n\n    /// @notice Returns the oracle name and address at index.\n    /// @param idx index to query.\n    function getRegisteredOracleAtIndex(uint256 idx)\n        external\n        view\n        returns (\n            address ownerAddr,\n            address oracleAddr,\n            string memory url\n        );\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS USED BY COINPAIR END\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS\n\n    // TODO: Check what is the minimum amount of getters the python server needs.\n\n    /// @notice Returns true if an oracle is subscribed to a coin pair\n    function isSubscribed(address oracleAddr, bytes32 coinPair) external view returns (bool);\n\n    /// @notice Return true if the oracle is registered on this coin-pair\n    /// @param oracleAddr addr The address of the Oracle check for.\n    function isOracleRegistered(address oracleAddr) external view returns (bool);\n\n    /// @notice Returns registration information for a registered Oracle.\n    /// @param oracleAddr addr The address of the Oracle to query for.\n    function getOracleRegistrationInfo(address oracleAddr)\n        external\n        view\n        returns (\n            string memory internetName,\n            uint256 stake,\n            address _owner\n        );\n\n    /// @notice Returns round information for a registered oracle in a specific coin-pair.\n    /// @param oracleAddr address of the oracle to query for.\n    /// @param coinpair The coin pair to lookup.\n    function getOracleRoundInfo(address oracleAddr, bytes32 coinpair)\n        external\n        view\n        returns (uint256 points, bool selectedInCurrentRound);\n\n    /// @notice Returns true if an oracle satisfies conditions to be removed from system.\n    /// @param oracleAddr the oracle address to lookup.\n    function canRemoveOracle(address oracleAddr) external view returns (bool);\n\n    /// @notice Get the stake in MOCs that an oracle has.\n    /// @param oracleAddr The address of the oracle.\n    function getStake(address oracleAddr) external view returns (uint256 balance);\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTER TO LIST COIN PAIRS\n\n    /// @notice Returns the count of registered coin pairs.\n    /// Keep in mind that Deleted coin-pairs will contain zeroed addresses.\n    function getCoinPairCount() external view returns (uint256);\n\n    /// @notice Returns the coin pair at index.\n    /// @param i index to query.\n    function getCoinPairAtIndex(uint256 i) external view returns (bytes32);\n\n    /// @notice Return the contract address for a specified registered coin pair.\n    /// @param coinpair Coin-pair string to lookup (e.g: BTCUSD)\n    /// @return address Address of contract or zero if does not exist or was deleted.\n    function getContractAddress(bytes32 coinpair) external view returns (address);\n\n    /// @notice Searches a coinpair in coinPairList\n    /// @param coinPair The bytes32-encoded coinpair string (e.g. BTCUSD)\n    /// @param hint Optional hint to start traversing the coinPairList array, zero is to search all the array.\n    function getCoinPairIndex(bytes32 coinPair, uint256 hint) external view returns (uint256);\n\n    function getMaxStake(address[] calldata addresses) external view returns (address, uint256);\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTER TO LIST COIN PAIRS END\n\n    // Public variable\n    function getStakingContract() external view returns (IStakingMachine);\n\n    // Public variable\n    function getMinCPSubscriptionStake() external view returns (uint256);\n}\n\n\n\ninterface IDelayMachine {\n    /// @notice Accept a deposit from an account.\n    /// @param mocs token quantity\n    /// @param expiration the expiration date for this deposit\n    /// @return id the transaction id\n    function deposit(\n        uint256 mocs,\n        address destination,\n        uint256 expiration\n    ) external returns (uint256 id);\n\n    /// @notice Cancel a transaction returning the funds to the source\n    /// @param id transaction id\n    function cancel(uint256 id) external;\n\n    /// @notice Withdraw stake, send it to the delay machine.\n    /// @param id transaction id\n    function withdraw(uint256 id) external;\n\n    /// @notice Returns the list of transaction for some account\n    /// @return ids transaction ids\n    /// @return amounts token quantity\n    /// @return expirations expiration dates\n    function getTransactions(address account)\n        external\n        view\n        returns (\n            uint256[] memory ids,\n            uint256[] memory amounts,\n            uint256[] memory expirations\n        );\n\n    /// @notice Returns the total balance in MOCs for an account\n    function getBalance(address account) external view returns (uint256);\n\n    // Public variable\n    function getToken() external view returns (IERC20);\n\n    // Public variable\n    function getLastId() external view returns (uint256);\n\n    // Public variable\n    function getSource() external view returns (address);\n}\n\n\ninterface IStakingMachine {\n    /// @notice Used by the voting machine to lock the current balance of MOCs.\n    /// @param mocHolder the moc holder whose mocs will be locked.\n    /// @param untilTimestamp timestamp until which the mocs will be locked.\n    function lockMocs(address mocHolder, uint256 untilTimestamp) external;\n\n    /// @notice Accept a deposit from an account.\n    /// Delegate to the Supporters smart contract.\n    /// @param mocs token quantity\n    /// @param destination the destination account of this deposit.\n    function deposit(uint256 mocs, address destination) external;\n\n    /// @notice Accept a deposit from an account.\n    /// @param mocs token quantity\n    /// @param destination the destination account of this deposit.\n    /// @param source the address that approved the transfer\n    function depositFrom(\n        uint256 mocs,\n        address destination,\n        address source\n    ) external;\n\n    /// @notice Withdraw stake, send it to the delay machine.\n    /// @param mocs token quantity\n    function withdraw(uint256 mocs) external;\n\n    /// @notice Reports the balance of MOCs for a specific user.\n    /// @param user user address\n    function getBalance(address user) external view returns (uint256);\n\n    /// @notice Reports the locked balance of MOCs for a specific user.\n    /// @param user user address\n    function getLockedBalance(address user) external view returns (uint256);\n\n    /// @notice Reports the balance of locked MOCs for a specific user.\n    /// Delegates to the Supporters smart contract.\n    /// @param user user address\n    /// @return amount the amount of mocs locked\n    /// @return untilTimestamp the timestamp that corresponds to the locking date.\n    function getLockingInfo(address user)\n        external\n        view\n        returns (uint256 amount, uint256 untilTimestamp);\n\n    // Public variable\n    function getSupporters() external view returns (address);\n\n    // Public variable\n    function getOracleManager() external view returns (IOracleManager);\n\n    // Public variable\n    function getMocToken() external view returns (IERC20);\n\n    // Public variable\n    function getDelayMachine() external view returns (IDelayMachine);\n\n    // Public variable\n    function getWithdrawLockTime() external view returns (uint256);\n}\n\ninterface IStakingMachineOracles {\n    /// @notice Register an oracle\n    /// @param oracleAddr address of the oracle (from which we publish prices)\n    /// @param url url used by the oracle server\n    function registerOracle(address oracleAddr, string calldata url) external;\n\n    /// @notice Change the oracle \"internet\" name (URI)\n    /// @param url The new url to set.\n    function setOracleName(string calldata url) external;\n\n    /// @notice Change the oracle address\n    /// @param oracleAddr The new oracle address\n    function setOracleAddress(address oracleAddr) external;\n\n    /// @notice Return true if the oracle is registered.\n    /// @param oracleAddr addr The address of the Oracle check for.\n    function isOracleRegistered(address oracleAddr) external view returns (bool);\n\n    /// @notice Returns true if an oracle satisfies conditions to be removed from system.\n    /// @param oracleAddr the oracle address to lookup.\n    function canRemoveOracle(address oracleAddr) external view returns (bool);\n\n    /// @notice Remove an oracle.\n    function removeOracle() external;\n\n    /// @notice Returns the count of registered coin pairs.\n    /// Keep in mind that Deleted coin-pairs will contain zeroed addresses.\n    function getCoinPairCount() external view returns (uint256);\n\n    /// @notice Returns the coin pair at index.\n    /// @param i index to query.\n    function getCoinPairAtIndex(uint256 i) external view returns (bytes32);\n\n    /// @notice Return the contract address for a specified registered coin pair.\n    /// @param coinpair Coin-pair string to lookup (e.g: BTCUSD)\n    /// @return address Address of contract or zero if does not exist or was deleted.\n    function getContractAddress(bytes32 coinpair) external view returns (address);\n\n    /// @notice Searches a coinpair in coinPairList\n    /// @param coinPair The bytes32-encoded coinpair string (e.g. BTCUSD)\n    /// @param hint Optional hint to start traversing the coinPairList array, zero is to search all the array.\n    function getCoinPairIndex(bytes32 coinPair, uint256 hint) external view returns (uint256);\n\n    /// @notice Subscribe an oracle to a coin pair.\n    /// @param coinPair coin pair to subscribe, for example BTCUSD\n    function subscribeToCoinPair(bytes32 coinPair) external;\n\n    /// @notice Unsubscribe an oracle from a coin pair.\n    /// @param coinPair coin pair to unsubscribe, for example BTCUSD\n    function unSubscribeFromCoinPair(bytes32 coinPair) external;\n\n    /// @notice Returns true if an oracle is subscribed to a coin pair\n    /// @param oracleAddr address of the oracle\n    /// @param coinPair coin pair to unsubscribe, for example BTCUSD\n    function isSubscribed(address oracleAddr, bytes32 coinPair) external view returns (bool);\n\n    /// @notice Returns the amount of owners registered.\n    /// Delegates to the Oracle Manager smart contract.\n    function getRegisteredOraclesLen() external view returns (uint256);\n\n    /// @notice Returns the oracle name and address at index.\n    /// Delegates to the Oracle Manager smart contract.\n    /// @param idx index to query.\n    function getRegisteredOracleAtIndex(uint256 idx)\n        external\n        view\n        returns (\n            address ownerAddr,\n            address oracleAddr,\n            string memory url\n        );\n}\n\n\ninterface IVotingMachine {\n    /**\n        get current contract state\n        */\n    function getState() external view returns (uint256);\n\n    /**\n        return the current voting round\n        */\n    function getVotingRound() external view returns (uint256);\n\n    /**\n    Pre Vote a proposal\n\n    @param _proposal Address of the change contract that will be executed if this vote is successful\n    */\n    function preVote(address _proposal) external;\n\n    /**\n    Vote a proposal\n\n    @param _inFavorAgainst Type of vote\n    */\n    function vote(bool _inFavorAgainst) external;\n\n    /**\n    There is a veto Condition\n\n    */\n    function vetoCondition() external;\n\n    /**\n    Veto\n    */\n    function veto() external;\n\n    function readyToPreVoteStep() external view returns (bool);\n\n    /**\n    preVoteStep\n    */\n    function preVoteStep() external;\n\n    function readyToVoteStep() external view returns (bool);\n\n    /**\n    voteStep\n    */\n    function voteStep() external;\n\n    /**\n    vetoStep\n    */\n    function vetoStep() external;\n\n    /**\n    acceptedStep\n    */\n    function acceptedStep() external;\n\n    /**\n    Get the pre-voting registered proposal count.\n    */\n    function getProposalCount() external view returns (uint256);\n\n    /**\n    Get pre-voting proposal address and information by index\n\n    @param _index Index of proposal to query.\n    */\n    function getProposalByIndex(uint256 _index)\n        external\n        view\n        returns (\n            address proposalAddress,\n            uint256 proposalVotingRound,\n            uint256 proposalVotes,\n            uint256 proposalExpirationTimeStamp\n        );\n\n    /**\n    Get voting data\n    */\n    function getVotingData()\n        external\n        view\n        returns (\n            address winnerProposal,\n            uint256 inFavorVotes,\n            uint256 againstVotes,\n            uint256 votingExpirationTime\n        );\n\n    /**\n        Get user vote\n    */\n    function getUserVote(address user)\n        external\n        view\n        returns (address voteAddress, uint256 voteRound);\n\n    /**\n    will the call to unregister be successfull?\n\n    @param _proposal Address of the change contract that will be executed if this vote is successful\n    */\n    function canUnregister(address _proposal) external view returns (bool);\n\n    /**\n    Unregister a proposal, free the assets it uses.\n\n    @param _proposal Address of the change contract that will be executed if this vote is successful\n    */\n    function unregister(address _proposal) external;\n}\n\n\n\n\n/**\n  @notice Based on heavily on EnumberableSet, but with the ability to clear all the contents.\n */\nlibrary AddressSetLib {\n    using SafeMath for uint256;\n\n    struct AddressSet {\n        // Storage of set values\n        address[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(address => uint256) _indexes;\n    }\n\n    function init() internal pure returns (AddressSet memory) {\n        return AddressSet({_values: new address[](0)});\n    }\n\n    /**\n     * @dev Removes all value from a set. O(N).\n     *\n     */\n    function clear(AddressSet storage set) internal {\n        for (uint256 i = 0; i < set._values.length; i++) {\n            delete set._indexes[set._values[i]];\n        }\n        delete set._values;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        if (!contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            address lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1;\n            // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        require(set._values.length > index, \"index out of bounds\");\n        return set._values[index];\n    }\n\n    /**\n     * @dev Returns the set contents as an array\n     */\n    function asArray(AddressSet storage set)\n        internal\n        view\n        returns (address[] memory selectedOracles)\n    {\n        return set._values;\n    }\n}\n\n// Autogenerated by registryConstants.js\n\ncontract RegistryConstants {\n    // MOC_TOKEN = keccak256(moc.token)\n    bytes32\n        public constant MOC_TOKEN = 0x4bd5e7ff929fdd1ba62a33f76e0f40e97bb35e8bf126c0d9d91ce5c69a4bc521;\n\n    // MOC_DELAY_MACHINE = keccak256(moc.delay-machine)\n    bytes32\n        public constant MOC_DELAY_MACHINE = 0x66b60892ff6e7f0da16db27046f5960fdfd6bce5c3c8c21d56ccca3236a6281b;\n\n    // MOC_STAKING_MACHINE = keccak256(moc.staking-machine)\n    bytes32\n        public constant MOC_STAKING_MACHINE = 0x3c557531fea67120f21bc7711270a96f1b8cff3dfe3dd798a8a9f09ce9b77972;\n\n    // MOC_VESTING_MACHINE = keccak256(moc.vesting-machine)\n    bytes32\n        public constant MOC_VESTING_MACHINE = 0x7dfea4fb968e2599cdb7b3028c07d0188d0f92d1d00bd95c2805523c224649dd;\n\n    // MOC_VOTING_MACHINE = keccak256(moc.voting-machine)\n    bytes32\n        public constant MOC_VOTING_MACHINE = 0xc0ded27704f62d8726fdbd83648113d9fd8cf32c09f80523d2ba523e0bbd5ba4;\n\n    // MOC_UPGRADE_DELEGATOR = keccak256(moc.upgrade-delegator)\n    bytes32\n        public constant MOC_UPGRADE_DELEGATOR = 0x631bcbb9b033f9c8d13c32cf6e60827348d77b91b58c295e87745219242cca22;\n\n    // MOC_VOTING_MACHINE_MIN_STAKE = keccak256(moc.voting-machine.minStake)\n    bytes32\n        public constant MOC_VOTING_MACHINE_MIN_STAKE = 0x580be8e098dd1016787d59c2a534bf9df9ec679a29de4c8f92dc3807f7d7d54d;\n\n    // MOC_VOTING_MACHINE_PRE_VOTE_EXPIRATION_TIME_DELTA = keccak256(moc.voting-machine.preVoteExpirationTimeDelta)\n    bytes32\n        public constant MOC_VOTING_MACHINE_PRE_VOTE_EXPIRATION_TIME_DELTA = 0x62f5dbf0c17b0df83487409f747ad2eeca5fd54c140ca59b32cf39d6f6eaf916;\n\n    // MOC_VOTING_MACHINE_MAX_PRE_PROPOSALS = keccak256(moc.voting-machine.maxPreProposals)\n    bytes32\n        public constant MOC_VOTING_MACHINE_MAX_PRE_PROPOSALS = 0xc32b9cbc59039d297e670e7c196424308c90ba4a437fa7ccd008498c934e7dbf;\n\n    // MOC_VOTING_MACHINE_PRE_VOTE_MIN_PCT_TO_WIN = keccak256(moc.voting-machine.preVoteMinPCToWin)\n    bytes32\n        public constant MOC_VOTING_MACHINE_PRE_VOTE_MIN_PCT_TO_WIN = 0x0a1b21dfd7e4f3741529cf579e2731e847d81bbf13a82d0eba6910d7ac4c1c0a;\n\n    // MOC_VOTING_MACHINE_VOTE_MIN_PCT_TO_VETO = keccak256(moc.voting-machine.voteMinPctToVeto)\n    bytes32\n        public constant MOC_VOTING_MACHINE_VOTE_MIN_PCT_TO_VETO = 0xfb2d33acd65c36f68a15f8fe41cb8c0dd1eda164ffa87c6882e685ccb1c1adfb;\n\n    // MOC_VOTING_MACHINE_VOTE_MIN_PCT_FOR_QUORUM = keccak256(moc.voting-machine.voteMinPctForQuorum)\n    bytes32\n        public constant MOC_VOTING_MACHINE_VOTE_MIN_PCT_FOR_QUORUM = 0xde1ede48948567c43c504b761af8cd6af5363fafeceb1239b3083955d809714f;\n\n    // MOC_VOTING_MACHINE_VOTE_MIN_PCT_TO_ACCEPT = keccak256(moc.voting-machine.voteMinPctToAccept)\n    bytes32\n        public constant MOC_VOTING_MACHINE_VOTE_MIN_PCT_TO_ACCEPT = 0x99f83ee0c57b325f3deafb536d55596743ff112c6ac0d853d5f4f89b75dec045;\n\n    // MOC_VOTING_MACHINE_PCT_PRECISION = keccak256(moc.voting-machine.PCTPrecision)\n    bytes32\n        public constant MOC_VOTING_MACHINE_PCT_PRECISION = 0x73ee596441ef88c207a7a9147d62f59186b4991555e37b7ce9c801f9539d1050;\n\n    // MOC_VOTING_MACHINE_VOTING_TIME_DELTA = keccak256(moc.voting-machine.votingTimeDelta)\n    bytes32\n        public constant MOC_VOTING_MACHINE_VOTING_TIME_DELTA = 0xb43ee0a5ee6dcc7115ce824e4e353526ad6e479afa4daeb78451070de942de36;\n\n    // ORACLE_MANAGER_ADDR = keccak256(MOC_ORACLE\\1\\ORACLE_MANAGER_ADDR)\n    bytes32\n        public constant ORACLE_MANAGER_ADDR = 0x16986f74674f2ed21d50b6e74e6b12bb323ff4f72364542fd5de5104f3cc3ca9;\n\n    // SUPPORTERS_ADDR = keccak256(MOC_ORACLE\\1\\SUPPORTERS_ADDR)\n    bytes32\n        public constant SUPPORTERS_ADDR = 0xe4f979504d2a7a24557a15195eb83131e7c4a66d33900454705435aa5a6ee086;\n\n    // INFO_ADDR = keccak256(MOC_ORACLE\\1\\INFO_ADDR)\n    bytes32\n        public constant INFO_ADDR = 0xda9f12e01fc92de345bb741448d36ecb967052dd7aa1670439af833c9a3d78f1;\n\n    // ORACLE_PRICE_FETCH_RATE = keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_FETCH_RATE)\n    bytes32\n        public constant ORACLE_PRICE_FETCH_RATE = 0x945f72e5d44fb0ce3b1de393d19415723b79f97ad801089d8470d1c20e15ffef;\n\n    // ORACLE_BLOCKCHAIN_INFO_INTERVAL = keccak256(MOC_ORACLE\\1\\ORACLE_BLOCKCHAIN_INFO_INTERVAL)\n    bytes32\n        public constant ORACLE_BLOCKCHAIN_INFO_INTERVAL = 0x11cfbdf601b80a575e4366f0234cc06de0c9f401fe250dd9dccfccefeedb6fc2;\n\n    // ORACLE_COIN_PAIR_LOOP_TASK_INTERVAL = keccak256(MOC_ORACLE\\1\\ORACLE_COIN_PAIR_LOOP_TASK_INTERVAL)\n    bytes32\n        public constant ORACLE_COIN_PAIR_LOOP_TASK_INTERVAL = 0x2f271dc1fa81985bda14a2d6d0d60b45191d2a2d97e636b192696a8796d654a7;\n\n    // ORACLE_MAIN_LOOP_TASK_INTERVAL = keccak256(MOC_ORACLE\\1\\ORACLE_MAIN_LOOP_TASK_INTERVAL)\n    bytes32\n        public constant ORACLE_MAIN_LOOP_TASK_INTERVAL = 0x275d8a46b817572476d2d55b41c7709dee307740bad676a9693805003a48d231;\n\n    // ORACLE_PRICE_REJECT_DELTA_PCT = keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_REJECT_DELTA_PCT)\n    bytes32\n        public constant ORACLE_PRICE_REJECT_DELTA_PCT = 0x7a3ee46ca1bd3e19089870d8d6530b083a86da93aab52efccb32d5950e2709cf;\n\n    // ORACLE_CONFIGURATION_TASK_INTERVAL = keccak256(MOC_ORACLE\\1\\ORACLE_CONFIGURATION_TASK_INTERVAL)\n    bytes32\n        public constant ORACLE_CONFIGURATION_TASK_INTERVAL = 0xb027f2006a45346de89db4c5efc53f4e05e96532d27366aff00367a394d0abc4;\n\n    // ORACLE_GATHER_SIGNATURE_TIMEOUT = keccak256(MOC_ORACLE\\1\\ORACLE_GATHER_SIGNATURE_TIMEOUT)\n    bytes32\n        public constant ORACLE_GATHER_SIGNATURE_TIMEOUT = 0xf75b08b2b912abdbb87cc459ca0b4fdc019329386ec84ab68399b0c86fed5a95;\n\n    // ORACLE_MAIN_EXECUTOR_TASK_INTERVAL = keccak256(MOC_ORACLE\\1\\ORACLE_MAIN_EXECUTOR_TASK_INTERVAL)\n    bytes32\n        public constant ORACLE_MAIN_EXECUTOR_TASK_INTERVAL = 0xb324a91be1ac0d0c4888c835aee124ca1a7caf4b73ce10aa3504e2683865d7e5;\n\n    // SCHEDULER_POOL_DELAY = keccak256(MOC_ORACLE\\1\\SCHEDULER_POOL_DELAY)\n    bytes32\n        public constant SCHEDULER_POOL_DELAY = 0x6c2abc911c0fa4c73b90c7143a9f4429749be45ebfe7b81e69b86e7ca440d811;\n\n    // SCHEDULER_ROUND_DELAY = keccak256(MOC_ORACLE\\1\\SCHEDULER_ROUND_DELAY)\n    bytes32\n        public constant SCHEDULER_ROUND_DELAY = 0xa82bea7140872d1398fa0ab5075330ab0228f4c7e381b4b6502379ffc7cdcd9f;\n\n    // ORACLE_PRICE_DIGITS = keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_DIGITS)\n    bytes32\n        public constant ORACLE_PRICE_DIGITS = 0x4cd7e3f12ee4a2db0a6ba16e03fbc31bba1048c149bbf4fc9f3c02021ec550b8;\n\n    // ORACLE_QUEUE_LEN = keccak256(MOC_ORACLE\\1\\ORACLE_QUEUE_LEN)\n    bytes32\n        public constant ORACLE_QUEUE_LEN = 0x7d32d87d65898c3cbc7e72c59d223bf61c7811e99dafafd24fb08e0a38f10914;\n\n    // MESSAGE_VERSION = keccak256(MOC_ORACLE\\1\\MESSAGE_VERSION)\n    bytes32\n        public constant MESSAGE_VERSION = 0xeafac1a2b4d4fdcc942cbdce334a88ec83387087978d039f1320d3639a0b59df;\n\n    // ORACLE_STAKE_LIMIT_MULTIPLICATOR = keccak256(MOC_ORACLE\\1\\ORACLE_STAKE_LIMIT_MULTIPLICATOR)\n    bytes32\n        public constant ORACLE_STAKE_LIMIT_MULTIPLICATOR = 0xa1e0b5b458fe661fe687da135d3340a172e262c3cb31d646a4cb5cea9b6f1790;\n\n    // ORACLE_WITHDRAW_LOCK_TIME = keccak256(MOC_ORACLE\\1\\ORACLE_WITHDRAW_LOCK_TIME)\n    bytes32\n        public constant ORACLE_WITHDRAW_LOCK_TIME = 0x5e92c359b77ace8f4933558289f577781c0713b4ff91b2d2f76c8e523e560070;\n\n    // ORACLE_PRICE_DELTA_PCT = keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_DELTA_PCT)\n    bytes32\n        public constant ORACLE_PRICE_DELTA_PCT = 0x41a2ac05b365409628009a8091d8dda06fe52fe2f1c792e651e5df7599a7a7de;\n\n    // ORACLE_PRICE_PUBLISH_BLOCKS = keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_PUBLISH_BLOCKS)\n    bytes32\n        public constant ORACLE_PRICE_PUBLISH_BLOCKS = 0x51a2be29a473202678b6cf57b717ba5d7ff671f01fdbdbfcad4e1882601b8896;\n\n    // ORACLE_ENTERING_FALLBACKS_AMOUNTS = keccak256(MOC_ORACLE\\1\\ORACLE_ENTERING_FALLBACKS_AMOUNTS)\n    bytes32\n        public constant ORACLE_ENTERING_FALLBACKS_AMOUNTS = 0xf646c455329c7af0436f9e95c59c90ce0e11bb4e3a1deff805807798696adf88;\n\n    // ORACLE_TRIGGER_VALID_PUBLICATION_BLOCKS = keccak256(MOC_ORACLE\\1\\ORACLE_TRIGGER_VALID_PUBLICATION_BLOCKS)\n    bytes32\n        public constant ORACLE_TRIGGER_VALID_PUBLICATION_BLOCKS = 0xef9006fe6663199909dfaa4ab45e3f86d6454adb7773682f356824b6b3bc6b0e;\n}\n\nlibrary RegistryConstantsLib {\n    function MOC_TOKEN() internal pure returns (bytes32) {\n        // keccak256(moc.token)\n        return 0x4bd5e7ff929fdd1ba62a33f76e0f40e97bb35e8bf126c0d9d91ce5c69a4bc521;\n    }\n\n    function MOC_DELAY_MACHINE() internal pure returns (bytes32) {\n        // keccak256(moc.delay-machine)\n        return 0x66b60892ff6e7f0da16db27046f5960fdfd6bce5c3c8c21d56ccca3236a6281b;\n    }\n\n    function MOC_STAKING_MACHINE() internal pure returns (bytes32) {\n        // keccak256(moc.staking-machine)\n        return 0x3c557531fea67120f21bc7711270a96f1b8cff3dfe3dd798a8a9f09ce9b77972;\n    }\n\n    function MOC_VESTING_MACHINE() internal pure returns (bytes32) {\n        // keccak256(moc.vesting-machine)\n        return 0x7dfea4fb968e2599cdb7b3028c07d0188d0f92d1d00bd95c2805523c224649dd;\n    }\n\n    function MOC_VOTING_MACHINE() internal pure returns (bytes32) {\n        // keccak256(moc.voting-machine)\n        return 0xc0ded27704f62d8726fdbd83648113d9fd8cf32c09f80523d2ba523e0bbd5ba4;\n    }\n\n    function MOC_UPGRADE_DELEGATOR() internal pure returns (bytes32) {\n        // keccak256(moc.upgrade-delegator)\n        return 0x631bcbb9b033f9c8d13c32cf6e60827348d77b91b58c295e87745219242cca22;\n    }\n\n    function MOC_VOTING_MACHINE_MIN_STAKE() internal pure returns (bytes32) {\n        // keccak256(moc.voting-machine.minStake)\n        return 0x580be8e098dd1016787d59c2a534bf9df9ec679a29de4c8f92dc3807f7d7d54d;\n    }\n\n    function MOC_VOTING_MACHINE_PRE_VOTE_EXPIRATION_TIME_DELTA() internal pure returns (bytes32) {\n        // keccak256(moc.voting-machine.preVoteExpirationTimeDelta)\n        return 0x62f5dbf0c17b0df83487409f747ad2eeca5fd54c140ca59b32cf39d6f6eaf916;\n    }\n\n    function MOC_VOTING_MACHINE_MAX_PRE_PROPOSALS() internal pure returns (bytes32) {\n        // keccak256(moc.voting-machine.maxPreProposals)\n        return 0xc32b9cbc59039d297e670e7c196424308c90ba4a437fa7ccd008498c934e7dbf;\n    }\n\n    function MOC_VOTING_MACHINE_PRE_VOTE_MIN_PCT_TO_WIN() internal pure returns (bytes32) {\n        // keccak256(moc.voting-machine.preVoteMinPCToWin)\n        return 0x0a1b21dfd7e4f3741529cf579e2731e847d81bbf13a82d0eba6910d7ac4c1c0a;\n    }\n\n    function MOC_VOTING_MACHINE_VOTE_MIN_PCT_TO_VETO() internal pure returns (bytes32) {\n        // keccak256(moc.voting-machine.voteMinPctToVeto)\n        return 0xfb2d33acd65c36f68a15f8fe41cb8c0dd1eda164ffa87c6882e685ccb1c1adfb;\n    }\n\n    function MOC_VOTING_MACHINE_VOTE_MIN_PCT_FOR_QUORUM() internal pure returns (bytes32) {\n        // keccak256(moc.voting-machine.voteMinPctForQuorum)\n        return 0xde1ede48948567c43c504b761af8cd6af5363fafeceb1239b3083955d809714f;\n    }\n\n    function MOC_VOTING_MACHINE_VOTE_MIN_PCT_TO_ACCEPT() internal pure returns (bytes32) {\n        // keccak256(moc.voting-machine.voteMinPctToAccept)\n        return 0x99f83ee0c57b325f3deafb536d55596743ff112c6ac0d853d5f4f89b75dec045;\n    }\n\n    function MOC_VOTING_MACHINE_PCT_PRECISION() internal pure returns (bytes32) {\n        // keccak256(moc.voting-machine.PCTPrecision)\n        return 0x73ee596441ef88c207a7a9147d62f59186b4991555e37b7ce9c801f9539d1050;\n    }\n\n    function MOC_VOTING_MACHINE_VOTING_TIME_DELTA() internal pure returns (bytes32) {\n        // keccak256(moc.voting-machine.votingTimeDelta)\n        return 0xb43ee0a5ee6dcc7115ce824e4e353526ad6e479afa4daeb78451070de942de36;\n    }\n\n    function ORACLE_MANAGER_ADDR() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_MANAGER_ADDR)\n        return 0x16986f74674f2ed21d50b6e74e6b12bb323ff4f72364542fd5de5104f3cc3ca9;\n    }\n\n    function SUPPORTERS_ADDR() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\SUPPORTERS_ADDR)\n        return 0xe4f979504d2a7a24557a15195eb83131e7c4a66d33900454705435aa5a6ee086;\n    }\n\n    function INFO_ADDR() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\INFO_ADDR)\n        return 0xda9f12e01fc92de345bb741448d36ecb967052dd7aa1670439af833c9a3d78f1;\n    }\n\n    function ORACLE_PRICE_FETCH_RATE() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_FETCH_RATE)\n        return 0x945f72e5d44fb0ce3b1de393d19415723b79f97ad801089d8470d1c20e15ffef;\n    }\n\n    function ORACLE_BLOCKCHAIN_INFO_INTERVAL() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_BLOCKCHAIN_INFO_INTERVAL)\n        return 0x11cfbdf601b80a575e4366f0234cc06de0c9f401fe250dd9dccfccefeedb6fc2;\n    }\n\n    function ORACLE_COIN_PAIR_LOOP_TASK_INTERVAL() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_COIN_PAIR_LOOP_TASK_INTERVAL)\n        return 0x2f271dc1fa81985bda14a2d6d0d60b45191d2a2d97e636b192696a8796d654a7;\n    }\n\n    function ORACLE_MAIN_LOOP_TASK_INTERVAL() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_MAIN_LOOP_TASK_INTERVAL)\n        return 0x275d8a46b817572476d2d55b41c7709dee307740bad676a9693805003a48d231;\n    }\n\n    function ORACLE_PRICE_REJECT_DELTA_PCT() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_REJECT_DELTA_PCT)\n        return 0x7a3ee46ca1bd3e19089870d8d6530b083a86da93aab52efccb32d5950e2709cf;\n    }\n\n    function ORACLE_CONFIGURATION_TASK_INTERVAL() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_CONFIGURATION_TASK_INTERVAL)\n        return 0xb027f2006a45346de89db4c5efc53f4e05e96532d27366aff00367a394d0abc4;\n    }\n\n    function ORACLE_GATHER_SIGNATURE_TIMEOUT() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_GATHER_SIGNATURE_TIMEOUT)\n        return 0xf75b08b2b912abdbb87cc459ca0b4fdc019329386ec84ab68399b0c86fed5a95;\n    }\n\n    function ORACLE_MAIN_EXECUTOR_TASK_INTERVAL() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_MAIN_EXECUTOR_TASK_INTERVAL)\n        return 0xb324a91be1ac0d0c4888c835aee124ca1a7caf4b73ce10aa3504e2683865d7e5;\n    }\n\n    function SCHEDULER_POOL_DELAY() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\SCHEDULER_POOL_DELAY)\n        return 0x6c2abc911c0fa4c73b90c7143a9f4429749be45ebfe7b81e69b86e7ca440d811;\n    }\n\n    function SCHEDULER_ROUND_DELAY() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\SCHEDULER_ROUND_DELAY)\n        return 0xa82bea7140872d1398fa0ab5075330ab0228f4c7e381b4b6502379ffc7cdcd9f;\n    }\n\n    function ORACLE_PRICE_DIGITS() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_DIGITS)\n        return 0x4cd7e3f12ee4a2db0a6ba16e03fbc31bba1048c149bbf4fc9f3c02021ec550b8;\n    }\n\n    function ORACLE_QUEUE_LEN() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_QUEUE_LEN)\n        return 0x7d32d87d65898c3cbc7e72c59d223bf61c7811e99dafafd24fb08e0a38f10914;\n    }\n\n    function MESSAGE_VERSION() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\MESSAGE_VERSION)\n        return 0xeafac1a2b4d4fdcc942cbdce334a88ec83387087978d039f1320d3639a0b59df;\n    }\n\n    function ORACLE_STAKE_LIMIT_MULTIPLICATOR() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_STAKE_LIMIT_MULTIPLICATOR)\n        return 0xa1e0b5b458fe661fe687da135d3340a172e262c3cb31d646a4cb5cea9b6f1790;\n    }\n\n    function ORACLE_WITHDRAW_LOCK_TIME() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_WITHDRAW_LOCK_TIME)\n        return 0x5e92c359b77ace8f4933558289f577781c0713b4ff91b2d2f76c8e523e560070;\n    }\n\n    function ORACLE_PRICE_DELTA_PCT() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_DELTA_PCT)\n        return 0x41a2ac05b365409628009a8091d8dda06fe52fe2f1c792e651e5df7599a7a7de;\n    }\n\n    function ORACLE_PRICE_PUBLISH_BLOCKS() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_PUBLISH_BLOCKS)\n        return 0x51a2be29a473202678b6cf57b717ba5d7ff671f01fdbdbfcad4e1882601b8896;\n    }\n\n    function ORACLE_ENTERING_FALLBACKS_AMOUNTS() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_ENTERING_FALLBACKS_AMOUNTS)\n        return 0xf646c455329c7af0436f9e95c59c90ce0e11bb4e3a1deff805807798696adf88;\n    }\n\n    function ORACLE_TRIGGER_VALID_PUBLICATION_BLOCKS() internal pure returns (bytes32) {\n        // keccak256(MOC_ORACLE\\1\\ORACLE_TRIGGER_VALID_PUBLICATION_BLOCKS)\n        return 0xef9006fe6663199909dfaa4ab45e3f86d6454adb7773682f356824b6b3bc6b0e;\n    }\n}\n\n\n/*\n    Abstract contract meant to be reused.\n*/\nlibrary VestingLib {\n    uint256 public constant PERCENTAGES_BASE = 10000;\n\n    using SafeMath for uint256;\n    using AddressSetLib for AddressSetLib.AddressSet;\n\n    // Global data\n    struct VestingData {\n        // @dev Percentages array of locked funds at a given time,\n        // percentages are in fixed point with 4 decimals,\n        // percentages should be in decreasing order.\n        // Example: percentages = [9000, 5000, 0]\n        uint256[] percentages;\n        // @dev Time deltas array when percentages become active,\n        // time deltas should sorted in increasing order,\n        // time deltas are measured from the TGE event,\n        // time deltas are expressed in seconds.\n        // Example: timedeltas = [2592000, 7776000, 15552000]\n        uint256[] timedeltas;\n        // @dev Address of holder\n        address holder;\n        // @dev Vesting Factory\n        VestingFactory vestingFactory;\n        // @dev Registry contracts\n        IRegistry registry;\n        // @dev Indicates if holder has verified the contract\n        bool verified;\n        // @dev Total vesting\n        uint256 total;\n        // @dev Contract that can be called with callWithData\n        AddressSetLib.AddressSet whitelistedContracts;\n    }\n\n    /**\n        Contract creation\n\n        @param _holder address who will able to withdraw tokens when released\n    */\n    function _initialize(\n        VestingData storage self,\n        VestingFactory _vestingFactory,\n        address _holder\n    ) internal {\n        self.holder = _holder;\n        self.verified = false;\n        require(_vestingFactory != VestingFactory(0), \"Invalid vestingFactory address\");\n        self.vestingFactory = _vestingFactory;\n        self.registry = _vestingFactory.getRegistry();\n        self.whitelistedContracts.add(address(_getDelayMachine(self)));\n        self.whitelistedContracts.add(address(_getStakingMachine(self)));\n        self.whitelistedContracts.add(address(_getVotingMachine(self)));\n    }\n\n    /**\n     * @notice Retrieve vesting parameters\n     */\n    function _getParameters(VestingData storage self)\n        internal\n        view\n        returns (uint256[] memory, uint256[] memory)\n    {\n        return (self.percentages, self.timedeltas);\n    }\n\n    /**\n     * @notice Mark contract as verified by holder\n     */\n    function _verify(VestingData storage self) internal {\n        require(msg.sender == self.holder, \"Only holder can verify contract\");\n        self.verified = true;\n    }\n\n    /**\n     * @notice Change holder address\n     * @param _newHolder the new holder\n     */\n    function _setHolder(VestingData storage self, address _newHolder) internal {\n        require(msg.sender == address(self.vestingFactory), \"Only factory can change holder\");\n        require(!_isVerified(self), \"Cannot change after verification\");\n        self.holder = _newHolder;\n    }\n\n    /**\n     * @notice Calls a function from target passing data\n     * @param target Target contract to call\n     * @param data Data to pass target contract\n     */\n    function _callWithData(\n        VestingData storage self,\n        address target,\n        bytes memory data\n    ) internal {\n        require(msg.sender == self.holder, \"Holder is required\");\n        require(self.whitelistedContracts.contains(target), \"Invalid target\");\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = target.call(data);\n        require(success, \"CallWithData failed\");\n    }\n\n    /**\n     * @notice approve a transfer to the staking machine.\n     * @param amount Token amount to approve\n     */\n    function approve(VestingData storage self, uint256 amount) internal {\n        require(msg.sender == self.holder, \"Holder is required\");\n        _approve(self, amount);\n    }\n\n    /**\n     * @notice deposit MOCs in the staking machine\n     * @param amount Token amount to approve\n     */\n    function _deposit(VestingData storage self, uint256 amount) internal {\n        require(msg.sender == self.holder, \"Holder is required\");\n        IStakingMachine stakingMachine = _getStakingMachine(self);\n        _approve(self, amount);\n        stakingMachine.deposit(amount, address(this));\n    }\n\n    /**\n     * @notice Withdraws tokens to holder address\n     * @param amount Tokens amount to withdraw\n     * @return Returns true on success\n     */\n    function _withdraw(VestingData storage self, uint256 amount) internal returns (bool) {\n        require(_isVerified(self), \"Holder should verify\");\n        require(msg.sender == self.holder, \"Holder is required\");\n        uint256 freeMocs = _getAvailable(self);\n        require(amount <= freeMocs, \"Not enough mocs to withdraw\");\n        IERC20 token = _getToken(self);\n        require(token.transfer(msg.sender, amount), \"Withdraw failed\");\n        return true;\n    }\n\n    /**\n     * @notice Withdraws all available tokens to holder address\n     * @return Returns true on success\n     */\n    function _withdrawAll(VestingData storage self) internal returns (bool) {\n        require(msg.sender == self.holder, \"Holder is required\");\n        uint256 amount = _getAvailable(self);\n        require(amount > 0, \"Not enough mocs to withdraw\");\n        IERC20 token = _getToken(self);\n        require(token.transfer(msg.sender, amount), \"Withdraw failed\");\n        return true;\n    }\n\n    /**\n     * @notice Configure vesting total balance\n     */\n    function _setTotal(VestingData storage self, uint256 amount) internal {\n        require(msg.sender == address(self.vestingFactory), \"Only factory allowed\");\n        self.total = amount;\n    }\n\n    /**\n     * @notice Token amount available for withdrawal\n     */\n    function _getAvailable(VestingData storage self) internal view returns (uint256) {\n        if (!_isWithdrawEnabled(self)) {\n            // Withdraw not enabled\n            return 0;\n        }\n        // Minimum token amount to be locked in vesting contract\n        uint256 minimumLocked = _getLocked(self);\n        // Tokens locked in outside contracts\n        uint256 lockedOutside = _getStakingBalance(self);\n        lockedOutside = lockedOutside.add(_getDelayBalance(self));\n        if (minimumLocked >= lockedOutside) {\n            minimumLocked = minimumLocked.sub(lockedOutside);\n        } else {\n            minimumLocked = 0;\n        }\n        uint256 balance = _getTokenBalance(self);\n        // Available mocs for withdrawal\n        uint256 freeMocs = 0;\n        if (balance >= minimumLocked) {\n            freeMocs = balance.sub(minimumLocked);\n        }\n        return freeMocs;\n    }\n\n    function _isVerified(VestingData storage self) internal view returns (bool) {\n        return self.verified;\n    }\n\n    /**\n     * @notice Minimum token amount required to be locked\n     */\n    function _getLocked(VestingData storage self) internal view returns (uint256) {\n        // solhint-disable-next-line not-rely-on-time\n        return _getLockedAt(self, block.timestamp);\n    }\n\n    /**\n     * @notice Minimum token amount required to be locked\n     * @param timestamp date to check\n     */\n    function _getLockedAt(VestingData storage self, uint256 timestamp)\n        internal\n        view\n        returns (uint256)\n    {\n        if (!self.vestingFactory.isTGEConfigured()) {\n            // TGE not configured yet\n            return self.total;\n        }\n        uint256 tgeTimestamp = self.vestingFactory.getTGETimestamp();\n        if (timestamp <= tgeTimestamp) {\n            // Can't withdraw at a time prior to the TGE\n            return self.total;\n        }\n        // Time deltas are base from the TGE event and they are expressed in days\n        uint256 delta = timestamp.sub(tgeTimestamp);\n        uint256 i = 0;\n        // Search i such that timedeltas[i-1] <= delta < timedeltas[i]\n        while (i < self.timedeltas.length && delta >= self.timedeltas[i]) {\n            i += 1;\n        }\n        if (i >= self.timedeltas.length) {\n            // All funds are available\n            return 0;\n        } else if (i == 0) {\n            return self.total;\n        } else {\n            return (self.total.mul(self.percentages[i - 1])).div(PERCENTAGES_BASE);\n        }\n    }\n\n    /**\n     * @notice Add an address to the whitelisted contracts\n     * @param addr address to add\n     */\n    function _addToWhitelist(VestingData storage self, address addr) internal returns (bool) {\n        require(msg.sender == address(self.vestingFactory), \"Only factory allowed\");\n        return self.whitelistedContracts.add(addr);\n    }\n\n    /**\n     * @notice Remove an address from the whitelisted contracts\n     * @param addr address to add\n     */\n    function _removeFromWhitelist(VestingData storage self, address addr) internal returns (bool) {\n        require(msg.sender == address(self.vestingFactory), \"Only factory allowed\");\n        return self.whitelistedContracts.remove(addr);\n    }\n\n    /**\n     * @notice Get the whitelisted contracts length\n     */\n    function _getWhitelistLen(VestingData storage self) internal view returns (uint256) {\n        return self.whitelistedContracts.length();\n    }\n\n    /**\n     * @notice Get the whitelisted contracts length\n     * @param idx the index in the whitelist\n     */\n    function _getWhitelistEntry(VestingData storage self, uint256 idx)\n        internal\n        view\n        returns (address)\n    {\n        return self.whitelistedContracts.at(idx);\n    }\n\n    function _updateParameters(\n        VestingData storage self,\n        uint256[] memory _percentages,\n        uint256[] memory _timedeltas\n    ) internal {\n        require(_percentages.length == _timedeltas.length, \"Arrays length should be equal\");\n        for (uint256 i = 1; i < _timedeltas.length; i += 1) {\n            require(_percentages[i - 1] >= _percentages[i], \"Percentages decreasing order\");\n            require(_timedeltas[i - 1] < _timedeltas[i], \"Time deltas increasing order\");\n        }\n        self.percentages = _percentages;\n        self.timedeltas = _timedeltas;\n    }\n\n    function _approve(VestingData storage self, uint256 amount) internal {\n        IERC20 mocToken = _getToken(self);\n        require(mocToken.approve(address(_getStakingMachine(self)), amount), \"Approve failed\");\n    }\n\n    function _getToken(VestingData storage self) internal view returns (IERC20) {\n        return IERC20(self.registry.getAddress(RegistryConstantsLib.MOC_TOKEN()));\n    }\n\n    function _getTokenBalance(VestingData storage self) internal view returns (uint256) {\n        return _getToken(self).balanceOf(address(this));\n    }\n\n    function _getDelayMachine(VestingData storage self) internal view returns (IDelayMachine) {\n        return IDelayMachine(self.registry.getAddress(RegistryConstantsLib.MOC_DELAY_MACHINE()));\n    }\n\n    function _getDelayBalance(VestingData storage self) internal view returns (uint256) {\n        return _getDelayMachine(self).getBalance(address(this));\n    }\n\n    function _getStakingMachine(VestingData storage self) internal view returns (IStakingMachine) {\n        return\n            IStakingMachine(self.registry.getAddress(RegistryConstantsLib.MOC_STAKING_MACHINE()));\n    }\n\n    function _getStakingBalance(VestingData storage self) internal view returns (uint256) {\n        return _getStakingMachine(self).getBalance(address(this));\n    }\n\n    function _getVotingMachine(VestingData storage self) internal view returns (IVotingMachine) {\n        return IVotingMachine(self.registry.getAddress(RegistryConstantsLib.MOC_VOTING_MACHINE()));\n    }\n\n    function _isWithdrawEnabled(VestingData storage self) internal view returns (bool) {\n        // solhint-disable-next-line not-rely-on-time\n        uint256 timestamp = block.timestamp;\n        return (self.vestingFactory.isTGEConfigured() &&\n            timestamp >= self.vestingFactory.getTGETimestamp());\n    }\n}\n\n\n/// @title Vesting contract\n/// @notice Release tokens following a release schedule\ncontract Vesting is IVestingMachine {\n    using SafeMath for uint256;\n    using VestingLib for VestingLib.VestingData;\n\n    VestingLib.VestingData internal vestingData;\n\n    /// @notice Create a vesting contract\n    /// @param _holder address who will able to withdraw tokens when released\n    /// @param _percentages array of token percentages locked at a date\n    /// @param _timedeltas array of date deltas from TGE when percentages are valid\n    constructor(\n        address _holder,\n        uint256[] memory _percentages,\n        uint256[] memory _timedeltas\n    ) public {\n        vestingData._initialize(VestingFactory(msg.sender), _holder);\n        vestingData._updateParameters(_percentages, _timedeltas);\n    }\n\n    /// @notice Retrieve vesting parameters\n    function getParameters() public view override returns (uint256[] memory, uint256[] memory) {\n        return vestingData._getParameters();\n    }\n\n    /// @notice Mark contract as verified by holder\n    function verify() public override {\n        vestingData._verify();\n    }\n\n    /// @notice Change holder address\n    /// @param newHolder the new holder\n    function setHolder(address newHolder) public override {\n        vestingData._setHolder(newHolder);\n    }\n\n    /// @notice Returns current holder address\n    function getHolder() public view override returns (address) {\n        return vestingData.holder;\n    }\n\n    /// @notice Calls a function from target passing data\n    /// @param target Target contract to call\n    /// @param data Data to pass target contract\n    function callWithData(address target, bytes memory data) public override {\n        vestingData._callWithData(target, data);\n    }\n\n    /// @notice approve a transfer to the staking machine.\n    /// @param amount Token amount to approve\n    function approve(uint256 amount) public override {\n        vestingData.approve(amount);\n    }\n\n    /// @notice deposit MOCs in the staking machine\n    /// @param amount Token amount to approve\n    function deposit(uint256 amount) public override {\n        vestingData._deposit(amount);\n    }\n\n    /// @notice Withdraws tokens to holder address\n    /// @param amount Tokens amount to withdraw\n    /// @return Returns true on success\n    function withdraw(uint256 amount) public override returns (bool) {\n        return vestingData._withdraw(amount);\n    }\n\n    /// @notice Withdraws all available tokens to holder address\n    /// @return Returns true on success\n    function withdrawAll() public override returns (bool) {\n        return vestingData._withdrawAll();\n    }\n\n    /// @notice Minimum token amount required to be locked\n    /// @param timestamp date to check\n    function getLockedAt(uint256 timestamp) public view override returns (uint256) {\n        return vestingData._getLockedAt(timestamp);\n    }\n\n    /// @notice Minimum token amount required to be locked\n    function getLocked() public view override returns (uint256) {\n        return vestingData._getLocked();\n    }\n\n    /// @notice Token amount available for withdrawal\n    function getAvailable() public view override returns (uint256) {\n        return vestingData._getAvailable();\n    }\n\n    /// @notice Returns true after contract has been verified by holder\n    function isVerified() public view override returns (bool) {\n        return vestingData._isVerified();\n    }\n\n    /// @notice Total token balance configured\n    function getTotal() public view override returns (uint256) {\n        return vestingData.total;\n    }\n\n    /// @notice Configure vesting total balance\n    function setTotal(uint256 amount) public override {\n        vestingData._setTotal(amount);\n    }\n\n    /// @notice Add an address to the whitelisted contracts\n    /// @param addr address to add\n    function addToWhitelist(address addr) public returns (bool) {\n        return vestingData._addToWhitelist(addr);\n    }\n\n    /// @notice Remove an address from the whitelisted contracts\n    /// @param addr address to add\n    function removeFromWhitelist(address addr) public returns (bool) {\n        return vestingData._removeFromWhitelist(addr);\n    }\n\n    /// @notice Get the whitelisted contracts length\n    function getWhitelistLen() public view returns (uint256) {\n        return vestingData._getWhitelistLen();\n    }\n\n    /// @notice Get the whitelisted contracts length\n    /// @param idx the index in the whitelist\n    function getWhitelistEntry(uint256 idx) public view returns (address) {\n        return vestingData._getWhitelistEntry(idx);\n    }\n}\n\n\ncontract VestingFactoryStorage is Initializable, Governed, OwnableUpgradeSafe {\n    using AddressSetLib for AddressSetLib.AddressSet;\n\n    /// @dev Registry to consult addresses\n    IRegistry internal registry;\n\n    /// @dev TGE timestamp\n    uint256 internal tgeTimestamp;\n\n    // @dev contract that can be called with callWithData\n    AddressSetLib.AddressSet internal vestingMachines;\n}\n\n\ncontract VestingFactory is VestingFactoryStorage, IVestingFactory {\n    event VestingCreated(address vesting, address holder);\n\n    /// @notice Contract creation\n    /// @param _governor The address of the contract which governs this one\n    /// @param _registry Registry contracts\n    function initialize(IGovernor _governor, IRegistry _registry) external initializer {\n        Governed._initialize(_governor);\n        __Ownable_init();\n        registry = _registry;\n        tgeTimestamp = 0;\n    }\n\n    /// @notice Create a holder wallet\n    /// @param holder wallet's owner\n    /// @param percentages percentages allowed in each step\n    /// @param timedeltas duration of each step\n    function create(\n        address holder,\n        uint256[] memory percentages,\n        uint256[] memory timedeltas\n    ) external override onlyOwner {\n        Vesting wallet = _createVesting(holder, percentages, timedeltas);\n        vestingMachines.add(address(wallet));\n        emit VestingCreated(address(wallet), holder);\n    }\n\n    function replaceHolder(IVestingMachine wallet, address newHolder) public onlyOwner {\n        wallet.setHolder(newHolder);\n    }\n\n    /// @notice Set the TGE time enabling holder wallets\n    function setTGE() public override onlyOwner {\n        require(tgeTimestamp == 0, \"TGE already configured\");\n        // solhint-disable-next-line not-rely-on-time\n        tgeTimestamp = block.timestamp;\n    }\n\n    /// @notice Returns true when the TGE was configured\n    function isTGEConfigured() public view override returns (bool) {\n        return tgeTimestamp > 0;\n    }\n\n    /// @notice Returns the configured TGE timestamp\n    function getTGETimestamp() public view override returns (uint256) {\n        return tgeTimestamp;\n    }\n\n    /// @notice Set a holder wallet balance\n    /// @param wallet the vesting machine\n    /// @param amount wallet balance\n    function setTotal(IVestingMachine wallet, uint256 amount) public override onlyOwner {\n        require(tgeTimestamp == 0, \"TGE already configured\");\n        wallet.setTotal(amount);\n    }\n\n    /// @notice Return registry\n    function getRegistry() public view override returns (IRegistry) {\n        return registry;\n    }\n\n    /// @notice Get the length of the list of vesting machines\n    function getVestingMachinesLen() public view override returns (uint256) {\n        return vestingMachines.length();\n    }\n\n    /// @notice Get the an entry of the list of vesting machines\n    /// @param idx the index in the list\n    function getVestingMachinesEntry(uint256 idx) public view override returns (address) {\n        return vestingMachines.at(idx);\n    }\n\n    function _createVesting(\n        address holder,\n        uint256[] memory percentages,\n        uint256[] memory timedeltas\n    ) internal returns (Vesting) {\n        return new Vesting(holder, percentages, timedeltas);\n    }\n}\n\n",
            "file": "VestingFactory.sol"
        }
    ],
    "libraries": {},
    "creationData": {
        "blockHash": "0x4ffbd5d354ddf13319142777317b0945c6a3ec46b71f0651c07505a3a50910e9",
        "blockNumber": 1694328,
        "transactionHash": "0x688af9f802ce83b48668eefc677f1d22bdf5d9227d05f55b9e8caf393f29596f",
        "timestamp": 1616096004
    }
}