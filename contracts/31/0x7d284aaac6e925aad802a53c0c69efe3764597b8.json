{
  "address": "0x7d284aaac6e925aad802a53c0c69efe3764597b8",
  "net": {
    "id": "31",
    "name": "RSK Testnet"
  },
  "name": "RNS",
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "evmVersion": "byzantium"
  },
  "version": "0.4.24+commit.e67f0147",
  "source": "pragma solidity ^0.4.24;\n\nimport './AbstractRNS.sol';\n\n/**\n * The RNS registry contract.\n */\ncontract RNS is AbstractRNS {\n    struct Record {\n        address owner;\n        address resolver;\n        uint64 ttl;\n    }\n\n    mapping(bytes32=>Record) records;\n\n    // Permits modifications only by the owner of the specified node.\n    modifier only_owner(bytes32 node) {\n        require(records[node].owner == msg.sender);\n        _;\n    }\n\n    /**\n     * Constructs a new RNS registrar.\n     */\n    constructor() public {\n        records[bytes32(0)].owner = msg.sender;\n    }\n\n    /**\n     * Returns the address that owns the specified node.\n     */\n    function owner(bytes32 node) public view returns (address) {\n        return records[node].owner;\n    }\n\n    /**\n     * Returns the address of the resolver for the specified node.\n     */\n    function resolver(bytes32 node) public view returns (address) {\n        return records[node].resolver;\n    }\n\n    /**\n     * Returns the TTL of a node, and any records associated with it.\n     */\n    function ttl(bytes32 node) public view returns (uint64) {\n        return records[node].ttl;\n    }\n\n    /**\n     * Transfers ownership of a node to a new address. May only be called by the current\n     * owner of the node.\n     * @param node The node to transfer ownership of.\n     * @param ownerAddress The address of the new owner.\n     */\n    function setOwner(bytes32 node, address ownerAddress) public only_owner(node) {\n        emit Transfer(node, ownerAddress);\n        records[node].owner = ownerAddress;\n    }\n\n    /**\n     * Transfers ownership of a subnode keccak256(node, label) to a new address. May only be\n     * called by the owner of the parent node.\n     * @param node The parent node.\n     * @param label The hash of the label specifying the subnode.\n     * @param ownerAddress The address of the new owner.\n     */\n    function setSubnodeOwner(bytes32 node, bytes32 label, address ownerAddress) public only_owner(node) {\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\n        emit NewOwner(node, label, ownerAddress);\n        records[subnode].owner = ownerAddress;\n\n        emit NewResolver(subnode, records[node].resolver);\n        records[subnode].resolver = records[node].resolver;\n    }\n\n    /**\n     * Sets the resolver address for the specified node.\n     * @param node The node to update.\n     * @param resolverAddress The address of the resolver.\n     */\n    function setResolver(bytes32 node, address resolverAddress) public only_owner(node) {\n        emit NewResolver(node, resolverAddress);\n        records[node].resolver = resolverAddress;\n    }\n\n    /**\n     * Sets the TTL for the specified node.\n     * @param node The node to update.\n     * @param ttlValue The TTL in seconds.\n     */\n    function setTTL(bytes32 node, uint64 ttlValue) public only_owner(node) {\n        emit NewTTL(node, ttlValue);\n        records[node].ttl = ttlValue;\n    }\n\n    /**\n     * Sets the default resolver for new nodes\n     * @param resolver The address of the new defaultResolver\n     */\n    function setDefaultResolver(address resolver) public only_owner(0) {\n        records[bytes32(0)].resolver = resolver;\n    }\n}\n",
  "imports": [
    {
      "name": "RNS.sol",
      "contents": "pragma solidity ^0.4.24;\n\nimport './AbstractRNS.sol';\n\n/**\n * The RNS registry contract.\n */\ncontract RNS is AbstractRNS {\n    struct Record {\n        address owner;\n        address resolver;\n        uint64 ttl;\n    }\n\n    mapping(bytes32=>Record) records;\n\n    // Permits modifications only by the owner of the specified node.\n    modifier only_owner(bytes32 node) {\n        require(records[node].owner == msg.sender);\n        _;\n    }\n\n    /**\n     * Constructs a new RNS registrar.\n     */\n    constructor() public {\n        records[bytes32(0)].owner = msg.sender;\n    }\n\n    /**\n     * Returns the address that owns the specified node.\n     */\n    function owner(bytes32 node) public view returns (address) {\n        return records[node].owner;\n    }\n\n    /**\n     * Returns the address of the resolver for the specified node.\n     */\n    function resolver(bytes32 node) public view returns (address) {\n        return records[node].resolver;\n    }\n\n    /**\n     * Returns the TTL of a node, and any records associated with it.\n     */\n    function ttl(bytes32 node) public view returns (uint64) {\n        return records[node].ttl;\n    }\n\n    /**\n     * Transfers ownership of a node to a new address. May only be called by the current\n     * owner of the node.\n     * @param node The node to transfer ownership of.\n     * @param ownerAddress The address of the new owner.\n     */\n    function setOwner(bytes32 node, address ownerAddress) public only_owner(node) {\n        emit Transfer(node, ownerAddress);\n        records[node].owner = ownerAddress;\n    }\n\n    /**\n     * Transfers ownership of a subnode keccak256(node, label) to a new address. May only be\n     * called by the owner of the parent node.\n     * @param node The parent node.\n     * @param label The hash of the label specifying the subnode.\n     * @param ownerAddress The address of the new owner.\n     */\n    function setSubnodeOwner(bytes32 node, bytes32 label, address ownerAddress) public only_owner(node) {\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\n        emit NewOwner(node, label, ownerAddress);\n        records[subnode].owner = ownerAddress;\n\n        emit NewResolver(subnode, records[node].resolver);\n        records[subnode].resolver = records[node].resolver;\n    }\n\n    /**\n     * Sets the resolver address for the specified node.\n     * @param node The node to update.\n     * @param resolverAddress The address of the resolver.\n     */\n    function setResolver(bytes32 node, address resolverAddress) public only_owner(node) {\n        emit NewResolver(node, resolverAddress);\n        records[node].resolver = resolverAddress;\n    }\n\n    /**\n     * Sets the TTL for the specified node.\n     * @param node The node to update.\n     * @param ttlValue The TTL in seconds.\n     */\n    function setTTL(bytes32 node, uint64 ttlValue) public only_owner(node) {\n        emit NewTTL(node, ttlValue);\n        records[node].ttl = ttlValue;\n    }\n\n    /**\n     * Sets the default resolver for new nodes\n     * @param resolver The address of the new defaultResolver\n     */\n    function setDefaultResolver(address resolver) public only_owner(0) {\n        records[bytes32(0)].resolver = resolver;\n    }\n}\n",
      "file": "RNS.sol"
    },
    {
      "name": "AbstractRNS.sol",
      "contents": "pragma solidity ^0.4.24;\n\ncontract AbstractRNS {\n    function owner(bytes32 node) public view returns(address);\n    function resolver(bytes32 node) public view returns(address);\n    function ttl(bytes32 node) public view returns(uint64);\n    function setOwner(bytes32 node, address ownerAddress) public;\n    function setSubnodeOwner(bytes32 node, bytes32 label, address ownerAddress) public;\n    function setResolver(bytes32 node, address resolverAddress) public;\n    function setTTL(bytes32 node, uint64 ttlValue) public;\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address ownerAddress);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address ownerAddress);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolverAddress);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttlValue);\n}\n"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x9f2f4345ada80f775820f038cbf49a4c2179eb4440664376252bb571cbb9cab5",
    "blockNumber": 385322,
    "transactionHash": "0x74e16ae390311fcd9ccdba7f81c74f43bb0376f1d2c12559d347c4f63736c744",
    "timestamp": 1574275952
  }
}