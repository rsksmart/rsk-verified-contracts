{
  "address": "0x23e485b89287a576baab6fd5927605387e730cc4",
  "net": {
    "id": "31",
    "name": "RSK Testnet"
  },
  "name": "UpgradeDelegator",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    }
  },
  "version": "0.6.12+commit.27d51765",
  "source": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\n\n/**\n * @dev Interface of the openzeppeling AdminUpgradeabilityProxy\n */\ninterface IOZAdminUpgradeabilityProxy {\n    /**\n     * @dev Emitted when the administration has been transferred.\n     * @param previousAdmin Address of the previous admin.\n     * @param newAdmin Address of the new admin.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @return The address of the proxy admin.\n     */\n    function admin() external returns (address);\n\n    /**\n     * @return The address of the implementation.\n     */\n    function implementation() external returns (address);\n\n    /**\n     * @dev Changes the admin of the proxy.\n     * Only the current admin can call this function.\n     * @param newAdmin Address to transfer proxy administration to.\n     */\n    function changeAdmin(address newAdmin) external;\n\n    /**\n     * @dev Upgrade the backing implementation of the proxy.\n     * Only the admin can call this function.\n     * @param newImplementation Address of the new implementation.\n     */\n    function upgradeTo(address newImplementation) external;\n\n    /**\n     * @dev Upgrade the backing implementation of the proxy and call a function\n     * on the new implementation.\n     * This is useful to initialize the proxied contract.\n     * @param newImplementation Address of the new implementation.\n     * @param data Data to send as msg.data in the low level call.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     * @param implementation Address of the new implementation.\n     */\n    event Upgraded(address indexed implementation);\n}\n\n\n\n/**\n * @dev Interface of the openzeppeling ProxyAdmin\n */\ninterface IOZProxyAdmin {\n    /**\n     * @dev Returns the current implementation of a proxy.\n     * This is needed because only the proxy admin can query it.\n     * @return The address of the current implementation of the proxy.\n     */\n    function getProxyImplementation(IOZAdminUpgradeabilityProxy proxy)\n        external\n        view\n        returns (address);\n\n    /**\n     * @dev Returns the admin of a proxy. Only the admin can query it.\n     * @return The address of the current admin of the proxy.\n     */\n    function getProxyAdmin(IOZAdminUpgradeabilityProxy proxy) external view returns (address);\n\n    /**\n     * @dev Changes the admin of a proxy.\n     * @param proxy Proxy to change admin.\n     * @param newAdmin Address to transfer proxy administration to.\n     */\n    function changeProxyAdmin(IOZAdminUpgradeabilityProxy proxy, address newAdmin) external;\n\n    /**\n     * @dev Upgrades a proxy to the newest implementation of a contract.\n     * @param proxy Proxy to be upgraded.\n     * @param implementation the address of the Implementation.\n     */\n    function upgrade(IOZAdminUpgradeabilityProxy proxy, address implementation) external;\n\n    /**\n     * @dev Upgrades a proxy to the newest implementation of a contract and forwards a function call to it.\n     * This is useful to initialize the proxied contract.\n     * @param proxy Proxy to be upgraded.\n     * @param implementation Address of the Implementation.\n     * @param data Data to send as msg.data in the low level call.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     */\n    function upgradeAndCall(\n        IOZAdminUpgradeabilityProxy proxy,\n        address implementation,\n        bytes calldata data\n    ) external payable;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @return true if msg.sender is the owner of the contract.\n     */\n    function isOwner() external view returns (bool);\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() external;\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) external;\n}\n\n\n\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n    /**\n      @notice Override this function with a recipe of the changes to be done when this ChangeContract\n      is executed\n     */\n    function execute() external;\n}\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor {\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @dev This function should be protected somehow to only execute changes that\n      benefit the system. This decision process is independent of this architechture\n      therefore is independent of this interface too\n      @param changeContract Address of the contract that will execute the changes\n     */\n    function executeChange(ChangeContract changeContract) external;\n\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @param _changer Address of the contract that will execute the changes\n     */\n    function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed {\n    /**\n      @notice The address of the contract which governs this one\n     */\n    IGovernor public governor;\n\n    string private constant NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n    /**\n      @notice Modifier that protects the function\n      @dev You should use this modifier in any function that should be called through\n      the governance system\n     */\n    modifier onlyAuthorizedChanger() {\n        require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n        _;\n    }\n\n    /**\n      @notice Initialize the contract with the basic settings\n      @dev This initialize replaces the constructor but it is not called automatically.\n      It is necessary because of the upgradeability of the contracts\n      @param _governor Governor address\n     */\n    function _initialize(IGovernor _governor) internal {\n        governor = _governor;\n    }\n\n    /**\n      @notice Change the contract's governor. Should be called through the old governance system\n      @param newIGovernor New governor address\n     */\n    function changeIGovernor(IGovernor newIGovernor) external onlyAuthorizedChanger {\n        governor = newIGovernor;\n    }\n\n    /**\n      @notice This method is used by a change contract to access the storage freely even without a setter.\n      @param data the serialized function arguments\n     */\n    function delegateCallToChanger(bytes calldata data)\n        external\n        onlyAuthorizedChanger\n        returns (bytes memory)\n    {\n        address changerContrat = msg.sender;\n        (bool success, bytes memory result) = changerContrat.delegatecall(\n            abi.encodeWithSignature(\"impersonate(bytes)\", data)\n        );\n        require(success, \"Error in delegate call\");\n        return result;\n    }\n\n    // Leave a gap betweeen inherited contracts variables in order to be\n    // able to add more variables in them later\n    uint256[50] private upgradeGap;\n}\n\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n\n/**\n  @title UpgradeDelegator\n  @notice Dispatches to the proxyAdmin any call made through the governance system\n  @dev Adapter between our governance system and the zeppelinOS proxyAdmin. This is\n  needed to be able to upgrade governance through the same system\n\n */\ncontract UpgradeDelegator is Initializable, Governed {\n    IOZProxyAdmin public proxyAdmin;\n\n    function initialize(IGovernor _governor, IOZProxyAdmin _proxyAdmin) public initializer {\n        Governed._initialize(_governor);\n        proxyAdmin = _proxyAdmin;\n    }\n\n    /**\n     * @dev Returns the current implementation of a proxy.\n     * This is needed because only the proxy admin can query it.\n     * @return The address of the current implementation of the proxy.\n     */\n    function getProxyImplementation(IOZAdminUpgradeabilityProxy proxy)\n        public\n        view\n        returns (address)\n    {\n        return proxyAdmin.getProxyImplementation(proxy);\n    }\n\n    /**\n     * @dev Returns the admin of a proxy. Only the admin can query it.\n     * @return The address of the current admin of the proxy.\n     */\n    function getProxyAdmin(IOZAdminUpgradeabilityProxy proxy) public view returns (address) {\n        return proxyAdmin.getProxyAdmin(proxy);\n    }\n\n    /**\n     * @dev Changes the admin of a proxy.\n     * @param proxy Proxy to change admin.\n     * @param newAdmin Address to transfer proxy administration to.\n     */\n    function changeProxyAdmin(IOZAdminUpgradeabilityProxy proxy, address newAdmin)\n        public\n        onlyAuthorizedChanger\n    {\n        proxyAdmin.changeProxyAdmin(proxy, newAdmin);\n    }\n\n    /**\n     * @dev Upgrades a proxy to the newest implementation of a contract.\n     * @param proxy Proxy to be upgraded.\n     * @param implementation the address of the Implementation.\n     */\n    function upgrade(IOZAdminUpgradeabilityProxy proxy, address implementation)\n        public\n        onlyAuthorizedChanger\n    {\n        proxyAdmin.upgrade(proxy, implementation);\n    }\n\n    /**\n     * @dev Upgrades a proxy to the newest implementation of a contract and forwards a function call to it.\n     * This is useful to initialize the proxied contract.\n     * @param proxy Proxy to be upgraded.\n     * @param implementation Address of the Implementation.\n     * @param data Data to send as msg.data in the low level call.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     */\n    function upgradeAndCall(\n        IOZAdminUpgradeabilityProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable onlyAuthorizedChanger {\n        proxyAdmin.upgradeAndCall{value: msg.value}(proxy, implementation, data);\n    }\n}\n\n",
  "imports": [
    {
      "name": "UpgradeDelegatorFlat.sol",
      "contents": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\n\n/**\n * @dev Interface of the openzeppeling AdminUpgradeabilityProxy\n */\ninterface IOZAdminUpgradeabilityProxy {\n    /**\n     * @dev Emitted when the administration has been transferred.\n     * @param previousAdmin Address of the previous admin.\n     * @param newAdmin Address of the new admin.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @return The address of the proxy admin.\n     */\n    function admin() external returns (address);\n\n    /**\n     * @return The address of the implementation.\n     */\n    function implementation() external returns (address);\n\n    /**\n     * @dev Changes the admin of the proxy.\n     * Only the current admin can call this function.\n     * @param newAdmin Address to transfer proxy administration to.\n     */\n    function changeAdmin(address newAdmin) external;\n\n    /**\n     * @dev Upgrade the backing implementation of the proxy.\n     * Only the admin can call this function.\n     * @param newImplementation Address of the new implementation.\n     */\n    function upgradeTo(address newImplementation) external;\n\n    /**\n     * @dev Upgrade the backing implementation of the proxy and call a function\n     * on the new implementation.\n     * This is useful to initialize the proxied contract.\n     * @param newImplementation Address of the new implementation.\n     * @param data Data to send as msg.data in the low level call.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     * @param implementation Address of the new implementation.\n     */\n    event Upgraded(address indexed implementation);\n}\n\n\n\n/**\n * @dev Interface of the openzeppeling ProxyAdmin\n */\ninterface IOZProxyAdmin {\n    /**\n     * @dev Returns the current implementation of a proxy.\n     * This is needed because only the proxy admin can query it.\n     * @return The address of the current implementation of the proxy.\n     */\n    function getProxyImplementation(IOZAdminUpgradeabilityProxy proxy)\n        external\n        view\n        returns (address);\n\n    /**\n     * @dev Returns the admin of a proxy. Only the admin can query it.\n     * @return The address of the current admin of the proxy.\n     */\n    function getProxyAdmin(IOZAdminUpgradeabilityProxy proxy) external view returns (address);\n\n    /**\n     * @dev Changes the admin of a proxy.\n     * @param proxy Proxy to change admin.\n     * @param newAdmin Address to transfer proxy administration to.\n     */\n    function changeProxyAdmin(IOZAdminUpgradeabilityProxy proxy, address newAdmin) external;\n\n    /**\n     * @dev Upgrades a proxy to the newest implementation of a contract.\n     * @param proxy Proxy to be upgraded.\n     * @param implementation the address of the Implementation.\n     */\n    function upgrade(IOZAdminUpgradeabilityProxy proxy, address implementation) external;\n\n    /**\n     * @dev Upgrades a proxy to the newest implementation of a contract and forwards a function call to it.\n     * This is useful to initialize the proxied contract.\n     * @param proxy Proxy to be upgraded.\n     * @param implementation Address of the Implementation.\n     * @param data Data to send as msg.data in the low level call.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     */\n    function upgradeAndCall(\n        IOZAdminUpgradeabilityProxy proxy,\n        address implementation,\n        bytes calldata data\n    ) external payable;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @return true if msg.sender is the owner of the contract.\n     */\n    function isOwner() external view returns (bool);\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() external;\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) external;\n}\n\n\n\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n    /**\n      @notice Override this function with a recipe of the changes to be done when this ChangeContract\n      is executed\n     */\n    function execute() external;\n}\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor {\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @dev This function should be protected somehow to only execute changes that\n      benefit the system. This decision process is independent of this architechture\n      therefore is independent of this interface too\n      @param changeContract Address of the contract that will execute the changes\n     */\n    function executeChange(ChangeContract changeContract) external;\n\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @param _changer Address of the contract that will execute the changes\n     */\n    function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed {\n    /**\n      @notice The address of the contract which governs this one\n     */\n    IGovernor public governor;\n\n    string private constant NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n    /**\n      @notice Modifier that protects the function\n      @dev You should use this modifier in any function that should be called through\n      the governance system\n     */\n    modifier onlyAuthorizedChanger() {\n        require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n        _;\n    }\n\n    /**\n      @notice Initialize the contract with the basic settings\n      @dev This initialize replaces the constructor but it is not called automatically.\n      It is necessary because of the upgradeability of the contracts\n      @param _governor Governor address\n     */\n    function _initialize(IGovernor _governor) internal {\n        governor = _governor;\n    }\n\n    /**\n      @notice Change the contract's governor. Should be called through the old governance system\n      @param newIGovernor New governor address\n     */\n    function changeIGovernor(IGovernor newIGovernor) external onlyAuthorizedChanger {\n        governor = newIGovernor;\n    }\n\n    /**\n      @notice This method is used by a change contract to access the storage freely even without a setter.\n      @param data the serialized function arguments\n     */\n    function delegateCallToChanger(bytes calldata data)\n        external\n        onlyAuthorizedChanger\n        returns (bytes memory)\n    {\n        address changerContrat = msg.sender;\n        (bool success, bytes memory result) = changerContrat.delegatecall(\n            abi.encodeWithSignature(\"impersonate(bytes)\", data)\n        );\n        require(success, \"Error in delegate call\");\n        return result;\n    }\n\n    // Leave a gap betweeen inherited contracts variables in order to be\n    // able to add more variables in them later\n    uint256[50] private upgradeGap;\n}\n\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n\n/**\n  @title UpgradeDelegator\n  @notice Dispatches to the proxyAdmin any call made through the governance system\n  @dev Adapter between our governance system and the zeppelinOS proxyAdmin. This is\n  needed to be able to upgrade governance through the same system\n\n */\ncontract UpgradeDelegator is Initializable, Governed {\n    IOZProxyAdmin public proxyAdmin;\n\n    function initialize(IGovernor _governor, IOZProxyAdmin _proxyAdmin) public initializer {\n        Governed._initialize(_governor);\n        proxyAdmin = _proxyAdmin;\n    }\n\n    /**\n     * @dev Returns the current implementation of a proxy.\n     * This is needed because only the proxy admin can query it.\n     * @return The address of the current implementation of the proxy.\n     */\n    function getProxyImplementation(IOZAdminUpgradeabilityProxy proxy)\n        public\n        view\n        returns (address)\n    {\n        return proxyAdmin.getProxyImplementation(proxy);\n    }\n\n    /**\n     * @dev Returns the admin of a proxy. Only the admin can query it.\n     * @return The address of the current admin of the proxy.\n     */\n    function getProxyAdmin(IOZAdminUpgradeabilityProxy proxy) public view returns (address) {\n        return proxyAdmin.getProxyAdmin(proxy);\n    }\n\n    /**\n     * @dev Changes the admin of a proxy.\n     * @param proxy Proxy to change admin.\n     * @param newAdmin Address to transfer proxy administration to.\n     */\n    function changeProxyAdmin(IOZAdminUpgradeabilityProxy proxy, address newAdmin)\n        public\n        onlyAuthorizedChanger\n    {\n        proxyAdmin.changeProxyAdmin(proxy, newAdmin);\n    }\n\n    /**\n     * @dev Upgrades a proxy to the newest implementation of a contract.\n     * @param proxy Proxy to be upgraded.\n     * @param implementation the address of the Implementation.\n     */\n    function upgrade(IOZAdminUpgradeabilityProxy proxy, address implementation)\n        public\n        onlyAuthorizedChanger\n    {\n        proxyAdmin.upgrade(proxy, implementation);\n    }\n\n    /**\n     * @dev Upgrades a proxy to the newest implementation of a contract and forwards a function call to it.\n     * This is useful to initialize the proxied contract.\n     * @param proxy Proxy to be upgraded.\n     * @param implementation Address of the Implementation.\n     * @param data Data to send as msg.data in the low level call.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     */\n    function upgradeAndCall(\n        IOZAdminUpgradeabilityProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable onlyAuthorizedChanger {\n        proxyAdmin.upgradeAndCall{value: msg.value}(proxy, implementation, data);\n    }\n}\n\n",
      "file": "UpgradeDelegatorFlat.sol"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0xb68205a00281ca0ec7733593a9c4c846f756f7d9a032415b6cb9e22c4d4be7e8",
    "blockNumber": 1330843,
    "transactionHash": "0x228e8eb72300323590f37db0be4597765bf272398c17f96ad76f69f62bdfbca5",
    "timestamp": 1604959094
  }
}