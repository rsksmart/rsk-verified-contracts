{
    "address": "0xcd8efd4d8c87eb70d1ebb7fb43d0b20cd36fe3b1",
    "net": {
        "id": "31",
        "name": "RSK Testnet"
    },
    "name": "MoCExchange",
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": "1"
        },
        "evmVersion": "byzantium"
    },
    "version": "0.5.8+commit.23d335f2",
    "source": "\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n// File: contracts/MoCHelperLib.sol\n\npragma solidity 0.5.8;\n\n\nlibrary MoCHelperLib {\n\n  struct MocLibConfig {\n    uint256 reservePrecision;\n    uint256 dayPrecision;\n    uint256 mocPrecision;\n  }\n\n  using SafeMath for uint256;\n\n  uint256 constant UINT256_MAX = ~uint256(0);\n\n  /**\n    @dev Returns max uint256 value constant.\n    @return max uint256 value constant\n  */\n  function getMaxInt(MocLibConfig storage /*config*/) public pure returns(uint256) {\n    return UINT256_MAX;\n  }\n\n  /**\n    @dev Calculates average interest using integral function: T =  Rate = a * (x ** b) + c\n    @param tMax maxInterestRate [using mocPrecision]\n    @param power factor [using noPrecision]\n    @param tMin minInterestRate C0 doc amount [using mocPrecision]\n    @param abRat1 initial abundance ratio [using mocPrecision]\n    @param abRat2 final abundance ratio [using mocPrecision]\n    @return average interest rate [using mocPrecision]\n  */\n  function inrateAvg(MocLibConfig storage config, uint256 tMax, uint256 power, uint256 tMin, uint256 abRat1, uint256 abRat2)\n  public view returns(uint256) {\n    require(tMax > tMin, \"Max inrate should be bigger than Min inrate\");\n    uint256 abRat1Comp = config.mocPrecision.sub(abRat1);\n    uint256 abRat2Comp = config.mocPrecision.sub(abRat2);\n\n    if (abRat1 == abRat2) {\n      return potential(config, tMax, power, tMin, abRat1Comp);\n    }\n    else if (abRat2 < abRat1) {\n      return avgInt(config, tMax, power, tMin, abRat1Comp, abRat2Comp);\n    }\n    else {\n      return avgInt(config, tMax, power, tMin, abRat2Comp, abRat1Comp);\n    }\n  }\n\n  /**\n    @dev Calculates spot interest rate that BProx owners should pay to BPro owners: Rate = tMax * (abRatio ** power) + tMin\n    @param tMin min interest rate [using mocPrecision]\n    @param power power to use in the formula [using NoPrecision]\n    @param tMax max interest rate [using mocPrecision]\n    @param abRatio bucket C0  abundance Ratio [using mocPrecision]\n   */\n  function spotInrate(\n    MocLibConfig storage config, uint256 tMax, uint256 power, uint256 tMin, uint256 abRatio\n  ) public view returns(uint256) {\n    uint256 abRatioComp = config.mocPrecision.sub(abRatio);\n\n    return potential(config, tMax, power, tMin, abRatioComp);\n  }\n\n  /**\n    @dev Calculates potential interests function with given parameters: Rate = a * (x ** b) + c\n    @param a maxInterestRate [using mocPrecision]\n    @param b factor [using NoPrecision]\n    @param c minInterestRate C0 doc amount [using mocPrecision]\n    @param value global doc amount [using mocPrecision]\n  */\n  function potential(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value)\n  public view returns(uint256) {\n    // value ** b\n    // [MOC] ** [] = [MOC]\n    uint256 aux1 = pow(value, b, config.mocPrecision);\n    // (a * aux1) + c\n    // [MOC] [MOC] / [MOC] + [MOC] = [MOC]\n    return a.mul(aux1).div(config.mocPrecision).add(c);\n  }\n\n  /**\n    @dev Calculates average of the integral function:\n     T = (\n              (c * xf + ((a * (xf ** (b + 1))) / (b + 1))) -\n              (c * xi + ((a * (xi ** (b + 1))) / (b + 1)))\n             ) / (xf - xi)\n    @param a maxInterestRate [using mocPrecision]\n    @param b factor [using NoPrecision]\n    @param c minInterestRate C0 doc amount [using mocPrecision]\n    @param value1 value to put in the function [using mocPrecision]\n    @param value2 value to put in the function [using mocPrecision]\n    @return average interest rate [using mocPrecision]\n  */\n  function avgInt(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value1, uint256 value2)\n  public view returns(uint256) {\n    // value2 - value1\n    // [MOC]\n    uint256 diff = value2.sub(value1);\n    // ((c * (1 - value1) + ((a * ((1 - value1) ** (b + 1))) / (b + 1)))\n    uint256 intV1 = integral(config, a, b, c, value1);\n    // ((c * (1 - value2) + ((a * ((1 - value2) ** (b + 1))) / (b + 1)))\n    uint256 intV2 = integral(config,  a, b, c, value2);\n    // (secOp - first) / diff\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\n    return intV2.sub(intV1).div(diff);\n  }\n\n  /**\n    @dev Calculates integral of the exponential function: T = c * (value) + (a * value ** (b + 1)) / (b + 1))\n    @param a maxInterestRate [using mocPrecision]\n    @param b factor [using NoPrecision]\n    @param c minInterestRate C0 doc amount [using mocPrecision]\n    @param value value to put in the function [using mocPrecision]\n    @return integration result [using mocPrecision]\n  */\n  function integral(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value)\n  public view returns(uint256) {\n    // b + 1\n    // [NONE]\n    uint256 b2 = b.add(1);\n    // c * value\n    // [MOC][MOC]\n    uint256 firstOp = c.mul(value);\n    // [MOC]\n    uint256 pow = pow(value, b2, config.mocPrecision);\n    // (a * value ** b2) / b2)\n    // [MOC][MOC]\n    uint256 secOp = a.mul(pow).div(b2);\n    // (firstOp + secOp)\n    // [MOC][MOC] + [MOC][MOC] = [MOC][MOC]\n    return firstOp.add(secOp);\n  }\n\n  /**\n  * @dev Relation between docs in bucket 0 and Doc total supply\n  * @param doc0 doc count in bucket 0 [using mocPrecision]\n  * @param doct total doc supply [using mocPrecision]\n  * @return abundance ratio [using mocPrecision]\n  */\n  function abundanceRatio(MocLibConfig storage config, uint256 doc0, uint256 doct)\n  public view returns(uint256) {\n    if (doct == 0) {\n      return config.mocPrecision;\n    }\n    // [DOC] [MOC] / [DOC] = [MOC]\n    return doc0.mul(config.mocPrecision).div(doct);\n  }\n\n  /**\n    @dev Returns the Ratio to apply to BPro Price in discount situations: SpotDiscountRate = TPD * (utpdu - cob) / (uptdu -liq)\n    @param bproLiqDiscountRate Discount rate applied at Liquidation level coverage [using mocPrecision]\n    @param liq Liquidation coverage threshold [using mocPrecision]\n    @param utpdu Discount coverage threshold [using mocPrecision]\n    @param cov Actual global Coverage threshold [using mocPrecision]\n    @return Spot discount rate [using mocPrecision]\n  */\n  function bproSpotDiscountRate(\n    MocLibConfig storage libConfig, uint256 bproLiqDiscountRate,\n    uint256 liq, uint256 utpdu, uint256 cov\n  ) public view returns(uint256) {\n    require(bproLiqDiscountRate < libConfig.mocPrecision, \"Discount rate should be lower than 1\");\n\n    if (cov >= utpdu) {\n      return 0;\n    }\n\n    // utpdu - liq\n    // [MOC] - [MOC] = [MOC]\n    uint256 utpduLiqDiff = utpdu.sub(liq);\n\n    // utpdu - cov\n    // [MOC] - [MOC] = [MOC]\n    uint256 utpduCovDiff = utpdu.sub(cov);\n\n    // TPD * utpduCovDiff / utpduLiqDiff\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    return bproLiqDiscountRate.mul(utpduCovDiff).div(utpduLiqDiff);\n  }\n\n  /**\n    @dev Max amount of BPro to available with discount: MaxBProWithDiscount = (uTPDU * nDOC * PEG - (nBTC * B)) / (TPusd * TPD)\n    @param nB Total BTC amount [using reservePrecision]\n    @param nDoc DOC amount [using mocPrecision]\n    @param utpdu Discount coverage threshold [using mocPrecision]\n    @param peg peg value\n    @param btcPrice BTC price [using mocPrecision]\n    @param bproUsdPrice bproUsdPrice [using mocPrecision]\n    @param spotDiscount spot discount [using mocPrecision]\n    @return Total BPro amount [using mocPrecision]\n  */\n  function maxBProWithDiscount(\n    MocLibConfig storage libConfig, uint256 nB, uint256 nDoc, uint256 utpdu,\n    uint256 peg, uint256 btcPrice, uint256 bproUsdPrice, uint256 spotDiscount\n  ) public view returns(uint256)  {\n    require(spotDiscount < libConfig.mocPrecision, \"Discount Rate should be lower than 1\");\n\n    if (spotDiscount == 0) {\n      return 0;\n    }\n\n    // nBTC * B\n    // [RES] * [MOC] / [RES] = [MOC]\n    uint256 nbUsdValue = nB.mul(btcPrice).div(libConfig.reservePrecision);\n\n    // (TPusd * (1 - TPD))\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 bproDiscountPrice = bproUsdPrice.mul(libConfig.mocPrecision.sub(spotDiscount))\n      .div(libConfig.mocPrecision);\n\n    return maxBProWithDiscountAux(libConfig, nbUsdValue, nDoc, utpdu, peg, bproDiscountPrice);\n  }\n\n  /**\n    @dev Max amount of BPro to available with discount: MaxBProWithDiscount = (uTPDU * nDOC * PEG - (nBTC * B)) / (TPusd * TPD)\n    @param nbUsdValue Total amount of BTC in USD [using mocPrecision]\n    @param nDoc DOC amount [using mocPrecision]\n    @param utpdu Discount coverage threshold [using mocPrecision]\n    @param bproDiscountPrice bproUsdPrice with discount applied [using mocPrecision]\n    @param peg peg value\n    @return Total BPro amount [using mocPrecision]\n  */\n  function maxBProWithDiscountAux(\n    MocLibConfig storage libConfig, uint256 nbUsdValue, uint256 nDoc,\n    uint256 utpdu, uint256 peg, uint256 bproDiscountPrice\n  ) internal view returns(uint256) {\n\n    // uTPDU * nDOC * PEG\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 coverageUSDAmount = utpdu.mul(nDoc).mul(peg).div(libConfig.mocPrecision);\n\n    // This case only occurs with Coverage below 1\n    if (coverageUSDAmount <= nbUsdValue) {\n      return 0;\n    }\n\n    // ([MOC] - [MOC]) * [RES] / [MOC] = [RES]\n    return coverageUSDAmount.sub(nbUsdValue).mul(libConfig.reservePrecision).div(bproDiscountPrice);\n  }\n\n  /**\n    @dev Calculates Locked bitcoin\n    @param btcPrice BTC price [using mocPrecision]\n    @param nDoc Docs amount [using mocPrecision]\n    @param peg peg value\n    @return Locked bitcoin [using reservePrecision]\n  */\n  function lockedBitcoin(\n    MocLibConfig storage libConfig, uint256 btcPrice, uint256 nDoc, uint256 peg\n  ) public view returns(uint256) {\n    return nDoc.mul(peg).mul(libConfig.reservePrecision).div(btcPrice);\n  }\n\n  /**\n    @dev Calculates price at liquidation event as a relation between the doc total supply\n    and the amount of RBTC available to distribute\n    @param rbtcAmount RBTC to distribute [using reservePrecision]\n    @param nDoc Docs amount [using mocPrecision]\n    @return Price at liquidation event [using mocPrecision]\n  */\n  function liquidationPrice(MocLibConfig storage libConfig, uint256 rbtcAmount, uint256 nDoc)\n  public view returns(uint256) {\n    // [MOC] * [RES] / [RES]\n    return nDoc.mul(libConfig.reservePrecision).div(rbtcAmount);\n  }\n\n  /**\n    @dev Calculates BPro BTC price: TPbtc = (nB-LB) / nTP\n    @param nB Total BTC amount [using reservePrecision]\n    @param lb Locked bitcoins amount [using reservePrecision]\n    @param nTP BPro amount [using mocPrecision]\n    @return BPro BTC price [using reservePrecision]\n  */\n  function bproTecPrice(MocLibConfig storage libConfig, uint256 nB, uint256 lb, uint256 nTP)\n    public view returns(uint256) {\n    // Liquidation happens before this condition turns true\n    if (nB < lb) {\n      return 0;\n    }\n\n    if (nTP == 0) {\n      return libConfig.mocPrecision;\n    }\n    // ([RES] - [RES]) * [MOC] / [MOC]\n    return nB.sub(lb).mul(libConfig.mocPrecision).div(nTP);\n  }\n\n  /**\n    @dev Calculates BPro BTC price: BProxInBPro = bproxTecPrice / bproPrice\n    @param bproxTecPrice BProx BTC price [using reservePrecision]\n    @param bproPrice Trog BTC price [using reservePrecision]\n    @return BProx price in BPro [using mocPrecision]\n  */\n  function bproxBProPrice(\n    MocLibConfig storage libConfig, uint256 bproxTecPrice, uint256 bproPrice\n  ) public view returns(uint256) {\n    // [RES] * [MOC] / [RES] = [MOC]\n    return bproxTecPrice.mul(libConfig.mocPrecision).div(bproPrice);\n  }\n\n  /**\n    @dev Returns a new value with the discountRate applied: TPbtc = (price)* (1 - discountRate)\n    @param price Price [using SomePrecision]\n    @param discountRate Discount rate to apply [using mocPrecision]\n    @return Price with discount applied [using SomePrecision]\n  */\n  function applyDiscountRate(MocLibConfig storage libConfig, uint256 price, uint256 discountRate)\n    public view returns(uint256) {\n\n    uint256 discountCoeff = libConfig.mocPrecision.sub(discountRate);\n\n    return price.mul(discountCoeff).div(libConfig.mocPrecision);\n  }\n\n  /**\n    @dev Returns the amount of interest to pay: TPbtc = price * interestRate\n    @param value Cost to apply interest [using SomePrecision]\n    @param interestRate Interest rate to apply [using mocPrecision]\n    @return Interest cost based on the value and interestRate [using SomePrecision]\n  */\n  function getInterestCost(MocLibConfig storage libConfig, uint256 value, uint256 interestRate)\n    public view returns(uint256) {\n    // [ORIGIN] * [MOC] / [MOC] = [ORIGIN]\n    return value.mul(interestRate).div(libConfig.mocPrecision);\n  }\n\n  /**\n    @dev Calculates Coverage: Coverage = nB / LB\n    @param nB Total BTC amount [using reservePrecision]\n    @param lB Locked bitcoins amount [using reservePrecision]\n    @return Coverage [using mocPrecision]\n  */\n  function coverage(MocLibConfig storage libConfig, uint256 nB, uint256 lB) public view\n    returns(uint256) {\n    if (lB == 0) {\n      return UINT256_MAX;\n    }\n\n    return nB.mul(libConfig.mocPrecision).div(lB);\n  }\n\n /**\n    @dev Calculates Leverage from Coverage: Leverage = C / (C - 1)\n    @param cov Coverage [using mocPrecision]\n    @return Leverage [using mocPrecision]\n  */\n  function leverageFromCoverage(MocLibConfig storage libConfig, uint256 cov)\n  public view returns(uint256) {\n    if (cov == UINT256_MAX) {\n      return libConfig.mocPrecision;\n    }\n\n    if (cov <= libConfig.mocPrecision) {\n      return UINT256_MAX;\n    }\n\n    return cov.mul(libConfig.mocPrecision).div(cov.sub(libConfig.mocPrecision));\n  }\n\n /**\n    @dev Calculates Leverage: Leverage = nB / (nB - lB)\n    @param nB Total BTC amount [using reservePrecision]\n    @param lB Locked bitcoins amount [using reservePrecision]\n    @return Leverage [using mocPrecision]\n  */\n  function leverage(MocLibConfig storage libConfig, uint256 nB,uint256 lB)\n  public view returns(uint256) {\n    if (lB == 0) {\n      return libConfig.mocPrecision;\n    }\n\n    if (nB <= lB) {\n      return UINT256_MAX;\n    }\n\n    return nB.mul(libConfig.mocPrecision).div(nB.sub(lB));\n  }\n\n  /**\n    @dev Price in BTC of the amount of Docs\n    @param amount Total BTC amount [using reservePrecision]\n    @param btcPrice BTC price [using mocPrecision]\n    @return Total value [using reservePrecision]\n  */\n  function docsBtcValue(\n    MocLibConfig storage libConfig, uint256 amount,uint256 peg, uint256 btcPrice\n  ) public view returns(uint256) {\n    require(btcPrice > 0,\"Bitcoin price should be more than zero\");\n    require(libConfig.reservePrecision > 0, \"Precision should be more than zero\");\n    //Total = amount / satoshi price\n    //Total = amount / (btcPrice / precision)\n    // [RES] * [MOC] / [MOC]\n    uint256 docBtcTotal = amount.mul(libConfig.mocPrecision).mul(peg).div(btcPrice);\n\n    return docBtcTotal;\n  }\n\n /**\n    @dev Price in RBTC of the amount of BPros\n    @param bproAmount amount of BPro [using mocPrecision]\n    @param bproBtcPrice BPro price in RBTC [using reservePrecision]\n    @return Total value [using reservePrecision]\n  */\n  function bproBtcValue(MocLibConfig storage libConfig, uint256 bproAmount, uint256 bproBtcPrice)\n    public view returns(uint256) {\n    require(libConfig.reservePrecision > 0, \"Precision should be more than zero\");\n\n    // [MOC] * [RES] / [MOC] =  [RES]\n    uint256 bproBtcTotal = bproAmount.mul(bproBtcPrice).div(libConfig.mocPrecision);\n\n    return bproBtcTotal;\n  }\n\n  /**\n    @dev Max amount of Docs to issue: MaxDoc = ((nB*B)-(Cobj*B/Bcons*nDoc*PEG))/(PEG*(Cobj*B/BCons-1))\n    @param nB Total BTC amount [using reservePrecision]\n    @param cobj Target Coverage [using mocPrecision]\n    @param nDoc DOC amount [using mocPrecision]\n    @param peg peg value\n    @param btcPrice BTC price [using mocPrecision]\n    @param bCons BTC conservative price [using mocPrecision]\n    @return Total Docs amount [using mocPrecision]\n  */\n  function maxDoc(\n    MocLibConfig storage libConfig, uint256 nB,\n    uint256 cobj, uint256 nDoc, uint256 peg, uint256 btcPrice, uint256 bCons\n  ) public view returns(uint256) {\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\n\n    // If cobj is less than 1, just return zero\n    if (cobj < libConfig.mocPrecision)\n      return 0;\n\n    // Cobj * B / BCons\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 adjCobj = cobj.mul(btcPrice).div(bCons);\n\n    return maxDocAux(libConfig, nB, adjCobj, nDoc, peg, btcPrice);\n  }\n\n  function maxDocAux(MocLibConfig storage libConfig, uint256 nB, uint256 adjCobj, uint256 nDoc, uint256 peg, uint256 btcPrice)\n  internal view returns(uint256) {\n    // (nB*B)\n    // [RES] [MOC] [MOC] / [RES] = [MOC] [MOC]\n    uint256 firstOperand = nB.mul(btcPrice).mul(libConfig.mocPrecision).div(libConfig.reservePrecision);\n    // (adjCobj*nDoc*PEG)\n    // [MOC] [MOC]\n    uint256 secOperand = adjCobj.mul(nDoc).mul(peg);\n    // (PEG*(adjCobj-1)\n    // [MOC]\n    uint256 denom = adjCobj.sub(libConfig.mocPrecision).mul(peg);\n\n    if (firstOperand <= secOperand)\n      return 0;\n\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\n    return (firstOperand.sub(secOperand)).div(denom);\n  }\n\n  /**\n    @dev Max amount of BPro to redeem: MaxBPro = ((nB*B)-(Cobj*nDoc*PEG))/TPusd\n    @param nB Total BTC amount [using reservePrecision]\n    @param cobj Target Coverage [using mocPrecision]\n    @param nDoc Target Coverage [using mocPrecision]\n    @param peg peg value\n    @param btcPrice BTC price [using mocPrecision]\n    @param bCons BTC conservative price [using mocPrecision]\n    @param bproUsdPrice bproUsdPrice [using mocPrecision]\n    @return Total BPro amount [using mocPrecision]\n  */\n  function maxBPro(\n    MocLibConfig storage libConfig, uint256 nB, uint256 cobj,\n    uint256 nDoc, uint256 peg, uint256 btcPrice, uint256 bCons, uint256 bproUsdPrice\n  ) public view returns(uint256) {\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\n\n    // Cobj * btcPrice / BCons\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 adjCobj = cobj.mul(btcPrice).div(bCons);\n    // (nB * btcPrice)\n    // [RES] * [MOC] * [MOC] / [RES] = [MOC] [MOC]\n    uint256 firstOperand = nB.mul(btcPrice)\n      .mul(libConfig.mocPrecision)\n      .div(libConfig.reservePrecision);\n    // (adjCobj * nDoc * PEG)\n    // [MOC] * [MOC]\n    uint256 secOperand = adjCobj.mul(nDoc).mul(peg);\n\n    if (firstOperand <= secOperand)\n      return 0;\n\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\n    return (firstOperand.sub(secOperand)).div(bproUsdPrice);\n  }\n\n  /**\n    @dev Calculates the total BTC price of the amount of BPros\n    @param amount Amount of BPro [using mocPrecision]\n    @param bproPrice BPro BTC Price [using reservePrecision]\n    @return BPro total value in BTC [using reservePrecision]\n  */\n  function totalBProInBtc(\n    MocLibConfig storage libConfig, uint256 amount, uint256 bproPrice\n  ) public view returns(uint256) {\n    // [RES] * [MOC] / [MOC] = [RES]\n    return bproPrice.mul(amount).div(libConfig.mocPrecision);\n  }\n\n  /**\n    @dev Calculates the equivalent in Docs of the btcAmount\n    @param btcAmount BTC  amount [using reservePrecision]\n    @param btcPrice BTC price [using mocPrecision]\n    @return Equivalent Doc amount [using mocPrecision]\n  */\n  function maxDocsWithBtc(\n    MocLibConfig storage libConfig, uint256 btcAmount, uint256 btcPrice\n  ) public view returns(uint256) {\n    // [RES] * [MOC] / [RES] = [MOC]\n    return btcAmount.mul(btcPrice).div(libConfig.reservePrecision);\n  }\n\n  /**\n    @dev Calculates the equivalent in BPro of the btcAmount\n    @param btcAmount BTC amount [using reservePrecision]\n    @param bproPrice BPro BTC price [using reservePrecision]\n    @return Equivalent Bpro amount [using mocPrecision]\n  */\n  function maxBProWithBtc(\n    MocLibConfig storage libConfig, uint256 btcAmount, uint256 bproPrice\n  ) public view returns(uint256) {\n    if (bproPrice == 0) {\n      return 0;\n    }\n\n    // [RES] * [MOC] / [RES]\n    return btcAmount.mul(libConfig.mocPrecision).div(bproPrice);\n  }\n\n  /**\n    @dev Calculates the Btc amount to move from C0 bucket to: toMove = btcAmount * (lev - 1)\n    an L bucket when a BProx minting occurs\n    @param btcAmount Total BTC amount [using reservePrecision]\n    @param lev L bucket leverage [using mocPrecision]\n    @return btc to move [using reservePrecision]\n  */\n  function bucketTransferAmount(\n    MocLibConfig storage libConfig, uint256 btcAmount, uint256 lev\n  ) public view returns(uint256) {\n    require(lev > libConfig.mocPrecision, \"Leverage should be more than 1\");\n\n    if (lev == UINT256_MAX || btcAmount == 0) {\n      return 0;\n    }\n\n    // (lev-1)\n    uint256 levSubOne = lev.sub(libConfig.mocPrecision);\n\n    // Intentionally avaoid SafeMath\n    // [RES] * [MOC]\n    uint256 transferAmount = btcAmount * levSubOne;\n    if (transferAmount / btcAmount != levSubOne)\n      return 0;\n\n    // [RES] * [MOC] / [MOC] = [RES]\n    return transferAmount.div(libConfig.mocPrecision);\n  }\n\n  /**\n    @dev Max amount of BTC allowed to be used to mint bprox: Maxbprox = nDOC/ (PEG*B*(lev-1))\n    @param nDoc number of DOC [using mocPrecision]\n    @param peg peg value\n    @param btcPrice BTC price [using mocPrecision]\n    @param lev leverage [using mocPrecision]\n    @return Max bprox BTC value [using reservePrecision]\n  */\n  function maxBProxBtcValue(\n    MocLibConfig storage libConfig, uint256 nDoc, uint256 peg, uint256 btcPrice, uint256 lev\n  ) public view returns(uint256)  {\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\n\n    if (lev <= libConfig.mocPrecision) {\n      return 0;\n    }\n    // (lev-1)\n    // [MOC]\n    uint256 levSubOne = lev.sub(libConfig.mocPrecision);\n\n    // PEG * BtcPrice\n    // [MOC]\n    uint256 pegTimesPrice = peg.mul(btcPrice);\n\n    // This intentionally avoid using safeMath to handle overflow case\n    // PEG * BtcPrice * (lev - 1)\n    // [MOC] * [MOC]\n    uint256 dividend = pegTimesPrice * levSubOne;\n\n    if (dividend / pegTimesPrice != levSubOne)\n      return 0; // INFINIT dividend means 0\n\n    // nDoc adjusted with precisions\n    // [MOC] [RES]\n    uint256 divider = nDoc.mul(libConfig.reservePrecision);\n\n    // [MOC] [RES] [MOC] / [MOC] [MOC]\n    return divider.mul(libConfig.mocPrecision).div(dividend);\n  }\n\n  /**\n    @dev Calculates the equivalent in MoC of the btcAmount\n    @param btcAmount BTC  amount\n    @param btcPrice BTC price\n    @param mocPrice MoC price\n    @return Equivalent MoC amount\n  */\n  function maxMoCWithBtc(\n    MocLibConfig storage /*libConfig*/, uint256 btcAmount, uint256 btcPrice, uint256 mocPrice\n  ) public pure returns(uint256) {\n    return btcPrice.mul(btcAmount).div(mocPrice);\n  }\n\n  /**\n    @dev Calculates the equivalent in BTC of the MoC amount\n    @param amount BTC  amount\n    @param btcPrice BTC price\n    @param mocPrice MoC price\n    @return Equivalent MoC amount\n  */\n  function mocBtcValue(\n    MocLibConfig storage /*libConfig*/, uint256 amount, uint256 btcPrice, uint256 mocPrice\n  ) public pure returns(uint256) {\n    require(btcPrice > 0,\"Bitcoin price should be more than zero\");\n    require(mocPrice > 0,\"MoC price should be more than zero\");\n\n    uint256 mocBtcTotal = amount.mul(mocPrice).div(btcPrice);\n\n    return mocBtcTotal;\n  }\n\n  /**\n    @dev Transform an address to payable address\n    @param account Address to transform to payable\n    @return Payable address for account\n  */\n  function getPayableAddress(\n    MocLibConfig storage /*libConfig*/, address account\n  ) public pure\n  returns (address payable) {\n    return address(uint160(account));\n  }\n\n  /**\n    @dev Rounding product adapted from DSMath but with custom precision\n    @param x Multiplicand\n    @param y Multiplier\n    @return Product\n  */\n  function mulr(uint x, uint y, uint256 precision) internal pure returns (uint z) {\n    return x.mul(y).add(precision.div(2)).div(precision);\n  }\n\n  /**\n    @dev Potentiation by squaring adapted from DSMath but with custom precision\n    @param x Base\n    @param n Exponent\n    @return power\n  */\n  function pow(uint256 x, uint256 n, uint256 precision) internal pure returns (uint z) {\n    uint256 x2 = x;\n    z = n % 2 != 0 ? x : precision;\n\n    for (n /= 2; n != 0; n /= 2) {\n      x2 = mulr(x2, x2, precision);\n\n      if (n % 2 != 0) {\n        z = mulr(z, x2, precision);\n      }\n    }\n  }\n}\n\n// File: contracts/MoCLibConnection.sol\n\npragma solidity 0.5.8;\n\n\n/**\n  @dev Interface with MocHelperLib\n */\ncontract MoCLibConnection {\n  using MoCHelperLib for MoCHelperLib.MocLibConfig;\n  MoCHelperLib.MocLibConfig internal mocLibConfig;\n\n  /*\n  * Precision getters\n  */\n  function getMocPrecision() public view returns(uint256) {\n    return mocLibConfig.mocPrecision;\n  }\n\n  function getReservePrecision() public view returns(uint256) {\n    return mocLibConfig.reservePrecision;\n  }\n\n  function getDayPrecision() public view returns(uint256) {\n    return mocLibConfig.dayPrecision;\n  }\n\n  function initializePrecisions() internal {\n    mocLibConfig = MoCHelperLib.MocLibConfig({\n      reservePrecision: 10 ** 18,\n      mocPrecision: 10 ** 18,\n      dayPrecision: 1\n    });\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * > Note that this information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * `IERC20.balanceOf` and `IERC20.transfer`.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See `IERC20.approve`.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destoys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See `_burn` and `_approve`.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\n\n// File: openzeppelin-solidity/contracts/access/Roles.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\n// File: openzeppelin-solidity/contracts/access/roles/PauserRole.sol\n\npragma solidity ^0.5.0;\n\n\ncontract PauserRole {\n    using Roles for Roles.Role;\n\n    event PauserAdded(address indexed account);\n    event PauserRemoved(address indexed account);\n\n    Roles.Role private _pausers;\n\n    constructor () internal {\n        _addPauser(msg.sender);\n    }\n\n    modifier onlyPauser() {\n        require(isPauser(msg.sender), \"PauserRole: caller does not have the Pauser role\");\n        _;\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return _pausers.has(account);\n    }\n\n    function addPauser(address account) public onlyPauser {\n        _addPauser(account);\n    }\n\n    function renouncePauser() public {\n        _removePauser(msg.sender);\n    }\n\n    function _addPauser(address account) internal {\n        _pausers.add(account);\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) internal {\n        _pausers.remove(account);\n        emit PauserRemoved(account);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract Pausable is PauserRole {\n    /**\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\n     * to the deployer.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Called by a pauser to pause, triggers stopped state.\n     */\n    function pause() public onlyPauser whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @dev Called by a pauser to unpause, returns to normal state.\n     */\n    function unpause() public onlyPauser whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Pausable.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @title Pausable token\n * @dev ERC20 modified with pausable transfers.\n */\ncontract ERC20Pausable is ERC20, Pausable {\n    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {\n        return super.transfer(to, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {\n        return super.transferFrom(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {\n        return super.approve(spender, value);\n    }\n\n    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool) {\n        return super.increaseAllowance(spender, addedValue);\n    }\n\n    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool) {\n        return super.decreaseAllowance(spender, subtractedValue);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/access/roles/MinterRole.sol\n\npragma solidity ^0.5.0;\n\n\ncontract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(msg.sender), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Mintable.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @dev Extension of `ERC20` that adds a set of accounts with the `MinterRole`,\n * which have permission to mint (create) new tokens as they see fit.\n *\n * At construction, the deployer of the contract is the only minter.\n */\ncontract ERC20Mintable is ERC20, MinterRole {\n    /**\n     * @dev See `ERC20._mint`.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MinterRole`.\n     */\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: contracts/token/OwnerBurnableToken.sol\n\npragma solidity 0.5.8;\n\n\n\n/**\n * @title Owner Burnable Token\n * @dev Token that allows the owner to irreversibly burned (destroyed) any token.\n */\ncontract OwnerBurnableToken is Ownable, ERC20Mintable {\n  /**\n   * @dev Burns a specific amount of tokens for the address.\n   * @param who who's tokens are gona be burned\n   * @param value The amount of token to be burned.\n   */\n  function burn(address who, uint256 value) public onlyOwner {\n    _burn(who, value);\n  }\n}\n\n// File: contracts/token/BProToken.sol\n\npragma solidity 0.5.8;\n\n\n\n\ncontract BProToken is ERC20Detailed, ERC20Pausable, OwnerBurnableToken {\n\n  string private _name = \"BitPRO\";\n  string private _symbol = \"BITP\";\n  uint8 private _decimals = 18;\n\n  /**\n    @dev Constructor\n  */\n  constructor() Ownable() ERC20Detailed(_name, _symbol, _decimals) public {\n  }\n\n  /**\n    @dev Fallback function\n  */\n  function() external {\n  }\n}\n\n// File: contracts/token/DocToken.sol\n\npragma solidity 0.5.8;\n\n\n\ncontract DocToken is ERC20Detailed, OwnerBurnableToken {\n\n  string private _name = \"Dollar on Chain\";\n  string private _symbol = \"DOC\";\n  uint8 private _decimals = 18;\n\n  /**\n    @dev Constructor\n  */\n  constructor() Ownable() ERC20Detailed(_name, _symbol, _decimals) public {\n\n  }\n\n  /**\n    @dev Fallback function\n  */\n  function() external {\n  }\n}\n\n// File: contracts/interface/IMoCInrate.sol\n\npragma solidity 0.5.8;\n\ninterface IMoCInrate {\n    // Transaction types\n    function MINT_BPRO_FEES_RBTC() external view returns(uint8);\n    function REDEEM_BPRO_FEES_RBTC() external view returns(uint8);\n    function MINT_DOC_FEES_RBTC() external view returns(uint8);\n    function REDEEM_DOC_FEES_RBTC() external view returns(uint8);\n    function MINT_BTCX_FEES_RBTC() external view returns(uint8);\n    function REDEEM_BTCX_FEES_RBTC() external view returns(uint8);\n    function MINT_BPRO_FEES_MOC() external view returns(uint8);\n    function REDEEM_BPRO_FEES_MOC() external view returns(uint8);\n    function MINT_DOC_FEES_MOC() external view returns(uint8);\n    function REDEEM_DOC_FEES_MOC() external view returns(uint8);\n    function MINT_BTCX_FEES_MOC() external view returns(uint8);\n    function REDEEM_BTCX_FEES_MOC() external view returns(uint8);\n\n    function dailyInratePayment() external returns(uint256);\n\n    function payBitProHoldersInterestPayment() external returns(uint256);\n\n    function calculateBitProHoldersInterest() external view returns(uint256, uint256);\n\n    function getBitProInterestAddress() external view returns(address payable);\n\n    function getBitProRate() external view returns(uint256);\n\n    function getBitProInterestBlockSpan() external view returns(uint256);\n\n    function isDailyEnabled() external view returns(bool);\n\n    function isBitProInterestEnabled() external view returns(bool);\n\n    function commissionsAddress() external view returns(address payable);\n\n    function calcCommissionValue(uint256 rbtcAmount, uint8 txType) external view returns(uint256);\n\n    function calculateVendorMarkup(address vendorAccount, uint256 amount) external view returns (uint256 markup);\n\n    function calcDocRedInterestValues(uint256 docAmount, uint256 rbtcAmount) external view returns(uint256);\n\n    function calcMintInterestValues(bytes32 bucket, uint256 rbtcAmount) external view returns(uint256);\n\n    function calcFinalRedeemInterestValue(bytes32 bucket, uint256 rbtcToRedeem) external view returns(uint256);\n\n    function setBitProInterestBlockSpan(uint256 newBitProBlockSpan) external;\n}\n\n// File: zos-lib/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.6.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: contracts/base/MoCWhitelist.sol\n\npragma solidity 0.5.8;\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCWhitelist {\n  mapping(address => bool) whitelist;\n\n  /**\n   * @dev Check if an account is whitelisted\n   * @return Bool\n   */\n  function isWhitelisted(address account)\n    public\n    view\n    returns (bool)\n  {\n    require(account != address(0), \"Account must not be 0x0\");\n    return whitelist[account];\n  }\n\n  /**\n   * @dev Add account to whitelist\n   */\n  function add(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(!isWhitelisted(account), \"Account not allowed to add accounts into white list\");\n    whitelist[account] = true;\n  }\n\n  /**\n   * @dev Remove account from whitelist\n   */\n  function remove(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(isWhitelisted(account), \"Account is not allowed to remove address from the white list\");\n\n    whitelist[account] = false;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/base/MoCConnector.sol\n\npragma solidity 0.5.8;\n\n\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCConnector is MoCWhitelist, Initializable {\n  // References\n  address payable public moc;\n  address public docToken;\n  address public bproToken;\n  address public bproxManager;\n  address public mocState;\n  address public mocConverter;\n  address public mocSettlement;\n  address public mocExchange;\n  address public mocInrate;\n  /** DEPRECATED mocBurnout **/\n  address public mocBurnout;\n\n  bool internal initialized;\n\n  /**\n    @dev Initializes the contract\n    @param mocAddress MoC contract address\n    @param docAddress DoCToken contract address\n    @param bproAddress BProToken contract address\n    @param bproxAddress BProxManager contract address\n    @param stateAddress MoCState contract address\n    @param settlementAddress MoCSettlement contract address\n    @param converterAddress MoCConverter contract address\n    @param exchangeAddress MoCExchange contract address\n    @param inrateAddress MoCInrate contract address\n    @param burnoutBookAddress (DEPRECATED) MoCBurnout contract address. DO NOT USE.\n  */\n  function initialize(\n    address payable mocAddress,\n    address docAddress,\n    address bproAddress,\n    address bproxAddress,\n    address stateAddress,\n    address settlementAddress,\n    address converterAddress,\n    address exchangeAddress,\n    address inrateAddress,\n    address burnoutBookAddress\n  ) public initializer {\n    moc = mocAddress;\n    docToken = docAddress;\n    bproToken = bproAddress;\n    bproxManager = bproxAddress;\n    mocState = stateAddress;\n    mocSettlement = settlementAddress;\n    mocConverter = converterAddress;\n    mocExchange = exchangeAddress;\n    mocInrate = inrateAddress;\n    mocBurnout = burnoutBookAddress;\n\n    // Add to Whitelist\n    add(mocAddress);\n    add(docAddress);\n    add(bproAddress);\n    add(bproxAddress);\n    add(stateAddress);\n    add(settlementAddress);\n    add(converterAddress);\n    add(exchangeAddress);\n    add(inrateAddress);\n    add(burnoutBookAddress);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/base/MoCConstants.sol\n\npragma solidity 0.5.8;\n\n/**\n * @dev Defines special constants to use along all the MoC System\n */\ncontract MoCConstants {\n  bytes32 constant public BUCKET_X2 = \"X2\";\n  bytes32 constant public BUCKET_C0 = \"C0\";\n}\n\n// File: contracts/base/MoCBase.sol\n\npragma solidity 0.5.8;\n\n\n\n\n/**\n  @dev General usefull modifiers and functions\n */\ncontract MoCBase is MoCConstants, Initializable {\n  // Contracts\n  MoCConnector public connector;\n\n  bool internal initialized;\n\n  function initializeBase(address connectorAddress) internal initializer {\n    connector = MoCConnector(connectorAddress);\n  }\n\n  modifier onlyWhitelisted(address account) {\n    require(connector.isWhitelisted(account), \"Address is not whitelisted\");\n    _;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/token/MoCToken.sol\n\npragma solidity 0.5.8;\n\n\n\ncontract MoCToken is ERC20Detailed, OwnerBurnableToken {\n\n  string private _name = \"MoC\";\n  string private _symbol = \"MOC\";\n  uint8 private _decimals = 18;\n\n  /**\n    @dev Constructor\n  */\n  constructor() Ownable() ERC20Detailed(_name, _symbol, _decimals) public {\n\n  }\n\n  /**\n    @dev Fallback function\n  */\n  function() external {\n  }\n}\n\n// File: contracts/interface/IMoCState.sol\n\npragma solidity 0.5.8;\n\ninterface IMoCState {\n\n     /******STATE MACHINE*********/\n    enum States {\n        // State 0\n        Liquidated,\n        // State 1\n        BProDiscount,\n        // State 2\n        BelowCobj,\n        // State 3\n        AboveCobj\n    }\n\n\n    function addToRbtcInSystem(uint256 btcAmount) external;\n\n    function subtractRbtcFromSystem(uint256 btcAmount) external;\n\n    function coverage(bytes32 bucket) external view returns(uint256);\n\n    function getRbtcRemainder() external view returns(uint256);\n\n    function liq() external view returns(uint256);\n\n    function state() external view returns(States);\n\n    function peg() external view returns(uint256);\n\n    function dayBlockSpan() external view returns(uint256);\n\n    function getBitcoinPrice() external view returns(uint256);\n\n    function getMoCPrice() external view returns(uint256);\n\n    function getProtected() external view returns(uint256);\n\n    function globalCoverage() external view returns(uint256);\n\n    function getMoCVendors() external view returns(address);\n\n    function getMoCToken() external view returns(address);\n\n    function nextState() external;\n\n    function maxBProWithDiscount() external view returns(uint256);\n\n    function absoluteMaxBPro() external view returns(uint256);\n\n    function absoluteMaxDoc() external view returns(uint256);\n\n    function freeDoc() external view returns(uint256);\n\n    function bproTecPrice() external view returns(uint256);\n\n    function bproSpotDiscountRate() external view returns(uint256);\n\n    function bproDiscountPrice() external view returns(uint256);\n\n    function bucketBProTecPrice(bytes32 bucket) external view returns(uint256);\n\n    function currentAbundanceRatio() external view returns(uint256);\n\n    function abundanceRatio(uint256 doc0) external view returns(uint256);\n\n    function daysToSettlement() external view returns(uint256);\n\n    function leverage(bytes32 bucket) external view returns(uint256);\n\n    function getBucketNBTC(bytes32 bucket) external view returns(uint256);\n\n    function getLiquidationPrice() external view returns(uint256);\n\n    function maxBProxBtcValue(bytes32 bucket) external view returns(uint256);\n\n    function bucketBProTecPriceHelper(bytes32 bucket) external view returns(uint256);\n}\n\n// File: contracts/MoCConverter.sol\n\npragma solidity 0.5.8;\n\n\n\n\ncontract MoCConverter is MoCBase, MoCLibConnection {\n  IMoCState internal mocState;\n\n  function initialize(address connectorAddress) public initializer {\n    initializePrecisions();\n    initializeBase(connectorAddress);\n    mocState = IMoCState(connector.mocState());\n  }\n\n  /**\n  * @dev BTC equivalent for the amount of bpros given\n  * @param amount Amount of BPro to calculate the total price\n  * @return total BTC Price of the amount BPros [using reservePrecision]\n  */\n  function bproToBtc(uint256 amount) public view returns(uint256) {\n    uint256 tecPrice = mocState.bproTecPrice();\n\n    return mocLibConfig.totalBProInBtc(amount, tecPrice);\n  }\n\n  /**\n  * @dev Converts BTC to BPro\n  * @param btcAmount BTC amount\n  * @return BPro amount\n  */\n  function btcToBPro(uint256 btcAmount) public view returns(uint256) {\n    return mocLibConfig.maxBProWithBtc(btcAmount, mocState.bproTecPrice());\n  }\n\n  /**\n  * @dev BTC equivalent for the amount of bpro given applying the spotDiscountRate\n  * @param amount amount of BPro [using mocPrecision]\n  * @return BTC amount\n  */\n  function bproDiscToBtc(uint256 amount) public view returns(uint256) {\n    uint256 discountRate = mocState.bproSpotDiscountRate();\n    uint256 totalBtcValue = bproToBtc(amount);\n\n    return mocLibConfig.applyDiscountRate(totalBtcValue, discountRate);\n  }\n\n  function btcToBProDisc(uint256 btcAmount) public view returns(uint256) {\n    return mocLibConfig.maxBProWithBtc(btcAmount, mocState.bproDiscountPrice());\n  }\n\n  function docsToBtc(uint256 docAmount) public view returns(uint256) {\n    return mocLibConfig.docsBtcValue(docAmount, mocState.peg(), mocState.getBitcoinPrice());\n  }\n\n  function docsToBtcWithPrice(uint256 docAmount, uint256 btcPrice) public view returns(uint256) {\n    return mocLibConfig.docsBtcValue(docAmount, mocState.peg(), btcPrice);\n  }\n\n  function btcToDoc(uint256 btcAmount) public view returns(uint256) {\n    return mocLibConfig.maxDocsWithBtc(btcAmount, mocState.getBitcoinPrice());\n  }\n\n  function bproxToBtc(uint256 bproxAmount, bytes32 bucket) public view returns(uint256) {\n    return mocLibConfig.bproBtcValue(bproxAmount, mocState.bucketBProTecPrice(bucket));\n  }\n\n  function bproxToBtcHelper(uint256 bproxAmount, bytes32 bucket) public view returns(uint256) {\n    return mocLibConfig.bproBtcValue(bproxAmount, mocState.bucketBProTecPriceHelper(bucket));\n  }\n\n  function btcToBProx(uint256 btcAmount, bytes32 bucket) public view returns(uint256) {\n    return mocLibConfig.maxBProWithBtc(btcAmount, mocState.bucketBProTecPrice(bucket));\n  }\n\n  function btcToBProWithPrice(uint256 btcAmount, uint256 price) public view returns(uint256) {\n    return mocLibConfig.maxBProWithBtc(btcAmount, price);\n  }\n\n  function bproToBtcWithPrice(uint256 bproAmount, uint256 bproPrice) public view returns(uint256) {\n    return mocLibConfig.bproBtcValue(bproAmount, bproPrice);\n  }\n\n  function mocToBtc(uint256 mocAmount) public view returns(uint256) {\n    return mocLibConfig.mocBtcValue(mocAmount, mocState.getBitcoinPrice(), mocState.getMoCPrice());\n  }\n\n  function btcToMoC(uint256 btcAmount) public view returns(uint256) {\n    return mocLibConfig.maxMoCWithBtc(btcAmount, mocState.getBitcoinPrice(), mocState.getMoCPrice());\n  }\n\n  function mocToBtcWithPrice(uint256 mocAmount, uint256 btcPrice, uint256 mocPrice) public view returns(uint256) {\n    return mocLibConfig.mocBtcValue(mocAmount, btcPrice, mocPrice);\n  }\n\n  function btcToMoCWithPrice(uint256 btcAmount, uint256 btcPrice, uint256 mocPrice) public view returns(uint256) {\n    return mocLibConfig.maxMoCWithBtc(btcAmount, btcPrice, mocPrice);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: openzeppelin-solidity/contracts/math/Math.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n\n// File: moc-governance/contracts/Governance/ChangeContract.sol\n\npragma solidity ^0.5.8;\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n\n  /**\n    @notice Override this function with a recipe of the changes to be done when this ChangeContract\n    is executed\n   */\n  function execute() external;\n}\n\n// File: moc-governance/contracts/Governance/IGovernor.sol\n\npragma solidity ^0.5.8;\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor{\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @dev This function should be protected somehow to only execute changes that\n    benefit the system. This decision process is independent of this architechture\n    therefore is independent of this interface too\n    @param changeContract Address of the contract that will execute the changes\n   */\n  function executeChange(ChangeContract changeContract) external;\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @param _changer Address of the contract that will execute the changes\n   */\n  function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n// File: moc-governance/contracts/Governance/Governed.sol\n\npragma solidity ^0.5.8;\n\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed is Initializable {\n\n  /**\n    @notice The address of the contract which governs this one\n   */\n  IGovernor public governor;\n\n  string constant private NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n  /**\n    @notice Modifier that protects the function\n    @dev You should use this modifier in any function that should be called through\n    the governance system\n   */\n  modifier onlyAuthorizedChanger() {\n    require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n    _;\n  }\n\n  /**\n    @notice Initialize the contract with the basic settings\n    @dev This initialize replaces the constructor but it is not called automatically.\n    It is necessary because of the upgradeability of the contracts\n    @param _governor Governor address\n   */\n  function initialize(IGovernor _governor) public initializer {\n    governor = _governor;\n  }\n\n  /**\n    @notice Change the contract's governor. Should be called through the old governance system\n    @param newIGovernor New governor address\n   */\n  function changeIGovernor(IGovernor newIGovernor) public onlyAuthorizedChanger {\n    governor = newIGovernor;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/MoCBucketContainer.sol\n\npragma solidity 0.5.8;\n\n\n\n\n\ncontract MoCBucketContainer is MoCBase, Governed {\n  using SafeMath for uint256;\n  using Math for uint256;\n\n  struct BProxBalance {\n    uint256 value;\n    uint index; // Index start in 1, zero is reserved for NULL\n  }\n\n  struct MoCBucket {\n    bytes32 name;\n    bool isBase;\n    uint256 nDoc;\n    uint256 nBPro;\n    uint256 nBTC;\n    uint256 cobj;\n    // Should only be used in L buckets\n    mapping(address => BProxBalance) bproxBalances;\n    address payable[] activeBalances;\n    uint256 activeBalancesLength;\n    // Should only be used in Base buckets (C0)\n    uint256 inrateBag;\n    bool available;\n  }\n\n  event BucketMovement(\n    bytes32 from,\n    bytes32 to,\n    uint256 reserves,\n    uint256 stableTokens\n  );\n\n  event BucketCreation(\n    bytes32 name,\n    uint256 cobj\n  );\n\n  event BucketStateUpdate(\n    bytes32 name,\n    uint256 nReserve,\n    uint256 nStable,\n    uint256 nRiskProx,\n    uint256 inrateBag\n  );\n\n  mapping(bytes32 => MoCBucket) internal mocBuckets;\n\n   /**\n   GETTERS\n   */\n  function getBucketNBTC(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].nBTC;\n  }\n\n  function getBucketNBPro(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].nBPro;\n  }\n\n  function getBucketNDoc(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].nDoc;\n  }\n\n  function getBucketCobj(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].cobj;\n  }\n\n  function getInrateBag(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].inrateBag;\n  }\n\n  /**\n   * @dev Sets the objective coverage (cobj) on an specficied bucket.\n   * @param  _bucket - name of the bucket\n   * @param  _cobj - new value of cobj\n   */\n  function setBucketCobj(bytes32 _bucket, uint256 _cobj) public onlyAuthorizedChanger(){\n    //TODO: It is necessary to analyze the impact in the model it has when changing X2. This\n    mocBuckets[_bucket].cobj = _cobj;\n  }\n\n  /**\n    @dev returns true if the bucket is a base bucket\n    @param bucket Name of the bucket\n  */\n  function isBucketBase(bytes32 bucket) public view returns(bool){\n    return mocBuckets[bucket].isBase;\n  }\n\n  /**\n    @dev returns true if the bucket have docs in it\n    @param bucket Name of the bucket\n  */\n  function isBucketEmpty(bytes32 bucket) public view returns(bool) {\n    return mocBuckets[bucket].nDoc == 0;\n  }\n\n  /**\n    @dev Returns all the address that currently have bprox position for this bucket\n    @param bucket bucket of the active address\n  */\n  function getActiveAddresses(bytes32 bucket) public view returns(address payable[] memory) {\n    return mocBuckets[bucket].activeBalances;\n  }\n\n  /**\n    @dev Returns all the address that currently have bprox position for this bucket\n    @param bucket bucket of the active address\n  */\n  function getActiveAddressesCount(bytes32 bucket) public view returns(uint256 count) {\n    return mocBuckets[bucket].activeBalancesLength;\n  }\n\n  /**\n    @dev Add values to all variables of the bucket\n    @param bucketName Name of the bucket\n    @param btc BTC amount [using reservePrecision]\n    @param doc Doc amount [using mocPrecision]\n    @param bprox BPro amount [using mocPrecision]\n  */\n  function addValuesToBucket(bytes32 bucketName, uint256 btc, uint256 doc, uint256 bprox)\n  public onlyWhitelisted(msg.sender) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    bucket.nBTC = bucket.nBTC.add(btc);\n    bucket.nDoc = bucket.nDoc.add(doc);\n    bucket.nBPro = bucket.nBPro.add(bprox);\n  }\n\n  /**\n    @dev Substract values to all variables of the bucket\n    @param bucketName Name of the bucket\n    @param btc BTC amount [using reservePrecision]\n    @param doc Doc amount [using mocPrecision]\n    @param bprox BPro amount [using mocPrecision]\n  */\n  function substractValuesFromBucket(bytes32 bucketName, uint256 btc, uint256 doc, uint256 bprox)\n  public onlyWhitelisted(msg.sender)  {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    bucket.nBTC = bucket.nBTC.sub(btc);\n    bucket.nDoc = bucket.nDoc.sub(doc);\n    bucket.nBPro = bucket.nBPro.sub(bprox);\n  }\n\n  /**\n    @dev Moves BTC from inrateBag to main BTC bucket bag\n    @param bucketName Name of the bucket to operate\n    @param amount value to move from inrateBag to main bag [using reservePrecision]\n   */\n  function deliverInrate(bytes32 bucketName, uint256 amount) public\n   onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) bucketStateUpdate(bucketName) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    uint256 toMove = Math.min(bucket.inrateBag, amount);\n\n    bucket.inrateBag = bucket.inrateBag.sub(toMove);\n    bucket.nBTC = bucket.nBTC.add(toMove);\n  }\n\n  /**\n    @dev Removes Interests rate from Inrate bag\n    @param bucketName Name of the bucket to operate\n    @param amount value to move from inrateBag to main bag [using reservePrecision]\n    @return Retrieved value\n   */\n  function recoverInrate(bytes32 bucketName, uint256 amount) public\n  onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) bucketStateUpdate(bucketName) returns(uint256) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    uint256 toRetrieve = Math.min(bucket.inrateBag, amount);\n\n    bucket.inrateBag = bucket.inrateBag.sub(toRetrieve);\n\n    return toRetrieve;\n  }\n\n  /**\n    @dev Moves BTC from origin bucket to destination bucket inrateBag\n    @param bucketName name of the bucket to from which takes\n    @param btcAmount value to add to main bag [using reservePrecision]\n  */\n  function payInrate(bytes32 bucketName, uint256 btcAmount) public\n  onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n    bucket.inrateBag = bucket.inrateBag.add(btcAmount);\n  }\n\n  /**\n    @dev Move Btcs and Docs from one bucket to another\n    @param from Name of bucket from where the BTCs will be removed\n    @param to Name of bucket from where the BTCs will be added\n    @param btc BTCs amount [using reservePrecision]\n    @param docs Docs amount [using mocPrecision]\n  */\n  function moveBtcAndDocs(bytes32 from, bytes32 to, uint256 btc, uint256 docs) public\n  onlyWhitelisted(msg.sender) bucketStateUpdate(from) bucketStateUpdate(to) {\n    MoCBucket storage bucketFrom = mocBuckets[from];\n    MoCBucket storage bucketTo = mocBuckets[to];\n\n    bucketFrom.nBTC = bucketFrom.nBTC.sub(btc);\n    bucketTo.nBTC = bucketTo.nBTC.add(btc);\n\n    bucketFrom.nDoc = bucketFrom.nDoc.sub(docs);\n    bucketTo.nDoc = bucketTo.nDoc.add(docs);\n\n    emit BucketMovement(from, to, btc, docs);\n  }\n\n  /**\n    @dev Clears completely the origin bucket, removing all Docs, RBTCs and bproxs\n    @param toLiquidate Bucket to be cleared out\n    @param destination Bucket that will receive the Docs and RBTCs\n   */\n  function liquidateBucket(bytes32 toLiquidate, bytes32 destination) public onlyWhitelisted(msg.sender) {\n    require(!isBucketBase(toLiquidate), \"Cannot liquidate a base bucket\");\n\n    clearBucketBalances(toLiquidate);\n    emptyBucket(toLiquidate, destination);\n  }\n\n  /**\n    @dev Clears Docs and BTC from bucket origin and sends them to destination bucket\n    @param origin Bucket to clear out\n    @param destination Destination bucket\n  */\n  function emptyBucket(bytes32 origin, bytes32 destination) public onlyWhitelisted(msg.sender) {\n    moveBtcAndDocs(origin, destination, mocBuckets[origin].nBTC, mocBuckets[origin].nDoc);\n  }\n\n  /**\n   * @dev checks if a bucket exists\n   * @param bucket name of the bucket\n   */\n  function isAvailableBucket(bytes32 bucket) public view returns(bool) {\n    return mocBuckets[bucket].available;\n  }\n\n  /**\n    @dev Put all bucket BProx balances in zero\n    @param bucketName Bucket to clear out\n   */\n  function clearBucketBalances(bytes32 bucketName) public onlyWhitelisted(msg.sender) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n    bucket.nBPro = 0;\n    bucket.activeBalancesLength = 0;\n  }\n\n  /**\n    @dev Creates bucket\n    @param name Name of the bucket\n    @param cobj Target Coverage of the bucket\n    @param isBase Indicates if it is a base bucket (true) or not (false)\n  */\n  function createBucket(bytes32 name, uint256 cobj, bool isBase) internal {\n    mocBuckets[name].name = name;\n    mocBuckets[name].nDoc = 0;\n    mocBuckets[name].nBPro = 0;\n    mocBuckets[name].nBTC = 0;\n    mocBuckets[name].cobj = cobj;\n    mocBuckets[name].isBase = isBase;\n    mocBuckets[name].available = true;\n    emit BucketCreation(name, cobj);\n  }\n\n  modifier onlyBaseBucket(bytes32 bucket) {\n    require(isBucketBase(bucket), \"Bucket should be a base type bucket\");\n    _;\n  }\n\n  modifier bucketStateUpdate(bytes32 bucket) {\n    _;\n    emit BucketStateUpdate(\n      bucket,\n      mocBuckets[bucket].nBTC,\n      mocBuckets[bucket].nDoc,\n      mocBuckets[bucket].nBPro,\n      mocBuckets[bucket].inrateBag\n      );\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/MoCBProxManager.sol\n\npragma solidity 0.5.8;\n\n\n\n\ncontract MoCBProxManager is MoCBucketContainer {\n  using SafeMath for uint256;\n  uint256 constant MIN_ALLOWED_BALANCE = 0;\n\n  /**\n    @dev Initializes the contract\n    @param connectorAddress MoCConnector contract address\n    @param _governor Governor contract address\n    @param _c0Cobj Bucket C0 objective coverage\n    @param _x2Cobj Bucket X2 objective coverage\n  */\n  function initialize(\n    address connectorAddress,\n    address _governor,\n    uint256 _c0Cobj,\n    uint256 _x2Cobj\n  ) public initializer {\n    initializeBase(connectorAddress);\n    initializeValues(_governor);\n    createBucket(BUCKET_C0, _c0Cobj, true);\n    createBucket(BUCKET_X2, _x2Cobj, false);\n  }\n\n  /**\n    @dev returns user balance\n    @param bucket BProx corresponding bucket to get balance from\n    @param userAddress user address to get balance from\n    @return total balance for the userAddress\n  */\n  function bproxBalanceOf(bytes32 bucket, address userAddress) public view returns(uint256) {\n    BProxBalance memory userBalance = mocBuckets[bucket].bproxBalances[userAddress];\n    if (!hasValidBalance(bucket, userAddress, userBalance.index)) return 0;\n    return userBalance.value;\n  }\n\n  /**\n    @dev verifies that this user has assigned balance for the given bucket\n    @param bucket corresponding Leveraged bucket to get balance from\n    @param userAddress user address to verify balance for\n    @param index index, starting from 1, where the address of the user is being kept\n    @return true if the user has assigned balance\n  */\n  function hasValidBalance(bytes32 bucket, address userAddress, uint index) public view returns(bool) {\n    return (index != 0) &&\n      (index <= getActiveAddressesCount(bucket)) &&\n      (mocBuckets[bucket].activeBalances[index - 1] == userAddress);\n  }\n\n  /**\n    @dev  Assigns the amount of BProx\n    @param bucket bucket from which the BProx will be removed\n    @param account user address to redeem for\n    @param bproxAmount bprox amount to redeem [using mocPresicion]\n    @param totalCost btc value of bproxAmount [using reservePrecision]\n  */\n  function assignBProx(bytes32 bucket, address payable account, uint256 bproxAmount, uint256 totalCost)\n  public onlyWhitelisted(msg.sender) {\n    uint256 currentBalance = bproxBalanceOf(bucket, account);\n\n    setBProxBalanceOf(bucket, account, currentBalance.add(bproxAmount));\n    addValuesToBucket(bucket, totalCost, 0, bproxAmount);\n  }\n\n  /**\n    @dev Removes the amount of BProx and substract BTC cost from bucket\n    @param bucket bucket from which the BProx will be removed\n    @param userAddress user address to redeem for\n    @param bproxAmount bprox amount to redeem [using mocPresicion]\n    @param totalCost btc value of bproxAmount [using reservePrecision]\n  */\n  function removeBProx(bytes32 bucket, address payable userAddress, uint256 bproxAmount, uint256 totalCost)\n  public onlyWhitelisted(msg.sender) {\n    uint256 currentBalance = bproxBalanceOf(bucket, userAddress);\n\n    setBProxBalanceOf(bucket, userAddress, currentBalance.sub(bproxAmount));\n    substractValuesFromBucket(bucket, totalCost, 0, bproxAmount);\n  }\n\n  /**\n    @dev Sets the amount of BProx\n    @param bucket bucket from which the BProx will be setted\n    @param userAddress user address to redeem for\n    @param value bprox amount to redeem [using mocPresicion]\n  */\n  function setBProxBalanceOf(bytes32 bucket, address payable userAddress, uint256 value) public onlyWhitelisted(msg.sender) {\n    mocBuckets[bucket].bproxBalances[userAddress].value = value;\n    uint256 index = mocBuckets[bucket].bproxBalances[userAddress].index;\n    if (!hasValidBalance(bucket, userAddress, index))\n      index = 0;\n\n    bool hasBalance = value > MIN_ALLOWED_BALANCE;\n    // The address is not in the array\n    if (index == 0) {\n      if (hasBalance) {\n        if (mocBuckets[bucket].activeBalances.length == mocBuckets[bucket].activeBalancesLength) {\n          mocBuckets[bucket].activeBalances.length += 1;\n        }\n        uint256 currentIndex = mocBuckets[bucket].activeBalancesLength++;\n        mocBuckets[bucket].activeBalances[currentIndex] = userAddress;\n        mocBuckets[bucket].bproxBalances[userAddress].index = mocBuckets[bucket].activeBalancesLength;\n      }\n    } else {\n      if (!hasBalance) {\n        // We need to delete this address from the tracker\n        uint256 lastActiveIndex = mocBuckets[bucket].activeBalancesLength;\n        address payable keyToMove = mocBuckets[bucket].activeBalances[lastActiveIndex - 1];\n        mocBuckets[bucket].activeBalances[index - 1] = keyToMove;\n        // Alternative index and array decreases lenght to prevent gas limit\n        mocBuckets[bucket].activeBalancesLength--;\n        // Update moved key index\n        mocBuckets[bucket].bproxBalances[keyToMove].index = index;\n        // Disable empty account index (0 == NULL)\n        mocBuckets[bucket].bproxBalances[userAddress].index = 0;\n      }\n    }\n  }\n\n  /**\n   @dev intializes values of the contract\n   @param _governor Governor contract address\n  */\n  function initializeValues(address _governor) internal {\n    governor = IGovernor(_governor);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/interface/IMoC.sol\n\npragma solidity 0.5.8;\n\ninterface IMoC {\n    function() external payable;\n\n    function sendToAddress(address payable receiver, uint256 btcAmount) external returns(bool);\n}\n\n// File: contracts/interface/IMoCExchange.sol\n\npragma solidity 0.5.8;\n\ninterface IMoCExchange {\n    function getMoCTokenBalance(address owner, address spender) external view\n    returns (uint256 mocBalance, uint256 mocAllowance);\n\n    function mintBPro(address account, uint256 btcAmount, address vendorAccount) external\n    returns (uint256, uint256, uint256, uint256, uint256);\n\n    function redeemBPro(address account, uint256 bproAmount, address vendorAccount) external\n    returns (uint256, uint256, uint256, uint256, uint256);\n\n    function mintDoc(address account, uint256 btcToMint, address vendorAccount) external\n    returns (uint256, uint256, uint256, uint256, uint256);\n\n    function redeemBProx(address payable account, bytes32 bucket, uint256 bproxAmount, address vendorAccount)\n    external returns (uint256, uint256, uint256, uint256, uint256);\n\n    function mintBProx(address payable account, bytes32 bucket, uint256 btcToMint, address vendorAccount) external\n    returns (uint256, uint256, uint256, uint256, uint256);\n\n    function redeemFreeDoc(address account, uint256 docAmount, address vendorAccount) external\n    returns (uint256, uint256, uint256, uint256, uint256);\n\n    function redeemAllDoc(address origin, address payable destination) external\n    returns (uint256);\n\n    function convertToMoCPrice(uint256 btcAmount) external view returns (uint256, uint256, uint256);\n\n    function forceRedeemBProx(bytes32 bucket, address payable account, uint256 bproxAmount, uint256 bproxPrice)\n    external returns (bool);\n\n    function redeemDocWithPrice(address payable userAddress, uint256 amount, uint256 btcPrice) external\n    returns (bool, uint256);\n}\n\n// File: contracts/MoCExchange.sol\n\npragma solidity 0.5.8;\npragma experimental ABIEncoderV2;\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract MoCExchangeEvents {\n  event RiskProMint(\n    address indexed account,\n    uint256 amount,\n    uint256 reserveTotal,\n    uint256 commission,\n    uint256 reservePrice,\n    uint256 mocCommissionValue,\n    uint256 mocPrice,\n    uint256 btcMarkup,\n    uint256 mocMarkup,\n    address vendorAccount\n  );\n  event RiskProWithDiscountMint(\n    uint256 riskProTecPrice,\n    uint256 riskProDiscountPrice,\n    uint256 amount\n  );\n  event RiskProRedeem(\n    address indexed account,\n    uint256 amount,\n    uint256 reserveTotal,\n    uint256 commission,\n    uint256 reservePrice,\n    uint256 mocCommissionValue,\n    uint256 mocPrice,\n    uint256 btcMarkup,\n    uint256 mocMarkup,\n    address vendorAccount\n  );\n  event StableTokenMint(\n    address indexed account,\n    uint256 amount,\n    uint256 reserveTotal,\n    uint256 commission,\n    uint256 reservePrice,\n    uint256 mocCommissionValue,\n    uint256 mocPrice,\n    uint256 btcMarkup,\n    uint256 mocMarkup,\n    address vendorAccount\n  );\n  event StableTokenRedeem(\n    address indexed account,\n    uint256 amount,\n    uint256 reserveTotal,\n    uint256 commission,\n    uint256 reservePrice,\n    uint256 mocCommissionValue,\n    uint256 mocPrice,\n    uint256 btcMarkup,\n    uint256 mocMarkup,\n    address vendorAccount\n  );\n  event FreeStableTokenRedeem(\n    address indexed account,\n    uint256 amount,\n    uint256 reserveTotal,\n    uint256 commission,\n    uint256 interests,\n    uint256 reservePrice,\n    uint256 mocCommissionValue,\n    uint256 mocPrice,\n    uint256 btcMarkup,\n    uint256 mocMarkup,\n    address vendorAccount\n  );\n\n  event RiskProxMint(\n    bytes32 bucket,\n    address indexed account,\n    uint256 amount,\n    uint256 reserveTotal,\n    uint256 interests,\n    uint256 leverage,\n    uint256 commission,\n    uint256 reservePrice,\n    uint256 mocCommissionValue,\n    uint256 mocPrice,\n    uint256 btcMarkup,\n    uint256 mocMarkup,\n    address vendorAccount\n  );\n\n  event RiskProxRedeem(\n    bytes32 bucket,\n    address indexed account,\n    uint256 commission,\n    uint256 amount,\n    uint256 reserveTotal,\n    uint256 interests,\n    uint256 leverage,\n    uint256 reservePrice,\n    uint256 mocCommissionValue,\n    uint256 mocPrice,\n    uint256 btcMarkup,\n    uint256 mocMarkup,\n    address vendorAccount\n  );\n}\n\n\ncontract MoCExchange is MoCExchangeEvents, MoCBase, MoCLibConnection, IMoCExchange {\n  using Math for uint256;\n  using SafeMath for uint256;\n\n  // Contracts\n  IMoCState internal mocState;\n  MoCConverter internal mocConverter;\n  MoCBProxManager internal bproxManager;\n  BProToken internal bproToken;\n  DocToken internal docToken;\n  IMoCInrate internal mocInrate;\n  IMoC internal moc;\n\n  /**\n    @dev Initializes the contract\n    @param connectorAddress MoCConnector contract address\n  */\n  function initialize(address connectorAddress) public initializer {\n    initializePrecisions();\n    initializeBase(connectorAddress);\n    initializeContracts();\n  }\n\n  /************************************/\n  /***** UPGRADE v0110      ***********/\n  /************************************/\n\n  /** START UPDATE V0110: 24/09/2020  **/\n  /** Upgrade to support multiple commission rates **/\n  /** Public functions **/\n\n  /**\n   @dev Converts MoC commission from RBTC to MoC price\n   @param btcAmount Amount to be converted to MoC price\n   @return Amount converted to MoC Price, Bitcoin price and MoC price\n  */\n  function convertToMoCPrice(uint256 btcAmount) public view returns (uint256, uint256, uint256) {\n    uint256 btcPrice = mocState.getBitcoinPrice();\n    uint256 mocPrice = mocState.getMoCPrice();\n\n    // Calculate amount in MoC\n    uint256 amountInMoC = mocConverter.btcToMoCWithPrice(btcAmount, btcPrice, mocPrice);\n\n    return (amountInMoC, btcPrice, mocPrice);\n  }\n\n  /**\n   @dev Converts MoC commission from RBTC to MoC price\n   @param owner address of token owner\n   @param spender address of token spender\n   @return MoC balance of owner and MoC allowance of spender\n  */\n  function getMoCTokenBalance(address owner, address spender) public view\n  returns (uint256 mocBalance, uint256 mocAllowance) {\n    mocBalance = 0;\n    mocAllowance = 0;\n\n    MoCToken mocToken = MoCToken(mocState.getMoCToken());\n\n    if (address(mocToken) != address(0)) {\n      // Get balance and allowance from sender\n      mocBalance = mocToken.balanceOf(owner);\n      mocAllowance = mocToken.allowance(owner, spender);\n    }\n\n    return (mocBalance, mocAllowance);\n  }\n\n  /**\n   @dev Calculates commissions in MoC and BTC\n   @param params Params defined in CommissionParamsStruct\n   @return Commissions calculated in MoC price and bitcoin price; and Bitcoin and MoC prices\n  */\n  function calculateCommissionsWithPrices(CommissionParamsStruct memory params)\n  public view\n  returns (CommissionReturnStruct memory ret) {\n    // Get balance and allowance from sender\n    (uint256 mocBalance, uint256 mocAllowance) = getMoCTokenBalance(params.account, address(moc));\n\n    // Check commission rate in MoC according to transaction type\n    uint256 mocCommissionInBtc = mocInrate.calcCommissionValue(params.amount, params.txTypeFeesMOC);\n\n    // Calculate amount in MoC\n    (ret.mocCommission, ret.btcPrice, ret.mocPrice) = convertToMoCPrice(mocCommissionInBtc);\n    ret.btcCommission = 0;\n\n    // Calculate vendor markup\n    uint256 btcMarkup = mocInrate.calculateVendorMarkup(params.vendorAccount, params.amount);\n    (ret.mocMarkup, , ) = convertToMoCPrice(btcMarkup);\n    ret.btcMarkup = 0;\n    uint256 totalMoCFee = ret.mocCommission.add(ret.mocMarkup);\n\n    // Check if there is enough balance of MoC\n    if ((!(mocBalance >= totalMoCFee && mocAllowance >= totalMoCFee)) || (mocCommissionInBtc == 0)) {\n      // Insufficient funds\n      ret.mocCommission = 0;\n      ret.mocMarkup = 0;\n\n      // Check commission rate in RBTC according to transaction type\n      ret.btcCommission = mocInrate.calcCommissionValue(params.amount, params.txTypeFeesRBTC);\n      ret.btcMarkup = btcMarkup;\n    }\n\n    return ret;\n  }\n\n  /** END UPDATE V0110: 24/09/2020 **/\n\n  /**\n   @dev Mint BPros and give it to the msg.sender\n   @param account Address of minter\n   @param btcAmount Amount in BTC to mint\n   @param vendorAccount Vendor address\n  */\n// solium-disable-next-line security/no-assign-params\n  function mintBPro(address account, uint256 btcAmount, address vendorAccount)\n    public\n    onlyWhitelisted(msg.sender)\n    returns (uint256, uint256, uint256, uint256, uint256)\n  {\n    RiskProMintStruct memory details;\n\n    details.bproRegularPrice = mocState.bproTecPrice();\n    details.finalBProAmount = 0;\n    details.btcValue = 0;\n\n    if (mocState.state() == IMoCState.States.BProDiscount) {\n      details.discountPrice = mocState.bproDiscountPrice();\n      details.bproDiscountAmount = mocConverter.btcToBProDisc(btcAmount);\n\n      details.finalBProAmount = Math.min(\n        details.bproDiscountAmount,\n        mocState.maxBProWithDiscount()\n      );\n      details.btcValue = details.finalBProAmount == details.bproDiscountAmount\n        ? btcAmount\n        : mocConverter.bproDiscToBtc(details.finalBProAmount);\n\n      emit RiskProWithDiscountMint(\n        details.bproRegularPrice,\n        details.discountPrice,\n        details.finalBProAmount\n      );\n    }\n\n    if (btcAmount != details.btcValue) {\n      details.regularBProAmount = mocConverter.btcToBPro(\n        btcAmount.sub(details.btcValue)\n      );\n      details.finalBProAmount = details.finalBProAmount.add(details.regularBProAmount);\n    }\n\n    /** UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n    CommissionParamsStruct memory params;\n    params.account = account;\n    params.amount = btcAmount;\n    params.txTypeFeesMOC = mocInrate.MINT_BPRO_FEES_MOC();\n    params.txTypeFeesRBTC = mocInrate.MINT_BPRO_FEES_RBTC();\n    params.vendorAccount = vendorAccount;\n\n    (details.commission) = calculateCommissionsWithPrices(params);\n\n    mintBProInternal(account, btcAmount, details, vendorAccount);\n\n    return (\n      btcAmount,\n      details.commission.btcCommission,\n      details.commission.mocCommission,\n      details.commission.btcMarkup,\n      details.commission.mocMarkup\n    );\n    /** END UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n  }\n\n  /**\n   @dev Sender burns his BProS and redeems the equivalent BTCs\n   @param account Address of the redeeemer\n   @param bproAmount Amount of BPros to be redeemed\n   @param vendorAccount Vendor address\n   @return bitcoins to transfer to the redeemer and commission spent (in BTC and MoC), using [using reservePrecision]\n  */\n  function redeemBPro(address account, uint256 bproAmount, address vendorAccount)\n    public\n    onlyWhitelisted(msg.sender)\n    returns (uint256, uint256, uint256, uint256, uint256)\n  {\n    RiskProRedeemStruct memory details;\n\n    uint256 userBalance = bproToken.balanceOf(account);\n    uint256 userAmount = Math.min(bproAmount, userBalance);\n\n    details.bproFinalAmount = Math.min(userAmount, mocState.absoluteMaxBPro());\n    uint256 totalBtc = mocConverter.bproToBtc(details.bproFinalAmount);\n\n    /** UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n    CommissionParamsStruct memory params;\n    params.account = account;\n    params.amount = totalBtc;\n    params.txTypeFeesMOC = mocInrate.REDEEM_BPRO_FEES_MOC();\n    params.txTypeFeesRBTC = mocInrate.REDEEM_BPRO_FEES_RBTC();\n    params.vendorAccount = vendorAccount;\n\n    (details.commission) = calculateCommissionsWithPrices(params);\n    /** END UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n\n    // Mint token\n    bproToken.burn(account, details.bproFinalAmount);\n\n    // Update Buckets\n    bproxManager.substractValuesFromBucket(\n      BUCKET_C0,\n      totalBtc,\n      0,\n      details.bproFinalAmount\n    );\n\n    details.btcTotalWithoutCommission = totalBtc.sub(details.commission.btcCommission).sub(details.commission.btcMarkup);\n\n    redeemBProInternal(account, details, vendorAccount);\n\n    return (\n      details.btcTotalWithoutCommission,\n      details.commission.btcCommission,\n      details.commission.mocCommission,\n      details.commission.btcMarkup,\n      details.commission.mocMarkup\n    );\n  }\n\n  /**\n   @dev Redeems the requested amount for the account, or the max amount of free docs possible.\n   @param account Address of the redeeemer\n   @param docAmount Amount of Docs to redeem [using mocPrecision]\n   @param vendorAccount Vendor address\n   @return bitcoins to transfer to the redeemer and commission spent (in BTC and MoC), using [using reservePrecision]\n  */\n  function redeemFreeDoc(address account, uint256 docAmount, address vendorAccount)\n    public\n    onlyWhitelisted(msg.sender)\n    returns (uint256, uint256, uint256, uint256, uint256)\n  {\n    if (docAmount <= 0) {\n      return (0, 0, 0, 0, 0);\n    } else {\n      FreeStableTokenRedeemStruct memory details;\n      details.finalDocAmount = Math.min(\n        docAmount,\n        Math.min(mocState.freeDoc(), docToken.balanceOf(account))\n      );\n      uint256 docsBtcValue = mocConverter.docsToBtc(details.finalDocAmount);\n\n      details.btcInterestAmount = mocInrate.calcDocRedInterestValues(\n        details.finalDocAmount,\n        docsBtcValue\n      );\n      details.finalBtcAmount = docsBtcValue.sub(details.btcInterestAmount);\n\n      /** UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n      CommissionParamsStruct memory params;\n      params.account = account;\n      params.amount = details.finalBtcAmount;\n      params.txTypeFeesMOC = mocInrate.REDEEM_DOC_FEES_MOC();\n      params.txTypeFeesRBTC = mocInrate.REDEEM_DOC_FEES_RBTC();\n      params.vendorAccount = vendorAccount;\n\n      (details.commission) = calculateCommissionsWithPrices(params);\n\n      /** END UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n\n      doDocRedeem(account, details.finalDocAmount, docsBtcValue);\n      bproxManager.payInrate(BUCKET_C0, details.btcInterestAmount);\n\n      redeemFreeDocInternal(account, details, vendorAccount);\n\n      return (details.finalBtcAmount.sub(details.commission.btcCommission).sub(details.commission.btcMarkup), details.commission.btcCommission, details.commission.mocCommission, details.commission.btcMarkup, details.commission.mocMarkup);\n    }\n  }\n\n  /**\n   @dev Mint Max amount of Docs and give it to the msg.sender\n   @param account minter user address\n   @param btcToMint btc amount the user intents to convert to DoC [using rbtPresicion]\n   @param vendorAccount Vendor address\n   @return the actual amount of btc used and the btc commission (in BTC and MoC) for them [using rbtPresicion]\n  */\n  function mintDoc(address account, uint256 btcToMint, address vendorAccount)\n    public\n    onlyWhitelisted(msg.sender)\n    returns (uint256, uint256, uint256, uint256, uint256)\n  {\n    StableTokenMintStruct memory details;\n\n    // Docs to issue with tx value amount\n    if (btcToMint > 0) {\n      details.docs = mocConverter.btcToDoc(btcToMint);\n      details.docAmount = Math.min(details.docs, mocState.absoluteMaxDoc());\n      details.totalCost = details.docAmount == details.docs\n        ? btcToMint\n        : mocConverter.docsToBtc(details.docAmount);\n\n      // Mint Token\n      docToken.mint(account, details.docAmount);\n\n      // Update Buckets\n      bproxManager.addValuesToBucket(BUCKET_C0, details.totalCost, details.docAmount, 0);\n\n      /** UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n      CommissionParamsStruct memory params;\n      params.account = account;\n      params.amount = details.totalCost;\n      params.txTypeFeesMOC = mocInrate.MINT_DOC_FEES_MOC();\n      params.txTypeFeesRBTC = mocInrate.MINT_DOC_FEES_RBTC();\n      params.vendorAccount = vendorAccount;\n\n      (details.commission) = calculateCommissionsWithPrices(params);\n\n      mintDocInternal(account, details, vendorAccount);\n\n      /** END UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n\n      return (details.totalCost, details.commission.btcCommission, details.commission.mocCommission, details.commission.btcMarkup, details.commission.mocMarkup);\n    }\n\n    return (0, 0, 0, 0, 0);\n  }\n\n  /**\n   @dev User DoCs get burned and he receives the equivalent BTCs in return\n   @param userAddress Address of the user asking to redeem\n   @param amount Verified amount of Docs to be redeemed [using mocPrecision]\n   @param btcPrice bitcoin price [using mocPrecision]\n   @return true and commission spent (in BTC and MoC) if btc send was completed, false if fails.\n  */\n  function redeemDocWithPrice(\n    address payable userAddress,\n    uint256 amount,\n    uint256 btcPrice\n  ) public onlyWhitelisted(msg.sender) returns (bool, uint256) {\n    StableTokenRedeemStruct memory details;\n\n    details.totalBtc = mocConverter.docsToBtcWithPrice(amount, btcPrice);\n\n    /** UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n    // Check commission rate in RBTC according to transaction type\n    details.commission.btcCommission = mocInrate.calcCommissionValue(details.totalBtc, mocInrate.REDEEM_DOC_FEES_RBTC());\n    details.commission.btcMarkup = 0;\n    /** END UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n\n    details.btcToRedeem = details.totalBtc.sub(details.commission.btcCommission).sub(details.commission.btcMarkup);\n\n    bool result = moc.sendToAddress(userAddress, details.btcToRedeem);\n\n    details.reserveTotal = details.totalBtc.sub(details.commission.btcCommission).sub(details.commission.btcMarkup);\n    details.commission.btcPrice = btcPrice;\n    details.commission.mocCommission = 0;\n    details.commission.mocPrice = 0;\n    details.commission.mocMarkup = 0;\n\n    // If sends fail, then no redemption is executed\n    if (result) {\n      doDocRedeem(userAddress, amount, details.totalBtc);\n      redeemDocWithPriceInternal(userAddress, amount, details, address(0));\n    }\n\n    return (result, details.commission.btcCommission);\n  }\n\n  /**\n   @dev Allow redeem on liquidation state, user DoCs get burned and he receives\n   the equivalent RBTCs according to liquidationPrice\n   @param origin address owner of the DoCs\n   @param destination address to send the RBTC\n   @return The amount of RBTC in sent for the redemption or 0 if send does not succed\n  */\n  function redeemAllDoc(address origin, address payable destination)\n    public\n    onlyWhitelisted(msg.sender)\n    returns (uint256)\n  {\n    uint256 userDocBalance = docToken.balanceOf(origin);\n    if (userDocBalance == 0) return 0;\n\n    uint256 liqPrice = mocState.getLiquidationPrice();\n    // [USD * RBTC / USD]\n    uint256 totalRbtc = mocConverter.docsToBtcWithPrice(\n      userDocBalance,\n      liqPrice\n    );\n\n    // If send fails we don't burn the tokens\n    if (moc.sendToAddress(destination, totalRbtc)) {\n      docToken.burn(origin, userDocBalance);\n      emit StableTokenRedeem(\n        origin,\n        userDocBalance,\n        totalRbtc,\n        0,\n        liqPrice,\n        0,\n        0,\n        0,\n        0,\n        address(0)\n      );\n\n      return totalRbtc;\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n    @dev  Mint the amount of BPros\n    @param account Address that will owned the BPros\n    @param bproAmount Amount of BPros to mint [using mocPrecision]\n    @param rbtcValue RBTC cost of the minting [using reservePrecision]\n  */\n  function mintBPro(\n    address account,\n    uint256 btcCommission,\n    uint256 bproAmount,\n    uint256 rbtcValue,\n    uint256 mocCommission,\n    uint256 btcPrice,\n    uint256 mocPrice,\n    uint256 btcMarkup,\n    uint256 mocMarkup,\n    address vendorAccount\n  ) public onlyWhitelisted(msg.sender) {\n    bproToken.mint(account, bproAmount);\n    bproxManager.addValuesToBucket(BUCKET_C0, rbtcValue, 0, bproAmount);\n\n    emit RiskProMint(\n      account,\n      bproAmount,\n      rbtcValue,\n      btcCommission,\n      btcPrice,\n      mocCommission,\n      mocPrice,\n      btcMarkup,\n      mocMarkup,\n      vendorAccount\n    );\n  }\n\n  /**\n   @dev BUCKET Bprox minting. Mints Bprox for the specified bucket\n   @param account owner of the new minted Bprox\n   @param bucket bucket name\n   @param btcToMint rbtc amount to mint [using reservePrecision]\n   @param vendorAccount Vendor address\n   @return total RBTC Spent (btcToMint more interest) and commission spent (in BTC and MoC) [using reservePrecision]\n  */\n  function mintBProx(address payable account, bytes32 bucket, uint256 btcToMint, address vendorAccount)\n    public\n    onlyWhitelisted(msg.sender)\n    returns (uint256, uint256, uint256, uint256, uint256)\n  {\n    if (btcToMint > 0) {\n      RiskProxMintStruct memory details;\n\n      details.lev = mocState.leverage(bucket);\n\n      details.finalBtcToMint = Math.min(\n        btcToMint,\n        mocState.maxBProxBtcValue(bucket)\n      );\n\n      // Get interest and the adjusted BProAmount\n      details.btcInterestAmount = mocInrate.calcMintInterestValues(\n        bucket,\n        details.finalBtcToMint\n      );\n\n      // pay interest\n      bproxManager.payInrate(BUCKET_C0, details.btcInterestAmount);\n\n      details.bproxToMint = mocConverter.btcToBProx(details.finalBtcToMint, bucket);\n\n      bproxManager.assignBProx(bucket, account, details.bproxToMint, details.finalBtcToMint);\n      moveExtraFundsToBucket(BUCKET_C0, bucket, details.finalBtcToMint, details.lev);\n\n      // Calculate leverage after mint\n      details.lev = mocState.leverage(bucket);\n\n      /** UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n      CommissionParamsStruct memory params;\n      params.account = account;\n      params.amount = details.finalBtcToMint;\n      params.txTypeFeesMOC = mocInrate.MINT_BTCX_FEES_MOC();\n      params.txTypeFeesRBTC = mocInrate.MINT_BTCX_FEES_RBTC();\n      params.vendorAccount = vendorAccount;\n\n      (details.commission) = calculateCommissionsWithPrices(params);\n\n      mintBProxInternal(account, bucket, details, vendorAccount);\n      /** END UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n\n      return (details.finalBtcToMint.add(details.btcInterestAmount), details.commission.btcCommission, details.commission.mocCommission, details.commission.btcMarkup, details.commission.mocMarkup);\n    }\n\n    return (0, 0, 0, 0, 0);\n  }\n\n  /**\n   @dev Sender burns his BProx, redeems the equivalent amount of BPros, return\n   the \"borrowed\" DOCs and recover pending interests\n   @param account user address to redeem bprox from\n   @param bucket Bucket where the BProxs are hold\n   @param bproxAmount Amount of BProxs to be redeemed [using mocPrecision]\n   @param vendorAccount Vendor address\n   @return the actual amount of btc to redeem and the btc commission (in BTC and MoC) for them [using reservePrecision]\n  */\n  function redeemBProx(\n    address payable account,\n    bytes32 bucket,\n    uint256 bproxAmount,\n    address vendorAccount\n  ) public onlyWhitelisted(msg.sender) returns (uint256, uint256, uint256, uint256, uint256) {\n    // Revert could cause not evaluating state changing\n    if (bproxManager.bproxBalanceOf(bucket, account) == 0) {\n      return (0, 0, 0, 0, 0);\n    }\n\n    RiskProxRedeemStruct memory details;\n    // Calculate leverage before the redeem\n    details.bucketLev = mocState.leverage(bucket);\n    // Get redeemable value\n    details.bproxToRedeem = Math.min(bproxAmount, bproxManager.bproxBalanceOf(bucket, account));\n    details.rbtcToRedeem = mocConverter.bproxToBtc(details.bproxToRedeem, bucket);\n    // Pay interests\n    // Update 2020-03-31\n    // No recover interest in BTCX Redemption\n    // details.rbtcInterests = recoverInterests(bucket, details.rbtcToRedeem);\n    details.rbtcInterests = 0;\n\n    // Burn Bprox\n    burnBProxFor(\n      bucket,\n      account,\n      details.bproxToRedeem,\n      mocState.bucketBProTecPrice(bucket)\n    );\n\n    if (bproxManager.getBucketNBPro(bucket) == 0) {\n      // If there is no BProx left, empty bucket for rounding remnant\n      bproxManager.emptyBucket(bucket, BUCKET_C0);\n    } else {\n      // Move extra value from L bucket to C0\n      moveExtraFundsToBucket(bucket, BUCKET_C0, details.rbtcToRedeem, details.bucketLev);\n    }\n\n    /** UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n    CommissionParamsStruct memory params;\n    params.account = account;\n    params.amount = details.rbtcToRedeem;\n    params.txTypeFeesMOC = mocInrate.REDEEM_BTCX_FEES_MOC();\n    params.txTypeFeesRBTC = mocInrate.REDEEM_BTCX_FEES_RBTC();\n    params.vendorAccount = vendorAccount;\n\n    (details.commission) = calculateCommissionsWithPrices(params);\n\n    /** END UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n\n    details.btcTotalWithoutCommission = details.rbtcToRedeem.sub(details.commission.btcCommission).sub(details.commission.btcMarkup);\n    details.totalBtcRedeemed = details.btcTotalWithoutCommission.add(details.rbtcInterests);\n\n    redeemBProxInternal(account, bucket, bproxAmount, details, vendorAccount);\n\n    return (\n      details.totalBtcRedeemed,\n      details.commission.btcCommission,\n      details.commission.mocCommission,\n      details.commission.btcMarkup,\n      details.commission.mocMarkup\n    );\n  }\n\n  /**\n    @dev Burns user BProx and sends the equivalent amount of RBTC\n    to the account without caring if transaction succeeds\n    @param bucket Bucket where the BProxs are hold\n    @param account user address to redeem bprox from\n    @param bproxAmount Amount of BProx to redeem [using mocPrecision]\n    @param bproxPrice Price of one BProx in RBTC [using reservePrecision]\n    @return result of the RBTC sending transaction [using reservePrecision]\n  */\n  function forceRedeemBProx(\n    bytes32 bucket,\n    address payable account,\n    uint256 bproxAmount,\n    uint256 bproxPrice\n  ) public onlyWhitelisted(msg.sender) returns (bool) {\n    // Do burning part of the redemption\n    uint256 btcTotalAmount = burnBProxFor(\n      bucket,\n      account,\n      bproxAmount,\n      bproxPrice\n    );\n\n    // Send transaction can only fail for external code\n    // if transaction fails, user will lost his RBTC and BProx\n    return moc.sendToAddress(account, btcTotalAmount);\n  }\n\n  /**\n    @dev Burns user BProx\n    @param bucket Bucket where the BProxs are hold\n    @param account user address to redeem bprox from\n    @param bproxAmount Amount of BProx to redeem [using mocPrecision]\n    @param bproxPrice Price of one BProx in RBTC [using reservePrecision]\n    @return Bitcoin total value of the redemption [using reservePrecision]\n  */\n  function burnBProxFor(\n    bytes32 bucket,\n    address payable account,\n    uint256 bproxAmount,\n    uint256 bproxPrice\n  ) public onlyWhitelisted(msg.sender) returns (uint256) {\n    // Calculate total RBTC\n    uint256 btcTotalAmount = mocConverter.bproToBtcWithPrice(\n      bproxAmount,\n      bproxPrice\n    );\n    bproxManager.removeBProx(bucket, account, bproxAmount, btcTotalAmount);\n\n    return btcTotalAmount;\n  }\n\n  /************************************/\n  /***** UPGRADE v0110      ***********/\n  /************************************/\n\n  /** START UPDATE V0110: 24/09/2020  **/\n  /** Upgrade to support multiple commission rates **/\n  /** Internal functions **/\n\n  /**\n   @dev Internal function to avoid stack too deep errors\n  */\n  function redeemBProxInternal(\n    address account,\n    bytes32 bucket,\n    uint256 bproxAmount,\n    RiskProxRedeemStruct memory details,\n    address vendorAccount\n  ) internal {\n    emit RiskProxRedeem(\n      bucket,\n      account,\n      details.commission.btcCommission,\n      bproxAmount,\n      details.btcTotalWithoutCommission,\n      details.rbtcInterests,\n      details.bucketLev,\n      details.commission.btcPrice,\n      details.commission.mocCommission,\n      details.commission.mocPrice,\n      details.commission.btcMarkup,\n      details.commission.mocMarkup,\n      vendorAccount\n    );\n  }\n\n  /**\n   @dev Internal function to avoid stack too deep errors\n  */\n  function mintBProInternal(address account, uint256 btcAmount, RiskProMintStruct memory details, address vendorAccount) internal {\n    mintBPro(\n      account,\n      details.commission.btcCommission,\n      details.finalBProAmount,\n      btcAmount,\n      details.commission.mocCommission,\n      details.commission.btcPrice,\n      details.commission.mocPrice,\n      details.commission.btcMarkup,\n      details.commission.mocMarkup,\n      vendorAccount\n    );\n  }\n\n  /**\n   @dev Internal function to avoid stack too deep errors\n  */\n  function mintBProxInternal(address account, bytes32 bucket, RiskProxMintStruct memory details, address vendorAccount) internal {\n    emit RiskProxMint(\n      bucket,\n      account,\n      details.bproxToMint,\n      details.finalBtcToMint,\n      details.btcInterestAmount,\n      details.lev,\n      details.commission.btcCommission,\n      details.commission.btcPrice,\n      details.commission.mocCommission,\n      details.commission.mocPrice,\n      details.commission.btcMarkup,\n      details.commission.mocMarkup,\n      vendorAccount\n    );\n  }\n\n  /**\n   @dev Internal function to avoid stack too deep errors\n  */\n  function mintDocInternal(address account, StableTokenMintStruct memory details, address vendorAccount) internal {\n    emit StableTokenMint(\n      account,\n      details.docAmount,\n      details.totalCost,\n      details.commission.btcCommission,\n      details.commission.btcPrice,\n      details.commission.mocCommission,\n      details.commission.mocPrice,\n      details.commission.btcMarkup,\n      details.commission.mocMarkup,\n      vendorAccount\n    );\n  }\n\n  /**\n   @dev Internal function to avoid stack too deep errors\n  */\n  function redeemFreeDocInternal(address account, FreeStableTokenRedeemStruct memory details, address vendorAccount) internal {\n    emit FreeStableTokenRedeem(\n      account,\n      details.finalDocAmount,\n      details.finalBtcAmount,\n      details.commission.btcCommission,\n      details.btcInterestAmount,\n      details.commission.btcPrice,\n      details.commission.mocCommission,\n      details.commission.mocPrice,\n      details.commission.btcMarkup,\n      details.commission.mocMarkup,\n      vendorAccount\n    );\n  }\n\n  /**\n   @dev Internal function to avoid stack too deep errors\n  */\n  function redeemBProInternal(address account, RiskProRedeemStruct memory details, address vendorAccount) internal {\n    emit RiskProRedeem(\n      account,\n      details.bproFinalAmount,\n      details.btcTotalWithoutCommission,\n      details.commission.btcCommission,\n      details.commission.btcPrice,\n      details.commission.mocCommission,\n      details.commission.mocPrice,\n      details.commission.btcMarkup,\n      details.commission.mocMarkup,\n      vendorAccount\n    );\n  }\n\n  /**\n   @dev Internal function to avoid stack too deep errors\n  */\n  function redeemDocWithPriceInternal(address account, uint256 amount, StableTokenRedeemStruct memory details, address vendorAccount) internal {\n    emit StableTokenRedeem(\n      account, //userAddress,\n      amount,\n      details.reserveTotal,\n      details.commission.btcCommission,\n      details.commission.btcPrice,\n      details.commission.mocCommission,\n      details.commission.mocPrice,\n      details.commission.btcMarkup,\n      details.commission.mocMarkup,\n      vendorAccount\n    );\n  }\n\n  /** END UPDATE V0110: 24/09/2020 **/\n\n  /**\n    @dev Calculates the amount of RBTC that one bucket should move to another in\n    BProx minting/redemption. This extra makes BProx more leveraging than BPro.\n    @param bucketFrom Origin bucket from which the BTC are moving\n    @param bucketTo Destination bucket to which the BTC are moving\n    @param totalBtc Amount of BTC moving between buckets [using reservePrecision]\n    @param lev lev of the L bucket [using mocPrecision]\n  */\n  function moveExtraFundsToBucket(\n    bytes32 bucketFrom,\n    bytes32 bucketTo,\n    uint256 totalBtc,\n    uint256 lev\n  ) internal {\n    uint256 btcToMove = mocLibConfig.bucketTransferAmount(totalBtc, lev);\n    uint256 docsToMove = mocConverter.btcToDoc(btcToMove);\n\n    uint256 btcToMoveFinal = Math.min(\n      btcToMove,\n      bproxManager.getBucketNBTC(bucketFrom)\n    );\n    uint256 docsToMoveFinal = Math.min(\n      docsToMove,\n      bproxManager.getBucketNDoc(bucketFrom)\n    );\n\n    bproxManager.moveBtcAndDocs(\n      bucketFrom,\n      bucketTo,\n      btcToMoveFinal,\n      docsToMoveFinal\n    );\n  }\n\n  /**\n   @dev Returns RBTCs for user in concept of interests refund\n   @param bucket Bucket where the BProxs are hold\n   @param rbtcToRedeem Total RBTC value of the redemption [using reservePrecision]\n   @return Interests [using reservePrecision]\n  */\n  function recoverInterests(bytes32 bucket, uint256 rbtcToRedeem)\n    internal\n    returns (uint256)\n  {\n    uint256 rbtcInterests = mocInrate.calcFinalRedeemInterestValue(\n      bucket,\n      rbtcToRedeem\n    );\n\n    return bproxManager.recoverInrate(BUCKET_C0, rbtcInterests);\n  }\n\n  function doDocRedeem(address userAddress, uint256 docAmount, uint256 totalBtc)\n    internal\n  {\n    docToken.burn(userAddress, docAmount);\n    bproxManager.substractValuesFromBucket(BUCKET_C0, totalBtc, docAmount, 0);\n  }\n\n  function initializeContracts() internal {\n    moc = IMoC(connector.moc());\n    docToken = DocToken(connector.docToken());\n    bproToken = BProToken(connector.bproToken());\n    bproxManager = MoCBProxManager(connector.bproxManager());\n    mocState = IMoCState(connector.mocState());\n    mocConverter = MoCConverter(connector.mocConverter());\n    mocInrate = IMoCInrate(connector.mocInrate());\n  }\n\n\n  /************************************/\n  /***** UPGRADE v0110      ***********/\n  /************************************/\n\n  /** START UPDATE V0110: 24/09/2020  **/\n  /** Upgrade to support multiple commission rates **/\n  /** Structs **/\n\n  struct RiskProxRedeemStruct{\n    uint256 totalBtcRedeemed;\n    uint256 btcTotalWithoutCommission;\n    uint256 rbtcInterests;\n    uint256 bucketLev;\n    uint256 bproxToRedeem;\n    uint256 rbtcToRedeem;\n    CommissionReturnStruct commission;\n  }\n\n  struct RiskProxMintStruct{\n    uint256 bproxToMint;\n    uint256 finalBtcToMint;\n    uint256 btcInterestAmount;\n    uint256 lev;\n    CommissionReturnStruct commission;\n  }\n\n  struct RiskProRedeemStruct{\n    uint256 bproFinalAmount;\n    uint256 btcTotalWithoutCommission;\n    CommissionReturnStruct commission;\n  }\n\n  struct FreeStableTokenRedeemStruct{\n    uint256 finalDocAmount;\n    uint256 finalBtcAmount;\n    uint256 btcInterestAmount;\n    CommissionReturnStruct commission;\n  }\n\n  struct RiskProMintStruct{\n    uint256 bproRegularPrice;\n    uint256 btcValue;\n    uint256 discountPrice;\n    uint256 bproDiscountAmount;\n    uint256 regularBProAmount;\n    uint256 availableBPro;\n    uint256 finalBProAmount;\n    CommissionReturnStruct commission;\n  }\n\n  struct StableTokenMintStruct{\n    uint256 docs;\n    uint256 docAmount;\n    uint256 totalCost;\n    CommissionReturnStruct commission;\n  }\n\n  struct CommissionParamsStruct{\n    address account; // Address of the user doing the transaction\n    uint256 amount; // Amount from which commissions are calculated\n    uint8 txTypeFeesMOC; // Transaction type if fees are paid in MoC\n    uint8 txTypeFeesRBTC; // Transaction type if fees are paid in RBTC\n    address vendorAccount; // Vendor address\n  }\n\n  struct CommissionReturnStruct{\n    uint256 btcCommission;\n    uint256 mocCommission;\n    uint256 btcPrice;\n    uint256 mocPrice;\n    uint256 btcMarkup;\n    uint256 mocMarkup;\n  }\n\n  struct StableTokenRedeemStruct{\n    uint256 reserveTotal;\n    uint256 btcToRedeem;\n    uint256 totalBtc;\n    CommissionReturnStruct commission;\n  }\n\n  /** END UPDATE V0110: 24/09/2020 **/\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n",
    "imports": [
        {
            "name": "MoCExchange-flat.sol",
            "contents": "\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n// File: contracts/MoCHelperLib.sol\n\npragma solidity 0.5.8;\n\n\nlibrary MoCHelperLib {\n\n  struct MocLibConfig {\n    uint256 reservePrecision;\n    uint256 dayPrecision;\n    uint256 mocPrecision;\n  }\n\n  using SafeMath for uint256;\n\n  uint256 constant UINT256_MAX = ~uint256(0);\n\n  /**\n    @dev Returns max uint256 value constant.\n    @return max uint256 value constant\n  */\n  function getMaxInt(MocLibConfig storage /*config*/) public pure returns(uint256) {\n    return UINT256_MAX;\n  }\n\n  /**\n    @dev Calculates average interest using integral function: T =  Rate = a * (x ** b) + c\n    @param tMax maxInterestRate [using mocPrecision]\n    @param power factor [using noPrecision]\n    @param tMin minInterestRate C0 doc amount [using mocPrecision]\n    @param abRat1 initial abundance ratio [using mocPrecision]\n    @param abRat2 final abundance ratio [using mocPrecision]\n    @return average interest rate [using mocPrecision]\n  */\n  function inrateAvg(MocLibConfig storage config, uint256 tMax, uint256 power, uint256 tMin, uint256 abRat1, uint256 abRat2)\n  public view returns(uint256) {\n    require(tMax > tMin, \"Max inrate should be bigger than Min inrate\");\n    uint256 abRat1Comp = config.mocPrecision.sub(abRat1);\n    uint256 abRat2Comp = config.mocPrecision.sub(abRat2);\n\n    if (abRat1 == abRat2) {\n      return potential(config, tMax, power, tMin, abRat1Comp);\n    }\n    else if (abRat2 < abRat1) {\n      return avgInt(config, tMax, power, tMin, abRat1Comp, abRat2Comp);\n    }\n    else {\n      return avgInt(config, tMax, power, tMin, abRat2Comp, abRat1Comp);\n    }\n  }\n\n  /**\n    @dev Calculates spot interest rate that BProx owners should pay to BPro owners: Rate = tMax * (abRatio ** power) + tMin\n    @param tMin min interest rate [using mocPrecision]\n    @param power power to use in the formula [using NoPrecision]\n    @param tMax max interest rate [using mocPrecision]\n    @param abRatio bucket C0  abundance Ratio [using mocPrecision]\n   */\n  function spotInrate(\n    MocLibConfig storage config, uint256 tMax, uint256 power, uint256 tMin, uint256 abRatio\n  ) public view returns(uint256) {\n    uint256 abRatioComp = config.mocPrecision.sub(abRatio);\n\n    return potential(config, tMax, power, tMin, abRatioComp);\n  }\n\n  /**\n    @dev Calculates potential interests function with given parameters: Rate = a * (x ** b) + c\n    @param a maxInterestRate [using mocPrecision]\n    @param b factor [using NoPrecision]\n    @param c minInterestRate C0 doc amount [using mocPrecision]\n    @param value global doc amount [using mocPrecision]\n  */\n  function potential(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value)\n  public view returns(uint256) {\n    // value ** b\n    // [MOC] ** [] = [MOC]\n    uint256 aux1 = pow(value, b, config.mocPrecision);\n    // (a * aux1) + c\n    // [MOC] [MOC] / [MOC] + [MOC] = [MOC]\n    return a.mul(aux1).div(config.mocPrecision).add(c);\n  }\n\n  /**\n    @dev Calculates average of the integral function:\n     T = (\n              (c * xf + ((a * (xf ** (b + 1))) / (b + 1))) -\n              (c * xi + ((a * (xi ** (b + 1))) / (b + 1)))\n             ) / (xf - xi)\n    @param a maxInterestRate [using mocPrecision]\n    @param b factor [using NoPrecision]\n    @param c minInterestRate C0 doc amount [using mocPrecision]\n    @param value1 value to put in the function [using mocPrecision]\n    @param value2 value to put in the function [using mocPrecision]\n    @return average interest rate [using mocPrecision]\n  */\n  function avgInt(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value1, uint256 value2)\n  public view returns(uint256) {\n    // value2 - value1\n    // [MOC]\n    uint256 diff = value2.sub(value1);\n    // ((c * (1 - value1) + ((a * ((1 - value1) ** (b + 1))) / (b + 1)))\n    uint256 intV1 = integral(config, a, b, c, value1);\n    // ((c * (1 - value2) + ((a * ((1 - value2) ** (b + 1))) / (b + 1)))\n    uint256 intV2 = integral(config,  a, b, c, value2);\n    // (secOp - first) / diff\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\n    return intV2.sub(intV1).div(diff);\n  }\n\n  /**\n    @dev Calculates integral of the exponential function: T = c * (value) + (a * value ** (b + 1)) / (b + 1))\n    @param a maxInterestRate [using mocPrecision]\n    @param b factor [using NoPrecision]\n    @param c minInterestRate C0 doc amount [using mocPrecision]\n    @param value value to put in the function [using mocPrecision]\n    @return integration result [using mocPrecision]\n  */\n  function integral(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value)\n  public view returns(uint256) {\n    // b + 1\n    // [NONE]\n    uint256 b2 = b.add(1);\n    // c * value\n    // [MOC][MOC]\n    uint256 firstOp = c.mul(value);\n    // [MOC]\n    uint256 pow = pow(value, b2, config.mocPrecision);\n    // (a * value ** b2) / b2)\n    // [MOC][MOC]\n    uint256 secOp = a.mul(pow).div(b2);\n    // (firstOp + secOp)\n    // [MOC][MOC] + [MOC][MOC] = [MOC][MOC]\n    return firstOp.add(secOp);\n  }\n\n  /**\n  * @dev Relation between docs in bucket 0 and Doc total supply\n  * @param doc0 doc count in bucket 0 [using mocPrecision]\n  * @param doct total doc supply [using mocPrecision]\n  * @return abundance ratio [using mocPrecision]\n  */\n  function abundanceRatio(MocLibConfig storage config, uint256 doc0, uint256 doct)\n  public view returns(uint256) {\n    if (doct == 0) {\n      return config.mocPrecision;\n    }\n    // [DOC] [MOC] / [DOC] = [MOC]\n    return doc0.mul(config.mocPrecision).div(doct);\n  }\n\n  /**\n    @dev Returns the Ratio to apply to BPro Price in discount situations: SpotDiscountRate = TPD * (utpdu - cob) / (uptdu -liq)\n    @param bproLiqDiscountRate Discount rate applied at Liquidation level coverage [using mocPrecision]\n    @param liq Liquidation coverage threshold [using mocPrecision]\n    @param utpdu Discount coverage threshold [using mocPrecision]\n    @param cov Actual global Coverage threshold [using mocPrecision]\n    @return Spot discount rate [using mocPrecision]\n  */\n  function bproSpotDiscountRate(\n    MocLibConfig storage libConfig, uint256 bproLiqDiscountRate,\n    uint256 liq, uint256 utpdu, uint256 cov\n  ) public view returns(uint256) {\n    require(bproLiqDiscountRate < libConfig.mocPrecision, \"Discount rate should be lower than 1\");\n\n    if (cov >= utpdu) {\n      return 0;\n    }\n\n    // utpdu - liq\n    // [MOC] - [MOC] = [MOC]\n    uint256 utpduLiqDiff = utpdu.sub(liq);\n\n    // utpdu - cov\n    // [MOC] - [MOC] = [MOC]\n    uint256 utpduCovDiff = utpdu.sub(cov);\n\n    // TPD * utpduCovDiff / utpduLiqDiff\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    return bproLiqDiscountRate.mul(utpduCovDiff).div(utpduLiqDiff);\n  }\n\n  /**\n    @dev Max amount of BPro to available with discount: MaxBProWithDiscount = (uTPDU * nDOC * PEG - (nBTC * B)) / (TPusd * TPD)\n    @param nB Total BTC amount [using reservePrecision]\n    @param nDoc DOC amount [using mocPrecision]\n    @param utpdu Discount coverage threshold [using mocPrecision]\n    @param peg peg value\n    @param btcPrice BTC price [using mocPrecision]\n    @param bproUsdPrice bproUsdPrice [using mocPrecision]\n    @param spotDiscount spot discount [using mocPrecision]\n    @return Total BPro amount [using mocPrecision]\n  */\n  function maxBProWithDiscount(\n    MocLibConfig storage libConfig, uint256 nB, uint256 nDoc, uint256 utpdu,\n    uint256 peg, uint256 btcPrice, uint256 bproUsdPrice, uint256 spotDiscount\n  ) public view returns(uint256)  {\n    require(spotDiscount < libConfig.mocPrecision, \"Discount Rate should be lower than 1\");\n\n    if (spotDiscount == 0) {\n      return 0;\n    }\n\n    // nBTC * B\n    // [RES] * [MOC] / [RES] = [MOC]\n    uint256 nbUsdValue = nB.mul(btcPrice).div(libConfig.reservePrecision);\n\n    // (TPusd * (1 - TPD))\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 bproDiscountPrice = bproUsdPrice.mul(libConfig.mocPrecision.sub(spotDiscount))\n      .div(libConfig.mocPrecision);\n\n    return maxBProWithDiscountAux(libConfig, nbUsdValue, nDoc, utpdu, peg, bproDiscountPrice);\n  }\n\n  /**\n    @dev Max amount of BPro to available with discount: MaxBProWithDiscount = (uTPDU * nDOC * PEG - (nBTC * B)) / (TPusd * TPD)\n    @param nbUsdValue Total amount of BTC in USD [using mocPrecision]\n    @param nDoc DOC amount [using mocPrecision]\n    @param utpdu Discount coverage threshold [using mocPrecision]\n    @param bproDiscountPrice bproUsdPrice with discount applied [using mocPrecision]\n    @param peg peg value\n    @return Total BPro amount [using mocPrecision]\n  */\n  function maxBProWithDiscountAux(\n    MocLibConfig storage libConfig, uint256 nbUsdValue, uint256 nDoc,\n    uint256 utpdu, uint256 peg, uint256 bproDiscountPrice\n  ) internal view returns(uint256) {\n\n    // uTPDU * nDOC * PEG\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 coverageUSDAmount = utpdu.mul(nDoc).mul(peg).div(libConfig.mocPrecision);\n\n    // This case only occurs with Coverage below 1\n    if (coverageUSDAmount <= nbUsdValue) {\n      return 0;\n    }\n\n    // ([MOC] - [MOC]) * [RES] / [MOC] = [RES]\n    return coverageUSDAmount.sub(nbUsdValue).mul(libConfig.reservePrecision).div(bproDiscountPrice);\n  }\n\n  /**\n    @dev Calculates Locked bitcoin\n    @param btcPrice BTC price [using mocPrecision]\n    @param nDoc Docs amount [using mocPrecision]\n    @param peg peg value\n    @return Locked bitcoin [using reservePrecision]\n  */\n  function lockedBitcoin(\n    MocLibConfig storage libConfig, uint256 btcPrice, uint256 nDoc, uint256 peg\n  ) public view returns(uint256) {\n    return nDoc.mul(peg).mul(libConfig.reservePrecision).div(btcPrice);\n  }\n\n  /**\n    @dev Calculates price at liquidation event as a relation between the doc total supply\n    and the amount of RBTC available to distribute\n    @param rbtcAmount RBTC to distribute [using reservePrecision]\n    @param nDoc Docs amount [using mocPrecision]\n    @return Price at liquidation event [using mocPrecision]\n  */\n  function liquidationPrice(MocLibConfig storage libConfig, uint256 rbtcAmount, uint256 nDoc)\n  public view returns(uint256) {\n    // [MOC] * [RES] / [RES]\n    return nDoc.mul(libConfig.reservePrecision).div(rbtcAmount);\n  }\n\n  /**\n    @dev Calculates BPro BTC price: TPbtc = (nB-LB) / nTP\n    @param nB Total BTC amount [using reservePrecision]\n    @param lb Locked bitcoins amount [using reservePrecision]\n    @param nTP BPro amount [using mocPrecision]\n    @return BPro BTC price [using reservePrecision]\n  */\n  function bproTecPrice(MocLibConfig storage libConfig, uint256 nB, uint256 lb, uint256 nTP)\n    public view returns(uint256) {\n    // Liquidation happens before this condition turns true\n    if (nB < lb) {\n      return 0;\n    }\n\n    if (nTP == 0) {\n      return libConfig.mocPrecision;\n    }\n    // ([RES] - [RES]) * [MOC] / [MOC]\n    return nB.sub(lb).mul(libConfig.mocPrecision).div(nTP);\n  }\n\n  /**\n    @dev Calculates BPro BTC price: BProxInBPro = bproxTecPrice / bproPrice\n    @param bproxTecPrice BProx BTC price [using reservePrecision]\n    @param bproPrice Trog BTC price [using reservePrecision]\n    @return BProx price in BPro [using mocPrecision]\n  */\n  function bproxBProPrice(\n    MocLibConfig storage libConfig, uint256 bproxTecPrice, uint256 bproPrice\n  ) public view returns(uint256) {\n    // [RES] * [MOC] / [RES] = [MOC]\n    return bproxTecPrice.mul(libConfig.mocPrecision).div(bproPrice);\n  }\n\n  /**\n    @dev Returns a new value with the discountRate applied: TPbtc = (price)* (1 - discountRate)\n    @param price Price [using SomePrecision]\n    @param discountRate Discount rate to apply [using mocPrecision]\n    @return Price with discount applied [using SomePrecision]\n  */\n  function applyDiscountRate(MocLibConfig storage libConfig, uint256 price, uint256 discountRate)\n    public view returns(uint256) {\n\n    uint256 discountCoeff = libConfig.mocPrecision.sub(discountRate);\n\n    return price.mul(discountCoeff).div(libConfig.mocPrecision);\n  }\n\n  /**\n    @dev Returns the amount of interest to pay: TPbtc = price * interestRate\n    @param value Cost to apply interest [using SomePrecision]\n    @param interestRate Interest rate to apply [using mocPrecision]\n    @return Interest cost based on the value and interestRate [using SomePrecision]\n  */\n  function getInterestCost(MocLibConfig storage libConfig, uint256 value, uint256 interestRate)\n    public view returns(uint256) {\n    // [ORIGIN] * [MOC] / [MOC] = [ORIGIN]\n    return value.mul(interestRate).div(libConfig.mocPrecision);\n  }\n\n  /**\n    @dev Calculates Coverage: Coverage = nB / LB\n    @param nB Total BTC amount [using reservePrecision]\n    @param lB Locked bitcoins amount [using reservePrecision]\n    @return Coverage [using mocPrecision]\n  */\n  function coverage(MocLibConfig storage libConfig, uint256 nB, uint256 lB) public view\n    returns(uint256) {\n    if (lB == 0) {\n      return UINT256_MAX;\n    }\n\n    return nB.mul(libConfig.mocPrecision).div(lB);\n  }\n\n /**\n    @dev Calculates Leverage from Coverage: Leverage = C / (C - 1)\n    @param cov Coverage [using mocPrecision]\n    @return Leverage [using mocPrecision]\n  */\n  function leverageFromCoverage(MocLibConfig storage libConfig, uint256 cov)\n  public view returns(uint256) {\n    if (cov == UINT256_MAX) {\n      return libConfig.mocPrecision;\n    }\n\n    if (cov <= libConfig.mocPrecision) {\n      return UINT256_MAX;\n    }\n\n    return cov.mul(libConfig.mocPrecision).div(cov.sub(libConfig.mocPrecision));\n  }\n\n /**\n    @dev Calculates Leverage: Leverage = nB / (nB - lB)\n    @param nB Total BTC amount [using reservePrecision]\n    @param lB Locked bitcoins amount [using reservePrecision]\n    @return Leverage [using mocPrecision]\n  */\n  function leverage(MocLibConfig storage libConfig, uint256 nB,uint256 lB)\n  public view returns(uint256) {\n    if (lB == 0) {\n      return libConfig.mocPrecision;\n    }\n\n    if (nB <= lB) {\n      return UINT256_MAX;\n    }\n\n    return nB.mul(libConfig.mocPrecision).div(nB.sub(lB));\n  }\n\n  /**\n    @dev Price in BTC of the amount of Docs\n    @param amount Total BTC amount [using reservePrecision]\n    @param btcPrice BTC price [using mocPrecision]\n    @return Total value [using reservePrecision]\n  */\n  function docsBtcValue(\n    MocLibConfig storage libConfig, uint256 amount,uint256 peg, uint256 btcPrice\n  ) public view returns(uint256) {\n    require(btcPrice > 0,\"Bitcoin price should be more than zero\");\n    require(libConfig.reservePrecision > 0, \"Precision should be more than zero\");\n    //Total = amount / satoshi price\n    //Total = amount / (btcPrice / precision)\n    // [RES] * [MOC] / [MOC]\n    uint256 docBtcTotal = amount.mul(libConfig.mocPrecision).mul(peg).div(btcPrice);\n\n    return docBtcTotal;\n  }\n\n /**\n    @dev Price in RBTC of the amount of BPros\n    @param bproAmount amount of BPro [using mocPrecision]\n    @param bproBtcPrice BPro price in RBTC [using reservePrecision]\n    @return Total value [using reservePrecision]\n  */\n  function bproBtcValue(MocLibConfig storage libConfig, uint256 bproAmount, uint256 bproBtcPrice)\n    public view returns(uint256) {\n    require(libConfig.reservePrecision > 0, \"Precision should be more than zero\");\n\n    // [MOC] * [RES] / [MOC] =  [RES]\n    uint256 bproBtcTotal = bproAmount.mul(bproBtcPrice).div(libConfig.mocPrecision);\n\n    return bproBtcTotal;\n  }\n\n  /**\n    @dev Max amount of Docs to issue: MaxDoc = ((nB*B)-(Cobj*B/Bcons*nDoc*PEG))/(PEG*(Cobj*B/BCons-1))\n    @param nB Total BTC amount [using reservePrecision]\n    @param cobj Target Coverage [using mocPrecision]\n    @param nDoc DOC amount [using mocPrecision]\n    @param peg peg value\n    @param btcPrice BTC price [using mocPrecision]\n    @param bCons BTC conservative price [using mocPrecision]\n    @return Total Docs amount [using mocPrecision]\n  */\n  function maxDoc(\n    MocLibConfig storage libConfig, uint256 nB,\n    uint256 cobj, uint256 nDoc, uint256 peg, uint256 btcPrice, uint256 bCons\n  ) public view returns(uint256) {\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\n\n    // If cobj is less than 1, just return zero\n    if (cobj < libConfig.mocPrecision)\n      return 0;\n\n    // Cobj * B / BCons\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 adjCobj = cobj.mul(btcPrice).div(bCons);\n\n    return maxDocAux(libConfig, nB, adjCobj, nDoc, peg, btcPrice);\n  }\n\n  function maxDocAux(MocLibConfig storage libConfig, uint256 nB, uint256 adjCobj, uint256 nDoc, uint256 peg, uint256 btcPrice)\n  internal view returns(uint256) {\n    // (nB*B)\n    // [RES] [MOC] [MOC] / [RES] = [MOC] [MOC]\n    uint256 firstOperand = nB.mul(btcPrice).mul(libConfig.mocPrecision).div(libConfig.reservePrecision);\n    // (adjCobj*nDoc*PEG)\n    // [MOC] [MOC]\n    uint256 secOperand = adjCobj.mul(nDoc).mul(peg);\n    // (PEG*(adjCobj-1)\n    // [MOC]\n    uint256 denom = adjCobj.sub(libConfig.mocPrecision).mul(peg);\n\n    if (firstOperand <= secOperand)\n      return 0;\n\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\n    return (firstOperand.sub(secOperand)).div(denom);\n  }\n\n  /**\n    @dev Max amount of BPro to redeem: MaxBPro = ((nB*B)-(Cobj*nDoc*PEG))/TPusd\n    @param nB Total BTC amount [using reservePrecision]\n    @param cobj Target Coverage [using mocPrecision]\n    @param nDoc Target Coverage [using mocPrecision]\n    @param peg peg value\n    @param btcPrice BTC price [using mocPrecision]\n    @param bCons BTC conservative price [using mocPrecision]\n    @param bproUsdPrice bproUsdPrice [using mocPrecision]\n    @return Total BPro amount [using mocPrecision]\n  */\n  function maxBPro(\n    MocLibConfig storage libConfig, uint256 nB, uint256 cobj,\n    uint256 nDoc, uint256 peg, uint256 btcPrice, uint256 bCons, uint256 bproUsdPrice\n  ) public view returns(uint256) {\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\n\n    // Cobj * btcPrice / BCons\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 adjCobj = cobj.mul(btcPrice).div(bCons);\n    // (nB * btcPrice)\n    // [RES] * [MOC] * [MOC] / [RES] = [MOC] [MOC]\n    uint256 firstOperand = nB.mul(btcPrice)\n      .mul(libConfig.mocPrecision)\n      .div(libConfig.reservePrecision);\n    // (adjCobj * nDoc * PEG)\n    // [MOC] * [MOC]\n    uint256 secOperand = adjCobj.mul(nDoc).mul(peg);\n\n    if (firstOperand <= secOperand)\n      return 0;\n\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\n    return (firstOperand.sub(secOperand)).div(bproUsdPrice);\n  }\n\n  /**\n    @dev Calculates the total BTC price of the amount of BPros\n    @param amount Amount of BPro [using mocPrecision]\n    @param bproPrice BPro BTC Price [using reservePrecision]\n    @return BPro total value in BTC [using reservePrecision]\n  */\n  function totalBProInBtc(\n    MocLibConfig storage libConfig, uint256 amount, uint256 bproPrice\n  ) public view returns(uint256) {\n    // [RES] * [MOC] / [MOC] = [RES]\n    return bproPrice.mul(amount).div(libConfig.mocPrecision);\n  }\n\n  /**\n    @dev Calculates the equivalent in Docs of the btcAmount\n    @param btcAmount BTC  amount [using reservePrecision]\n    @param btcPrice BTC price [using mocPrecision]\n    @return Equivalent Doc amount [using mocPrecision]\n  */\n  function maxDocsWithBtc(\n    MocLibConfig storage libConfig, uint256 btcAmount, uint256 btcPrice\n  ) public view returns(uint256) {\n    // [RES] * [MOC] / [RES] = [MOC]\n    return btcAmount.mul(btcPrice).div(libConfig.reservePrecision);\n  }\n\n  /**\n    @dev Calculates the equivalent in BPro of the btcAmount\n    @param btcAmount BTC amount [using reservePrecision]\n    @param bproPrice BPro BTC price [using reservePrecision]\n    @return Equivalent Bpro amount [using mocPrecision]\n  */\n  function maxBProWithBtc(\n    MocLibConfig storage libConfig, uint256 btcAmount, uint256 bproPrice\n  ) public view returns(uint256) {\n    if (bproPrice == 0) {\n      return 0;\n    }\n\n    // [RES] * [MOC] / [RES]\n    return btcAmount.mul(libConfig.mocPrecision).div(bproPrice);\n  }\n\n  /**\n    @dev Calculates the Btc amount to move from C0 bucket to: toMove = btcAmount * (lev - 1)\n    an L bucket when a BProx minting occurs\n    @param btcAmount Total BTC amount [using reservePrecision]\n    @param lev L bucket leverage [using mocPrecision]\n    @return btc to move [using reservePrecision]\n  */\n  function bucketTransferAmount(\n    MocLibConfig storage libConfig, uint256 btcAmount, uint256 lev\n  ) public view returns(uint256) {\n    require(lev > libConfig.mocPrecision, \"Leverage should be more than 1\");\n\n    if (lev == UINT256_MAX || btcAmount == 0) {\n      return 0;\n    }\n\n    // (lev-1)\n    uint256 levSubOne = lev.sub(libConfig.mocPrecision);\n\n    // Intentionally avaoid SafeMath\n    // [RES] * [MOC]\n    uint256 transferAmount = btcAmount * levSubOne;\n    if (transferAmount / btcAmount != levSubOne)\n      return 0;\n\n    // [RES] * [MOC] / [MOC] = [RES]\n    return transferAmount.div(libConfig.mocPrecision);\n  }\n\n  /**\n    @dev Max amount of BTC allowed to be used to mint bprox: Maxbprox = nDOC/ (PEG*B*(lev-1))\n    @param nDoc number of DOC [using mocPrecision]\n    @param peg peg value\n    @param btcPrice BTC price [using mocPrecision]\n    @param lev leverage [using mocPrecision]\n    @return Max bprox BTC value [using reservePrecision]\n  */\n  function maxBProxBtcValue(\n    MocLibConfig storage libConfig, uint256 nDoc, uint256 peg, uint256 btcPrice, uint256 lev\n  ) public view returns(uint256)  {\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\n\n    if (lev <= libConfig.mocPrecision) {\n      return 0;\n    }\n    // (lev-1)\n    // [MOC]\n    uint256 levSubOne = lev.sub(libConfig.mocPrecision);\n\n    // PEG * BtcPrice\n    // [MOC]\n    uint256 pegTimesPrice = peg.mul(btcPrice);\n\n    // This intentionally avoid using safeMath to handle overflow case\n    // PEG * BtcPrice * (lev - 1)\n    // [MOC] * [MOC]\n    uint256 dividend = pegTimesPrice * levSubOne;\n\n    if (dividend / pegTimesPrice != levSubOne)\n      return 0; // INFINIT dividend means 0\n\n    // nDoc adjusted with precisions\n    // [MOC] [RES]\n    uint256 divider = nDoc.mul(libConfig.reservePrecision);\n\n    // [MOC] [RES] [MOC] / [MOC] [MOC]\n    return divider.mul(libConfig.mocPrecision).div(dividend);\n  }\n\n  /**\n    @dev Calculates the equivalent in MoC of the btcAmount\n    @param btcAmount BTC  amount\n    @param btcPrice BTC price\n    @param mocPrice MoC price\n    @return Equivalent MoC amount\n  */\n  function maxMoCWithBtc(\n    MocLibConfig storage /*libConfig*/, uint256 btcAmount, uint256 btcPrice, uint256 mocPrice\n  ) public pure returns(uint256) {\n    return btcPrice.mul(btcAmount).div(mocPrice);\n  }\n\n  /**\n    @dev Calculates the equivalent in BTC of the MoC amount\n    @param amount BTC  amount\n    @param btcPrice BTC price\n    @param mocPrice MoC price\n    @return Equivalent MoC amount\n  */\n  function mocBtcValue(\n    MocLibConfig storage /*libConfig*/, uint256 amount, uint256 btcPrice, uint256 mocPrice\n  ) public pure returns(uint256) {\n    require(btcPrice > 0,\"Bitcoin price should be more than zero\");\n    require(mocPrice > 0,\"MoC price should be more than zero\");\n\n    uint256 mocBtcTotal = amount.mul(mocPrice).div(btcPrice);\n\n    return mocBtcTotal;\n  }\n\n  /**\n    @dev Transform an address to payable address\n    @param account Address to transform to payable\n    @return Payable address for account\n  */\n  function getPayableAddress(\n    MocLibConfig storage /*libConfig*/, address account\n  ) public pure\n  returns (address payable) {\n    return address(uint160(account));\n  }\n\n  /**\n    @dev Rounding product adapted from DSMath but with custom precision\n    @param x Multiplicand\n    @param y Multiplier\n    @return Product\n  */\n  function mulr(uint x, uint y, uint256 precision) internal pure returns (uint z) {\n    return x.mul(y).add(precision.div(2)).div(precision);\n  }\n\n  /**\n    @dev Potentiation by squaring adapted from DSMath but with custom precision\n    @param x Base\n    @param n Exponent\n    @return power\n  */\n  function pow(uint256 x, uint256 n, uint256 precision) internal pure returns (uint z) {\n    uint256 x2 = x;\n    z = n % 2 != 0 ? x : precision;\n\n    for (n /= 2; n != 0; n /= 2) {\n      x2 = mulr(x2, x2, precision);\n\n      if (n % 2 != 0) {\n        z = mulr(z, x2, precision);\n      }\n    }\n  }\n}\n\n// File: contracts/MoCLibConnection.sol\n\npragma solidity 0.5.8;\n\n\n/**\n  @dev Interface with MocHelperLib\n */\ncontract MoCLibConnection {\n  using MoCHelperLib for MoCHelperLib.MocLibConfig;\n  MoCHelperLib.MocLibConfig internal mocLibConfig;\n\n  /*\n  * Precision getters\n  */\n  function getMocPrecision() public view returns(uint256) {\n    return mocLibConfig.mocPrecision;\n  }\n\n  function getReservePrecision() public view returns(uint256) {\n    return mocLibConfig.reservePrecision;\n  }\n\n  function getDayPrecision() public view returns(uint256) {\n    return mocLibConfig.dayPrecision;\n  }\n\n  function initializePrecisions() internal {\n    mocLibConfig = MoCHelperLib.MocLibConfig({\n      reservePrecision: 10 ** 18,\n      mocPrecision: 10 ** 18,\n      dayPrecision: 1\n    });\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * > Note that this information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * `IERC20.balanceOf` and `IERC20.transfer`.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See `IERC20.approve`.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destoys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See `_burn` and `_approve`.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\n\n// File: openzeppelin-solidity/contracts/access/Roles.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\n// File: openzeppelin-solidity/contracts/access/roles/PauserRole.sol\n\npragma solidity ^0.5.0;\n\n\ncontract PauserRole {\n    using Roles for Roles.Role;\n\n    event PauserAdded(address indexed account);\n    event PauserRemoved(address indexed account);\n\n    Roles.Role private _pausers;\n\n    constructor () internal {\n        _addPauser(msg.sender);\n    }\n\n    modifier onlyPauser() {\n        require(isPauser(msg.sender), \"PauserRole: caller does not have the Pauser role\");\n        _;\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return _pausers.has(account);\n    }\n\n    function addPauser(address account) public onlyPauser {\n        _addPauser(account);\n    }\n\n    function renouncePauser() public {\n        _removePauser(msg.sender);\n    }\n\n    function _addPauser(address account) internal {\n        _pausers.add(account);\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) internal {\n        _pausers.remove(account);\n        emit PauserRemoved(account);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract Pausable is PauserRole {\n    /**\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\n     * to the deployer.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Called by a pauser to pause, triggers stopped state.\n     */\n    function pause() public onlyPauser whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @dev Called by a pauser to unpause, returns to normal state.\n     */\n    function unpause() public onlyPauser whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Pausable.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @title Pausable token\n * @dev ERC20 modified with pausable transfers.\n */\ncontract ERC20Pausable is ERC20, Pausable {\n    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {\n        return super.transfer(to, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {\n        return super.transferFrom(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {\n        return super.approve(spender, value);\n    }\n\n    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool) {\n        return super.increaseAllowance(spender, addedValue);\n    }\n\n    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool) {\n        return super.decreaseAllowance(spender, subtractedValue);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/access/roles/MinterRole.sol\n\npragma solidity ^0.5.0;\n\n\ncontract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(msg.sender), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Mintable.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @dev Extension of `ERC20` that adds a set of accounts with the `MinterRole`,\n * which have permission to mint (create) new tokens as they see fit.\n *\n * At construction, the deployer of the contract is the only minter.\n */\ncontract ERC20Mintable is ERC20, MinterRole {\n    /**\n     * @dev See `ERC20._mint`.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MinterRole`.\n     */\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: contracts/token/OwnerBurnableToken.sol\n\npragma solidity 0.5.8;\n\n\n\n/**\n * @title Owner Burnable Token\n * @dev Token that allows the owner to irreversibly burned (destroyed) any token.\n */\ncontract OwnerBurnableToken is Ownable, ERC20Mintable {\n  /**\n   * @dev Burns a specific amount of tokens for the address.\n   * @param who who's tokens are gona be burned\n   * @param value The amount of token to be burned.\n   */\n  function burn(address who, uint256 value) public onlyOwner {\n    _burn(who, value);\n  }\n}\n\n// File: contracts/token/BProToken.sol\n\npragma solidity 0.5.8;\n\n\n\n\ncontract BProToken is ERC20Detailed, ERC20Pausable, OwnerBurnableToken {\n\n  string private _name = \"BitPRO\";\n  string private _symbol = \"BITP\";\n  uint8 private _decimals = 18;\n\n  /**\n    @dev Constructor\n  */\n  constructor() Ownable() ERC20Detailed(_name, _symbol, _decimals) public {\n  }\n\n  /**\n    @dev Fallback function\n  */\n  function() external {\n  }\n}\n\n// File: contracts/token/DocToken.sol\n\npragma solidity 0.5.8;\n\n\n\ncontract DocToken is ERC20Detailed, OwnerBurnableToken {\n\n  string private _name = \"Dollar on Chain\";\n  string private _symbol = \"DOC\";\n  uint8 private _decimals = 18;\n\n  /**\n    @dev Constructor\n  */\n  constructor() Ownable() ERC20Detailed(_name, _symbol, _decimals) public {\n\n  }\n\n  /**\n    @dev Fallback function\n  */\n  function() external {\n  }\n}\n\n// File: contracts/interface/IMoCInrate.sol\n\npragma solidity 0.5.8;\n\ninterface IMoCInrate {\n    // Transaction types\n    function MINT_BPRO_FEES_RBTC() external view returns(uint8);\n    function REDEEM_BPRO_FEES_RBTC() external view returns(uint8);\n    function MINT_DOC_FEES_RBTC() external view returns(uint8);\n    function REDEEM_DOC_FEES_RBTC() external view returns(uint8);\n    function MINT_BTCX_FEES_RBTC() external view returns(uint8);\n    function REDEEM_BTCX_FEES_RBTC() external view returns(uint8);\n    function MINT_BPRO_FEES_MOC() external view returns(uint8);\n    function REDEEM_BPRO_FEES_MOC() external view returns(uint8);\n    function MINT_DOC_FEES_MOC() external view returns(uint8);\n    function REDEEM_DOC_FEES_MOC() external view returns(uint8);\n    function MINT_BTCX_FEES_MOC() external view returns(uint8);\n    function REDEEM_BTCX_FEES_MOC() external view returns(uint8);\n\n    function dailyInratePayment() external returns(uint256);\n\n    function payBitProHoldersInterestPayment() external returns(uint256);\n\n    function calculateBitProHoldersInterest() external view returns(uint256, uint256);\n\n    function getBitProInterestAddress() external view returns(address payable);\n\n    function getBitProRate() external view returns(uint256);\n\n    function getBitProInterestBlockSpan() external view returns(uint256);\n\n    function isDailyEnabled() external view returns(bool);\n\n    function isBitProInterestEnabled() external view returns(bool);\n\n    function commissionsAddress() external view returns(address payable);\n\n    function calcCommissionValue(uint256 rbtcAmount, uint8 txType) external view returns(uint256);\n\n    function calculateVendorMarkup(address vendorAccount, uint256 amount) external view returns (uint256 markup);\n\n    function calcDocRedInterestValues(uint256 docAmount, uint256 rbtcAmount) external view returns(uint256);\n\n    function calcMintInterestValues(bytes32 bucket, uint256 rbtcAmount) external view returns(uint256);\n\n    function calcFinalRedeemInterestValue(bytes32 bucket, uint256 rbtcToRedeem) external view returns(uint256);\n\n    function setBitProInterestBlockSpan(uint256 newBitProBlockSpan) external;\n}\n\n// File: zos-lib/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.6.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: contracts/base/MoCWhitelist.sol\n\npragma solidity 0.5.8;\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCWhitelist {\n  mapping(address => bool) whitelist;\n\n  /**\n   * @dev Check if an account is whitelisted\n   * @return Bool\n   */\n  function isWhitelisted(address account)\n    public\n    view\n    returns (bool)\n  {\n    require(account != address(0), \"Account must not be 0x0\");\n    return whitelist[account];\n  }\n\n  /**\n   * @dev Add account to whitelist\n   */\n  function add(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(!isWhitelisted(account), \"Account not allowed to add accounts into white list\");\n    whitelist[account] = true;\n  }\n\n  /**\n   * @dev Remove account from whitelist\n   */\n  function remove(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(isWhitelisted(account), \"Account is not allowed to remove address from the white list\");\n\n    whitelist[account] = false;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/base/MoCConnector.sol\n\npragma solidity 0.5.8;\n\n\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCConnector is MoCWhitelist, Initializable {\n  // References\n  address payable public moc;\n  address public docToken;\n  address public bproToken;\n  address public bproxManager;\n  address public mocState;\n  address public mocConverter;\n  address public mocSettlement;\n  address public mocExchange;\n  address public mocInrate;\n  /** DEPRECATED mocBurnout **/\n  address public mocBurnout;\n\n  bool internal initialized;\n\n  /**\n    @dev Initializes the contract\n    @param mocAddress MoC contract address\n    @param docAddress DoCToken contract address\n    @param bproAddress BProToken contract address\n    @param bproxAddress BProxManager contract address\n    @param stateAddress MoCState contract address\n    @param settlementAddress MoCSettlement contract address\n    @param converterAddress MoCConverter contract address\n    @param exchangeAddress MoCExchange contract address\n    @param inrateAddress MoCInrate contract address\n    @param burnoutBookAddress (DEPRECATED) MoCBurnout contract address. DO NOT USE.\n  */\n  function initialize(\n    address payable mocAddress,\n    address docAddress,\n    address bproAddress,\n    address bproxAddress,\n    address stateAddress,\n    address settlementAddress,\n    address converterAddress,\n    address exchangeAddress,\n    address inrateAddress,\n    address burnoutBookAddress\n  ) public initializer {\n    moc = mocAddress;\n    docToken = docAddress;\n    bproToken = bproAddress;\n    bproxManager = bproxAddress;\n    mocState = stateAddress;\n    mocSettlement = settlementAddress;\n    mocConverter = converterAddress;\n    mocExchange = exchangeAddress;\n    mocInrate = inrateAddress;\n    mocBurnout = burnoutBookAddress;\n\n    // Add to Whitelist\n    add(mocAddress);\n    add(docAddress);\n    add(bproAddress);\n    add(bproxAddress);\n    add(stateAddress);\n    add(settlementAddress);\n    add(converterAddress);\n    add(exchangeAddress);\n    add(inrateAddress);\n    add(burnoutBookAddress);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/base/MoCConstants.sol\n\npragma solidity 0.5.8;\n\n/**\n * @dev Defines special constants to use along all the MoC System\n */\ncontract MoCConstants {\n  bytes32 constant public BUCKET_X2 = \"X2\";\n  bytes32 constant public BUCKET_C0 = \"C0\";\n}\n\n// File: contracts/base/MoCBase.sol\n\npragma solidity 0.5.8;\n\n\n\n\n/**\n  @dev General usefull modifiers and functions\n */\ncontract MoCBase is MoCConstants, Initializable {\n  // Contracts\n  MoCConnector public connector;\n\n  bool internal initialized;\n\n  function initializeBase(address connectorAddress) internal initializer {\n    connector = MoCConnector(connectorAddress);\n  }\n\n  modifier onlyWhitelisted(address account) {\n    require(connector.isWhitelisted(account), \"Address is not whitelisted\");\n    _;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/token/MoCToken.sol\n\npragma solidity 0.5.8;\n\n\n\ncontract MoCToken is ERC20Detailed, OwnerBurnableToken {\n\n  string private _name = \"MoC\";\n  string private _symbol = \"MOC\";\n  uint8 private _decimals = 18;\n\n  /**\n    @dev Constructor\n  */\n  constructor() Ownable() ERC20Detailed(_name, _symbol, _decimals) public {\n\n  }\n\n  /**\n    @dev Fallback function\n  */\n  function() external {\n  }\n}\n\n// File: contracts/interface/IMoCState.sol\n\npragma solidity 0.5.8;\n\ninterface IMoCState {\n\n     /******STATE MACHINE*********/\n    enum States {\n        // State 0\n        Liquidated,\n        // State 1\n        BProDiscount,\n        // State 2\n        BelowCobj,\n        // State 3\n        AboveCobj\n    }\n\n\n    function addToRbtcInSystem(uint256 btcAmount) external;\n\n    function subtractRbtcFromSystem(uint256 btcAmount) external;\n\n    function coverage(bytes32 bucket) external view returns(uint256);\n\n    function getRbtcRemainder() external view returns(uint256);\n\n    function liq() external view returns(uint256);\n\n    function state() external view returns(States);\n\n    function peg() external view returns(uint256);\n\n    function dayBlockSpan() external view returns(uint256);\n\n    function getBitcoinPrice() external view returns(uint256);\n\n    function getMoCPrice() external view returns(uint256);\n\n    function getProtected() external view returns(uint256);\n\n    function globalCoverage() external view returns(uint256);\n\n    function getMoCVendors() external view returns(address);\n\n    function getMoCToken() external view returns(address);\n\n    function nextState() external;\n\n    function maxBProWithDiscount() external view returns(uint256);\n\n    function absoluteMaxBPro() external view returns(uint256);\n\n    function absoluteMaxDoc() external view returns(uint256);\n\n    function freeDoc() external view returns(uint256);\n\n    function bproTecPrice() external view returns(uint256);\n\n    function bproSpotDiscountRate() external view returns(uint256);\n\n    function bproDiscountPrice() external view returns(uint256);\n\n    function bucketBProTecPrice(bytes32 bucket) external view returns(uint256);\n\n    function currentAbundanceRatio() external view returns(uint256);\n\n    function abundanceRatio(uint256 doc0) external view returns(uint256);\n\n    function daysToSettlement() external view returns(uint256);\n\n    function leverage(bytes32 bucket) external view returns(uint256);\n\n    function getBucketNBTC(bytes32 bucket) external view returns(uint256);\n\n    function getLiquidationPrice() external view returns(uint256);\n\n    function maxBProxBtcValue(bytes32 bucket) external view returns(uint256);\n\n    function bucketBProTecPriceHelper(bytes32 bucket) external view returns(uint256);\n}\n\n// File: contracts/MoCConverter.sol\n\npragma solidity 0.5.8;\n\n\n\n\ncontract MoCConverter is MoCBase, MoCLibConnection {\n  IMoCState internal mocState;\n\n  function initialize(address connectorAddress) public initializer {\n    initializePrecisions();\n    initializeBase(connectorAddress);\n    mocState = IMoCState(connector.mocState());\n  }\n\n  /**\n  * @dev BTC equivalent for the amount of bpros given\n  * @param amount Amount of BPro to calculate the total price\n  * @return total BTC Price of the amount BPros [using reservePrecision]\n  */\n  function bproToBtc(uint256 amount) public view returns(uint256) {\n    uint256 tecPrice = mocState.bproTecPrice();\n\n    return mocLibConfig.totalBProInBtc(amount, tecPrice);\n  }\n\n  /**\n  * @dev Converts BTC to BPro\n  * @param btcAmount BTC amount\n  * @return BPro amount\n  */\n  function btcToBPro(uint256 btcAmount) public view returns(uint256) {\n    return mocLibConfig.maxBProWithBtc(btcAmount, mocState.bproTecPrice());\n  }\n\n  /**\n  * @dev BTC equivalent for the amount of bpro given applying the spotDiscountRate\n  * @param amount amount of BPro [using mocPrecision]\n  * @return BTC amount\n  */\n  function bproDiscToBtc(uint256 amount) public view returns(uint256) {\n    uint256 discountRate = mocState.bproSpotDiscountRate();\n    uint256 totalBtcValue = bproToBtc(amount);\n\n    return mocLibConfig.applyDiscountRate(totalBtcValue, discountRate);\n  }\n\n  function btcToBProDisc(uint256 btcAmount) public view returns(uint256) {\n    return mocLibConfig.maxBProWithBtc(btcAmount, mocState.bproDiscountPrice());\n  }\n\n  function docsToBtc(uint256 docAmount) public view returns(uint256) {\n    return mocLibConfig.docsBtcValue(docAmount, mocState.peg(), mocState.getBitcoinPrice());\n  }\n\n  function docsToBtcWithPrice(uint256 docAmount, uint256 btcPrice) public view returns(uint256) {\n    return mocLibConfig.docsBtcValue(docAmount, mocState.peg(), btcPrice);\n  }\n\n  function btcToDoc(uint256 btcAmount) public view returns(uint256) {\n    return mocLibConfig.maxDocsWithBtc(btcAmount, mocState.getBitcoinPrice());\n  }\n\n  function bproxToBtc(uint256 bproxAmount, bytes32 bucket) public view returns(uint256) {\n    return mocLibConfig.bproBtcValue(bproxAmount, mocState.bucketBProTecPrice(bucket));\n  }\n\n  function bproxToBtcHelper(uint256 bproxAmount, bytes32 bucket) public view returns(uint256) {\n    return mocLibConfig.bproBtcValue(bproxAmount, mocState.bucketBProTecPriceHelper(bucket));\n  }\n\n  function btcToBProx(uint256 btcAmount, bytes32 bucket) public view returns(uint256) {\n    return mocLibConfig.maxBProWithBtc(btcAmount, mocState.bucketBProTecPrice(bucket));\n  }\n\n  function btcToBProWithPrice(uint256 btcAmount, uint256 price) public view returns(uint256) {\n    return mocLibConfig.maxBProWithBtc(btcAmount, price);\n  }\n\n  function bproToBtcWithPrice(uint256 bproAmount, uint256 bproPrice) public view returns(uint256) {\n    return mocLibConfig.bproBtcValue(bproAmount, bproPrice);\n  }\n\n  function mocToBtc(uint256 mocAmount) public view returns(uint256) {\n    return mocLibConfig.mocBtcValue(mocAmount, mocState.getBitcoinPrice(), mocState.getMoCPrice());\n  }\n\n  function btcToMoC(uint256 btcAmount) public view returns(uint256) {\n    return mocLibConfig.maxMoCWithBtc(btcAmount, mocState.getBitcoinPrice(), mocState.getMoCPrice());\n  }\n\n  function mocToBtcWithPrice(uint256 mocAmount, uint256 btcPrice, uint256 mocPrice) public view returns(uint256) {\n    return mocLibConfig.mocBtcValue(mocAmount, btcPrice, mocPrice);\n  }\n\n  function btcToMoCWithPrice(uint256 btcAmount, uint256 btcPrice, uint256 mocPrice) public view returns(uint256) {\n    return mocLibConfig.maxMoCWithBtc(btcAmount, btcPrice, mocPrice);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: openzeppelin-solidity/contracts/math/Math.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n\n// File: moc-governance/contracts/Governance/ChangeContract.sol\n\npragma solidity ^0.5.8;\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n\n  /**\n    @notice Override this function with a recipe of the changes to be done when this ChangeContract\n    is executed\n   */\n  function execute() external;\n}\n\n// File: moc-governance/contracts/Governance/IGovernor.sol\n\npragma solidity ^0.5.8;\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor{\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @dev This function should be protected somehow to only execute changes that\n    benefit the system. This decision process is independent of this architechture\n    therefore is independent of this interface too\n    @param changeContract Address of the contract that will execute the changes\n   */\n  function executeChange(ChangeContract changeContract) external;\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @param _changer Address of the contract that will execute the changes\n   */\n  function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n// File: moc-governance/contracts/Governance/Governed.sol\n\npragma solidity ^0.5.8;\n\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed is Initializable {\n\n  /**\n    @notice The address of the contract which governs this one\n   */\n  IGovernor public governor;\n\n  string constant private NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n  /**\n    @notice Modifier that protects the function\n    @dev You should use this modifier in any function that should be called through\n    the governance system\n   */\n  modifier onlyAuthorizedChanger() {\n    require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n    _;\n  }\n\n  /**\n    @notice Initialize the contract with the basic settings\n    @dev This initialize replaces the constructor but it is not called automatically.\n    It is necessary because of the upgradeability of the contracts\n    @param _governor Governor address\n   */\n  function initialize(IGovernor _governor) public initializer {\n    governor = _governor;\n  }\n\n  /**\n    @notice Change the contract's governor. Should be called through the old governance system\n    @param newIGovernor New governor address\n   */\n  function changeIGovernor(IGovernor newIGovernor) public onlyAuthorizedChanger {\n    governor = newIGovernor;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/MoCBucketContainer.sol\n\npragma solidity 0.5.8;\n\n\n\n\n\ncontract MoCBucketContainer is MoCBase, Governed {\n  using SafeMath for uint256;\n  using Math for uint256;\n\n  struct BProxBalance {\n    uint256 value;\n    uint index; // Index start in 1, zero is reserved for NULL\n  }\n\n  struct MoCBucket {\n    bytes32 name;\n    bool isBase;\n    uint256 nDoc;\n    uint256 nBPro;\n    uint256 nBTC;\n    uint256 cobj;\n    // Should only be used in L buckets\n    mapping(address => BProxBalance) bproxBalances;\n    address payable[] activeBalances;\n    uint256 activeBalancesLength;\n    // Should only be used in Base buckets (C0)\n    uint256 inrateBag;\n    bool available;\n  }\n\n  event BucketMovement(\n    bytes32 from,\n    bytes32 to,\n    uint256 reserves,\n    uint256 stableTokens\n  );\n\n  event BucketCreation(\n    bytes32 name,\n    uint256 cobj\n  );\n\n  event BucketStateUpdate(\n    bytes32 name,\n    uint256 nReserve,\n    uint256 nStable,\n    uint256 nRiskProx,\n    uint256 inrateBag\n  );\n\n  mapping(bytes32 => MoCBucket) internal mocBuckets;\n\n   /**\n   GETTERS\n   */\n  function getBucketNBTC(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].nBTC;\n  }\n\n  function getBucketNBPro(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].nBPro;\n  }\n\n  function getBucketNDoc(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].nDoc;\n  }\n\n  function getBucketCobj(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].cobj;\n  }\n\n  function getInrateBag(bytes32 bucket) public view returns(uint256) {\n    return mocBuckets[bucket].inrateBag;\n  }\n\n  /**\n   * @dev Sets the objective coverage (cobj) on an specficied bucket.\n   * @param  _bucket - name of the bucket\n   * @param  _cobj - new value of cobj\n   */\n  function setBucketCobj(bytes32 _bucket, uint256 _cobj) public onlyAuthorizedChanger(){\n    //TODO: It is necessary to analyze the impact in the model it has when changing X2. This\n    mocBuckets[_bucket].cobj = _cobj;\n  }\n\n  /**\n    @dev returns true if the bucket is a base bucket\n    @param bucket Name of the bucket\n  */\n  function isBucketBase(bytes32 bucket) public view returns(bool){\n    return mocBuckets[bucket].isBase;\n  }\n\n  /**\n    @dev returns true if the bucket have docs in it\n    @param bucket Name of the bucket\n  */\n  function isBucketEmpty(bytes32 bucket) public view returns(bool) {\n    return mocBuckets[bucket].nDoc == 0;\n  }\n\n  /**\n    @dev Returns all the address that currently have bprox position for this bucket\n    @param bucket bucket of the active address\n  */\n  function getActiveAddresses(bytes32 bucket) public view returns(address payable[] memory) {\n    return mocBuckets[bucket].activeBalances;\n  }\n\n  /**\n    @dev Returns all the address that currently have bprox position for this bucket\n    @param bucket bucket of the active address\n  */\n  function getActiveAddressesCount(bytes32 bucket) public view returns(uint256 count) {\n    return mocBuckets[bucket].activeBalancesLength;\n  }\n\n  /**\n    @dev Add values to all variables of the bucket\n    @param bucketName Name of the bucket\n    @param btc BTC amount [using reservePrecision]\n    @param doc Doc amount [using mocPrecision]\n    @param bprox BPro amount [using mocPrecision]\n  */\n  function addValuesToBucket(bytes32 bucketName, uint256 btc, uint256 doc, uint256 bprox)\n  public onlyWhitelisted(msg.sender) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    bucket.nBTC = bucket.nBTC.add(btc);\n    bucket.nDoc = bucket.nDoc.add(doc);\n    bucket.nBPro = bucket.nBPro.add(bprox);\n  }\n\n  /**\n    @dev Substract values to all variables of the bucket\n    @param bucketName Name of the bucket\n    @param btc BTC amount [using reservePrecision]\n    @param doc Doc amount [using mocPrecision]\n    @param bprox BPro amount [using mocPrecision]\n  */\n  function substractValuesFromBucket(bytes32 bucketName, uint256 btc, uint256 doc, uint256 bprox)\n  public onlyWhitelisted(msg.sender)  {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    bucket.nBTC = bucket.nBTC.sub(btc);\n    bucket.nDoc = bucket.nDoc.sub(doc);\n    bucket.nBPro = bucket.nBPro.sub(bprox);\n  }\n\n  /**\n    @dev Moves BTC from inrateBag to main BTC bucket bag\n    @param bucketName Name of the bucket to operate\n    @param amount value to move from inrateBag to main bag [using reservePrecision]\n   */\n  function deliverInrate(bytes32 bucketName, uint256 amount) public\n   onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) bucketStateUpdate(bucketName) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    uint256 toMove = Math.min(bucket.inrateBag, amount);\n\n    bucket.inrateBag = bucket.inrateBag.sub(toMove);\n    bucket.nBTC = bucket.nBTC.add(toMove);\n  }\n\n  /**\n    @dev Removes Interests rate from Inrate bag\n    @param bucketName Name of the bucket to operate\n    @param amount value to move from inrateBag to main bag [using reservePrecision]\n    @return Retrieved value\n   */\n  function recoverInrate(bytes32 bucketName, uint256 amount) public\n  onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) bucketStateUpdate(bucketName) returns(uint256) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    uint256 toRetrieve = Math.min(bucket.inrateBag, amount);\n\n    bucket.inrateBag = bucket.inrateBag.sub(toRetrieve);\n\n    return toRetrieve;\n  }\n\n  /**\n    @dev Moves BTC from origin bucket to destination bucket inrateBag\n    @param bucketName name of the bucket to from which takes\n    @param btcAmount value to add to main bag [using reservePrecision]\n  */\n  function payInrate(bytes32 bucketName, uint256 btcAmount) public\n  onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n    bucket.inrateBag = bucket.inrateBag.add(btcAmount);\n  }\n\n  /**\n    @dev Move Btcs and Docs from one bucket to another\n    @param from Name of bucket from where the BTCs will be removed\n    @param to Name of bucket from where the BTCs will be added\n    @param btc BTCs amount [using reservePrecision]\n    @param docs Docs amount [using mocPrecision]\n  */\n  function moveBtcAndDocs(bytes32 from, bytes32 to, uint256 btc, uint256 docs) public\n  onlyWhitelisted(msg.sender) bucketStateUpdate(from) bucketStateUpdate(to) {\n    MoCBucket storage bucketFrom = mocBuckets[from];\n    MoCBucket storage bucketTo = mocBuckets[to];\n\n    bucketFrom.nBTC = bucketFrom.nBTC.sub(btc);\n    bucketTo.nBTC = bucketTo.nBTC.add(btc);\n\n    bucketFrom.nDoc = bucketFrom.nDoc.sub(docs);\n    bucketTo.nDoc = bucketTo.nDoc.add(docs);\n\n    emit BucketMovement(from, to, btc, docs);\n  }\n\n  /**\n    @dev Clears completely the origin bucket, removing all Docs, RBTCs and bproxs\n    @param toLiquidate Bucket to be cleared out\n    @param destination Bucket that will receive the Docs and RBTCs\n   */\n  function liquidateBucket(bytes32 toLiquidate, bytes32 destination) public onlyWhitelisted(msg.sender) {\n    require(!isBucketBase(toLiquidate), \"Cannot liquidate a base bucket\");\n\n    clearBucketBalances(toLiquidate);\n    emptyBucket(toLiquidate, destination);\n  }\n\n  /**\n    @dev Clears Docs and BTC from bucket origin and sends them to destination bucket\n    @param origin Bucket to clear out\n    @param destination Destination bucket\n  */\n  function emptyBucket(bytes32 origin, bytes32 destination) public onlyWhitelisted(msg.sender) {\n    moveBtcAndDocs(origin, destination, mocBuckets[origin].nBTC, mocBuckets[origin].nDoc);\n  }\n\n  /**\n   * @dev checks if a bucket exists\n   * @param bucket name of the bucket\n   */\n  function isAvailableBucket(bytes32 bucket) public view returns(bool) {\n    return mocBuckets[bucket].available;\n  }\n\n  /**\n    @dev Put all bucket BProx balances in zero\n    @param bucketName Bucket to clear out\n   */\n  function clearBucketBalances(bytes32 bucketName) public onlyWhitelisted(msg.sender) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n    bucket.nBPro = 0;\n    bucket.activeBalancesLength = 0;\n  }\n\n  /**\n    @dev Creates bucket\n    @param name Name of the bucket\n    @param cobj Target Coverage of the bucket\n    @param isBase Indicates if it is a base bucket (true) or not (false)\n  */\n  function createBucket(bytes32 name, uint256 cobj, bool isBase) internal {\n    mocBuckets[name].name = name;\n    mocBuckets[name].nDoc = 0;\n    mocBuckets[name].nBPro = 0;\n    mocBuckets[name].nBTC = 0;\n    mocBuckets[name].cobj = cobj;\n    mocBuckets[name].isBase = isBase;\n    mocBuckets[name].available = true;\n    emit BucketCreation(name, cobj);\n  }\n\n  modifier onlyBaseBucket(bytes32 bucket) {\n    require(isBucketBase(bucket), \"Bucket should be a base type bucket\");\n    _;\n  }\n\n  modifier bucketStateUpdate(bytes32 bucket) {\n    _;\n    emit BucketStateUpdate(\n      bucket,\n      mocBuckets[bucket].nBTC,\n      mocBuckets[bucket].nDoc,\n      mocBuckets[bucket].nBPro,\n      mocBuckets[bucket].inrateBag\n      );\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/MoCBProxManager.sol\n\npragma solidity 0.5.8;\n\n\n\n\ncontract MoCBProxManager is MoCBucketContainer {\n  using SafeMath for uint256;\n  uint256 constant MIN_ALLOWED_BALANCE = 0;\n\n  /**\n    @dev Initializes the contract\n    @param connectorAddress MoCConnector contract address\n    @param _governor Governor contract address\n    @param _c0Cobj Bucket C0 objective coverage\n    @param _x2Cobj Bucket X2 objective coverage\n  */\n  function initialize(\n    address connectorAddress,\n    address _governor,\n    uint256 _c0Cobj,\n    uint256 _x2Cobj\n  ) public initializer {\n    initializeBase(connectorAddress);\n    initializeValues(_governor);\n    createBucket(BUCKET_C0, _c0Cobj, true);\n    createBucket(BUCKET_X2, _x2Cobj, false);\n  }\n\n  /**\n    @dev returns user balance\n    @param bucket BProx corresponding bucket to get balance from\n    @param userAddress user address to get balance from\n    @return total balance for the userAddress\n  */\n  function bproxBalanceOf(bytes32 bucket, address userAddress) public view returns(uint256) {\n    BProxBalance memory userBalance = mocBuckets[bucket].bproxBalances[userAddress];\n    if (!hasValidBalance(bucket, userAddress, userBalance.index)) return 0;\n    return userBalance.value;\n  }\n\n  /**\n    @dev verifies that this user has assigned balance for the given bucket\n    @param bucket corresponding Leveraged bucket to get balance from\n    @param userAddress user address to verify balance for\n    @param index index, starting from 1, where the address of the user is being kept\n    @return true if the user has assigned balance\n  */\n  function hasValidBalance(bytes32 bucket, address userAddress, uint index) public view returns(bool) {\n    return (index != 0) &&\n      (index <= getActiveAddressesCount(bucket)) &&\n      (mocBuckets[bucket].activeBalances[index - 1] == userAddress);\n  }\n\n  /**\n    @dev  Assigns the amount of BProx\n    @param bucket bucket from which the BProx will be removed\n    @param account user address to redeem for\n    @param bproxAmount bprox amount to redeem [using mocPresicion]\n    @param totalCost btc value of bproxAmount [using reservePrecision]\n  */\n  function assignBProx(bytes32 bucket, address payable account, uint256 bproxAmount, uint256 totalCost)\n  public onlyWhitelisted(msg.sender) {\n    uint256 currentBalance = bproxBalanceOf(bucket, account);\n\n    setBProxBalanceOf(bucket, account, currentBalance.add(bproxAmount));\n    addValuesToBucket(bucket, totalCost, 0, bproxAmount);\n  }\n\n  /**\n    @dev Removes the amount of BProx and substract BTC cost from bucket\n    @param bucket bucket from which the BProx will be removed\n    @param userAddress user address to redeem for\n    @param bproxAmount bprox amount to redeem [using mocPresicion]\n    @param totalCost btc value of bproxAmount [using reservePrecision]\n  */\n  function removeBProx(bytes32 bucket, address payable userAddress, uint256 bproxAmount, uint256 totalCost)\n  public onlyWhitelisted(msg.sender) {\n    uint256 currentBalance = bproxBalanceOf(bucket, userAddress);\n\n    setBProxBalanceOf(bucket, userAddress, currentBalance.sub(bproxAmount));\n    substractValuesFromBucket(bucket, totalCost, 0, bproxAmount);\n  }\n\n  /**\n    @dev Sets the amount of BProx\n    @param bucket bucket from which the BProx will be setted\n    @param userAddress user address to redeem for\n    @param value bprox amount to redeem [using mocPresicion]\n  */\n  function setBProxBalanceOf(bytes32 bucket, address payable userAddress, uint256 value) public onlyWhitelisted(msg.sender) {\n    mocBuckets[bucket].bproxBalances[userAddress].value = value;\n    uint256 index = mocBuckets[bucket].bproxBalances[userAddress].index;\n    if (!hasValidBalance(bucket, userAddress, index))\n      index = 0;\n\n    bool hasBalance = value > MIN_ALLOWED_BALANCE;\n    // The address is not in the array\n    if (index == 0) {\n      if (hasBalance) {\n        if (mocBuckets[bucket].activeBalances.length == mocBuckets[bucket].activeBalancesLength) {\n          mocBuckets[bucket].activeBalances.length += 1;\n        }\n        uint256 currentIndex = mocBuckets[bucket].activeBalancesLength++;\n        mocBuckets[bucket].activeBalances[currentIndex] = userAddress;\n        mocBuckets[bucket].bproxBalances[userAddress].index = mocBuckets[bucket].activeBalancesLength;\n      }\n    } else {\n      if (!hasBalance) {\n        // We need to delete this address from the tracker\n        uint256 lastActiveIndex = mocBuckets[bucket].activeBalancesLength;\n        address payable keyToMove = mocBuckets[bucket].activeBalances[lastActiveIndex - 1];\n        mocBuckets[bucket].activeBalances[index - 1] = keyToMove;\n        // Alternative index and array decreases lenght to prevent gas limit\n        mocBuckets[bucket].activeBalancesLength--;\n        // Update moved key index\n        mocBuckets[bucket].bproxBalances[keyToMove].index = index;\n        // Disable empty account index (0 == NULL)\n        mocBuckets[bucket].bproxBalances[userAddress].index = 0;\n      }\n    }\n  }\n\n  /**\n   @dev intializes values of the contract\n   @param _governor Governor contract address\n  */\n  function initializeValues(address _governor) internal {\n    governor = IGovernor(_governor);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/interface/IMoC.sol\n\npragma solidity 0.5.8;\n\ninterface IMoC {\n    function() external payable;\n\n    function sendToAddress(address payable receiver, uint256 btcAmount) external returns(bool);\n}\n\n// File: contracts/interface/IMoCExchange.sol\n\npragma solidity 0.5.8;\n\ninterface IMoCExchange {\n    function getMoCTokenBalance(address owner, address spender) external view\n    returns (uint256 mocBalance, uint256 mocAllowance);\n\n    function mintBPro(address account, uint256 btcAmount, address vendorAccount) external\n    returns (uint256, uint256, uint256, uint256, uint256);\n\n    function redeemBPro(address account, uint256 bproAmount, address vendorAccount) external\n    returns (uint256, uint256, uint256, uint256, uint256);\n\n    function mintDoc(address account, uint256 btcToMint, address vendorAccount) external\n    returns (uint256, uint256, uint256, uint256, uint256);\n\n    function redeemBProx(address payable account, bytes32 bucket, uint256 bproxAmount, address vendorAccount)\n    external returns (uint256, uint256, uint256, uint256, uint256);\n\n    function mintBProx(address payable account, bytes32 bucket, uint256 btcToMint, address vendorAccount) external\n    returns (uint256, uint256, uint256, uint256, uint256);\n\n    function redeemFreeDoc(address account, uint256 docAmount, address vendorAccount) external\n    returns (uint256, uint256, uint256, uint256, uint256);\n\n    function redeemAllDoc(address origin, address payable destination) external\n    returns (uint256);\n\n    function convertToMoCPrice(uint256 btcAmount) external view returns (uint256, uint256, uint256);\n\n    function forceRedeemBProx(bytes32 bucket, address payable account, uint256 bproxAmount, uint256 bproxPrice)\n    external returns (bool);\n\n    function redeemDocWithPrice(address payable userAddress, uint256 amount, uint256 btcPrice) external\n    returns (bool, uint256);\n}\n\n// File: contracts/MoCExchange.sol\n\npragma solidity 0.5.8;\npragma experimental ABIEncoderV2;\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract MoCExchangeEvents {\n  event RiskProMint(\n    address indexed account,\n    uint256 amount,\n    uint256 reserveTotal,\n    uint256 commission,\n    uint256 reservePrice,\n    uint256 mocCommissionValue,\n    uint256 mocPrice,\n    uint256 btcMarkup,\n    uint256 mocMarkup,\n    address vendorAccount\n  );\n  event RiskProWithDiscountMint(\n    uint256 riskProTecPrice,\n    uint256 riskProDiscountPrice,\n    uint256 amount\n  );\n  event RiskProRedeem(\n    address indexed account,\n    uint256 amount,\n    uint256 reserveTotal,\n    uint256 commission,\n    uint256 reservePrice,\n    uint256 mocCommissionValue,\n    uint256 mocPrice,\n    uint256 btcMarkup,\n    uint256 mocMarkup,\n    address vendorAccount\n  );\n  event StableTokenMint(\n    address indexed account,\n    uint256 amount,\n    uint256 reserveTotal,\n    uint256 commission,\n    uint256 reservePrice,\n    uint256 mocCommissionValue,\n    uint256 mocPrice,\n    uint256 btcMarkup,\n    uint256 mocMarkup,\n    address vendorAccount\n  );\n  event StableTokenRedeem(\n    address indexed account,\n    uint256 amount,\n    uint256 reserveTotal,\n    uint256 commission,\n    uint256 reservePrice,\n    uint256 mocCommissionValue,\n    uint256 mocPrice,\n    uint256 btcMarkup,\n    uint256 mocMarkup,\n    address vendorAccount\n  );\n  event FreeStableTokenRedeem(\n    address indexed account,\n    uint256 amount,\n    uint256 reserveTotal,\n    uint256 commission,\n    uint256 interests,\n    uint256 reservePrice,\n    uint256 mocCommissionValue,\n    uint256 mocPrice,\n    uint256 btcMarkup,\n    uint256 mocMarkup,\n    address vendorAccount\n  );\n\n  event RiskProxMint(\n    bytes32 bucket,\n    address indexed account,\n    uint256 amount,\n    uint256 reserveTotal,\n    uint256 interests,\n    uint256 leverage,\n    uint256 commission,\n    uint256 reservePrice,\n    uint256 mocCommissionValue,\n    uint256 mocPrice,\n    uint256 btcMarkup,\n    uint256 mocMarkup,\n    address vendorAccount\n  );\n\n  event RiskProxRedeem(\n    bytes32 bucket,\n    address indexed account,\n    uint256 commission,\n    uint256 amount,\n    uint256 reserveTotal,\n    uint256 interests,\n    uint256 leverage,\n    uint256 reservePrice,\n    uint256 mocCommissionValue,\n    uint256 mocPrice,\n    uint256 btcMarkup,\n    uint256 mocMarkup,\n    address vendorAccount\n  );\n}\n\n\ncontract MoCExchange is MoCExchangeEvents, MoCBase, MoCLibConnection, IMoCExchange {\n  using Math for uint256;\n  using SafeMath for uint256;\n\n  // Contracts\n  IMoCState internal mocState;\n  MoCConverter internal mocConverter;\n  MoCBProxManager internal bproxManager;\n  BProToken internal bproToken;\n  DocToken internal docToken;\n  IMoCInrate internal mocInrate;\n  IMoC internal moc;\n\n  /**\n    @dev Initializes the contract\n    @param connectorAddress MoCConnector contract address\n  */\n  function initialize(address connectorAddress) public initializer {\n    initializePrecisions();\n    initializeBase(connectorAddress);\n    initializeContracts();\n  }\n\n  /************************************/\n  /***** UPGRADE v0110      ***********/\n  /************************************/\n\n  /** START UPDATE V0110: 24/09/2020  **/\n  /** Upgrade to support multiple commission rates **/\n  /** Public functions **/\n\n  /**\n   @dev Converts MoC commission from RBTC to MoC price\n   @param btcAmount Amount to be converted to MoC price\n   @return Amount converted to MoC Price, Bitcoin price and MoC price\n  */\n  function convertToMoCPrice(uint256 btcAmount) public view returns (uint256, uint256, uint256) {\n    uint256 btcPrice = mocState.getBitcoinPrice();\n    uint256 mocPrice = mocState.getMoCPrice();\n\n    // Calculate amount in MoC\n    uint256 amountInMoC = mocConverter.btcToMoCWithPrice(btcAmount, btcPrice, mocPrice);\n\n    return (amountInMoC, btcPrice, mocPrice);\n  }\n\n  /**\n   @dev Converts MoC commission from RBTC to MoC price\n   @param owner address of token owner\n   @param spender address of token spender\n   @return MoC balance of owner and MoC allowance of spender\n  */\n  function getMoCTokenBalance(address owner, address spender) public view\n  returns (uint256 mocBalance, uint256 mocAllowance) {\n    mocBalance = 0;\n    mocAllowance = 0;\n\n    MoCToken mocToken = MoCToken(mocState.getMoCToken());\n\n    if (address(mocToken) != address(0)) {\n      // Get balance and allowance from sender\n      mocBalance = mocToken.balanceOf(owner);\n      mocAllowance = mocToken.allowance(owner, spender);\n    }\n\n    return (mocBalance, mocAllowance);\n  }\n\n  /**\n   @dev Calculates commissions in MoC and BTC\n   @param params Params defined in CommissionParamsStruct\n   @return Commissions calculated in MoC price and bitcoin price; and Bitcoin and MoC prices\n  */\n  function calculateCommissionsWithPrices(CommissionParamsStruct memory params)\n  public view\n  returns (CommissionReturnStruct memory ret) {\n    // Get balance and allowance from sender\n    (uint256 mocBalance, uint256 mocAllowance) = getMoCTokenBalance(params.account, address(moc));\n\n    // Check commission rate in MoC according to transaction type\n    uint256 mocCommissionInBtc = mocInrate.calcCommissionValue(params.amount, params.txTypeFeesMOC);\n\n    // Calculate amount in MoC\n    (ret.mocCommission, ret.btcPrice, ret.mocPrice) = convertToMoCPrice(mocCommissionInBtc);\n    ret.btcCommission = 0;\n\n    // Calculate vendor markup\n    uint256 btcMarkup = mocInrate.calculateVendorMarkup(params.vendorAccount, params.amount);\n    (ret.mocMarkup, , ) = convertToMoCPrice(btcMarkup);\n    ret.btcMarkup = 0;\n    uint256 totalMoCFee = ret.mocCommission.add(ret.mocMarkup);\n\n    // Check if there is enough balance of MoC\n    if ((!(mocBalance >= totalMoCFee && mocAllowance >= totalMoCFee)) || (mocCommissionInBtc == 0)) {\n      // Insufficient funds\n      ret.mocCommission = 0;\n      ret.mocMarkup = 0;\n\n      // Check commission rate in RBTC according to transaction type\n      ret.btcCommission = mocInrate.calcCommissionValue(params.amount, params.txTypeFeesRBTC);\n      ret.btcMarkup = btcMarkup;\n    }\n\n    return ret;\n  }\n\n  /** END UPDATE V0110: 24/09/2020 **/\n\n  /**\n   @dev Mint BPros and give it to the msg.sender\n   @param account Address of minter\n   @param btcAmount Amount in BTC to mint\n   @param vendorAccount Vendor address\n  */\n// solium-disable-next-line security/no-assign-params\n  function mintBPro(address account, uint256 btcAmount, address vendorAccount)\n    public\n    onlyWhitelisted(msg.sender)\n    returns (uint256, uint256, uint256, uint256, uint256)\n  {\n    RiskProMintStruct memory details;\n\n    details.bproRegularPrice = mocState.bproTecPrice();\n    details.finalBProAmount = 0;\n    details.btcValue = 0;\n\n    if (mocState.state() == IMoCState.States.BProDiscount) {\n      details.discountPrice = mocState.bproDiscountPrice();\n      details.bproDiscountAmount = mocConverter.btcToBProDisc(btcAmount);\n\n      details.finalBProAmount = Math.min(\n        details.bproDiscountAmount,\n        mocState.maxBProWithDiscount()\n      );\n      details.btcValue = details.finalBProAmount == details.bproDiscountAmount\n        ? btcAmount\n        : mocConverter.bproDiscToBtc(details.finalBProAmount);\n\n      emit RiskProWithDiscountMint(\n        details.bproRegularPrice,\n        details.discountPrice,\n        details.finalBProAmount\n      );\n    }\n\n    if (btcAmount != details.btcValue) {\n      details.regularBProAmount = mocConverter.btcToBPro(\n        btcAmount.sub(details.btcValue)\n      );\n      details.finalBProAmount = details.finalBProAmount.add(details.regularBProAmount);\n    }\n\n    /** UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n    CommissionParamsStruct memory params;\n    params.account = account;\n    params.amount = btcAmount;\n    params.txTypeFeesMOC = mocInrate.MINT_BPRO_FEES_MOC();\n    params.txTypeFeesRBTC = mocInrate.MINT_BPRO_FEES_RBTC();\n    params.vendorAccount = vendorAccount;\n\n    (details.commission) = calculateCommissionsWithPrices(params);\n\n    mintBProInternal(account, btcAmount, details, vendorAccount);\n\n    return (\n      btcAmount,\n      details.commission.btcCommission,\n      details.commission.mocCommission,\n      details.commission.btcMarkup,\n      details.commission.mocMarkup\n    );\n    /** END UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n  }\n\n  /**\n   @dev Sender burns his BProS and redeems the equivalent BTCs\n   @param account Address of the redeeemer\n   @param bproAmount Amount of BPros to be redeemed\n   @param vendorAccount Vendor address\n   @return bitcoins to transfer to the redeemer and commission spent (in BTC and MoC), using [using reservePrecision]\n  */\n  function redeemBPro(address account, uint256 bproAmount, address vendorAccount)\n    public\n    onlyWhitelisted(msg.sender)\n    returns (uint256, uint256, uint256, uint256, uint256)\n  {\n    RiskProRedeemStruct memory details;\n\n    uint256 userBalance = bproToken.balanceOf(account);\n    uint256 userAmount = Math.min(bproAmount, userBalance);\n\n    details.bproFinalAmount = Math.min(userAmount, mocState.absoluteMaxBPro());\n    uint256 totalBtc = mocConverter.bproToBtc(details.bproFinalAmount);\n\n    /** UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n    CommissionParamsStruct memory params;\n    params.account = account;\n    params.amount = totalBtc;\n    params.txTypeFeesMOC = mocInrate.REDEEM_BPRO_FEES_MOC();\n    params.txTypeFeesRBTC = mocInrate.REDEEM_BPRO_FEES_RBTC();\n    params.vendorAccount = vendorAccount;\n\n    (details.commission) = calculateCommissionsWithPrices(params);\n    /** END UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n\n    // Mint token\n    bproToken.burn(account, details.bproFinalAmount);\n\n    // Update Buckets\n    bproxManager.substractValuesFromBucket(\n      BUCKET_C0,\n      totalBtc,\n      0,\n      details.bproFinalAmount\n    );\n\n    details.btcTotalWithoutCommission = totalBtc.sub(details.commission.btcCommission).sub(details.commission.btcMarkup);\n\n    redeemBProInternal(account, details, vendorAccount);\n\n    return (\n      details.btcTotalWithoutCommission,\n      details.commission.btcCommission,\n      details.commission.mocCommission,\n      details.commission.btcMarkup,\n      details.commission.mocMarkup\n    );\n  }\n\n  /**\n   @dev Redeems the requested amount for the account, or the max amount of free docs possible.\n   @param account Address of the redeeemer\n   @param docAmount Amount of Docs to redeem [using mocPrecision]\n   @param vendorAccount Vendor address\n   @return bitcoins to transfer to the redeemer and commission spent (in BTC and MoC), using [using reservePrecision]\n  */\n  function redeemFreeDoc(address account, uint256 docAmount, address vendorAccount)\n    public\n    onlyWhitelisted(msg.sender)\n    returns (uint256, uint256, uint256, uint256, uint256)\n  {\n    if (docAmount <= 0) {\n      return (0, 0, 0, 0, 0);\n    } else {\n      FreeStableTokenRedeemStruct memory details;\n      details.finalDocAmount = Math.min(\n        docAmount,\n        Math.min(mocState.freeDoc(), docToken.balanceOf(account))\n      );\n      uint256 docsBtcValue = mocConverter.docsToBtc(details.finalDocAmount);\n\n      details.btcInterestAmount = mocInrate.calcDocRedInterestValues(\n        details.finalDocAmount,\n        docsBtcValue\n      );\n      details.finalBtcAmount = docsBtcValue.sub(details.btcInterestAmount);\n\n      /** UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n      CommissionParamsStruct memory params;\n      params.account = account;\n      params.amount = details.finalBtcAmount;\n      params.txTypeFeesMOC = mocInrate.REDEEM_DOC_FEES_MOC();\n      params.txTypeFeesRBTC = mocInrate.REDEEM_DOC_FEES_RBTC();\n      params.vendorAccount = vendorAccount;\n\n      (details.commission) = calculateCommissionsWithPrices(params);\n\n      /** END UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n\n      doDocRedeem(account, details.finalDocAmount, docsBtcValue);\n      bproxManager.payInrate(BUCKET_C0, details.btcInterestAmount);\n\n      redeemFreeDocInternal(account, details, vendorAccount);\n\n      return (details.finalBtcAmount.sub(details.commission.btcCommission).sub(details.commission.btcMarkup), details.commission.btcCommission, details.commission.mocCommission, details.commission.btcMarkup, details.commission.mocMarkup);\n    }\n  }\n\n  /**\n   @dev Mint Max amount of Docs and give it to the msg.sender\n   @param account minter user address\n   @param btcToMint btc amount the user intents to convert to DoC [using rbtPresicion]\n   @param vendorAccount Vendor address\n   @return the actual amount of btc used and the btc commission (in BTC and MoC) for them [using rbtPresicion]\n  */\n  function mintDoc(address account, uint256 btcToMint, address vendorAccount)\n    public\n    onlyWhitelisted(msg.sender)\n    returns (uint256, uint256, uint256, uint256, uint256)\n  {\n    StableTokenMintStruct memory details;\n\n    // Docs to issue with tx value amount\n    if (btcToMint > 0) {\n      details.docs = mocConverter.btcToDoc(btcToMint);\n      details.docAmount = Math.min(details.docs, mocState.absoluteMaxDoc());\n      details.totalCost = details.docAmount == details.docs\n        ? btcToMint\n        : mocConverter.docsToBtc(details.docAmount);\n\n      // Mint Token\n      docToken.mint(account, details.docAmount);\n\n      // Update Buckets\n      bproxManager.addValuesToBucket(BUCKET_C0, details.totalCost, details.docAmount, 0);\n\n      /** UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n      CommissionParamsStruct memory params;\n      params.account = account;\n      params.amount = details.totalCost;\n      params.txTypeFeesMOC = mocInrate.MINT_DOC_FEES_MOC();\n      params.txTypeFeesRBTC = mocInrate.MINT_DOC_FEES_RBTC();\n      params.vendorAccount = vendorAccount;\n\n      (details.commission) = calculateCommissionsWithPrices(params);\n\n      mintDocInternal(account, details, vendorAccount);\n\n      /** END UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n\n      return (details.totalCost, details.commission.btcCommission, details.commission.mocCommission, details.commission.btcMarkup, details.commission.mocMarkup);\n    }\n\n    return (0, 0, 0, 0, 0);\n  }\n\n  /**\n   @dev User DoCs get burned and he receives the equivalent BTCs in return\n   @param userAddress Address of the user asking to redeem\n   @param amount Verified amount of Docs to be redeemed [using mocPrecision]\n   @param btcPrice bitcoin price [using mocPrecision]\n   @return true and commission spent (in BTC and MoC) if btc send was completed, false if fails.\n  */\n  function redeemDocWithPrice(\n    address payable userAddress,\n    uint256 amount,\n    uint256 btcPrice\n  ) public onlyWhitelisted(msg.sender) returns (bool, uint256) {\n    StableTokenRedeemStruct memory details;\n\n    details.totalBtc = mocConverter.docsToBtcWithPrice(amount, btcPrice);\n\n    /** UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n    // Check commission rate in RBTC according to transaction type\n    details.commission.btcCommission = mocInrate.calcCommissionValue(details.totalBtc, mocInrate.REDEEM_DOC_FEES_RBTC());\n    details.commission.btcMarkup = 0;\n    /** END UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n\n    details.btcToRedeem = details.totalBtc.sub(details.commission.btcCommission).sub(details.commission.btcMarkup);\n\n    bool result = moc.sendToAddress(userAddress, details.btcToRedeem);\n\n    details.reserveTotal = details.totalBtc.sub(details.commission.btcCommission).sub(details.commission.btcMarkup);\n    details.commission.btcPrice = btcPrice;\n    details.commission.mocCommission = 0;\n    details.commission.mocPrice = 0;\n    details.commission.mocMarkup = 0;\n\n    // If sends fail, then no redemption is executed\n    if (result) {\n      doDocRedeem(userAddress, amount, details.totalBtc);\n      redeemDocWithPriceInternal(userAddress, amount, details, address(0));\n    }\n\n    return (result, details.commission.btcCommission);\n  }\n\n  /**\n   @dev Allow redeem on liquidation state, user DoCs get burned and he receives\n   the equivalent RBTCs according to liquidationPrice\n   @param origin address owner of the DoCs\n   @param destination address to send the RBTC\n   @return The amount of RBTC in sent for the redemption or 0 if send does not succed\n  */\n  function redeemAllDoc(address origin, address payable destination)\n    public\n    onlyWhitelisted(msg.sender)\n    returns (uint256)\n  {\n    uint256 userDocBalance = docToken.balanceOf(origin);\n    if (userDocBalance == 0) return 0;\n\n    uint256 liqPrice = mocState.getLiquidationPrice();\n    // [USD * RBTC / USD]\n    uint256 totalRbtc = mocConverter.docsToBtcWithPrice(\n      userDocBalance,\n      liqPrice\n    );\n\n    // If send fails we don't burn the tokens\n    if (moc.sendToAddress(destination, totalRbtc)) {\n      docToken.burn(origin, userDocBalance);\n      emit StableTokenRedeem(\n        origin,\n        userDocBalance,\n        totalRbtc,\n        0,\n        liqPrice,\n        0,\n        0,\n        0,\n        0,\n        address(0)\n      );\n\n      return totalRbtc;\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n    @dev  Mint the amount of BPros\n    @param account Address that will owned the BPros\n    @param bproAmount Amount of BPros to mint [using mocPrecision]\n    @param rbtcValue RBTC cost of the minting [using reservePrecision]\n  */\n  function mintBPro(\n    address account,\n    uint256 btcCommission,\n    uint256 bproAmount,\n    uint256 rbtcValue,\n    uint256 mocCommission,\n    uint256 btcPrice,\n    uint256 mocPrice,\n    uint256 btcMarkup,\n    uint256 mocMarkup,\n    address vendorAccount\n  ) public onlyWhitelisted(msg.sender) {\n    bproToken.mint(account, bproAmount);\n    bproxManager.addValuesToBucket(BUCKET_C0, rbtcValue, 0, bproAmount);\n\n    emit RiskProMint(\n      account,\n      bproAmount,\n      rbtcValue,\n      btcCommission,\n      btcPrice,\n      mocCommission,\n      mocPrice,\n      btcMarkup,\n      mocMarkup,\n      vendorAccount\n    );\n  }\n\n  /**\n   @dev BUCKET Bprox minting. Mints Bprox for the specified bucket\n   @param account owner of the new minted Bprox\n   @param bucket bucket name\n   @param btcToMint rbtc amount to mint [using reservePrecision]\n   @param vendorAccount Vendor address\n   @return total RBTC Spent (btcToMint more interest) and commission spent (in BTC and MoC) [using reservePrecision]\n  */\n  function mintBProx(address payable account, bytes32 bucket, uint256 btcToMint, address vendorAccount)\n    public\n    onlyWhitelisted(msg.sender)\n    returns (uint256, uint256, uint256, uint256, uint256)\n  {\n    if (btcToMint > 0) {\n      RiskProxMintStruct memory details;\n\n      details.lev = mocState.leverage(bucket);\n\n      details.finalBtcToMint = Math.min(\n        btcToMint,\n        mocState.maxBProxBtcValue(bucket)\n      );\n\n      // Get interest and the adjusted BProAmount\n      details.btcInterestAmount = mocInrate.calcMintInterestValues(\n        bucket,\n        details.finalBtcToMint\n      );\n\n      // pay interest\n      bproxManager.payInrate(BUCKET_C0, details.btcInterestAmount);\n\n      details.bproxToMint = mocConverter.btcToBProx(details.finalBtcToMint, bucket);\n\n      bproxManager.assignBProx(bucket, account, details.bproxToMint, details.finalBtcToMint);\n      moveExtraFundsToBucket(BUCKET_C0, bucket, details.finalBtcToMint, details.lev);\n\n      // Calculate leverage after mint\n      details.lev = mocState.leverage(bucket);\n\n      /** UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n      CommissionParamsStruct memory params;\n      params.account = account;\n      params.amount = details.finalBtcToMint;\n      params.txTypeFeesMOC = mocInrate.MINT_BTCX_FEES_MOC();\n      params.txTypeFeesRBTC = mocInrate.MINT_BTCX_FEES_RBTC();\n      params.vendorAccount = vendorAccount;\n\n      (details.commission) = calculateCommissionsWithPrices(params);\n\n      mintBProxInternal(account, bucket, details, vendorAccount);\n      /** END UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n\n      return (details.finalBtcToMint.add(details.btcInterestAmount), details.commission.btcCommission, details.commission.mocCommission, details.commission.btcMarkup, details.commission.mocMarkup);\n    }\n\n    return (0, 0, 0, 0, 0);\n  }\n\n  /**\n   @dev Sender burns his BProx, redeems the equivalent amount of BPros, return\n   the \"borrowed\" DOCs and recover pending interests\n   @param account user address to redeem bprox from\n   @param bucket Bucket where the BProxs are hold\n   @param bproxAmount Amount of BProxs to be redeemed [using mocPrecision]\n   @param vendorAccount Vendor address\n   @return the actual amount of btc to redeem and the btc commission (in BTC and MoC) for them [using reservePrecision]\n  */\n  function redeemBProx(\n    address payable account,\n    bytes32 bucket,\n    uint256 bproxAmount,\n    address vendorAccount\n  ) public onlyWhitelisted(msg.sender) returns (uint256, uint256, uint256, uint256, uint256) {\n    // Revert could cause not evaluating state changing\n    if (bproxManager.bproxBalanceOf(bucket, account) == 0) {\n      return (0, 0, 0, 0, 0);\n    }\n\n    RiskProxRedeemStruct memory details;\n    // Calculate leverage before the redeem\n    details.bucketLev = mocState.leverage(bucket);\n    // Get redeemable value\n    details.bproxToRedeem = Math.min(bproxAmount, bproxManager.bproxBalanceOf(bucket, account));\n    details.rbtcToRedeem = mocConverter.bproxToBtc(details.bproxToRedeem, bucket);\n    // Pay interests\n    // Update 2020-03-31\n    // No recover interest in BTCX Redemption\n    // details.rbtcInterests = recoverInterests(bucket, details.rbtcToRedeem);\n    details.rbtcInterests = 0;\n\n    // Burn Bprox\n    burnBProxFor(\n      bucket,\n      account,\n      details.bproxToRedeem,\n      mocState.bucketBProTecPrice(bucket)\n    );\n\n    if (bproxManager.getBucketNBPro(bucket) == 0) {\n      // If there is no BProx left, empty bucket for rounding remnant\n      bproxManager.emptyBucket(bucket, BUCKET_C0);\n    } else {\n      // Move extra value from L bucket to C0\n      moveExtraFundsToBucket(bucket, BUCKET_C0, details.rbtcToRedeem, details.bucketLev);\n    }\n\n    /** UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n    CommissionParamsStruct memory params;\n    params.account = account;\n    params.amount = details.rbtcToRedeem;\n    params.txTypeFeesMOC = mocInrate.REDEEM_BTCX_FEES_MOC();\n    params.txTypeFeesRBTC = mocInrate.REDEEM_BTCX_FEES_RBTC();\n    params.vendorAccount = vendorAccount;\n\n    (details.commission) = calculateCommissionsWithPrices(params);\n\n    /** END UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n\n    details.btcTotalWithoutCommission = details.rbtcToRedeem.sub(details.commission.btcCommission).sub(details.commission.btcMarkup);\n    details.totalBtcRedeemed = details.btcTotalWithoutCommission.add(details.rbtcInterests);\n\n    redeemBProxInternal(account, bucket, bproxAmount, details, vendorAccount);\n\n    return (\n      details.totalBtcRedeemed,\n      details.commission.btcCommission,\n      details.commission.mocCommission,\n      details.commission.btcMarkup,\n      details.commission.mocMarkup\n    );\n  }\n\n  /**\n    @dev Burns user BProx and sends the equivalent amount of RBTC\n    to the account without caring if transaction succeeds\n    @param bucket Bucket where the BProxs are hold\n    @param account user address to redeem bprox from\n    @param bproxAmount Amount of BProx to redeem [using mocPrecision]\n    @param bproxPrice Price of one BProx in RBTC [using reservePrecision]\n    @return result of the RBTC sending transaction [using reservePrecision]\n  */\n  function forceRedeemBProx(\n    bytes32 bucket,\n    address payable account,\n    uint256 bproxAmount,\n    uint256 bproxPrice\n  ) public onlyWhitelisted(msg.sender) returns (bool) {\n    // Do burning part of the redemption\n    uint256 btcTotalAmount = burnBProxFor(\n      bucket,\n      account,\n      bproxAmount,\n      bproxPrice\n    );\n\n    // Send transaction can only fail for external code\n    // if transaction fails, user will lost his RBTC and BProx\n    return moc.sendToAddress(account, btcTotalAmount);\n  }\n\n  /**\n    @dev Burns user BProx\n    @param bucket Bucket where the BProxs are hold\n    @param account user address to redeem bprox from\n    @param bproxAmount Amount of BProx to redeem [using mocPrecision]\n    @param bproxPrice Price of one BProx in RBTC [using reservePrecision]\n    @return Bitcoin total value of the redemption [using reservePrecision]\n  */\n  function burnBProxFor(\n    bytes32 bucket,\n    address payable account,\n    uint256 bproxAmount,\n    uint256 bproxPrice\n  ) public onlyWhitelisted(msg.sender) returns (uint256) {\n    // Calculate total RBTC\n    uint256 btcTotalAmount = mocConverter.bproToBtcWithPrice(\n      bproxAmount,\n      bproxPrice\n    );\n    bproxManager.removeBProx(bucket, account, bproxAmount, btcTotalAmount);\n\n    return btcTotalAmount;\n  }\n\n  /************************************/\n  /***** UPGRADE v0110      ***********/\n  /************************************/\n\n  /** START UPDATE V0110: 24/09/2020  **/\n  /** Upgrade to support multiple commission rates **/\n  /** Internal functions **/\n\n  /**\n   @dev Internal function to avoid stack too deep errors\n  */\n  function redeemBProxInternal(\n    address account,\n    bytes32 bucket,\n    uint256 bproxAmount,\n    RiskProxRedeemStruct memory details,\n    address vendorAccount\n  ) internal {\n    emit RiskProxRedeem(\n      bucket,\n      account,\n      details.commission.btcCommission,\n      bproxAmount,\n      details.btcTotalWithoutCommission,\n      details.rbtcInterests,\n      details.bucketLev,\n      details.commission.btcPrice,\n      details.commission.mocCommission,\n      details.commission.mocPrice,\n      details.commission.btcMarkup,\n      details.commission.mocMarkup,\n      vendorAccount\n    );\n  }\n\n  /**\n   @dev Internal function to avoid stack too deep errors\n  */\n  function mintBProInternal(address account, uint256 btcAmount, RiskProMintStruct memory details, address vendorAccount) internal {\n    mintBPro(\n      account,\n      details.commission.btcCommission,\n      details.finalBProAmount,\n      btcAmount,\n      details.commission.mocCommission,\n      details.commission.btcPrice,\n      details.commission.mocPrice,\n      details.commission.btcMarkup,\n      details.commission.mocMarkup,\n      vendorAccount\n    );\n  }\n\n  /**\n   @dev Internal function to avoid stack too deep errors\n  */\n  function mintBProxInternal(address account, bytes32 bucket, RiskProxMintStruct memory details, address vendorAccount) internal {\n    emit RiskProxMint(\n      bucket,\n      account,\n      details.bproxToMint,\n      details.finalBtcToMint,\n      details.btcInterestAmount,\n      details.lev,\n      details.commission.btcCommission,\n      details.commission.btcPrice,\n      details.commission.mocCommission,\n      details.commission.mocPrice,\n      details.commission.btcMarkup,\n      details.commission.mocMarkup,\n      vendorAccount\n    );\n  }\n\n  /**\n   @dev Internal function to avoid stack too deep errors\n  */\n  function mintDocInternal(address account, StableTokenMintStruct memory details, address vendorAccount) internal {\n    emit StableTokenMint(\n      account,\n      details.docAmount,\n      details.totalCost,\n      details.commission.btcCommission,\n      details.commission.btcPrice,\n      details.commission.mocCommission,\n      details.commission.mocPrice,\n      details.commission.btcMarkup,\n      details.commission.mocMarkup,\n      vendorAccount\n    );\n  }\n\n  /**\n   @dev Internal function to avoid stack too deep errors\n  */\n  function redeemFreeDocInternal(address account, FreeStableTokenRedeemStruct memory details, address vendorAccount) internal {\n    emit FreeStableTokenRedeem(\n      account,\n      details.finalDocAmount,\n      details.finalBtcAmount,\n      details.commission.btcCommission,\n      details.btcInterestAmount,\n      details.commission.btcPrice,\n      details.commission.mocCommission,\n      details.commission.mocPrice,\n      details.commission.btcMarkup,\n      details.commission.mocMarkup,\n      vendorAccount\n    );\n  }\n\n  /**\n   @dev Internal function to avoid stack too deep errors\n  */\n  function redeemBProInternal(address account, RiskProRedeemStruct memory details, address vendorAccount) internal {\n    emit RiskProRedeem(\n      account,\n      details.bproFinalAmount,\n      details.btcTotalWithoutCommission,\n      details.commission.btcCommission,\n      details.commission.btcPrice,\n      details.commission.mocCommission,\n      details.commission.mocPrice,\n      details.commission.btcMarkup,\n      details.commission.mocMarkup,\n      vendorAccount\n    );\n  }\n\n  /**\n   @dev Internal function to avoid stack too deep errors\n  */\n  function redeemDocWithPriceInternal(address account, uint256 amount, StableTokenRedeemStruct memory details, address vendorAccount) internal {\n    emit StableTokenRedeem(\n      account, //userAddress,\n      amount,\n      details.reserveTotal,\n      details.commission.btcCommission,\n      details.commission.btcPrice,\n      details.commission.mocCommission,\n      details.commission.mocPrice,\n      details.commission.btcMarkup,\n      details.commission.mocMarkup,\n      vendorAccount\n    );\n  }\n\n  /** END UPDATE V0110: 24/09/2020 **/\n\n  /**\n    @dev Calculates the amount of RBTC that one bucket should move to another in\n    BProx minting/redemption. This extra makes BProx more leveraging than BPro.\n    @param bucketFrom Origin bucket from which the BTC are moving\n    @param bucketTo Destination bucket to which the BTC are moving\n    @param totalBtc Amount of BTC moving between buckets [using reservePrecision]\n    @param lev lev of the L bucket [using mocPrecision]\n  */\n  function moveExtraFundsToBucket(\n    bytes32 bucketFrom,\n    bytes32 bucketTo,\n    uint256 totalBtc,\n    uint256 lev\n  ) internal {\n    uint256 btcToMove = mocLibConfig.bucketTransferAmount(totalBtc, lev);\n    uint256 docsToMove = mocConverter.btcToDoc(btcToMove);\n\n    uint256 btcToMoveFinal = Math.min(\n      btcToMove,\n      bproxManager.getBucketNBTC(bucketFrom)\n    );\n    uint256 docsToMoveFinal = Math.min(\n      docsToMove,\n      bproxManager.getBucketNDoc(bucketFrom)\n    );\n\n    bproxManager.moveBtcAndDocs(\n      bucketFrom,\n      bucketTo,\n      btcToMoveFinal,\n      docsToMoveFinal\n    );\n  }\n\n  /**\n   @dev Returns RBTCs for user in concept of interests refund\n   @param bucket Bucket where the BProxs are hold\n   @param rbtcToRedeem Total RBTC value of the redemption [using reservePrecision]\n   @return Interests [using reservePrecision]\n  */\n  function recoverInterests(bytes32 bucket, uint256 rbtcToRedeem)\n    internal\n    returns (uint256)\n  {\n    uint256 rbtcInterests = mocInrate.calcFinalRedeemInterestValue(\n      bucket,\n      rbtcToRedeem\n    );\n\n    return bproxManager.recoverInrate(BUCKET_C0, rbtcInterests);\n  }\n\n  function doDocRedeem(address userAddress, uint256 docAmount, uint256 totalBtc)\n    internal\n  {\n    docToken.burn(userAddress, docAmount);\n    bproxManager.substractValuesFromBucket(BUCKET_C0, totalBtc, docAmount, 0);\n  }\n\n  function initializeContracts() internal {\n    moc = IMoC(connector.moc());\n    docToken = DocToken(connector.docToken());\n    bproToken = BProToken(connector.bproToken());\n    bproxManager = MoCBProxManager(connector.bproxManager());\n    mocState = IMoCState(connector.mocState());\n    mocConverter = MoCConverter(connector.mocConverter());\n    mocInrate = IMoCInrate(connector.mocInrate());\n  }\n\n\n  /************************************/\n  /***** UPGRADE v0110      ***********/\n  /************************************/\n\n  /** START UPDATE V0110: 24/09/2020  **/\n  /** Upgrade to support multiple commission rates **/\n  /** Structs **/\n\n  struct RiskProxRedeemStruct{\n    uint256 totalBtcRedeemed;\n    uint256 btcTotalWithoutCommission;\n    uint256 rbtcInterests;\n    uint256 bucketLev;\n    uint256 bproxToRedeem;\n    uint256 rbtcToRedeem;\n    CommissionReturnStruct commission;\n  }\n\n  struct RiskProxMintStruct{\n    uint256 bproxToMint;\n    uint256 finalBtcToMint;\n    uint256 btcInterestAmount;\n    uint256 lev;\n    CommissionReturnStruct commission;\n  }\n\n  struct RiskProRedeemStruct{\n    uint256 bproFinalAmount;\n    uint256 btcTotalWithoutCommission;\n    CommissionReturnStruct commission;\n  }\n\n  struct FreeStableTokenRedeemStruct{\n    uint256 finalDocAmount;\n    uint256 finalBtcAmount;\n    uint256 btcInterestAmount;\n    CommissionReturnStruct commission;\n  }\n\n  struct RiskProMintStruct{\n    uint256 bproRegularPrice;\n    uint256 btcValue;\n    uint256 discountPrice;\n    uint256 bproDiscountAmount;\n    uint256 regularBProAmount;\n    uint256 availableBPro;\n    uint256 finalBProAmount;\n    CommissionReturnStruct commission;\n  }\n\n  struct StableTokenMintStruct{\n    uint256 docs;\n    uint256 docAmount;\n    uint256 totalCost;\n    CommissionReturnStruct commission;\n  }\n\n  struct CommissionParamsStruct{\n    address account; // Address of the user doing the transaction\n    uint256 amount; // Amount from which commissions are calculated\n    uint8 txTypeFeesMOC; // Transaction type if fees are paid in MoC\n    uint8 txTypeFeesRBTC; // Transaction type if fees are paid in RBTC\n    address vendorAccount; // Vendor address\n  }\n\n  struct CommissionReturnStruct{\n    uint256 btcCommission;\n    uint256 mocCommission;\n    uint256 btcPrice;\n    uint256 mocPrice;\n    uint256 btcMarkup;\n    uint256 mocMarkup;\n  }\n\n  struct StableTokenRedeemStruct{\n    uint256 reserveTotal;\n    uint256 btcToRedeem;\n    uint256 totalBtc;\n    CommissionReturnStruct commission;\n  }\n\n  /** END UPDATE V0110: 24/09/2020 **/\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n",
            "file": "MoCExchange-flat.sol"
        }
    ],
    "libraries": {
        "MoCHelperLib": "0xEaCcD35dFf10A0B917cDbe80B8d7237A05F9579d"
    },
    "creationData": {
        "blockHash": "0x5d1198a0b0cd91132779ea890b620998f6c9602d1261b9fb48bbf2031c38acca",
        "blockNumber": 1769765,
        "transactionHash": "0x33ef7b84be70c7d2e608a85843c96efbd70b656aa1b4947895560fd40ba85a47",
        "timestamp": 1618597630
    }
}