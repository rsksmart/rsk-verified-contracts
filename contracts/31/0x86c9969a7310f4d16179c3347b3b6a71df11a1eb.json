{
    "address": "0x86c9969a7310f4d16179c3347b3b6a71df11a1eb",
    "net": {
        "id": "31",
        "name": "RSK Testnet"
    },
    "name": "MoCSettlement",
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": "1"
        },
        "evmVersion": "byzantium"
    },
    "version": "0.5.8+commit.23d335f2",
    "source": "\n// File: openzeppelin-solidity/contracts/math/Math.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n// File: zos-lib/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.6.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: contracts/base/MoCWhitelist.sol\n\npragma solidity 0.5.8;\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCWhitelist {\n  mapping(address => bool) whitelist;\n\n  /**\n   * @dev Check if an account is whitelisted\n   * @return Bool\n   */\n  function isWhitelisted(address account)\n    public\n    view\n    returns (bool)\n  {\n    require(account != address(0), \"Account must not be 0x0\");\n    return whitelist[account];\n  }\n\n  /**\n   * @dev Add account to whitelist\n   */\n  function add(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(!isWhitelisted(account), \"Account not allowed to add accounts into white list\");\n    whitelist[account] = true;\n  }\n\n  /**\n   * @dev Remove account from whitelist\n   */\n  function remove(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(isWhitelisted(account), \"Account is not allowed to remove address from the white list\");\n\n    whitelist[account] = false;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/base/MoCConnector.sol\n\npragma solidity 0.5.8;\n\n\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCConnector is MoCWhitelist, Initializable {\n  // References\n  address payable public moc;\n  address public stableToken;\n  address public riskProToken;\n  address public riskProxManager;\n  address public mocState;\n  address public mocConverter;\n  address public mocSettlement;\n  address public mocExchange;\n  address public mocInrate;\n  /** DEPRECATED mocBurnout **/\n  address public mocBurnout;\n  address public reserveToken;\n\n  bool internal initialized;\n\n  /**\n    @dev Initializes the contract\n    @param mocAddress MoC contract address\n    @param stableTokenAddress Stable token contract address\n    @param riskProAddress RiskPro token contract address\n    @param riskProxAddress RiskProxManager contract address\n    @param stateAddress MoCState contract address\n    @param settlementAddress MoCSettlement contract address\n    @param converterAddress MoCConverter contract address\n    @param exchangeAddress MoCExchange contract address\n    @param inrateAddress MoCInrate contract address\n    @param burnoutBookAddress (DEPRECATED) MoCBurnout contract address. DO NOT USE.\n    @param reserveTokenAddress Reserve token contract address\n  */\n  function initialize(\n    address payable mocAddress,\n    address stableTokenAddress,\n    address riskProAddress,\n    address riskProxAddress,\n    address stateAddress,\n    address settlementAddress,\n    address converterAddress,\n    address exchangeAddress,\n    address inrateAddress,\n    address burnoutBookAddress,\n    address reserveTokenAddress\n  ) public initializer {\n    moc = mocAddress;\n    stableToken = stableTokenAddress;\n    riskProToken = riskProAddress;\n    riskProxManager = riskProxAddress;\n    mocState = stateAddress;\n    mocSettlement = settlementAddress;\n    mocConverter = converterAddress;\n    mocExchange = exchangeAddress;\n    mocInrate = inrateAddress;\n    mocBurnout = burnoutBookAddress;\n    reserveToken = reserveTokenAddress;\n\n    // Add to Whitelist\n    add(mocAddress);\n    add(stableTokenAddress);\n    add(riskProAddress);\n    add(riskProxAddress);\n    add(stateAddress);\n    add(settlementAddress);\n    add(converterAddress);\n    add(exchangeAddress);\n    add(inrateAddress);\n    add(burnoutBookAddress);\n    add(reserveTokenAddress);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/base/MoCConstants.sol\n\npragma solidity 0.5.8;\n\n/**\n * @dev Defines special constants to use along all the MoC System\n */\ncontract MoCConstants {\n  bytes32 constant public BUCKET_X2 = \"X2\";\n  bytes32 constant public BUCKET_C0 = \"C0\";\n}\n\n// File: contracts/base/MoCBase.sol\n\npragma solidity 0.5.8;\n\n\n\n\n/**\n  @dev General usefull modifiers and functions\n */\ncontract MoCBase is MoCConstants, Initializable {\n  // Contracts\n  MoCConnector public connector;\n\n  bool internal initialized;\n\n  function initializeBase(address connectorAddress) internal initializer {\n    connector = MoCConnector(connectorAddress);\n  }\n\n  modifier onlyWhitelisted(address account) {\n    require(connector.isWhitelisted(account), \"Address is not whitelisted\");\n    _;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * > Note that this information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * `IERC20.balanceOf` and `IERC20.transfer`.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See `IERC20.approve`.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destoys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See `_burn` and `_approve`.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\n\n// File: openzeppelin-solidity/contracts/access/Roles.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\n// File: openzeppelin-solidity/contracts/access/roles/MinterRole.sol\n\npragma solidity ^0.5.0;\n\n\ncontract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(msg.sender), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Mintable.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @dev Extension of `ERC20` that adds a set of accounts with the `MinterRole`,\n * which have permission to mint (create) new tokens as they see fit.\n *\n * At construction, the deployer of the contract is the only minter.\n */\ncontract ERC20Mintable is ERC20, MinterRole {\n    /**\n     * @dev See `ERC20._mint`.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MinterRole`.\n     */\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: contracts/token/OwnerBurnableToken.sol\n\npragma solidity 0.5.8;\n\n\n\n/**\n * @title Owner Burnable Token\n * @dev Token that allows the owner to irreversibly burned (destroyed) any token.\n */\ncontract OwnerBurnableToken is Ownable, ERC20Mintable {\n  /**\n   * @dev Burns a specific amount of tokens for the address.\n   * @param who who's tokens are gona be burned\n   * @param value The amount of token to be burned.\n   */\n  function burn(address who, uint256 value) public onlyOwner {\n    _burn(who, value);\n  }\n}\n\n// File: contracts/token/StableToken.sol\n\npragma solidity 0.5.8;\n\n\n\ncontract StableToken is ERC20Detailed, OwnerBurnableToken {\n\n  string private _name = \"RIF Dollar on Chain\";\n  string private _symbol = \"RDOC\";\n  uint8 private _decimals = 18;\n\n  /**\n    @dev Constructor\n  */\n  constructor() Ownable() ERC20Detailed(_name, _symbol, _decimals) public {\n\n  }\n\n  /**\n    @dev Fallback function\n  */\n  function() external {\n  }\n}\n\n// File: contracts/interface/IMoCState.sol\n\npragma solidity 0.5.8;\n\ninterface IMoCState {\n\n     /******STATE MACHINE*********/\n    enum States {\n        // State 0\n        Liquidated,\n        // State 1\n        RiskProDiscount,\n        // State 2\n        BelowCobj,\n        // State 3\n        AboveCobj\n    }\n\n\n    function addToReserves(uint256 reserveAmount) external;\n\n    function substractFromReserves(uint256 reserveAmount) external;\n\n    function coverage(bytes32 bucket) external view returns(uint256);\n\n    function getReservesRemainder() external view returns(uint256);\n\n    function liq() external view returns(uint256);\n\n    function state() external view returns(States);\n\n    function peg() external view returns(uint256);\n\n    function dayBlockSpan() external view returns(uint256);\n\n    function getReserveTokenPrice() external view returns(uint256);\n\n    function getMoCPrice() external view returns(uint256);\n\n    function getProtected() external view returns(uint256);\n\n    function globalCoverage() external view returns(uint256);\n\n    function getMoCVendors() external view returns(address);\n\n    function getMoCToken() external view returns(address);\n\n    function nextState() external;\n\n    function maxRiskProWithDiscount() external view returns(uint256);\n\n    function absoluteMaxRiskPro() external view returns(uint256);\n\n    function absoluteMaxStableToken() external view returns(uint256);\n\n    function freeStableToken() external view returns(uint256);\n\n    function riskProTecPrice() external view returns(uint256);\n\n    function riskProSpotDiscountRate() external view returns(uint256);\n\n    function riskProDiscountPrice() external view returns(uint256);\n\n    function bucketRiskProTecPrice(bytes32 bucket) external view returns(uint256);\n\n    function currentAbundanceRatio() external view returns(uint256);\n\n    function abundanceRatio(uint256 stableToken0) external view returns(uint256);\n\n    function daysToSettlement() external view returns(uint256);\n\n    function leverage(bytes32 bucket) external view returns(uint256);\n\n    function getBucketNReserve(bytes32 bucket) external view returns(uint256);\n\n    function getLiquidationPrice() external view returns(uint256);\n\n    function maxRiskProxResTokenValue(bytes32 bucket) external view returns(uint256);\n\n    function bucketRiskProTecPriceHelper(bytes32 bucket) external view returns(uint256);\n}\n\n// File: contracts/interface/IMoCExchange.sol\n\npragma solidity 0.5.8;\n\ninterface IMoCExchange {\n    function getMoCTokenBalance(address owner, address spender) external view\n    returns (uint256 mocBalance, uint256 mocAllowance);\n\n    function mintRiskPro(address account, uint256 reserveAmount, address vendorAccount) external\n    returns (uint256, uint256, uint256, uint256, uint256);\n\n    function redeemRiskPro(address account, uint256 riskProAmount, address vendorAccount) external\n    returns (uint256, uint256, uint256, uint256, uint256);\n\n    function mintStableToken(address account, uint256 reserveToMint, address vendorAccount) external\n    returns (uint256, uint256, uint256, uint256, uint256);\n\n    function redeemRiskProx(address payable account, bytes32 bucket, uint256 riskProxAmount, address vendorAccount)\n    external returns (uint256, uint256, uint256, uint256, uint256);\n\n    function mintRiskProx(address payable account, bytes32 bucket, uint256 reserveToMint, address vendorAccount) external\n    returns (uint256, uint256, uint256, uint256, uint256);\n\n    function redeemFreeStableToken(address account, uint256 stableTokenAmount, address vendorAccount) external\n    returns (uint256, uint256, uint256, uint256, uint256);\n\n    function redeemAllStableToken(address origin, address payable destination) external\n    returns (uint256);\n\n    function convertToMoCPrice(uint256 reserveAmount) external view returns (uint256, uint256, uint256);\n\n    function forceRedeemRiskProx(bytes32 bucket, address payable account, uint256 riskProxAmount, uint256 riskProxPrice)\n    external returns (bool);\n\n    function redeemStableTokenWithPrice(address payable userAddress, uint256 amount, uint256 reservePrice) external\n    returns (bool, uint256);\n}\n\n// File: moc-governance/contracts/Governance/ChangeContract.sol\n\npragma solidity 0.5.8;\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n\n  /**\n    @notice Override this function with a recipe of the changes to be done when this ChangeContract\n    is executed\n   */\n  function execute() external;\n}\n\n// File: moc-governance/contracts/Governance/IGovernor.sol\n\npragma solidity 0.5.8;\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor{\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @dev This function should be protected somehow to only execute changes that\n    benefit the system. This decision process is independent of this architechture\n    therefore is independent of this interface too\n    @param changeContract Address of the contract that will execute the changes\n   */\n  function executeChange(ChangeContract changeContract) external;\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @param _changer Address of the contract that will execute the changes\n   */\n  function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n// File: moc-governance/contracts/Governance/Governed.sol\n\npragma solidity 0.5.8;\n\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed is Initializable {\n\n  /**\n    @notice The address of the contract which governs this one\n   */\n  IGovernor public governor;\n\n  string constant private NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n  /**\n    @notice Modifier that protects the function\n    @dev You should use this modifier in any function that should be called through\n    the governance system\n   */\n  modifier onlyAuthorizedChanger() {\n    require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n    _;\n  }\n\n  /**\n    @notice Initialize the contract with the basic settings\n    @dev This initialize replaces the constructor but it is not called automatically.\n    It is necessary because of the upgradeability of the contracts\n    @param _governor Governor address\n   */\n  function initialize(IGovernor _governor) public initializer {\n    governor = _governor;\n  }\n\n  /**\n    @notice Change the contract's governor. Should be called through the old governance system\n    @param newIGovernor New governor address\n   */\n  function changeIGovernor(IGovernor newIGovernor) public onlyAuthorizedChanger {\n    governor = newIGovernor;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/MoCBucketContainer.sol\n\npragma solidity 0.5.8;\n\n\n\n\n\n\ncontract MoCBucketContainer is MoCBase, Governed {\n  using SafeMath for uint256;\n  using Math for uint256;\n\n  struct RiskProxBalance {\n    uint256 value;\n    uint256 index; // Index start in 1, zero is reserved for NULL\n  }\n\n  struct MoCBucket {\n    bytes32 name;\n    bool isBase;\n    uint256 nStable;\n    uint256 nRiskPro;\n    uint256 nReserve;\n    uint256 cobj;\n    // Should only be used in X buckets\n    mapping(address => RiskProxBalance) riskProxBalances;\n    address payable[] activeBalances;\n    uint256 activeBalancesLength;\n    // Should only be used in Base buckets (C0)\n    uint256 inrateBag;\n    bool available;\n  }\n\n  event BucketMovement(\n    bytes32 from,\n    bytes32 to,\n    uint256 reserves,\n    uint256 stableTokens\n  );\n\n  event BucketCreation(\n    bytes32 name,\n    uint256 cobj\n  );\n\n  event BucketStateUpdate(\n    bytes32 name,\n    uint256 nReserve,\n    uint256 nStable,\n    uint256 nRiskProx,\n    uint256 inrateBag\n  );\n\n  mapping(bytes32 => MoCBucket) internal mocBuckets;\n\n  /**\n   GETTERS\n   */\n  function getBucketNReserve(bytes32 bucket) public view returns (uint256) {\n    return mocBuckets[bucket].nReserve;\n  }\n\n  function getBucketNRiskPro(bytes32 bucket) public view returns (uint256) {\n    return mocBuckets[bucket].nRiskPro;\n  }\n\n  function getBucketNStableToken(bytes32 bucket) public view returns (uint256) {\n    return mocBuckets[bucket].nStable;\n  }\n\n  function getBucketCobj(bytes32 bucket) public view returns (uint256) {\n    return mocBuckets[bucket].cobj;\n  }\n\n  function getInrateBag(bytes32 bucket) public view returns (uint256) {\n    return mocBuckets[bucket].inrateBag;\n  }\n\n  /**\n   * @dev Sets the objective coverage (cobj) on an specficied bucket.\n   * @param  _bucket - name of the bucket\n   * @param  _cobj - new value of cobj\n   */\n  function setBucketCobj(bytes32 _bucket, uint256 _cobj) public onlyAuthorizedChanger() {\n    //TODO: It is necessary to analyze the impact in the model it has when changing X2. This\n    mocBuckets[_bucket].cobj = _cobj;\n  }\n\n  /**\n    @dev returns true if the bucket is a base bucket\n    @param bucket Name of the bucket\n  **/\n  function isBucketBase(bytes32 bucket) public view returns (bool) {\n    return mocBuckets[bucket].isBase;\n  }\n\n  /**\n    @dev returns true if the bucket have stableTokens in it\n    @param bucket Name of the bucket\n  **/\n  function isBucketEmpty(bytes32 bucket) public view returns (bool) {\n    return mocBuckets[bucket].nStable == 0;\n  }\n\n  /**\n    @dev Returns all the address that currently have riskProx position for this bucket\n    @param bucket bucket of the active address\n  */\n  function getActiveAddresses(bytes32 bucket) public view returns (address payable[] memory) {\n    return mocBuckets[bucket].activeBalances;\n  }\n\n  /**\n    @dev Returns all the address that currently have riskProx position for this bucket\n    @param bucket bucket of the active address\n  */\n  function getActiveAddressesCount(bytes32 bucket) public view returns (uint256 count) {\n    return mocBuckets[bucket].activeBalancesLength;\n  }\n\n  /**\n    @dev Add values to all variables of the bucket\n    @param bucketName Name of the bucket\n    @param reserveTokens ReserveToken amount [using reservePrecision]\n    @param stableToken StableToken amount [using mocPrecision]\n    @param riskProx RiskProx amount [using mocPrecision]\n  */\n  function addValuesToBucket(bytes32 bucketName, uint256 reserveTokens, uint256 stableToken, uint256 riskProx)\n  public onlyWhitelisted(msg.sender) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    bucket.nReserve = bucket.nReserve.add(reserveTokens);\n    bucket.nStable = bucket.nStable.add(stableToken);\n    bucket.nRiskPro = bucket.nRiskPro.add(riskProx);\n  }\n\n  /**\n    @dev Substract values to all variables of the bucket\n    @param bucketName Name of the bucket\n    @param reserve ReserveToken amount [using reservePrecision]\n    @param stableToken StableToken amount [using mocPrecision]\n    @param riskProx RiskProx amount [using mocPrecision]\n  */\n  function substractValuesFromBucket(bytes32 bucketName, uint256 reserve, uint256 stableToken, uint256 riskProx)\n  public onlyWhitelisted(msg.sender) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    bucket.nReserve = bucket.nReserve.sub(reserve);\n    bucket.nStable = bucket.nStable.sub(stableToken);\n    bucket.nRiskPro = bucket.nRiskPro.sub(riskProx);\n  }\n\n  /**\n    @dev Moves ReserveTokens from inrateBag to main ReserveTokens bucket bag\n    @param bucketName Name of the bucket to operate\n    @param amount value to move from inrateBag to main bag [using reservePrecision]\n   */\n  function deliverInrate(bytes32 bucketName, uint256 amount) public\n   onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) bucketStateUpdate(bucketName) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    uint256 toMove = Math.min(bucket.inrateBag, amount);\n\n    bucket.inrateBag = bucket.inrateBag.sub(toMove);\n    bucket.nReserve = bucket.nReserve.add(toMove);\n  }\n\n  /**\n    @dev Removes Interests rate from Inrate bag\n    @param bucketName Name of the bucket to operate\n    @param amount value to move from inrateBag to main bag [using reservePrecision]\n    @return Retrieved value\n   */\n  function recoverInrate(bytes32 bucketName, uint256 amount) public\n  onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) bucketStateUpdate(bucketName) returns(uint256) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    uint256 toRetrieve = Math.min(bucket.inrateBag, amount);\n\n    bucket.inrateBag = bucket.inrateBag.sub(toRetrieve);\n\n    return toRetrieve;\n  }\n\n  /**\n    @dev Moves ReserveTokens from origin bucket to destination bucket inrateBag\n    @param bucketName name of the bucket to from which takes\n    @param reserveAmount value to add to main bag [using reservePrecision]\n  */\n  function payInrate(bytes32 bucketName, uint256 reserveAmount) public\n  onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n    bucket.inrateBag = bucket.inrateBag.add(reserveAmount);\n  }\n\n  /**\n    @dev Move ReserveTokens and StableTokens from one bucket to another\n    @param from Name of bucket from where the ReserveTokens will be removed\n    @param to Name of bucket from where the ReserveTokens will be added\n    @param reserve ReserveTokens amount [using reservePrecision]\n    @param stableTokens StableTokens amount [using mocPrecision]\n  **/\n  function moveResTokensAndStableTokens(bytes32 from, bytes32 to, uint256 reserve, uint256 stableTokens) public\n  onlyWhitelisted(msg.sender) bucketStateUpdate(from) bucketStateUpdate(to) {\n    MoCBucket storage bucketFrom = mocBuckets[from];\n    MoCBucket storage bucketTo = mocBuckets[to];\n\n    bucketFrom.nReserve = bucketFrom.nReserve.sub(reserve);\n    bucketTo.nReserve = bucketTo.nReserve.add(reserve);\n\n    bucketFrom.nStable = bucketFrom.nStable.sub(stableTokens);\n    bucketTo.nStable = bucketTo.nStable.add(stableTokens);\n\n    emit BucketMovement(from, to, reserve, stableTokens);\n  }\n\n  /**\n    @dev Clears completely the origin bucket, removing all StableTokens, ReserveTokens and riskProxs\n    @param toLiquidate Bucket to be cleared out\n    @param destination Bucket that will receive the StableTokens and ReserveTokens\n   */\n  function liquidateBucket(bytes32 toLiquidate, bytes32 destination) public onlyWhitelisted(msg.sender) {\n    require(!isBucketBase(toLiquidate), \"Cannot liquidate a base bucket\");\n\n    clearBucketBalances(toLiquidate);\n    emptyBucket(toLiquidate, destination);\n  }\n\n  /**\n    @dev Clears StableTokens and ReserveTokens from bucket origin and sends them to destination bucket\n    @param origin Bucket to clear out\n    @param destination Destination bucket\n  **/\n  function emptyBucket(bytes32 origin, bytes32 destination) public onlyWhitelisted(msg.sender) {\n    moveResTokensAndStableTokens(origin, destination, mocBuckets[origin].nReserve, mocBuckets[origin].nStable);\n  }\n\n  /**\n   * @dev checks if a bucket exists\n   * @param bucket name of the bucket\n   */\n  function isAvailableBucket(bytes32 bucket) public view returns (bool) {\n    return mocBuckets[bucket].available;\n  }\n\n  /**\n    @dev Put all bucket RiskProx balances in zero\n    @param bucketName Bucket to clear out\n   */\n  function clearBucketBalances(bytes32 bucketName) public onlyWhitelisted(msg.sender) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n    bucket.nRiskPro = 0;\n    bucket.activeBalancesLength = 0;\n  }\n\n  /**\n    @dev Creates bucket\n    @param name Name of the bucket\n    @param cobj Target Coverage of the bucket\n    @param isBase Indicates if it is a base bucket (true) or not (false)\n  */\n  function createBucket(bytes32 name, uint256 cobj, bool isBase) internal {\n    mocBuckets[name].name = name;\n    mocBuckets[name].nStable = 0;\n    mocBuckets[name].nRiskPro = 0;\n    mocBuckets[name].nReserve = 0;\n    mocBuckets[name].cobj = cobj;\n    mocBuckets[name].isBase = isBase;\n    mocBuckets[name].available = true;\n    emit BucketCreation(name, cobj);\n  }\n\n  modifier onlyBaseBucket(bytes32 bucket) {\n    require(isBucketBase(bucket), \"Bucket should be a base type bucket\");\n    _;\n  }\n\n  modifier bucketStateUpdate(bytes32 bucket) {\n    _;\n    emit BucketStateUpdate(\n      bucket,\n      mocBuckets[bucket].nReserve,\n      mocBuckets[bucket].nStable,\n      mocBuckets[bucket].nRiskPro,\n      mocBuckets[bucket].inrateBag\n    );\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/MoCRiskProxManager.sol\n\npragma solidity 0.5.8;\n\n\n\n\n\ncontract MoCRiskProxManager is MoCBucketContainer {\n  using SafeMath for uint256;\n  uint256 constant MIN_ALLOWED_BALANCE = 0;\n\n  function initialize(address connectorAddress, address _governor, uint256 _c0Cobj, uint256 _x2Cobj) public initializer {\n    initializeBase(connectorAddress);\n    initializeValues(_governor);\n    createBucket(BUCKET_C0, _c0Cobj, true);\n    createBucket(BUCKET_X2, _x2Cobj, false);\n  }\n\n  /**\n    @dev returns user balance\n    @param bucket RiskProx corresponding bucket to get balance from\n    @param userAddress user address to get balance from\n    @return total balance for the userAddress\n  */\n  function riskProxBalanceOf(bytes32 bucket, address userAddress) public view returns (uint256) {\n    RiskProxBalance memory userBalance = mocBuckets[bucket].riskProxBalances[userAddress];\n    if (!hasValidBalance(bucket, userAddress, userBalance.index)) return 0;\n    return userBalance.value;\n  }\n\n  /**\n    @dev verifies that this user has assigned balance for the given bucket\n    @param bucket corresponding Leveraged bucket to get balance from\n    @param userAddress user address to verify balance for\n    @param index index, starting from 1, where the address of the user is being kept\n    @return true if the user has assigned balance\n  */\n  function hasValidBalance(bytes32 bucket, address userAddress, uint256 index) public view returns (bool) {\n    return (index != 0) && (index <= getActiveAddressesCount(bucket)) && (mocBuckets[bucket].activeBalances[index - 1] == userAddress);\n  }\n\n  /**\n    @dev  Assigns the amount of RiskProx\n    @param bucket bucket from which the RiskProx will be removed\n    @param account user address to redeem for\n    @param riskProxAmount riskProx amount to redeem [using mocPresicion]\n    @param totalCost ReserveToken value of riskProxAmount [using reservePrecision]\n  */\n  function assignRiskProx(bytes32 bucket, address payable account, uint256 riskProxAmount, uint256 totalCost)\n    public\n    onlyWhitelisted(msg.sender)\n  {\n    uint256 currentBalance = riskProxBalanceOf(bucket, account);\n\n    setRiskProxBalanceOf(bucket, account, currentBalance.add(riskProxAmount));\n    addValuesToBucket(bucket, totalCost, 0, riskProxAmount);\n  }\n\n  /**\n    @dev  Removes the amount of RiskProx and substract ReserveTokens from bucket\n    @param bucket bucket from which the RiskProx will be removed\n    @param userAddress user address to redeem for\n    @param riskProxAmount riskProx amount to redeem [using mocPresicion]\n    @param totalCost reserveToken value of riskProxAmount [using reservePrecision]\n  */\n  function removeRiskProx(bytes32 bucket, address payable userAddress, uint256 riskProxAmount, uint256 totalCost)\n    public\n    onlyWhitelisted(msg.sender)\n  {\n    uint256 currentBalance = riskProxBalanceOf(bucket, userAddress);\n\n    setRiskProxBalanceOf(bucket, userAddress, currentBalance.sub(riskProxAmount));\n    substractValuesFromBucket(bucket, totalCost, 0, riskProxAmount);\n  }\n\n  /**\n    @dev Sets the amount of RiskProx\n    @param bucket bucket from which the RiskProx will be setted\n    @param userAddress user address to redeem for\n    @param value riskProx amount to redeem [using mocPresicion]\n  */\n  function setRiskProxBalanceOf(bytes32 bucket, address payable userAddress, uint256 value) public onlyWhitelisted(msg.sender) {\n    mocBuckets[bucket].riskProxBalances[userAddress].value = value;\n\n    uint256 index = mocBuckets[bucket].riskProxBalances[userAddress].index;\n    if (!hasValidBalance(bucket, userAddress, index)) index = 0;\n\n    bool hasBalance = value > MIN_ALLOWED_BALANCE;\n    // The address is not in the array\n    if (index == 0) {\n      if (hasBalance) {\n        if (mocBuckets[bucket].activeBalances.length == mocBuckets[bucket].activeBalancesLength) {\n          mocBuckets[bucket].activeBalances.length += 1;\n        }\n        uint256 currentIndex = mocBuckets[bucket].activeBalancesLength++;\n        mocBuckets[bucket].activeBalances[currentIndex] = userAddress;\n        mocBuckets[bucket].riskProxBalances[userAddress].index = mocBuckets[bucket].activeBalancesLength;\n      }\n    } else {\n      if (!hasBalance) {\n        // We need to delete this address from the tracker\n        uint256 lastActiveIndex = mocBuckets[bucket].activeBalancesLength;\n        address payable keyToMove = mocBuckets[bucket].activeBalances[lastActiveIndex - 1];\n        mocBuckets[bucket].activeBalances[index - 1] = keyToMove;\n        // Alternative index and array decreases lenght to prevent gas limit\n        mocBuckets[bucket].activeBalancesLength--;\n        // Update moved key index\n        mocBuckets[bucket].riskProxBalances[keyToMove].index = index;\n        // Disable empty account index (0 == NULL)\n        mocBuckets[bucket].riskProxBalances[userAddress].index = 0;\n      }\n    }\n  }\n\n  /**\n   * @dev intializes values of the contract\n   */\n  function initializeValues(address _governor) internal {\n    governor = IGovernor(_governor);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/PartialExecution.sol\n\npragma solidity 0.5.8;\n\n\n\n\ncontract PartialExecutionData {\n  enum ExecutionState {Ready, Running, Finished}\n\n  struct TaskGroup {\n    bytes32 id;\n    ExecutionState state;\n    bytes32[] subTasks;\n    function() internal onStart;\n    function() internal onFinish;\n    bool autoRestart;\n  }\n\n  struct Task {\n    bytes32 id;\n    function() internal returns (uint256) getStepCount;\n    function(uint256) internal stepFunction;\n    function() internal onStart;\n    function() internal onFinish;\n    uint256 currentStep;\n    uint256 stepCount;\n    ExecutionState state;\n  }\n}\n\n\n/**\n  @dev Brings basic data structures and functions for partial execution.\n  The main data structures are:\n    Task: Represents a function that needs to be executed by steps.\n    TaskGroup: Represents a function that contains several functions that needs to be executed by steps.\n  Tasks and Tasks groups can be executed specifying the amount of steps to run.\n*/\ncontract PartialExecution is PartialExecutionData {\n  using SafeMath for uint256;\n  using Math for uint256;\n  mapping(bytes32 => Task) internal tasks;\n  mapping(bytes32 => TaskGroup) internal taskGroups;\n\n  /**\n   @dev Auxiliar function for tasks with no onFinish function\n */\n  function noFunction() internal {}\n\n\n  /**\n   @dev Reset pointers a task group\n   @param _groupId Id of the task group\n   @param _subtasks Tasks to execute when executing the task group\n   @param _onFinish Function to execute when all tasks of the group are completed\n */\n  function resetTaskGroupPointers(\n    bytes32 _groupId,\n    bytes32[] memory _subtasks,\n    function() _onStart,\n    function() _onFinish,\n    bool _autoRestart\n  ) internal {\n    taskGroups[_groupId].id = _groupId;\n    taskGroups[_groupId].subTasks = _subtasks;\n    taskGroups[_groupId].onStart = _onStart;\n    taskGroups[_groupId].onFinish = _onFinish;\n    taskGroups[_groupId].autoRestart = _autoRestart;\n\n  }\n\n  /**\n   @dev Creates a task\n   @param taskId Id of the task\n   @param _getStepCount Function executed before starting the task\n   Should return the step count of the execution\n   @param _stepFunction Function to execute at each step\n   @param _onStart Function to execute before task execution\n   @param _onFinish Function to execute when all steps are completed\n */\n  function resetTaskPointers(\n    bytes32 taskId,\n    function() internal returns (uint256) _getStepCount,\n    function(uint256) internal _stepFunction,\n    function() internal _onStart,\n    function() internal _onFinish\n  ) internal {\n    tasks[taskId].id = taskId;\n    tasks[taskId].getStepCount = _getStepCount;\n    tasks[taskId].stepFunction = _stepFunction;\n    tasks[taskId].onStart = _onStart;\n    tasks[taskId].onFinish = _onFinish;\n  }\n\n\n\n  /**\n   @dev Creates a task group\n   @param _groupId Id of the task group\n   @param _subtasks Tasks to execute when executing the task group\n   @param _onFinish Function to execute when all tasks of the group are completed\n */\n  function createTaskGroup(\n    bytes32 _groupId,\n    bytes32[] memory _subtasks,\n    function() _onStart,\n    function() _onFinish,\n    bool _autoRestart\n  ) internal {\n    taskGroups[_groupId].id = _groupId;\n    taskGroups[_groupId].subTasks = _subtasks;\n    taskGroups[_groupId].onStart = _onStart;\n    taskGroups[_groupId].onFinish = _onFinish;\n    taskGroups[_groupId].state = ExecutionState.Ready;\n    taskGroups[_groupId].autoRestart = _autoRestart;\n  }\n\n  /**\n   @dev Creates a task\n   @param taskId Id of the task\n   @param _getStepCount Function executed before starting the task\n   Should return the step count of the execution\n   @param _stepFunction Function to execute at each step\n   @param _onStart Function to execute before task execution\n   @param _onFinish Function to execute when all steps are completed\n */\n  function createTask(\n    bytes32 taskId,\n    function() internal returns (uint256) _getStepCount,\n    function(uint256) internal _stepFunction,\n    function() internal _onStart,\n    function() internal _onFinish\n  ) internal {\n    tasks[taskId].id = taskId;\n    tasks[taskId].getStepCount = _getStepCount;\n    tasks[taskId].stepFunction = _stepFunction;\n    tasks[taskId].onStart = _onStart;\n    tasks[taskId].onFinish = _onFinish;\n    tasks[taskId].state = ExecutionState.Ready;\n  }\n\n  /**\n   @dev Executes all tasks of the group in order using the step count passed as parameter\n   @param groupId Id of the task group\n   @param stepCount Step count to execute\n */\n  function executeGroup(bytes32 groupId, uint256 stepCount) internal {\n    TaskGroup storage group = taskGroups[groupId];\n\n    if (group.state == ExecutionState.Ready) {\n      group.onStart();\n      group.state = ExecutionState.Running;\n    }\n\n    uint256 leftSteps = stepCount;\n\n    for (uint256 i = 0; i < group.subTasks.length && leftSteps > 0; i++) {\n      uint256 consumed = executeTask(group.subTasks[i], leftSteps);\n      leftSteps = leftSteps.sub(consumed);\n    }\n\n    if (groupFinished(groupId)) {\n      group.state = ExecutionState.Finished;\n      group.onFinish();\n      if (group.autoRestart) {\n        resetGroup(groupId);\n      }\n    }\n  }\n\n  /**\n   @dev Creates a task\n   @param taskId Id of the task\n   @param steps Step count to execute\n   @return The amount of steps consumed in the execution\n */\n  function executeTask(bytes32 taskId, uint256 steps)\n  internal\n  returns (uint256)\n  {\n    Task storage task = tasks[taskId];\n    uint256 initialStep = task.currentStep;\n\n    if (task.state == ExecutionState.Finished) {\n      // No execution\n      return 0;\n    }\n    if (task.state == ExecutionState.Ready) {\n      task.stepCount = task.getStepCount();\n      task.onStart();\n      task.state = ExecutionState.Running;\n    }\n    if (task.state == ExecutionState.Running) {\n      uint256 endStep = Math.min(\n        task.currentStep.add(steps),\n        task.stepCount\n      );\n\n      for (\n        task.currentStep;\n        task.currentStep < endStep;\n        task.currentStep++\n      ) {\n        task.stepFunction(task.currentStep);\n      }\n\n      if (task.currentStep == task.stepCount) {\n        task.state = ExecutionState.Finished;\n        task.onFinish();\n      }\n    }\n\n    return task.currentStep.sub(initialStep);\n  }\n\n  /**\n   @dev Put task in Ready to run state and reset currentStep value\n   @param taskId Id of the task\n */\n  function resetTask(bytes32 taskId) internal {\n    tasks[taskId].state = ExecutionState.Ready;\n    tasks[taskId].currentStep = 0;\n  }\n\n  /**\n  @dev Reset all tasks in a group. Used at the completion of a task group execution\n  @param groupId Id of the task group\n*/\n  function resetTasks(bytes32 groupId) internal {\n    TaskGroup storage group = taskGroups[groupId];\n\n    for (uint256 i = 0; i < group.subTasks.length; i++) {\n      resetTask(group.subTasks[i]);\n    }\n  }\n\n  /**\n  @dev Set if a Group should be automatically set to Ready state\n  after Finnished State is reached\n  @param groupId Id of the task group\n*/\n  function setAutoRestart(bytes32 groupId, bool _autoRestart) internal {\n    taskGroups[groupId].autoRestart = _autoRestart;\n  }\n\n  /**\n  @dev Set Group in Ready state. Reset all sub-task.\n  @param groupId Id of the task group\n*/\n  function resetGroup(bytes32 groupId) internal {\n    TaskGroup storage group = taskGroups[groupId];\n    group.state = ExecutionState.Ready;\n\n    resetTasks(groupId);\n  }\n\n  /**\n   @dev Returns true if the last task of the group was completed\n   @param groupId Id of the task group\n   @return boolean\n */\n  function groupFinished(bytes32 groupId) internal view returns (bool) {\n    TaskGroup storage group = taskGroups[groupId];\n    bytes32 taskId = group.subTasks[group.subTasks.length.sub(1)];\n    Task storage lastTask = tasks[taskId];\n\n    return lastTask.state == ExecutionState.Finished;\n  }\n\n  /**\n   @dev Returns true if the group is currently un Running state\n   @param groupId Id of the task group\n   @return boolean\n */\n  function isGroupRunning(bytes32 groupId) internal view returns (bool) {\n    return taskGroups[groupId].state == ExecutionState.Running;\n  }\n\n  /**\n   @dev Returns true if the group is currently in Ready state\n   @param groupId Id of the task group\n   @return boolean\n */\n  function isGroupReady(bytes32 groupId) internal view returns (bool) {\n    return taskGroups[groupId].state == ExecutionState.Ready;\n  }\n\n  /**\n   @dev Returns true if the task is currently un Running state\n   @param taskId Id of the task\n   @return boolean\n */\n  function isTaskRunning(bytes32 taskId) internal view returns (bool) {\n    return tasks[taskId].state == ExecutionState.Running;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/interface/IMoCVendors.sol\n\npragma solidity 0.5.8;\n\ninterface IMoCVendors {\n    function resetTotalPaidInMoC() external;\n\n    function getIsActive(address account) external view\n    returns (bool);\n\n    function getTotalPaidInMoC(address account) external view\n    returns (uint256);\n\n    function getStaking(address account) external view\n    returns (uint256);\n\n    function getMarkup(address account) external view\n    returns (uint256);\n\n    function updatePaidMarkup(address account, uint256 mocAmount, uint256 reserveAmount, uint256 totalMoCAmount) external;\n}\n\n// File: contracts/interface/IMoCSettlement.sol\n\npragma solidity 0.5.8;\n\ninterface IMoCSettlement {\n    function getRedeemRequestAt(uint256 _index) external view returns (address payable, uint256);\n\n    function redeemQueueSize() external view returns (uint256);\n\n    function stableTokenAmountToRedeem(address _who) external view returns (uint256);\n\n    function addRedeemRequest(uint256 amount, address payable redeemer) external;\n\n    function alterRedeemRequestAmount(bool isAddition, uint256 delta, address redeemer) external;\n\n    function isSettlementEnabled() external view returns (bool);\n\n    function runSettlement(uint256 steps) external returns (uint256);\n\n    function isSettlementReady() external view returns (bool);\n\n    function nextSettlementBlock() external view returns (uint256);\n}\n\n// File: contracts/MoCSettlement.sol\n\npragma solidity 0.5.8;\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract MoCSettlementEvents {\n  event RedeemRequestAlter(address indexed redeemer, bool isAddition, uint256 delta);\n  event RedeemRequestProcessed(address indexed redeemer, uint256 commission, uint256 amount);\n  event SettlementRedeemStableToken(uint256 queueSize, uint256 accumCommissions, uint256 reservePrice);\n  event SettlementDeleveraging(uint256 leverage, uint256 riskProxPrice, uint256 reservePrice, uint256 startBlockNumber);\n  event SettlementStarted(\n    uint256 stableTokenRedeemCount,\n    uint256 deleveragingCount,\n    uint256 riskProxPrice,\n    uint256 reservePrice\n  );\n  event SettlementCompleted(uint256 commissionsPayed);\n}\n\ncontract MoCSettlement is\nMoCSettlementEvents,\nMoCBase,\nPartialExecution,\nGoverned,\nIMoCSettlement\n{\n  using Math for uint256;\n  using SafeMath for uint256;\n\n  bytes32 public constant StableToken_REDEMPTION_TASK = keccak256(\"StableTokenRedemption\");\n  bytes32 public constant DELEVERAGING_TASK = keccak256(\"Deleveraging\");\n  bytes32 public constant SETTLEMENT_TASK = keccak256(\"Settlement\");\n\n  struct RedeemRequest {\n    address payable who;\n    uint256 amount;\n  }\n\n  struct UserRedeemRequest {\n    uint256 index;\n    bool activeRedeemer;\n  }\n\n  // All necessary data for Settlement execution\n  struct SettlementInfo {\n    uint256 reservePrice;\n    uint256 riskProxPrice;\n    uint256 stableTokenRedeemCount;\n    uint256 deleveragingCount;\n    uint256 riskProxAmount;\n    uint256 partialCommissionAmount;\n    uint256 finalCommissionAmount;\n    uint256 leverage;\n    uint256 startBlockNumber;\n    bool isProtectedMode;\n  }\n\n  // Contracts\n  IMoCState internal mocState;\n  IMoCExchange internal mocExchange;\n  StableToken internal stableToken;\n  MoCRiskProxManager internal riskProxManager;\n\n  /**\n  @dev Block Number of the last successful execution\n  */\n  uint256 internal lastProcessedBlock;\n  /**\n  @dev Min number of blocks settlement should be re evaluated on\n  */\n  uint256 internal blockSpan;\n  /**\n  @dev Information for Settlement execution\n  */\n  SettlementInfo internal settlementInfo;\n  /**\n  @dev Redeem queue\n  */\n  RedeemRequest[] private redeemQueue;\n  mapping(address => UserRedeemRequest) private redeemMapping;\n  uint256 private redeemQueueLength;\n\n  /**\n    @dev Initializes the contract\n    @param connectorAddress MoCConnector contract address\n    @param _governor Governor contract address\n    @param _blockSpan Blockspan configuration blockspan of settlement\n  */\n  function initialize(\n    address connectorAddress,\n    address _governor,\n    uint256 _blockSpan\n  ) public initializer {\n    initializeBase(connectorAddress);\n    initializeContracts();\n    initializeValues(_governor, _blockSpan);\n  }\n\n  /**\n   *  @dev Set the blockspan configuration blockspan of settlement\n   */\n  function setBlockSpan(uint256 bSpan) public onlyAuthorizedChanger() {\n    blockSpan = bSpan;\n  }\n\n  /**\n   *  @dev Set Settlement to be kept in finnished state after\n   *  all execution is completed.\n   */\n  function setSettlementToStall() public onlyAuthorizedChanger() {\n    setAutoRestart(SETTLEMENT_TASK, false);\n  }\n\n  /**\n   *  @dev Set Settlement state to Ready\n   */\n  function restartSettlementState() public onlyAuthorizedChanger() {\n    resetGroup(SETTLEMENT_TASK);\n    setAutoRestart(SETTLEMENT_TASK, true);\n  }\n\n  /**\n    @dev Gets the RedeemRequest at the queue index position\n    @param _index queue position to get\n    @return redeemer's address and amount he submitted\n  */\n  function getRedeemRequestAt(uint256 _index)\n  public\n  view\n  withinBoundaries(_index)\n  returns (address payable, uint256)\n  {\n    return (redeemQueue[_index].who, redeemQueue[_index].amount);\n  }\n\n  /**\n    @dev Gets the number of blocks the settlemnet will be allowed to run\n  */\n  function getBlockSpan() public view returns (uint256) {\n    return blockSpan;\n  }\n\n  /**\n    @dev Verify that the index is smaller than the length of the redeem request queue\n    @param _index queue position to get\n  */\n  modifier withinBoundaries(uint256 _index) {\n    require(_index < redeemQueueLength, \"Index out of boundaries\");\n    _;\n  }\n\n  /**\n    @dev returns current redeem queue size\n  */\n  function redeemQueueSize() public view returns (uint256) {\n    return redeemQueueLength;\n  }\n\n  /**\n    @dev Returns true if blockSpan number of blocks has pass since last execution\n  */\n  function isSettlementEnabled() public view returns (bool) {\n    return nextSettlementBlock() <= block.number;\n  }\n\n  /**\n    @dev Returns true if the settlment is running\n  */\n  function isSettlementRunning() public view returns (bool) {\n    return isGroupRunning(SETTLEMENT_TASK);\n  }\n\n  /**\n    @dev Returns true if the settlment is ready\n  */\n  function isSettlementReady() public view returns (bool) {\n    return isGroupReady(SETTLEMENT_TASK);\n  }\n\n  /**\n    @dev Returns the next block from which settlement is possible\n  */\n  function nextSettlementBlock() public view returns (uint256) {\n    return lastProcessedBlock.add(blockSpan);\n  }\n\n  /**\n    @dev returns the total amount of StableTokens in the redeem queue for _who\n    @param _who address for which ^ is computed\n    @return total amount of StableTokens in the redeem queue for _who [using mocPrecision]\n  */\n  function stableTokenAmountToRedeem(address _who) public view returns (uint256) {\n    if (!redeemMapping[_who].activeRedeemer) {\n      return 0;\n    }\n\n    uint256 indexRedeem = redeemMapping[_who].index;\n    RedeemRequest memory redeemRequest = redeemQueue[indexRedeem];\n    return redeemRequest.amount;\n  }\n\n  /**\n    @dev push a new redeem request to the queue for the sender or updates the amount if the user has a redeem request\n    @param amount amount he is willing to redeem [using mocPrecision]\n    @param redeemer redeemer address\n  */\n  function addRedeemRequest(uint256 amount, address payable redeemer)\n  public\n  onlyWhitelisted(msg.sender)\n  {\n    if (!redeemMapping[redeemer].activeRedeemer) {\n      if (redeemQueueLength == redeemQueue.length) {\n        redeemQueue.length += 1;\n      }\n      uint256 index = redeemQueueLength;\n      redeemQueue[redeemQueueLength++] = RedeemRequest(redeemer, amount);\n      redeemMapping[redeemer] = UserRedeemRequest(index, true);\n      emit RedeemRequestAlter(redeemer, true, amount);\n    } else {\n      alterRedeemRequestAmount(true, amount, redeemer);\n    }\n  }\n\n  /**\n    @dev empty the queue\n  */\n  function clear() public onlyWhitelisted(msg.sender) {\n    redeemQueueLength = 0;\n  }\n\n  /**\n    @dev Alters the redeem amount position for the redeemer\n    @param isAddition true if adding amount to redeem, false to substract.\n    @param delta the amount to add/substract to current position [using mocPrecision]\n    @param redeemer address to alter amount for\n    @return the filled amount [using mocPrecision]\n  */\n  function alterRedeemRequestAmount(\n    bool isAddition,\n    uint256 delta,\n    address redeemer\n  ) public onlyWhitelisted(msg.sender) {\n    require(\n      redeemMapping[redeemer].activeRedeemer,\n      \"This is not an active redeemer\"\n    );\n    uint256 indexRedeem = redeemMapping[redeemer].index;\n    RedeemRequest storage redeemRequest = redeemQueue[indexRedeem];\n    require(redeemRequest.who == redeemer, \"Not allowed redeemer\");\n    uint256 actualDelta = delta;\n    if (isAddition) {\n      redeemRequest.amount = redeemRequest.amount.add(delta);\n    } else {\n      if (redeemRequest.amount < delta) {\n        actualDelta = redeemRequest.amount;\n        redeemRequest.amount = 0;\n      } else {\n        redeemRequest.amount = redeemRequest.amount.sub(delta);\n      }\n    }\n    emit RedeemRequestAlter(redeemer, isAddition, actualDelta);\n  }\n\n  /**\n    @dev Runs settlement process in steps\n    @param steps Amount of steps to run\n    @return The commissions collected in the executed steps\n  */\n  function runSettlement(uint256 steps)\n  public\n  onlyWhitelisted(msg.sender)\n  isTime()\n  returns (uint256)\n  {\n    executeGroup(SETTLEMENT_TASK, steps);\n\n    return settlementInfo.finalCommissionAmount;\n  }\n\n  /**\n  @dev Create Task structures for Settlement execution\n  */\n  function fixTasksPointer() public {\n    resetTaskPointers(\n      DELEVERAGING_TASK,\n      deleveragingStepCount,\n      deleveragingStep,\n      noFunction,\n      finishDeleveraging\n    );\n    resetTaskPointers(\n      StableToken_REDEMPTION_TASK,\n      stableTokenRedemptionStepCount,\n      stableTokenRedemptionStep,\n      noFunction,\n      finishStableTokenRedemption\n    );\n\n    bytes32[] memory tasks = new bytes32[](2);\n    tasks[0] = DELEVERAGING_TASK;\n    tasks[1] = StableToken_REDEMPTION_TASK;\n\n    resetTaskGroupPointers(\n      SETTLEMENT_TASK,\n      tasks,\n      initializeSettlement,\n      finishSettlement,\n      true\n    );\n  }\n\n  function initializeContracts() internal {\n    stableToken = StableToken(connector.stableToken());\n    riskProxManager = MoCRiskProxManager(connector.riskProxManager());\n    mocState = IMoCState(connector.mocState());\n    mocExchange = IMoCExchange(connector.mocExchange());\n  }\n\n  function initializeValues(address _governor, uint256 _blockSpan) internal {\n    governor = IGovernor(_governor);\n    blockSpan = _blockSpan;\n    lastProcessedBlock = block.number;\n    initializeTasks();\n  }\n\n  modifier isTime() {\n    require(isSettlementEnabled(), \"Settlement not yet enabled\");\n    _;\n  }\n\n  /**************************************************/\n  /******************** TASKS ***********************/\n  /**************************************************/\n\n  /**\n  @dev Returns the amount of steps for the Deleveraging task\n  which is the amount of active RiskProx addresses\n*/\n  function deleveragingStepCount() internal view returns (uint256) {\n    return riskProxManager.getActiveAddressesCount(BUCKET_X2);\n  }\n\n  /**\n  @dev Returns the amount of steps for the StableToken Redemption task\n  which is the amount of redeem requests in the queue\n*/\n  function stableTokenRedemptionStepCount() internal view returns (uint256) {\n    // If Protected Mode is reached, DoCs in queue must not be redeemed until next settlement\n    if (mocState.globalCoverage() <= mocState.getProtected()) {\n      return 0;\n    }\n    return redeemQueueLength;\n  }\n\n  /**\n  @dev Freezes state for Settlement execution\n*/\n  function initializeSettlement() internal {\n    settlementInfo.leverage = mocState.leverage(BUCKET_X2);\n    settlementInfo.reservePrice = mocState.getReserveTokenPrice();\n    settlementInfo.riskProxPrice = mocState.bucketRiskProTecPrice(BUCKET_X2);\n    settlementInfo.startBlockNumber = block.number;\n\n    // Protected Mode\n    if (mocState.globalCoverage() <= mocState.getProtected()) {\n      settlementInfo.isProtectedMode = true;\n    } else {\n      settlementInfo.isProtectedMode = false;\n    }\n\n    settlementInfo.stableTokenRedeemCount = redeemQueueLength;\n    settlementInfo.deleveragingCount = riskProxManager.getActiveAddressesCount(\n      BUCKET_X2\n    );\n    settlementInfo.finalCommissionAmount = 0;\n    settlementInfo.partialCommissionAmount = 0;\n    settlementInfo.startBlockNumber = block.number;\n\n    // Reset total paid in MoC for every vendor\n    IMoCVendors mocVendors = IMoCVendors(mocState.getMoCVendors());\n    mocVendors.resetTotalPaidInMoC();\n\n    emit SettlementStarted(\n      settlementInfo.stableTokenRedeemCount,\n      settlementInfo.deleveragingCount,\n      settlementInfo.riskProxPrice,\n      settlementInfo.reservePrice\n    );\n  }\n\n  /**\n  @dev Execute final step of Settlement task group\n*/\n  function finishSettlement() internal {\n    lastProcessedBlock = lastProcessedBlock.add(blockSpan);\n    settlementInfo.finalCommissionAmount = settlementInfo\n    .partialCommissionAmount;\n    emit SettlementCompleted(settlementInfo.finalCommissionAmount);\n  }\n\n  /**\n  @dev Execute final step of Deleveraging task\n*/\n  function finishDeleveraging() internal {\n    emit SettlementDeleveraging(\n      settlementInfo.leverage,\n      settlementInfo.riskProxPrice,\n      settlementInfo.reservePrice,\n      settlementInfo.startBlockNumber\n    );\n\n    riskProxManager.emptyBucket(BUCKET_X2, BUCKET_C0);\n  }\n\n  /**\n  @dev Execute final step of StableTokenRedemption task\n*/\n  function finishStableTokenRedemption() internal {\n    emit SettlementRedeemStableToken(\n      settlementInfo.stableTokenRedeemCount,\n      settlementInfo.finalCommissionAmount,\n      settlementInfo.reservePrice\n    );\n\n    if (!settlementInfo.isProtectedMode) {\n      clear();\n    }\n  }\n\n  /**\n  @dev Individual Deleveraging step to be executed in partial execution\n  uint256 parameter needed for PartialExecution\n*/\n  function deleveragingStep(uint256) internal {\n    // We just pop the first element because the redemption always remove the address.\n    address payable userAddress = riskProxManager.getActiveAddresses(\n      BUCKET_X2\n    )[0];\n    uint256 riskProxBalance = riskProxManager.riskProxBalanceOf(\n      BUCKET_X2,\n      userAddress\n    );\n\n    // ReserveTokens sending could only fail if the receiving address\n    // executes code and reverts. If that happens, the user will lose\n    // his RiskProx and ReserveTokens will be kept in MoC.\n    mocExchange.forceRedeemRiskProx(\n      BUCKET_X2,\n      userAddress,\n      riskProxBalance,\n      settlementInfo.riskProxPrice\n    );\n  }\n\n  /**\n  @dev Individual StableTokenRedemption step to be executed in partial execution\n  @param index Step number currently in execution\n*/\n  function stableTokenRedemptionStep(uint256 index) internal {\n    (address payable redeemer, uint256 redeemAmount) = getRedeemRequestAt(\n      index\n    );\n    uint256 userStableTokenBalance = stableToken.balanceOf(redeemer);\n    uint256 amountToRedeem = Math.min(userStableTokenBalance, redeemAmount);\n    if (amountToRedeem > 0) {\n      (bool result, uint256 reserveTokenCommissionSpent) = mocExchange\n      .redeemStableTokenWithPrice(\n        redeemer,\n        amountToRedeem,\n        settlementInfo.reservePrice\n      );\n      // Redemption can fail if the receiving address is a contract\n      if (result) {\n        emit RedeemRequestProcessed(\n          redeemer,\n          reserveTokenCommissionSpent,\n          amountToRedeem\n        );\n        settlementInfo.partialCommissionAmount = settlementInfo\n        .partialCommissionAmount\n        .add(reserveTokenCommissionSpent);\n      }\n    }\n    UserRedeemRequest storage userReedem = redeemMapping[redeemer];\n    userReedem.activeRedeemer = false;\n    redeemQueue[index].amount = 0;\n  }\n\n  /**\n  @dev Create Task structures for Settlement execution\n*/\n  function initializeTasks() internal {\n    createTask(\n      DELEVERAGING_TASK,\n      deleveragingStepCount,\n      deleveragingStep,\n      noFunction,\n      finishDeleveraging\n    );\n    createTask(\n      StableToken_REDEMPTION_TASK,\n      stableTokenRedemptionStepCount,\n      stableTokenRedemptionStep,\n      noFunction,\n      finishStableTokenRedemption\n    );\n\n    bytes32[] memory tasks = new bytes32[](2);\n    tasks[0] = DELEVERAGING_TASK;\n    tasks[1] = StableToken_REDEMPTION_TASK;\n\n    createTaskGroup(\n      SETTLEMENT_TASK,\n      tasks,\n      initializeSettlement,\n      finishSettlement,\n      true\n    );\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n",
    "imports": [
        {
            "name": "MoCSettlement.sol",
            "contents": "\n// File: openzeppelin-solidity/contracts/math/Math.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n// File: zos-lib/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.6.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: contracts/base/MoCWhitelist.sol\n\npragma solidity 0.5.8;\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCWhitelist {\n  mapping(address => bool) whitelist;\n\n  /**\n   * @dev Check if an account is whitelisted\n   * @return Bool\n   */\n  function isWhitelisted(address account)\n    public\n    view\n    returns (bool)\n  {\n    require(account != address(0), \"Account must not be 0x0\");\n    return whitelist[account];\n  }\n\n  /**\n   * @dev Add account to whitelist\n   */\n  function add(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(!isWhitelisted(account), \"Account not allowed to add accounts into white list\");\n    whitelist[account] = true;\n  }\n\n  /**\n   * @dev Remove account from whitelist\n   */\n  function remove(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(isWhitelisted(account), \"Account is not allowed to remove address from the white list\");\n\n    whitelist[account] = false;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/base/MoCConnector.sol\n\npragma solidity 0.5.8;\n\n\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCConnector is MoCWhitelist, Initializable {\n  // References\n  address payable public moc;\n  address public stableToken;\n  address public riskProToken;\n  address public riskProxManager;\n  address public mocState;\n  address public mocConverter;\n  address public mocSettlement;\n  address public mocExchange;\n  address public mocInrate;\n  /** DEPRECATED mocBurnout **/\n  address public mocBurnout;\n  address public reserveToken;\n\n  bool internal initialized;\n\n  /**\n    @dev Initializes the contract\n    @param mocAddress MoC contract address\n    @param stableTokenAddress Stable token contract address\n    @param riskProAddress RiskPro token contract address\n    @param riskProxAddress RiskProxManager contract address\n    @param stateAddress MoCState contract address\n    @param settlementAddress MoCSettlement contract address\n    @param converterAddress MoCConverter contract address\n    @param exchangeAddress MoCExchange contract address\n    @param inrateAddress MoCInrate contract address\n    @param burnoutBookAddress (DEPRECATED) MoCBurnout contract address. DO NOT USE.\n    @param reserveTokenAddress Reserve token contract address\n  */\n  function initialize(\n    address payable mocAddress,\n    address stableTokenAddress,\n    address riskProAddress,\n    address riskProxAddress,\n    address stateAddress,\n    address settlementAddress,\n    address converterAddress,\n    address exchangeAddress,\n    address inrateAddress,\n    address burnoutBookAddress,\n    address reserveTokenAddress\n  ) public initializer {\n    moc = mocAddress;\n    stableToken = stableTokenAddress;\n    riskProToken = riskProAddress;\n    riskProxManager = riskProxAddress;\n    mocState = stateAddress;\n    mocSettlement = settlementAddress;\n    mocConverter = converterAddress;\n    mocExchange = exchangeAddress;\n    mocInrate = inrateAddress;\n    mocBurnout = burnoutBookAddress;\n    reserveToken = reserveTokenAddress;\n\n    // Add to Whitelist\n    add(mocAddress);\n    add(stableTokenAddress);\n    add(riskProAddress);\n    add(riskProxAddress);\n    add(stateAddress);\n    add(settlementAddress);\n    add(converterAddress);\n    add(exchangeAddress);\n    add(inrateAddress);\n    add(burnoutBookAddress);\n    add(reserveTokenAddress);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/base/MoCConstants.sol\n\npragma solidity 0.5.8;\n\n/**\n * @dev Defines special constants to use along all the MoC System\n */\ncontract MoCConstants {\n  bytes32 constant public BUCKET_X2 = \"X2\";\n  bytes32 constant public BUCKET_C0 = \"C0\";\n}\n\n// File: contracts/base/MoCBase.sol\n\npragma solidity 0.5.8;\n\n\n\n\n/**\n  @dev General usefull modifiers and functions\n */\ncontract MoCBase is MoCConstants, Initializable {\n  // Contracts\n  MoCConnector public connector;\n\n  bool internal initialized;\n\n  function initializeBase(address connectorAddress) internal initializer {\n    connector = MoCConnector(connectorAddress);\n  }\n\n  modifier onlyWhitelisted(address account) {\n    require(connector.isWhitelisted(account), \"Address is not whitelisted\");\n    _;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * > Note that this information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * `IERC20.balanceOf` and `IERC20.transfer`.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See `IERC20.approve`.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destoys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See `_burn` and `_approve`.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\n\n// File: openzeppelin-solidity/contracts/access/Roles.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\n// File: openzeppelin-solidity/contracts/access/roles/MinterRole.sol\n\npragma solidity ^0.5.0;\n\n\ncontract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(msg.sender), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Mintable.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @dev Extension of `ERC20` that adds a set of accounts with the `MinterRole`,\n * which have permission to mint (create) new tokens as they see fit.\n *\n * At construction, the deployer of the contract is the only minter.\n */\ncontract ERC20Mintable is ERC20, MinterRole {\n    /**\n     * @dev See `ERC20._mint`.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MinterRole`.\n     */\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: contracts/token/OwnerBurnableToken.sol\n\npragma solidity 0.5.8;\n\n\n\n/**\n * @title Owner Burnable Token\n * @dev Token that allows the owner to irreversibly burned (destroyed) any token.\n */\ncontract OwnerBurnableToken is Ownable, ERC20Mintable {\n  /**\n   * @dev Burns a specific amount of tokens for the address.\n   * @param who who's tokens are gona be burned\n   * @param value The amount of token to be burned.\n   */\n  function burn(address who, uint256 value) public onlyOwner {\n    _burn(who, value);\n  }\n}\n\n// File: contracts/token/StableToken.sol\n\npragma solidity 0.5.8;\n\n\n\ncontract StableToken is ERC20Detailed, OwnerBurnableToken {\n\n  string private _name = \"RIF Dollar on Chain\";\n  string private _symbol = \"RDOC\";\n  uint8 private _decimals = 18;\n\n  /**\n    @dev Constructor\n  */\n  constructor() Ownable() ERC20Detailed(_name, _symbol, _decimals) public {\n\n  }\n\n  /**\n    @dev Fallback function\n  */\n  function() external {\n  }\n}\n\n// File: contracts/interface/IMoCState.sol\n\npragma solidity 0.5.8;\n\ninterface IMoCState {\n\n     /******STATE MACHINE*********/\n    enum States {\n        // State 0\n        Liquidated,\n        // State 1\n        RiskProDiscount,\n        // State 2\n        BelowCobj,\n        // State 3\n        AboveCobj\n    }\n\n\n    function addToReserves(uint256 reserveAmount) external;\n\n    function substractFromReserves(uint256 reserveAmount) external;\n\n    function coverage(bytes32 bucket) external view returns(uint256);\n\n    function getReservesRemainder() external view returns(uint256);\n\n    function liq() external view returns(uint256);\n\n    function state() external view returns(States);\n\n    function peg() external view returns(uint256);\n\n    function dayBlockSpan() external view returns(uint256);\n\n    function getReserveTokenPrice() external view returns(uint256);\n\n    function getMoCPrice() external view returns(uint256);\n\n    function getProtected() external view returns(uint256);\n\n    function globalCoverage() external view returns(uint256);\n\n    function getMoCVendors() external view returns(address);\n\n    function getMoCToken() external view returns(address);\n\n    function nextState() external;\n\n    function maxRiskProWithDiscount() external view returns(uint256);\n\n    function absoluteMaxRiskPro() external view returns(uint256);\n\n    function absoluteMaxStableToken() external view returns(uint256);\n\n    function freeStableToken() external view returns(uint256);\n\n    function riskProTecPrice() external view returns(uint256);\n\n    function riskProSpotDiscountRate() external view returns(uint256);\n\n    function riskProDiscountPrice() external view returns(uint256);\n\n    function bucketRiskProTecPrice(bytes32 bucket) external view returns(uint256);\n\n    function currentAbundanceRatio() external view returns(uint256);\n\n    function abundanceRatio(uint256 stableToken0) external view returns(uint256);\n\n    function daysToSettlement() external view returns(uint256);\n\n    function leverage(bytes32 bucket) external view returns(uint256);\n\n    function getBucketNReserve(bytes32 bucket) external view returns(uint256);\n\n    function getLiquidationPrice() external view returns(uint256);\n\n    function maxRiskProxResTokenValue(bytes32 bucket) external view returns(uint256);\n\n    function bucketRiskProTecPriceHelper(bytes32 bucket) external view returns(uint256);\n}\n\n// File: contracts/interface/IMoCExchange.sol\n\npragma solidity 0.5.8;\n\ninterface IMoCExchange {\n    function getMoCTokenBalance(address owner, address spender) external view\n    returns (uint256 mocBalance, uint256 mocAllowance);\n\n    function mintRiskPro(address account, uint256 reserveAmount, address vendorAccount) external\n    returns (uint256, uint256, uint256, uint256, uint256);\n\n    function redeemRiskPro(address account, uint256 riskProAmount, address vendorAccount) external\n    returns (uint256, uint256, uint256, uint256, uint256);\n\n    function mintStableToken(address account, uint256 reserveToMint, address vendorAccount) external\n    returns (uint256, uint256, uint256, uint256, uint256);\n\n    function redeemRiskProx(address payable account, bytes32 bucket, uint256 riskProxAmount, address vendorAccount)\n    external returns (uint256, uint256, uint256, uint256, uint256);\n\n    function mintRiskProx(address payable account, bytes32 bucket, uint256 reserveToMint, address vendorAccount) external\n    returns (uint256, uint256, uint256, uint256, uint256);\n\n    function redeemFreeStableToken(address account, uint256 stableTokenAmount, address vendorAccount) external\n    returns (uint256, uint256, uint256, uint256, uint256);\n\n    function redeemAllStableToken(address origin, address payable destination) external\n    returns (uint256);\n\n    function convertToMoCPrice(uint256 reserveAmount) external view returns (uint256, uint256, uint256);\n\n    function forceRedeemRiskProx(bytes32 bucket, address payable account, uint256 riskProxAmount, uint256 riskProxPrice)\n    external returns (bool);\n\n    function redeemStableTokenWithPrice(address payable userAddress, uint256 amount, uint256 reservePrice) external\n    returns (bool, uint256);\n}\n\n// File: moc-governance/contracts/Governance/ChangeContract.sol\n\npragma solidity 0.5.8;\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n\n  /**\n    @notice Override this function with a recipe of the changes to be done when this ChangeContract\n    is executed\n   */\n  function execute() external;\n}\n\n// File: moc-governance/contracts/Governance/IGovernor.sol\n\npragma solidity 0.5.8;\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor{\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @dev This function should be protected somehow to only execute changes that\n    benefit the system. This decision process is independent of this architechture\n    therefore is independent of this interface too\n    @param changeContract Address of the contract that will execute the changes\n   */\n  function executeChange(ChangeContract changeContract) external;\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @param _changer Address of the contract that will execute the changes\n   */\n  function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n// File: moc-governance/contracts/Governance/Governed.sol\n\npragma solidity 0.5.8;\n\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed is Initializable {\n\n  /**\n    @notice The address of the contract which governs this one\n   */\n  IGovernor public governor;\n\n  string constant private NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n  /**\n    @notice Modifier that protects the function\n    @dev You should use this modifier in any function that should be called through\n    the governance system\n   */\n  modifier onlyAuthorizedChanger() {\n    require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n    _;\n  }\n\n  /**\n    @notice Initialize the contract with the basic settings\n    @dev This initialize replaces the constructor but it is not called automatically.\n    It is necessary because of the upgradeability of the contracts\n    @param _governor Governor address\n   */\n  function initialize(IGovernor _governor) public initializer {\n    governor = _governor;\n  }\n\n  /**\n    @notice Change the contract's governor. Should be called through the old governance system\n    @param newIGovernor New governor address\n   */\n  function changeIGovernor(IGovernor newIGovernor) public onlyAuthorizedChanger {\n    governor = newIGovernor;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/MoCBucketContainer.sol\n\npragma solidity 0.5.8;\n\n\n\n\n\n\ncontract MoCBucketContainer is MoCBase, Governed {\n  using SafeMath for uint256;\n  using Math for uint256;\n\n  struct RiskProxBalance {\n    uint256 value;\n    uint256 index; // Index start in 1, zero is reserved for NULL\n  }\n\n  struct MoCBucket {\n    bytes32 name;\n    bool isBase;\n    uint256 nStable;\n    uint256 nRiskPro;\n    uint256 nReserve;\n    uint256 cobj;\n    // Should only be used in X buckets\n    mapping(address => RiskProxBalance) riskProxBalances;\n    address payable[] activeBalances;\n    uint256 activeBalancesLength;\n    // Should only be used in Base buckets (C0)\n    uint256 inrateBag;\n    bool available;\n  }\n\n  event BucketMovement(\n    bytes32 from,\n    bytes32 to,\n    uint256 reserves,\n    uint256 stableTokens\n  );\n\n  event BucketCreation(\n    bytes32 name,\n    uint256 cobj\n  );\n\n  event BucketStateUpdate(\n    bytes32 name,\n    uint256 nReserve,\n    uint256 nStable,\n    uint256 nRiskProx,\n    uint256 inrateBag\n  );\n\n  mapping(bytes32 => MoCBucket) internal mocBuckets;\n\n  /**\n   GETTERS\n   */\n  function getBucketNReserve(bytes32 bucket) public view returns (uint256) {\n    return mocBuckets[bucket].nReserve;\n  }\n\n  function getBucketNRiskPro(bytes32 bucket) public view returns (uint256) {\n    return mocBuckets[bucket].nRiskPro;\n  }\n\n  function getBucketNStableToken(bytes32 bucket) public view returns (uint256) {\n    return mocBuckets[bucket].nStable;\n  }\n\n  function getBucketCobj(bytes32 bucket) public view returns (uint256) {\n    return mocBuckets[bucket].cobj;\n  }\n\n  function getInrateBag(bytes32 bucket) public view returns (uint256) {\n    return mocBuckets[bucket].inrateBag;\n  }\n\n  /**\n   * @dev Sets the objective coverage (cobj) on an specficied bucket.\n   * @param  _bucket - name of the bucket\n   * @param  _cobj - new value of cobj\n   */\n  function setBucketCobj(bytes32 _bucket, uint256 _cobj) public onlyAuthorizedChanger() {\n    //TODO: It is necessary to analyze the impact in the model it has when changing X2. This\n    mocBuckets[_bucket].cobj = _cobj;\n  }\n\n  /**\n    @dev returns true if the bucket is a base bucket\n    @param bucket Name of the bucket\n  **/\n  function isBucketBase(bytes32 bucket) public view returns (bool) {\n    return mocBuckets[bucket].isBase;\n  }\n\n  /**\n    @dev returns true if the bucket have stableTokens in it\n    @param bucket Name of the bucket\n  **/\n  function isBucketEmpty(bytes32 bucket) public view returns (bool) {\n    return mocBuckets[bucket].nStable == 0;\n  }\n\n  /**\n    @dev Returns all the address that currently have riskProx position for this bucket\n    @param bucket bucket of the active address\n  */\n  function getActiveAddresses(bytes32 bucket) public view returns (address payable[] memory) {\n    return mocBuckets[bucket].activeBalances;\n  }\n\n  /**\n    @dev Returns all the address that currently have riskProx position for this bucket\n    @param bucket bucket of the active address\n  */\n  function getActiveAddressesCount(bytes32 bucket) public view returns (uint256 count) {\n    return mocBuckets[bucket].activeBalancesLength;\n  }\n\n  /**\n    @dev Add values to all variables of the bucket\n    @param bucketName Name of the bucket\n    @param reserveTokens ReserveToken amount [using reservePrecision]\n    @param stableToken StableToken amount [using mocPrecision]\n    @param riskProx RiskProx amount [using mocPrecision]\n  */\n  function addValuesToBucket(bytes32 bucketName, uint256 reserveTokens, uint256 stableToken, uint256 riskProx)\n  public onlyWhitelisted(msg.sender) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    bucket.nReserve = bucket.nReserve.add(reserveTokens);\n    bucket.nStable = bucket.nStable.add(stableToken);\n    bucket.nRiskPro = bucket.nRiskPro.add(riskProx);\n  }\n\n  /**\n    @dev Substract values to all variables of the bucket\n    @param bucketName Name of the bucket\n    @param reserve ReserveToken amount [using reservePrecision]\n    @param stableToken StableToken amount [using mocPrecision]\n    @param riskProx RiskProx amount [using mocPrecision]\n  */\n  function substractValuesFromBucket(bytes32 bucketName, uint256 reserve, uint256 stableToken, uint256 riskProx)\n  public onlyWhitelisted(msg.sender) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    bucket.nReserve = bucket.nReserve.sub(reserve);\n    bucket.nStable = bucket.nStable.sub(stableToken);\n    bucket.nRiskPro = bucket.nRiskPro.sub(riskProx);\n  }\n\n  /**\n    @dev Moves ReserveTokens from inrateBag to main ReserveTokens bucket bag\n    @param bucketName Name of the bucket to operate\n    @param amount value to move from inrateBag to main bag [using reservePrecision]\n   */\n  function deliverInrate(bytes32 bucketName, uint256 amount) public\n   onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) bucketStateUpdate(bucketName) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    uint256 toMove = Math.min(bucket.inrateBag, amount);\n\n    bucket.inrateBag = bucket.inrateBag.sub(toMove);\n    bucket.nReserve = bucket.nReserve.add(toMove);\n  }\n\n  /**\n    @dev Removes Interests rate from Inrate bag\n    @param bucketName Name of the bucket to operate\n    @param amount value to move from inrateBag to main bag [using reservePrecision]\n    @return Retrieved value\n   */\n  function recoverInrate(bytes32 bucketName, uint256 amount) public\n  onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) bucketStateUpdate(bucketName) returns(uint256) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    uint256 toRetrieve = Math.min(bucket.inrateBag, amount);\n\n    bucket.inrateBag = bucket.inrateBag.sub(toRetrieve);\n\n    return toRetrieve;\n  }\n\n  /**\n    @dev Moves ReserveTokens from origin bucket to destination bucket inrateBag\n    @param bucketName name of the bucket to from which takes\n    @param reserveAmount value to add to main bag [using reservePrecision]\n  */\n  function payInrate(bytes32 bucketName, uint256 reserveAmount) public\n  onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n    bucket.inrateBag = bucket.inrateBag.add(reserveAmount);\n  }\n\n  /**\n    @dev Move ReserveTokens and StableTokens from one bucket to another\n    @param from Name of bucket from where the ReserveTokens will be removed\n    @param to Name of bucket from where the ReserveTokens will be added\n    @param reserve ReserveTokens amount [using reservePrecision]\n    @param stableTokens StableTokens amount [using mocPrecision]\n  **/\n  function moveResTokensAndStableTokens(bytes32 from, bytes32 to, uint256 reserve, uint256 stableTokens) public\n  onlyWhitelisted(msg.sender) bucketStateUpdate(from) bucketStateUpdate(to) {\n    MoCBucket storage bucketFrom = mocBuckets[from];\n    MoCBucket storage bucketTo = mocBuckets[to];\n\n    bucketFrom.nReserve = bucketFrom.nReserve.sub(reserve);\n    bucketTo.nReserve = bucketTo.nReserve.add(reserve);\n\n    bucketFrom.nStable = bucketFrom.nStable.sub(stableTokens);\n    bucketTo.nStable = bucketTo.nStable.add(stableTokens);\n\n    emit BucketMovement(from, to, reserve, stableTokens);\n  }\n\n  /**\n    @dev Clears completely the origin bucket, removing all StableTokens, ReserveTokens and riskProxs\n    @param toLiquidate Bucket to be cleared out\n    @param destination Bucket that will receive the StableTokens and ReserveTokens\n   */\n  function liquidateBucket(bytes32 toLiquidate, bytes32 destination) public onlyWhitelisted(msg.sender) {\n    require(!isBucketBase(toLiquidate), \"Cannot liquidate a base bucket\");\n\n    clearBucketBalances(toLiquidate);\n    emptyBucket(toLiquidate, destination);\n  }\n\n  /**\n    @dev Clears StableTokens and ReserveTokens from bucket origin and sends them to destination bucket\n    @param origin Bucket to clear out\n    @param destination Destination bucket\n  **/\n  function emptyBucket(bytes32 origin, bytes32 destination) public onlyWhitelisted(msg.sender) {\n    moveResTokensAndStableTokens(origin, destination, mocBuckets[origin].nReserve, mocBuckets[origin].nStable);\n  }\n\n  /**\n   * @dev checks if a bucket exists\n   * @param bucket name of the bucket\n   */\n  function isAvailableBucket(bytes32 bucket) public view returns (bool) {\n    return mocBuckets[bucket].available;\n  }\n\n  /**\n    @dev Put all bucket RiskProx balances in zero\n    @param bucketName Bucket to clear out\n   */\n  function clearBucketBalances(bytes32 bucketName) public onlyWhitelisted(msg.sender) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n    bucket.nRiskPro = 0;\n    bucket.activeBalancesLength = 0;\n  }\n\n  /**\n    @dev Creates bucket\n    @param name Name of the bucket\n    @param cobj Target Coverage of the bucket\n    @param isBase Indicates if it is a base bucket (true) or not (false)\n  */\n  function createBucket(bytes32 name, uint256 cobj, bool isBase) internal {\n    mocBuckets[name].name = name;\n    mocBuckets[name].nStable = 0;\n    mocBuckets[name].nRiskPro = 0;\n    mocBuckets[name].nReserve = 0;\n    mocBuckets[name].cobj = cobj;\n    mocBuckets[name].isBase = isBase;\n    mocBuckets[name].available = true;\n    emit BucketCreation(name, cobj);\n  }\n\n  modifier onlyBaseBucket(bytes32 bucket) {\n    require(isBucketBase(bucket), \"Bucket should be a base type bucket\");\n    _;\n  }\n\n  modifier bucketStateUpdate(bytes32 bucket) {\n    _;\n    emit BucketStateUpdate(\n      bucket,\n      mocBuckets[bucket].nReserve,\n      mocBuckets[bucket].nStable,\n      mocBuckets[bucket].nRiskPro,\n      mocBuckets[bucket].inrateBag\n    );\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/MoCRiskProxManager.sol\n\npragma solidity 0.5.8;\n\n\n\n\n\ncontract MoCRiskProxManager is MoCBucketContainer {\n  using SafeMath for uint256;\n  uint256 constant MIN_ALLOWED_BALANCE = 0;\n\n  function initialize(address connectorAddress, address _governor, uint256 _c0Cobj, uint256 _x2Cobj) public initializer {\n    initializeBase(connectorAddress);\n    initializeValues(_governor);\n    createBucket(BUCKET_C0, _c0Cobj, true);\n    createBucket(BUCKET_X2, _x2Cobj, false);\n  }\n\n  /**\n    @dev returns user balance\n    @param bucket RiskProx corresponding bucket to get balance from\n    @param userAddress user address to get balance from\n    @return total balance for the userAddress\n  */\n  function riskProxBalanceOf(bytes32 bucket, address userAddress) public view returns (uint256) {\n    RiskProxBalance memory userBalance = mocBuckets[bucket].riskProxBalances[userAddress];\n    if (!hasValidBalance(bucket, userAddress, userBalance.index)) return 0;\n    return userBalance.value;\n  }\n\n  /**\n    @dev verifies that this user has assigned balance for the given bucket\n    @param bucket corresponding Leveraged bucket to get balance from\n    @param userAddress user address to verify balance for\n    @param index index, starting from 1, where the address of the user is being kept\n    @return true if the user has assigned balance\n  */\n  function hasValidBalance(bytes32 bucket, address userAddress, uint256 index) public view returns (bool) {\n    return (index != 0) && (index <= getActiveAddressesCount(bucket)) && (mocBuckets[bucket].activeBalances[index - 1] == userAddress);\n  }\n\n  /**\n    @dev  Assigns the amount of RiskProx\n    @param bucket bucket from which the RiskProx will be removed\n    @param account user address to redeem for\n    @param riskProxAmount riskProx amount to redeem [using mocPresicion]\n    @param totalCost ReserveToken value of riskProxAmount [using reservePrecision]\n  */\n  function assignRiskProx(bytes32 bucket, address payable account, uint256 riskProxAmount, uint256 totalCost)\n    public\n    onlyWhitelisted(msg.sender)\n  {\n    uint256 currentBalance = riskProxBalanceOf(bucket, account);\n\n    setRiskProxBalanceOf(bucket, account, currentBalance.add(riskProxAmount));\n    addValuesToBucket(bucket, totalCost, 0, riskProxAmount);\n  }\n\n  /**\n    @dev  Removes the amount of RiskProx and substract ReserveTokens from bucket\n    @param bucket bucket from which the RiskProx will be removed\n    @param userAddress user address to redeem for\n    @param riskProxAmount riskProx amount to redeem [using mocPresicion]\n    @param totalCost reserveToken value of riskProxAmount [using reservePrecision]\n  */\n  function removeRiskProx(bytes32 bucket, address payable userAddress, uint256 riskProxAmount, uint256 totalCost)\n    public\n    onlyWhitelisted(msg.sender)\n  {\n    uint256 currentBalance = riskProxBalanceOf(bucket, userAddress);\n\n    setRiskProxBalanceOf(bucket, userAddress, currentBalance.sub(riskProxAmount));\n    substractValuesFromBucket(bucket, totalCost, 0, riskProxAmount);\n  }\n\n  /**\n    @dev Sets the amount of RiskProx\n    @param bucket bucket from which the RiskProx will be setted\n    @param userAddress user address to redeem for\n    @param value riskProx amount to redeem [using mocPresicion]\n  */\n  function setRiskProxBalanceOf(bytes32 bucket, address payable userAddress, uint256 value) public onlyWhitelisted(msg.sender) {\n    mocBuckets[bucket].riskProxBalances[userAddress].value = value;\n\n    uint256 index = mocBuckets[bucket].riskProxBalances[userAddress].index;\n    if (!hasValidBalance(bucket, userAddress, index)) index = 0;\n\n    bool hasBalance = value > MIN_ALLOWED_BALANCE;\n    // The address is not in the array\n    if (index == 0) {\n      if (hasBalance) {\n        if (mocBuckets[bucket].activeBalances.length == mocBuckets[bucket].activeBalancesLength) {\n          mocBuckets[bucket].activeBalances.length += 1;\n        }\n        uint256 currentIndex = mocBuckets[bucket].activeBalancesLength++;\n        mocBuckets[bucket].activeBalances[currentIndex] = userAddress;\n        mocBuckets[bucket].riskProxBalances[userAddress].index = mocBuckets[bucket].activeBalancesLength;\n      }\n    } else {\n      if (!hasBalance) {\n        // We need to delete this address from the tracker\n        uint256 lastActiveIndex = mocBuckets[bucket].activeBalancesLength;\n        address payable keyToMove = mocBuckets[bucket].activeBalances[lastActiveIndex - 1];\n        mocBuckets[bucket].activeBalances[index - 1] = keyToMove;\n        // Alternative index and array decreases lenght to prevent gas limit\n        mocBuckets[bucket].activeBalancesLength--;\n        // Update moved key index\n        mocBuckets[bucket].riskProxBalances[keyToMove].index = index;\n        // Disable empty account index (0 == NULL)\n        mocBuckets[bucket].riskProxBalances[userAddress].index = 0;\n      }\n    }\n  }\n\n  /**\n   * @dev intializes values of the contract\n   */\n  function initializeValues(address _governor) internal {\n    governor = IGovernor(_governor);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/PartialExecution.sol\n\npragma solidity 0.5.8;\n\n\n\n\ncontract PartialExecutionData {\n  enum ExecutionState {Ready, Running, Finished}\n\n  struct TaskGroup {\n    bytes32 id;\n    ExecutionState state;\n    bytes32[] subTasks;\n    function() internal onStart;\n    function() internal onFinish;\n    bool autoRestart;\n  }\n\n  struct Task {\n    bytes32 id;\n    function() internal returns (uint256) getStepCount;\n    function(uint256) internal stepFunction;\n    function() internal onStart;\n    function() internal onFinish;\n    uint256 currentStep;\n    uint256 stepCount;\n    ExecutionState state;\n  }\n}\n\n\n/**\n  @dev Brings basic data structures and functions for partial execution.\n  The main data structures are:\n    Task: Represents a function that needs to be executed by steps.\n    TaskGroup: Represents a function that contains several functions that needs to be executed by steps.\n  Tasks and Tasks groups can be executed specifying the amount of steps to run.\n*/\ncontract PartialExecution is PartialExecutionData {\n  using SafeMath for uint256;\n  using Math for uint256;\n  mapping(bytes32 => Task) internal tasks;\n  mapping(bytes32 => TaskGroup) internal taskGroups;\n\n  /**\n   @dev Auxiliar function for tasks with no onFinish function\n */\n  function noFunction() internal {}\n\n\n  /**\n   @dev Reset pointers a task group\n   @param _groupId Id of the task group\n   @param _subtasks Tasks to execute when executing the task group\n   @param _onFinish Function to execute when all tasks of the group are completed\n */\n  function resetTaskGroupPointers(\n    bytes32 _groupId,\n    bytes32[] memory _subtasks,\n    function() _onStart,\n    function() _onFinish,\n    bool _autoRestart\n  ) internal {\n    taskGroups[_groupId].id = _groupId;\n    taskGroups[_groupId].subTasks = _subtasks;\n    taskGroups[_groupId].onStart = _onStart;\n    taskGroups[_groupId].onFinish = _onFinish;\n    taskGroups[_groupId].autoRestart = _autoRestart;\n\n  }\n\n  /**\n   @dev Creates a task\n   @param taskId Id of the task\n   @param _getStepCount Function executed before starting the task\n   Should return the step count of the execution\n   @param _stepFunction Function to execute at each step\n   @param _onStart Function to execute before task execution\n   @param _onFinish Function to execute when all steps are completed\n */\n  function resetTaskPointers(\n    bytes32 taskId,\n    function() internal returns (uint256) _getStepCount,\n    function(uint256) internal _stepFunction,\n    function() internal _onStart,\n    function() internal _onFinish\n  ) internal {\n    tasks[taskId].id = taskId;\n    tasks[taskId].getStepCount = _getStepCount;\n    tasks[taskId].stepFunction = _stepFunction;\n    tasks[taskId].onStart = _onStart;\n    tasks[taskId].onFinish = _onFinish;\n  }\n\n\n\n  /**\n   @dev Creates a task group\n   @param _groupId Id of the task group\n   @param _subtasks Tasks to execute when executing the task group\n   @param _onFinish Function to execute when all tasks of the group are completed\n */\n  function createTaskGroup(\n    bytes32 _groupId,\n    bytes32[] memory _subtasks,\n    function() _onStart,\n    function() _onFinish,\n    bool _autoRestart\n  ) internal {\n    taskGroups[_groupId].id = _groupId;\n    taskGroups[_groupId].subTasks = _subtasks;\n    taskGroups[_groupId].onStart = _onStart;\n    taskGroups[_groupId].onFinish = _onFinish;\n    taskGroups[_groupId].state = ExecutionState.Ready;\n    taskGroups[_groupId].autoRestart = _autoRestart;\n  }\n\n  /**\n   @dev Creates a task\n   @param taskId Id of the task\n   @param _getStepCount Function executed before starting the task\n   Should return the step count of the execution\n   @param _stepFunction Function to execute at each step\n   @param _onStart Function to execute before task execution\n   @param _onFinish Function to execute when all steps are completed\n */\n  function createTask(\n    bytes32 taskId,\n    function() internal returns (uint256) _getStepCount,\n    function(uint256) internal _stepFunction,\n    function() internal _onStart,\n    function() internal _onFinish\n  ) internal {\n    tasks[taskId].id = taskId;\n    tasks[taskId].getStepCount = _getStepCount;\n    tasks[taskId].stepFunction = _stepFunction;\n    tasks[taskId].onStart = _onStart;\n    tasks[taskId].onFinish = _onFinish;\n    tasks[taskId].state = ExecutionState.Ready;\n  }\n\n  /**\n   @dev Executes all tasks of the group in order using the step count passed as parameter\n   @param groupId Id of the task group\n   @param stepCount Step count to execute\n */\n  function executeGroup(bytes32 groupId, uint256 stepCount) internal {\n    TaskGroup storage group = taskGroups[groupId];\n\n    if (group.state == ExecutionState.Ready) {\n      group.onStart();\n      group.state = ExecutionState.Running;\n    }\n\n    uint256 leftSteps = stepCount;\n\n    for (uint256 i = 0; i < group.subTasks.length && leftSteps > 0; i++) {\n      uint256 consumed = executeTask(group.subTasks[i], leftSteps);\n      leftSteps = leftSteps.sub(consumed);\n    }\n\n    if (groupFinished(groupId)) {\n      group.state = ExecutionState.Finished;\n      group.onFinish();\n      if (group.autoRestart) {\n        resetGroup(groupId);\n      }\n    }\n  }\n\n  /**\n   @dev Creates a task\n   @param taskId Id of the task\n   @param steps Step count to execute\n   @return The amount of steps consumed in the execution\n */\n  function executeTask(bytes32 taskId, uint256 steps)\n  internal\n  returns (uint256)\n  {\n    Task storage task = tasks[taskId];\n    uint256 initialStep = task.currentStep;\n\n    if (task.state == ExecutionState.Finished) {\n      // No execution\n      return 0;\n    }\n    if (task.state == ExecutionState.Ready) {\n      task.stepCount = task.getStepCount();\n      task.onStart();\n      task.state = ExecutionState.Running;\n    }\n    if (task.state == ExecutionState.Running) {\n      uint256 endStep = Math.min(\n        task.currentStep.add(steps),\n        task.stepCount\n      );\n\n      for (\n        task.currentStep;\n        task.currentStep < endStep;\n        task.currentStep++\n      ) {\n        task.stepFunction(task.currentStep);\n      }\n\n      if (task.currentStep == task.stepCount) {\n        task.state = ExecutionState.Finished;\n        task.onFinish();\n      }\n    }\n\n    return task.currentStep.sub(initialStep);\n  }\n\n  /**\n   @dev Put task in Ready to run state and reset currentStep value\n   @param taskId Id of the task\n */\n  function resetTask(bytes32 taskId) internal {\n    tasks[taskId].state = ExecutionState.Ready;\n    tasks[taskId].currentStep = 0;\n  }\n\n  /**\n  @dev Reset all tasks in a group. Used at the completion of a task group execution\n  @param groupId Id of the task group\n*/\n  function resetTasks(bytes32 groupId) internal {\n    TaskGroup storage group = taskGroups[groupId];\n\n    for (uint256 i = 0; i < group.subTasks.length; i++) {\n      resetTask(group.subTasks[i]);\n    }\n  }\n\n  /**\n  @dev Set if a Group should be automatically set to Ready state\n  after Finnished State is reached\n  @param groupId Id of the task group\n*/\n  function setAutoRestart(bytes32 groupId, bool _autoRestart) internal {\n    taskGroups[groupId].autoRestart = _autoRestart;\n  }\n\n  /**\n  @dev Set Group in Ready state. Reset all sub-task.\n  @param groupId Id of the task group\n*/\n  function resetGroup(bytes32 groupId) internal {\n    TaskGroup storage group = taskGroups[groupId];\n    group.state = ExecutionState.Ready;\n\n    resetTasks(groupId);\n  }\n\n  /**\n   @dev Returns true if the last task of the group was completed\n   @param groupId Id of the task group\n   @return boolean\n */\n  function groupFinished(bytes32 groupId) internal view returns (bool) {\n    TaskGroup storage group = taskGroups[groupId];\n    bytes32 taskId = group.subTasks[group.subTasks.length.sub(1)];\n    Task storage lastTask = tasks[taskId];\n\n    return lastTask.state == ExecutionState.Finished;\n  }\n\n  /**\n   @dev Returns true if the group is currently un Running state\n   @param groupId Id of the task group\n   @return boolean\n */\n  function isGroupRunning(bytes32 groupId) internal view returns (bool) {\n    return taskGroups[groupId].state == ExecutionState.Running;\n  }\n\n  /**\n   @dev Returns true if the group is currently in Ready state\n   @param groupId Id of the task group\n   @return boolean\n */\n  function isGroupReady(bytes32 groupId) internal view returns (bool) {\n    return taskGroups[groupId].state == ExecutionState.Ready;\n  }\n\n  /**\n   @dev Returns true if the task is currently un Running state\n   @param taskId Id of the task\n   @return boolean\n */\n  function isTaskRunning(bytes32 taskId) internal view returns (bool) {\n    return tasks[taskId].state == ExecutionState.Running;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/interface/IMoCVendors.sol\n\npragma solidity 0.5.8;\n\ninterface IMoCVendors {\n    function resetTotalPaidInMoC() external;\n\n    function getIsActive(address account) external view\n    returns (bool);\n\n    function getTotalPaidInMoC(address account) external view\n    returns (uint256);\n\n    function getStaking(address account) external view\n    returns (uint256);\n\n    function getMarkup(address account) external view\n    returns (uint256);\n\n    function updatePaidMarkup(address account, uint256 mocAmount, uint256 reserveAmount, uint256 totalMoCAmount) external;\n}\n\n// File: contracts/interface/IMoCSettlement.sol\n\npragma solidity 0.5.8;\n\ninterface IMoCSettlement {\n    function getRedeemRequestAt(uint256 _index) external view returns (address payable, uint256);\n\n    function redeemQueueSize() external view returns (uint256);\n\n    function stableTokenAmountToRedeem(address _who) external view returns (uint256);\n\n    function addRedeemRequest(uint256 amount, address payable redeemer) external;\n\n    function alterRedeemRequestAmount(bool isAddition, uint256 delta, address redeemer) external;\n\n    function isSettlementEnabled() external view returns (bool);\n\n    function runSettlement(uint256 steps) external returns (uint256);\n\n    function isSettlementReady() external view returns (bool);\n\n    function nextSettlementBlock() external view returns (uint256);\n}\n\n// File: contracts/MoCSettlement.sol\n\npragma solidity 0.5.8;\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract MoCSettlementEvents {\n  event RedeemRequestAlter(address indexed redeemer, bool isAddition, uint256 delta);\n  event RedeemRequestProcessed(address indexed redeemer, uint256 commission, uint256 amount);\n  event SettlementRedeemStableToken(uint256 queueSize, uint256 accumCommissions, uint256 reservePrice);\n  event SettlementDeleveraging(uint256 leverage, uint256 riskProxPrice, uint256 reservePrice, uint256 startBlockNumber);\n  event SettlementStarted(\n    uint256 stableTokenRedeemCount,\n    uint256 deleveragingCount,\n    uint256 riskProxPrice,\n    uint256 reservePrice\n  );\n  event SettlementCompleted(uint256 commissionsPayed);\n}\n\ncontract MoCSettlement is\nMoCSettlementEvents,\nMoCBase,\nPartialExecution,\nGoverned,\nIMoCSettlement\n{\n  using Math for uint256;\n  using SafeMath for uint256;\n\n  bytes32 public constant StableToken_REDEMPTION_TASK = keccak256(\"StableTokenRedemption\");\n  bytes32 public constant DELEVERAGING_TASK = keccak256(\"Deleveraging\");\n  bytes32 public constant SETTLEMENT_TASK = keccak256(\"Settlement\");\n\n  struct RedeemRequest {\n    address payable who;\n    uint256 amount;\n  }\n\n  struct UserRedeemRequest {\n    uint256 index;\n    bool activeRedeemer;\n  }\n\n  // All necessary data for Settlement execution\n  struct SettlementInfo {\n    uint256 reservePrice;\n    uint256 riskProxPrice;\n    uint256 stableTokenRedeemCount;\n    uint256 deleveragingCount;\n    uint256 riskProxAmount;\n    uint256 partialCommissionAmount;\n    uint256 finalCommissionAmount;\n    uint256 leverage;\n    uint256 startBlockNumber;\n    bool isProtectedMode;\n  }\n\n  // Contracts\n  IMoCState internal mocState;\n  IMoCExchange internal mocExchange;\n  StableToken internal stableToken;\n  MoCRiskProxManager internal riskProxManager;\n\n  /**\n  @dev Block Number of the last successful execution\n  */\n  uint256 internal lastProcessedBlock;\n  /**\n  @dev Min number of blocks settlement should be re evaluated on\n  */\n  uint256 internal blockSpan;\n  /**\n  @dev Information for Settlement execution\n  */\n  SettlementInfo internal settlementInfo;\n  /**\n  @dev Redeem queue\n  */\n  RedeemRequest[] private redeemQueue;\n  mapping(address => UserRedeemRequest) private redeemMapping;\n  uint256 private redeemQueueLength;\n\n  /**\n    @dev Initializes the contract\n    @param connectorAddress MoCConnector contract address\n    @param _governor Governor contract address\n    @param _blockSpan Blockspan configuration blockspan of settlement\n  */\n  function initialize(\n    address connectorAddress,\n    address _governor,\n    uint256 _blockSpan\n  ) public initializer {\n    initializeBase(connectorAddress);\n    initializeContracts();\n    initializeValues(_governor, _blockSpan);\n  }\n\n  /**\n   *  @dev Set the blockspan configuration blockspan of settlement\n   */\n  function setBlockSpan(uint256 bSpan) public onlyAuthorizedChanger() {\n    blockSpan = bSpan;\n  }\n\n  /**\n   *  @dev Set Settlement to be kept in finnished state after\n   *  all execution is completed.\n   */\n  function setSettlementToStall() public onlyAuthorizedChanger() {\n    setAutoRestart(SETTLEMENT_TASK, false);\n  }\n\n  /**\n   *  @dev Set Settlement state to Ready\n   */\n  function restartSettlementState() public onlyAuthorizedChanger() {\n    resetGroup(SETTLEMENT_TASK);\n    setAutoRestart(SETTLEMENT_TASK, true);\n  }\n\n  /**\n    @dev Gets the RedeemRequest at the queue index position\n    @param _index queue position to get\n    @return redeemer's address and amount he submitted\n  */\n  function getRedeemRequestAt(uint256 _index)\n  public\n  view\n  withinBoundaries(_index)\n  returns (address payable, uint256)\n  {\n    return (redeemQueue[_index].who, redeemQueue[_index].amount);\n  }\n\n  /**\n    @dev Gets the number of blocks the settlemnet will be allowed to run\n  */\n  function getBlockSpan() public view returns (uint256) {\n    return blockSpan;\n  }\n\n  /**\n    @dev Verify that the index is smaller than the length of the redeem request queue\n    @param _index queue position to get\n  */\n  modifier withinBoundaries(uint256 _index) {\n    require(_index < redeemQueueLength, \"Index out of boundaries\");\n    _;\n  }\n\n  /**\n    @dev returns current redeem queue size\n  */\n  function redeemQueueSize() public view returns (uint256) {\n    return redeemQueueLength;\n  }\n\n  /**\n    @dev Returns true if blockSpan number of blocks has pass since last execution\n  */\n  function isSettlementEnabled() public view returns (bool) {\n    return nextSettlementBlock() <= block.number;\n  }\n\n  /**\n    @dev Returns true if the settlment is running\n  */\n  function isSettlementRunning() public view returns (bool) {\n    return isGroupRunning(SETTLEMENT_TASK);\n  }\n\n  /**\n    @dev Returns true if the settlment is ready\n  */\n  function isSettlementReady() public view returns (bool) {\n    return isGroupReady(SETTLEMENT_TASK);\n  }\n\n  /**\n    @dev Returns the next block from which settlement is possible\n  */\n  function nextSettlementBlock() public view returns (uint256) {\n    return lastProcessedBlock.add(blockSpan);\n  }\n\n  /**\n    @dev returns the total amount of StableTokens in the redeem queue for _who\n    @param _who address for which ^ is computed\n    @return total amount of StableTokens in the redeem queue for _who [using mocPrecision]\n  */\n  function stableTokenAmountToRedeem(address _who) public view returns (uint256) {\n    if (!redeemMapping[_who].activeRedeemer) {\n      return 0;\n    }\n\n    uint256 indexRedeem = redeemMapping[_who].index;\n    RedeemRequest memory redeemRequest = redeemQueue[indexRedeem];\n    return redeemRequest.amount;\n  }\n\n  /**\n    @dev push a new redeem request to the queue for the sender or updates the amount if the user has a redeem request\n    @param amount amount he is willing to redeem [using mocPrecision]\n    @param redeemer redeemer address\n  */\n  function addRedeemRequest(uint256 amount, address payable redeemer)\n  public\n  onlyWhitelisted(msg.sender)\n  {\n    if (!redeemMapping[redeemer].activeRedeemer) {\n      if (redeemQueueLength == redeemQueue.length) {\n        redeemQueue.length += 1;\n      }\n      uint256 index = redeemQueueLength;\n      redeemQueue[redeemQueueLength++] = RedeemRequest(redeemer, amount);\n      redeemMapping[redeemer] = UserRedeemRequest(index, true);\n      emit RedeemRequestAlter(redeemer, true, amount);\n    } else {\n      alterRedeemRequestAmount(true, amount, redeemer);\n    }\n  }\n\n  /**\n    @dev empty the queue\n  */\n  function clear() public onlyWhitelisted(msg.sender) {\n    redeemQueueLength = 0;\n  }\n\n  /**\n    @dev Alters the redeem amount position for the redeemer\n    @param isAddition true if adding amount to redeem, false to substract.\n    @param delta the amount to add/substract to current position [using mocPrecision]\n    @param redeemer address to alter amount for\n    @return the filled amount [using mocPrecision]\n  */\n  function alterRedeemRequestAmount(\n    bool isAddition,\n    uint256 delta,\n    address redeemer\n  ) public onlyWhitelisted(msg.sender) {\n    require(\n      redeemMapping[redeemer].activeRedeemer,\n      \"This is not an active redeemer\"\n    );\n    uint256 indexRedeem = redeemMapping[redeemer].index;\n    RedeemRequest storage redeemRequest = redeemQueue[indexRedeem];\n    require(redeemRequest.who == redeemer, \"Not allowed redeemer\");\n    uint256 actualDelta = delta;\n    if (isAddition) {\n      redeemRequest.amount = redeemRequest.amount.add(delta);\n    } else {\n      if (redeemRequest.amount < delta) {\n        actualDelta = redeemRequest.amount;\n        redeemRequest.amount = 0;\n      } else {\n        redeemRequest.amount = redeemRequest.amount.sub(delta);\n      }\n    }\n    emit RedeemRequestAlter(redeemer, isAddition, actualDelta);\n  }\n\n  /**\n    @dev Runs settlement process in steps\n    @param steps Amount of steps to run\n    @return The commissions collected in the executed steps\n  */\n  function runSettlement(uint256 steps)\n  public\n  onlyWhitelisted(msg.sender)\n  isTime()\n  returns (uint256)\n  {\n    executeGroup(SETTLEMENT_TASK, steps);\n\n    return settlementInfo.finalCommissionAmount;\n  }\n\n  /**\n  @dev Create Task structures for Settlement execution\n  */\n  function fixTasksPointer() public {\n    resetTaskPointers(\n      DELEVERAGING_TASK,\n      deleveragingStepCount,\n      deleveragingStep,\n      noFunction,\n      finishDeleveraging\n    );\n    resetTaskPointers(\n      StableToken_REDEMPTION_TASK,\n      stableTokenRedemptionStepCount,\n      stableTokenRedemptionStep,\n      noFunction,\n      finishStableTokenRedemption\n    );\n\n    bytes32[] memory tasks = new bytes32[](2);\n    tasks[0] = DELEVERAGING_TASK;\n    tasks[1] = StableToken_REDEMPTION_TASK;\n\n    resetTaskGroupPointers(\n      SETTLEMENT_TASK,\n      tasks,\n      initializeSettlement,\n      finishSettlement,\n      true\n    );\n  }\n\n  function initializeContracts() internal {\n    stableToken = StableToken(connector.stableToken());\n    riskProxManager = MoCRiskProxManager(connector.riskProxManager());\n    mocState = IMoCState(connector.mocState());\n    mocExchange = IMoCExchange(connector.mocExchange());\n  }\n\n  function initializeValues(address _governor, uint256 _blockSpan) internal {\n    governor = IGovernor(_governor);\n    blockSpan = _blockSpan;\n    lastProcessedBlock = block.number;\n    initializeTasks();\n  }\n\n  modifier isTime() {\n    require(isSettlementEnabled(), \"Settlement not yet enabled\");\n    _;\n  }\n\n  /**************************************************/\n  /******************** TASKS ***********************/\n  /**************************************************/\n\n  /**\n  @dev Returns the amount of steps for the Deleveraging task\n  which is the amount of active RiskProx addresses\n*/\n  function deleveragingStepCount() internal view returns (uint256) {\n    return riskProxManager.getActiveAddressesCount(BUCKET_X2);\n  }\n\n  /**\n  @dev Returns the amount of steps for the StableToken Redemption task\n  which is the amount of redeem requests in the queue\n*/\n  function stableTokenRedemptionStepCount() internal view returns (uint256) {\n    // If Protected Mode is reached, DoCs in queue must not be redeemed until next settlement\n    if (mocState.globalCoverage() <= mocState.getProtected()) {\n      return 0;\n    }\n    return redeemQueueLength;\n  }\n\n  /**\n  @dev Freezes state for Settlement execution\n*/\n  function initializeSettlement() internal {\n    settlementInfo.leverage = mocState.leverage(BUCKET_X2);\n    settlementInfo.reservePrice = mocState.getReserveTokenPrice();\n    settlementInfo.riskProxPrice = mocState.bucketRiskProTecPrice(BUCKET_X2);\n    settlementInfo.startBlockNumber = block.number;\n\n    // Protected Mode\n    if (mocState.globalCoverage() <= mocState.getProtected()) {\n      settlementInfo.isProtectedMode = true;\n    } else {\n      settlementInfo.isProtectedMode = false;\n    }\n\n    settlementInfo.stableTokenRedeemCount = redeemQueueLength;\n    settlementInfo.deleveragingCount = riskProxManager.getActiveAddressesCount(\n      BUCKET_X2\n    );\n    settlementInfo.finalCommissionAmount = 0;\n    settlementInfo.partialCommissionAmount = 0;\n    settlementInfo.startBlockNumber = block.number;\n\n    // Reset total paid in MoC for every vendor\n    IMoCVendors mocVendors = IMoCVendors(mocState.getMoCVendors());\n    mocVendors.resetTotalPaidInMoC();\n\n    emit SettlementStarted(\n      settlementInfo.stableTokenRedeemCount,\n      settlementInfo.deleveragingCount,\n      settlementInfo.riskProxPrice,\n      settlementInfo.reservePrice\n    );\n  }\n\n  /**\n  @dev Execute final step of Settlement task group\n*/\n  function finishSettlement() internal {\n    lastProcessedBlock = lastProcessedBlock.add(blockSpan);\n    settlementInfo.finalCommissionAmount = settlementInfo\n    .partialCommissionAmount;\n    emit SettlementCompleted(settlementInfo.finalCommissionAmount);\n  }\n\n  /**\n  @dev Execute final step of Deleveraging task\n*/\n  function finishDeleveraging() internal {\n    emit SettlementDeleveraging(\n      settlementInfo.leverage,\n      settlementInfo.riskProxPrice,\n      settlementInfo.reservePrice,\n      settlementInfo.startBlockNumber\n    );\n\n    riskProxManager.emptyBucket(BUCKET_X2, BUCKET_C0);\n  }\n\n  /**\n  @dev Execute final step of StableTokenRedemption task\n*/\n  function finishStableTokenRedemption() internal {\n    emit SettlementRedeemStableToken(\n      settlementInfo.stableTokenRedeemCount,\n      settlementInfo.finalCommissionAmount,\n      settlementInfo.reservePrice\n    );\n\n    if (!settlementInfo.isProtectedMode) {\n      clear();\n    }\n  }\n\n  /**\n  @dev Individual Deleveraging step to be executed in partial execution\n  uint256 parameter needed for PartialExecution\n*/\n  function deleveragingStep(uint256) internal {\n    // We just pop the first element because the redemption always remove the address.\n    address payable userAddress = riskProxManager.getActiveAddresses(\n      BUCKET_X2\n    )[0];\n    uint256 riskProxBalance = riskProxManager.riskProxBalanceOf(\n      BUCKET_X2,\n      userAddress\n    );\n\n    // ReserveTokens sending could only fail if the receiving address\n    // executes code and reverts. If that happens, the user will lose\n    // his RiskProx and ReserveTokens will be kept in MoC.\n    mocExchange.forceRedeemRiskProx(\n      BUCKET_X2,\n      userAddress,\n      riskProxBalance,\n      settlementInfo.riskProxPrice\n    );\n  }\n\n  /**\n  @dev Individual StableTokenRedemption step to be executed in partial execution\n  @param index Step number currently in execution\n*/\n  function stableTokenRedemptionStep(uint256 index) internal {\n    (address payable redeemer, uint256 redeemAmount) = getRedeemRequestAt(\n      index\n    );\n    uint256 userStableTokenBalance = stableToken.balanceOf(redeemer);\n    uint256 amountToRedeem = Math.min(userStableTokenBalance, redeemAmount);\n    if (amountToRedeem > 0) {\n      (bool result, uint256 reserveTokenCommissionSpent) = mocExchange\n      .redeemStableTokenWithPrice(\n        redeemer,\n        amountToRedeem,\n        settlementInfo.reservePrice\n      );\n      // Redemption can fail if the receiving address is a contract\n      if (result) {\n        emit RedeemRequestProcessed(\n          redeemer,\n          reserveTokenCommissionSpent,\n          amountToRedeem\n        );\n        settlementInfo.partialCommissionAmount = settlementInfo\n        .partialCommissionAmount\n        .add(reserveTokenCommissionSpent);\n      }\n    }\n    UserRedeemRequest storage userReedem = redeemMapping[redeemer];\n    userReedem.activeRedeemer = false;\n    redeemQueue[index].amount = 0;\n  }\n\n  /**\n  @dev Create Task structures for Settlement execution\n*/\n  function initializeTasks() internal {\n    createTask(\n      DELEVERAGING_TASK,\n      deleveragingStepCount,\n      deleveragingStep,\n      noFunction,\n      finishDeleveraging\n    );\n    createTask(\n      StableToken_REDEMPTION_TASK,\n      stableTokenRedemptionStepCount,\n      stableTokenRedemptionStep,\n      noFunction,\n      finishStableTokenRedemption\n    );\n\n    bytes32[] memory tasks = new bytes32[](2);\n    tasks[0] = DELEVERAGING_TASK;\n    tasks[1] = StableToken_REDEMPTION_TASK;\n\n    createTaskGroup(\n      SETTLEMENT_TASK,\n      tasks,\n      initializeSettlement,\n      finishSettlement,\n      true\n    );\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n",
            "file": "MoCSettlement.sol"
        }
    ],
    "libraries": {
        "MoCHelperLib": "0x280a61eFa0bAaE2eD0F91e403376953640c28C8e"
    },
    "creationData": {
        "blockHash": "0x1f2de58888dd7fd5e17e2c8eba82b2adcef45644cbece0ac8e820236195801db",
        "blockNumber": 1840960,
        "transactionHash": "0x6d16316c42aeef7d906b6f3edbd8037f95cb214cfca679e32fb119fe7544ef9c",
        "timestamp": 1620932728
    }
}