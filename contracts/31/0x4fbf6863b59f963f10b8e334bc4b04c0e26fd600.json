{
  "address": "0x4fbf6863b59f963f10b8e334bc4b04c0e26fd600",
  "net": {
    "id": "31",
    "name": "RSK Testnet"
  },
  "name": "TheForceLending",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "metadata",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ]
      }
    }
  },
  "version": "0.4.24+commit.e67f0147",
  "source": "/**\r\n *Submitted for verification at Etherscan.io on 2019-09-26\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2019-09-20\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2019-09-17\r\n*/\r\npragma solidity ^0.4.24;\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) pure internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) pure internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) pure internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\ncontract EIP20Interface {\r\n    /* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n    // solhint-disable-next-line no-simple-event-func-name\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract ErrorReporter {\r\n\r\n    /**\r\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\r\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\r\n      **/\r\n    event Failure(string name, uint error);\r\n\r\n    enum Error {\r\n        NO_ERROR,\r\n        INVALIDE_ADMIN,\r\n        WITHDRAW_TOKEN_AMOUNT_ERROR,\r\n        WITHDRAW_TOKEN_TRANSER_ERROR,\r\n        TOKEN_INSUFFICIENT_ALLOWANCE,\r\n        TOKEN_INSUFFICIENT_BALANCE,\r\n        TRANSFER_FROM_ERROR,\r\n        LENDER_INSUFFICIENT_BORROW_ALLOWANCE,\r\n        LENDER_INSUFFICIENT_BORROWER_BALANCE,\r\n        LENDER_TRANSFER_FROM_BORROW_ERROR,\r\n        LENDER_INSUFFICIENT_ADMIN_ALLOWANCE,\r\n        LENDER_INSUFFICIENT_ADMIN_BALANCE,\r\n        LENDER_TRANSFER_FROM_ADMIN_ERROR,\r\n        CALL_MARGIN_ALLOWANCE_ERROR,\r\n        CALL_MARGIN_BALANCE_ERROR,\r\n        CALL_MARGIN_TRANSFER_ERROR,\r\n        REPAY_ALLOWANCE_ERROR,\r\n        REPAY_BALANCE_ERROR,\r\n        REPAY_TX_ERROR,\r\n        FORCE_REPAY_ALLOWANCE_ERROR,\r\n        FORCE_REPAY_BALANCE_ERROR,\r\n        FORCE_REPAY_TX_ERROR,\r\n        CLOSE_POSITION_ALLOWANCE_ERROR,\r\n        CLOSE_POSITION_TX_ERROR,\r\n        CLOSE_POSITION_MUST_ADMIN_BEFORE_DEADLINE,\r\n        CLOSE_POSITION_MUST_ADMIN_OR_LENDER_AFTER_DEADLINE,\r\n        LENDER_TEST_TRANSFER_ADMIN_ERROR,\r\n        LENDER_TEST_TRANSFER_BORROWR_ERROR,\r\n        LENDER_TEST_TRANSFERFROM_ADMIN_ERROR,\r\n        LENDER_TEST_TRANSFERFROM_BORROWR_ERROR,\r\n        SEND_TOKEN_AMOUNT_ERROR,\r\n        SEND_TOKEN_TRANSER_ERROR,\r\n        DEPOSIT_TOKEN,\r\n        CANCEL_ORDER,\r\n        REPAY_ERROR,\r\n        FORCE_REPAY_ERROR,\r\n        LENDER_SEND_ETH_ERROR,\r\n        REPAY_SEND_ETH_ERROR,\r\n        FORCE_REPAY_SEND_ETH_ERROR\r\n    }\r\n\r\n    /**\r\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\r\n      */\r\n    function fail(string name, Error err) internal returns (uint) {\r\n        emit Failure(name, uint(err));\r\n\r\n        return uint(err);\r\n    }\r\n}\r\n\r\nlibrary ERC20AsmFn {\r\n\r\n    function isContract(address addr)view internal {\r\n        assembly {\r\n            if iszero(extcodesize(addr)) { revert(0, 0) }\r\n        }\r\n    }\r\n\r\n    function handleReturnData()pure internal returns (bool result) {\r\n        assembly {\r\n            switch returndatasize()\r\n            case 0 { // not a std erc20\r\n                result := 1\r\n            }\r\n            case 32 { // std erc20\r\n                returndatacopy(0, 0, 32)\r\n                result := mload(0)\r\n            }\r\n            default { // anything else, should revert for safety\r\n                revert(0, 0)\r\n            }\r\n        }\r\n    }\r\n\r\n    function asmTransfer(address _erc20Addr, address _to, uint256 _value) internal returns (bool result) {\r\n\r\n        // Must be a contract addr first!\r\n        isContract(_erc20Addr);\r\n\r\n        // call return false when something wrong\r\n        require(_erc20Addr.call(bytes4(keccak256(\"transfer(address,uint256)\")), _to, _value), \"asmTransfer error\");\r\n\r\n        // handle returndata\r\n        return handleReturnData();\r\n    }\r\n\r\n    function asmTransferFrom(address _erc20Addr, address _from, address _to, uint256 _value) internal returns (bool result) {\r\n\r\n        // Must be a contract addr first!\r\n        isContract(_erc20Addr);\r\n\r\n        // call return false when something wrong\r\n        require(_erc20Addr.call(bytes4(keccak256(\"transferFrom(address,address,uint256)\")), _from, _to, _value), \"asmTransferFrom error\");\r\n\r\n        // handle returndata\r\n        return handleReturnData();\r\n    }\r\n\r\n}\r\n\r\ncontract TheForceLending is SafeMath, ErrorReporter {\r\n  using ERC20AsmFn for EIP20Interface;\r\n\r\n  enum OrderState {\r\n    ORDER_STATUS_PENDING,\r\n    ORDER_STATUS_ACCEPTED\r\n  }\r\n\r\n  struct Order_t {\r\n    bytes32 partner_id;\r\n    uint deadline;\r\n    OrderState state;\r\n\r\n    address borrower;\r\n    address lender;\r\n\r\n    uint lending_cycle;\r\n\r\n    address token_get;\r\n    uint amount_get;\r\n\r\n    address token_pledge;//tokenGive\r\n    uint amount_pledge;//amountGive\r\n\r\n    uint _nonce;\r\n\r\n    uint pledge_rate;\r\n    uint interest_rate;\r\n    uint fee_rate;\r\n  }\r\n\r\n  address public admin; //the admin address\r\n  address public offcialFeeAccount; //the account that will receive fees\r\n\r\n   mapping (bytes32 => address) public partnerAccounts;// bytes32-> address, eg: platformA->0xa{40}, platfromB->0xb{40}\r\n   mapping (bytes32 => mapping (address => mapping (address => uint))) public partnerTokens;// platform->tokenContract->address->balance\r\n   mapping (bytes32 => mapping (address => mapping (bytes32 => Order_t))) public partnerOrderBook;// platform->address->hash->order_t\r\n   mapping (bytes32 => mapping (address => bytes32[])) partnerOrderHash;\r\n\r\n  function numHash(bytes32 partnerId, address usr) public view returns (uint) {\r\n      return partnerOrderHash[partnerId][usr].length;\r\n  }\r\n\r\n  function listHash(bytes32 partnerId, address usr) public view returns (bytes32[]) {\r\n      return partnerOrderHash[partnerId][usr];\r\n  }\r\n\r\n  event Borrow(bytes32 partnerId,\r\n                address tokenGet,\r\n                  uint amountGet,\r\n                  address tokenGive,\r\n                  uint amountGive,\r\n                  uint nonce,\r\n                  uint lendingCycle,\r\n                  uint pledgeRate,\r\n                  uint interestRate,\r\n                  uint feeRate,\r\n                  address user,\r\n                  bytes32 hash,\r\n                  uint status);\r\n  event Lend(bytes32 partnerId, bytes32 lenderPartnerId, address borrower, bytes32 txId, address token, uint amount, address give);//txId为借款单txId\r\n  event CancelOrder(bytes32 partnerId, address borrower, bytes32 txId, address by);//取消借款单，只能被borrower或者合约取消\r\n  event Callmargin(bytes32 partnerId, address borrower, bytes32 txId, address token, uint amount, address by);\r\n  event Repay(bytes32 partnerId, address borrower, bytes32 txId, address token, uint amount, address by);\r\n  event Closepstion(bytes32 partnerId, address borrower, bytes32 txId, address token, address by);\r\n  event Forcerepay(bytes32 partnerId, address borrower, bytes32 txId, address token, address by);\r\n  event Deposit(bytes32 partnerId, address token, address user, uint256 amount, uint256 balance);\r\n  event SendEth(bytes32 partnerId, address token, address user, uint256 amount, uint256 balance);\r\n\r\n  constructor(address admin_, address offcialFeeAccount_) public {\r\n    admin = admin_;\r\n    offcialFeeAccount = offcialFeeAccount_;\r\n  }\r\n\r\n  function() public payable {\r\n    revert(\"fallback can't be payable\");\r\n }\r\n\r\n  modifier onlyAdmin() {\r\n    require(msg.sender == admin, \"only admin can do this!\");\r\n    _;\r\n  }\r\n\r\n  function changeAdmin(address admin_) public onlyAdmin {\r\n    admin = admin_;\r\n  }\r\n\r\n  function changeFeeAccount(address offcialFeeAccount_) public onlyAdmin {\r\n    offcialFeeAccount = offcialFeeAccount_;\r\n  }\r\n\r\n  //增\r\n  function addPartner(bytes32 partnerId, address partner) public onlyAdmin {\r\n    require(partnerAccounts[partnerId] == address(0), \"already exists!\");\r\n    partnerAccounts[partnerId] = partner;\r\n  }\r\n\r\n  //删\r\n  function delPartner(bytes32 partnerId) public onlyAdmin {\r\n    delete partnerAccounts[partnerId];\r\n  }\r\n\r\n  //改\r\n  function modPartner(bytes32 partnerId, address partner) public onlyAdmin {\r\n    require(partnerAccounts[partnerId] != address(0), \"not exists!\");\r\n    partnerAccounts[partnerId] = partner;\r\n  }\r\n\r\n  //查\r\n  function getPartner(bytes32 partnerId) public view returns (address) {\r\n    return partnerAccounts[partnerId];\r\n  }\r\n  \r\n  //充值ETH\r\n  function deposit(bytes32 partnerId) public payable  {\r\n    partnerTokens[partnerId][address(0)][msg.sender] = safeAdd(partnerTokens[partnerId][address(0)][msg.sender], msg.value);\r\n    emit Deposit(partnerId, address(0), msg.sender, msg.value, partnerTokens[partnerId][address(0)][msg.sender]);\r\n  }\r\n\r\n  function sendEth(bytes32 partnerId, address dst, address token, uint256 amount) internal returns (bool success) {\r\n    if (token != 0) revert(\"invalid token address!\");\r\n    if (partnerTokens[partnerId][token][msg.sender] < amount) revert(\"invalid amount\");//lend时，dst没有eth，所以取消判断\r\n    partnerTokens[partnerId][token][msg.sender] = safeSub(partnerTokens[partnerId][token][msg.sender], amount);\r\n    dst.transfer(amount);\r\n\r\n    emit SendEth(partnerId, token, dst, amount, partnerTokens[partnerId][token][msg.sender]);\r\n    return true;\r\n  }\r\n\r\n\r\n  function depositToken(bytes32 partnerId, address token, uint amount) internal returns (uint){\r\n    //remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\r\n    require(partnerAccounts[partnerId] != address(0), \"parnerId must add first\");\r\n\r\n    if (token == 0) revert(\"invalid token address!\");\r\n\r\n    if (EIP20Interface(token).allowance(msg.sender, address(this)) < amount) {\r\n        return uint(Error.TOKEN_INSUFFICIENT_ALLOWANCE);\r\n    }\r\n    \r\n    if (EIP20Interface(token).balanceOf(msg.sender) < amount) {\r\n        return uint(Error.TOKEN_INSUFFICIENT_ALLOWANCE);\r\n    }\r\n\r\n    if (!EIP20Interface(token).asmTransferFrom(msg.sender, address(this), amount)) {\r\n        return uint(Error.TRANSFER_FROM_ERROR);\r\n    }\r\n    partnerTokens[partnerId][token][msg.sender] = safeAdd(partnerTokens[partnerId][token][msg.sender], amount);\r\n  \r\n    return 0;\r\n  }\r\n\r\n  function withdrawToken(bytes32 partnerId, address token, uint amount) internal returns (uint) {\r\n    require(partnerAccounts[partnerId] != address(0), \"parnerId must add first\");\r\n\r\n    if (token == 0) revert(\"invalid token address\");\r\n    if (partnerTokens[partnerId][token][msg.sender] < amount) {\r\n        return uint(Error.WITHDRAW_TOKEN_AMOUNT_ERROR);\r\n    }\r\n    partnerTokens[partnerId][token][msg.sender] = safeSub(partnerTokens[partnerId][token][msg.sender], amount);\r\n    if (!EIP20Interface(token).asmTransfer(msg.sender, amount)) {\r\n        return uint(Error.WITHDRAW_TOKEN_TRANSER_ERROR);\r\n    }\r\n    return 0;\r\n  }\r\n  \r\n  function sendToken(bytes32 partnerId, address token, address to, uint amount) internal returns (uint) {\r\n    require(partnerAccounts[partnerId] != address(0), \"parnerId must add first\");\r\n\r\n    if (token==0 || to == 0 || amount == 0) revert(\"invalid token address or amount\");\r\n    if (partnerTokens[partnerId][token][to] < amount) {\r\n        return uint(Error.SEND_TOKEN_AMOUNT_ERROR);\r\n    }\r\n    partnerTokens[partnerId][token][to] = safeSub(partnerTokens[partnerId][token][to], amount);\r\n    if (!EIP20Interface(token).asmTransfer(to, amount)) {\r\n        return uint(Error.SEND_TOKEN_TRANSER_ERROR);\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  function balanceOf(bytes32 partnerId, address token, address user) public view returns (uint) {\r\n    return partnerTokens[partnerId][token][user];\r\n  }\r\n\r\n  function borrow(bytes32 partnerId,//平台标记\r\n                  address tokenGet, //借出币种地址\r\n                  uint amountGet, //借出币种数量\r\n                  address tokenGive, //抵押币种地址\r\n                  uint amountGive,//抵押币种数量\r\n                  uint nonce,\r\n                  uint lendingCycle,\r\n                  uint pledgeRate,\r\n                  uint interestRate,\r\n                  uint feeRate) public payable returns (uint){\r\n    require(partnerAccounts[partnerId] != address(0), \"parnerId must add first\");\r\n    bytes32 txid = hash(partnerId, tokenGet, amountGet, tokenGive, amountGive, nonce, lendingCycle, pledgeRate, interestRate, feeRate);\r\n    require(partnerOrderBook[partnerId][msg.sender][txid].borrower == address(0), \"order already exists\");\r\n\r\n    uint status = 0;\r\n\r\n    partnerOrderBook[partnerId][msg.sender][txid] = Order_t({\r\n      partner_id: partnerId,\r\n      deadline: 0,\r\n      state: OrderState.ORDER_STATUS_PENDING,\r\n      borrower: msg.sender,\r\n      lender: address(0),\r\n      lending_cycle: lendingCycle,\r\n      token_get: tokenGet,\r\n      amount_get: amountGet,\r\n      token_pledge: tokenGive,\r\n      amount_pledge: amountGive,\r\n      _nonce: nonce,\r\n      pledge_rate: pledgeRate,\r\n      interest_rate: interestRate,\r\n      fee_rate: feeRate\r\n    });\r\n    \r\n    partnerOrderHash[partnerId][msg.sender].push(txid);\r\n\r\n    if (tokenGive != 0) {\r\n        require(msg.value == 0, \"msg.value must be zero for non eth give\");\r\n    \tstatus = depositToken(partnerId, tokenGive, amountGive);\r\n    } else {\r\n      //deposit eth\r\n      require(amountGive == msg.value, \"amountGive must equal msg.value\");\r\n      deposit(partnerId);\r\n    }\r\n    if (status != 0) {\r\n      return fail(\"borrow\", Error.DEPOSIT_TOKEN);\r\n    }\r\n\r\n    emit Borrow(partnerId, tokenGet, amountGet, tokenGive, amountGive, nonce, lendingCycle, pledgeRate, interestRate, feeRate, msg.sender, txid, status);\r\n    return 0;\r\n  }\r\n\r\n  //A借款，B出借，A到账数量为申请数量，无砍头息，B出借的数量包括A的申请数量+手续费(项目方手续费+平台合作方手续费，手续费可能为0)\r\n  function lend(bytes32 partnerId, bytes32 lenderPartnerId, address borrower, bytes32 hash, address token, uint lenderAmount, uint offcialFeeAmount, uint partnerFeeAmount) public payable returns (uint) {\r\n    require(partnerAccounts[partnerId] != address(0), \"parnerId must add first\");\r\n    require(partnerAccounts[lenderPartnerId] != address(0), \"lenderPartnerId must add first\");\r\n\r\n    require(partnerOrderBook[partnerId][borrower][hash].borrower != address(0), \"order not found\");//order not found\r\n    require(partnerOrderBook[partnerId][borrower][hash].borrower != msg.sender, \"cannot lend to self\");//cannot lend to self\r\n    require(partnerOrderBook[partnerId][borrower][hash].token_get == token, \"attempt to use an invalid type of token\");//attempt to use an invalid type of token\r\n    require(partnerOrderBook[partnerId][borrower][hash].amount_get == lenderAmount - offcialFeeAmount - partnerFeeAmount, \"amount_get != amount - offcialFeeAmount - partnerFeeAmount\");//单个出借金额不足，后续可以考虑多个出借人，现在只考虑一个出借人\r\n    require(partnerOrderBook[partnerId][borrower][hash].state == OrderState.ORDER_STATUS_PENDING, \"state != OrderState.ORDER_STATUS_PENDING\");\r\n\r\n    if (token != 0) {\r\n        require(msg.value == 0, \"msg.value must be zero for non eth lend\");\r\n        if (EIP20Interface(token).allowance(msg.sender, address(this)) < lenderAmount) {\r\n            return fail(\"lend\", Error.TOKEN_INSUFFICIENT_ALLOWANCE);\r\n        }\r\n        if (EIP20Interface(token).balanceOf(msg.sender) < lenderAmount) {\r\n            return fail(\"lend\", Error.LENDER_INSUFFICIENT_BORROWER_BALANCE);\r\n        }\r\n        if (!EIP20Interface(token).asmTransferFrom(msg.sender, partnerOrderBook[partnerId][borrower][hash].borrower, partnerOrderBook[partnerId][borrower][hash].amount_get)) {\r\n            return fail(\"lend\", Error.LENDER_TRANSFER_FROM_BORROW_ERROR);\r\n        }\r\n\r\n        if (offcialFeeAmount != 0) {\r\n          if (EIP20Interface(token).allowance(msg.sender, address(this)) < offcialFeeAmount) {\r\n              return fail(\"lend\", Error.LENDER_INSUFFICIENT_ADMIN_ALLOWANCE);\r\n          }\r\n          if (EIP20Interface(token).balanceOf(msg.sender) < offcialFeeAmount) {\r\n              return fail(\"lend\", Error.LENDER_INSUFFICIENT_ADMIN_BALANCE);\r\n          }\r\n          if (!EIP20Interface(token).asmTransferFrom(msg.sender, offcialFeeAccount, offcialFeeAmount)) {\r\n              return fail(\"lend\", Error.LENDER_TRANSFER_FROM_ADMIN_ERROR);\r\n          }\r\n        }\r\n\r\n\t    if (partnerFeeAmount != 0) {\r\n\t      if (EIP20Interface(token).allowance(msg.sender, address(this)) < partnerFeeAmount) {\r\n\t          return fail(\"lend\", Error.LENDER_INSUFFICIENT_ADMIN_ALLOWANCE);\r\n\t      }\r\n\t      if (EIP20Interface(token).balanceOf(msg.sender) < partnerFeeAmount) {\r\n\t          return fail(\"lend\", Error.LENDER_INSUFFICIENT_ADMIN_BALANCE);\r\n\t      }\r\n\t      if (!EIP20Interface(token).asmTransferFrom(msg.sender, partnerAccounts[lenderPartnerId], partnerFeeAmount)) {\r\n\t          return fail(\"lend\", Error.LENDER_TRANSFER_FROM_ADMIN_ERROR);\r\n\t      }\r\n\t    }\r\n    } else {\r\n        require(lenderAmount == msg.value, \"lenderAmount must be msg.value\");\r\n        deposit(lenderPartnerId);\r\n        if (!sendEth(lenderPartnerId, partnerOrderBook[partnerId][borrower][hash].borrower, token, partnerOrderBook[partnerId][borrower][hash].amount_get)) {\r\n            return fail(\"lend\", Error.LENDER_SEND_ETH_ERROR);\r\n        }\r\n        if (!sendEth(lenderPartnerId, partnerAccounts[lenderPartnerId], token, partnerFeeAmount)) {\r\n                return fail(\"lend\", Error.LENDER_SEND_ETH_ERROR);\r\n        }\r\n        if (!sendEth(lenderPartnerId, offcialFeeAccount, token, offcialFeeAmount)) {\r\n            return fail(\"lend\", Error.LENDER_SEND_ETH_ERROR);\r\n        }\r\n    }\r\n\r\n    partnerOrderBook[partnerId][borrower][hash].deadline = now + partnerOrderBook[partnerId][borrower][hash].lending_cycle * (1 minutes);\r\n    partnerOrderBook[partnerId][borrower][hash].lender = msg.sender;\r\n    partnerOrderBook[partnerId][borrower][hash].state = OrderState.ORDER_STATUS_ACCEPTED;\r\n\r\n    emit Lend(partnerId, lenderPartnerId, borrower, hash, token, lenderAmount, msg.sender);\r\n    return 0;\r\n  }\r\n\r\n  function cancelOrder(bytes32 partnerId, address borrower, bytes32 hash) public {\r\n    require(partnerAccounts[partnerId] != address(0), \"parnerId must add first\");\r\n    \r\n    require(partnerOrderBook[partnerId][borrower][hash].borrower != address(0), \"order not found\");//order not found\r\n    require(partnerOrderBook[partnerId][borrower][hash].borrower == msg.sender || msg.sender == admin,\r\n      \"only borrower or admin can do this operation\");//only borrower or contract can do this operation\r\n    require(partnerOrderBook[partnerId][borrower][hash].state == OrderState.ORDER_STATUS_PENDING, \"state != OrderState.ORDER_STATUS_PENDING\");\r\n    uint status = 1;\r\n    \r\n    if (partnerOrderBook[partnerId][borrower][hash].token_pledge != 0) {\r\n    \tstatus = sendToken(partnerId, partnerOrderBook[partnerId][borrower][hash].token_pledge, partnerOrderBook[partnerId][borrower][hash].borrower, partnerOrderBook[partnerId][borrower][hash].amount_pledge);\r\n    } else {\r\n        bool ok = sendEth(partnerId, partnerOrderBook[partnerId][borrower][hash].borrower, partnerOrderBook[partnerId][borrower][hash].token_pledge, partnerOrderBook[partnerId][borrower][hash].amount_pledge);\r\n        if (ok) {\r\n            status = 0;\r\n        }\r\n    }\r\n\r\n    if (status == 0) {\r\n        delete partnerOrderBook[partnerId][borrower][hash];\r\n\t    emit CancelOrder(partnerId, borrower, hash, msg.sender);\r\n    } else {\r\n    \tfail(\"cancelOrder\", Error.CANCEL_ORDER);\r\n    }\r\n  }\r\n\r\n  function callmargin(bytes32 partnerId, address borrower, bytes32 hash, address token, uint amount) public payable returns (uint){\r\n    require(partnerAccounts[partnerId] != address(0), \"parnerId must add first\");\r\n\r\n    require(partnerOrderBook[partnerId][borrower][hash].borrower != address(0), \"order not found\");\r\n    require(amount > 0, \"amount must >0\");\r\n\r\n    require(partnerOrderBook[partnerId][borrower][hash].state == OrderState.ORDER_STATUS_ACCEPTED, \"state != OrderState.ORDER_STATUS_ACCEPTED\");\r\n    require(partnerOrderBook[partnerId][borrower][hash].token_pledge == token, \"invalid pledge token\");\r\n\r\n    if (token != 0) {\r\n        require(msg.value == 0, \"msg.value must be zero for non eth callmargin\");\r\n        if (EIP20Interface(token).allowance(msg.sender, address(this)) < amount) {\r\n            return fail(\"callmargin\", Error.CALL_MARGIN_ALLOWANCE_ERROR);\r\n        }\r\n        \r\n        partnerOrderBook[partnerId][borrower][hash].amount_pledge += amount;\r\n        partnerTokens[partnerId][token][borrower] = safeAdd(partnerTokens[partnerId][token][borrower], amount);\r\n        \r\n        if (EIP20Interface(token).balanceOf(msg.sender) < amount) {\r\n            return fail(\"callmargin\", Error.CALL_MARGIN_BALANCE_ERROR);\r\n        }\r\n\r\n        if (!EIP20Interface(token).asmTransferFrom(msg.sender, address(this), amount)) {\r\n            return fail(\"callmargin\", Error.CALL_MARGIN_TRANSFER_ERROR);\r\n        }\r\n    } else {\r\n        require(amount == msg.value, \"amount must equal msg.value\");\r\n        partnerOrderBook[partnerId][borrower][hash].amount_pledge += amount;\r\n        partnerTokens[partnerId][token][borrower] = safeAdd(partnerTokens[partnerId][token][borrower], amount);\r\n    }\r\n\r\n    emit Callmargin(partnerId, borrower, hash, token, amount, msg.sender);\r\n    return 0;\r\n  }\r\n\r\n  //A还款，需要支付本金+利息给出借方，给项目方和平台合作方手续费\r\n  function repay(bytes32 partnerId, address borrower, bytes32 hash, address token, uint repayAmount, uint lenderAmount, uint offcialFeeAmount, uint partnerFeeAmount) public payable returns (uint){\r\n    require(partnerAccounts[partnerId] != address(0), \"parnerId must add first\");\r\n\r\n    require(partnerOrderBook[partnerId][borrower][hash].borrower != address(0), \"order not found\");\r\n    require(partnerOrderBook[partnerId][borrower][hash].state == OrderState.ORDER_STATUS_ACCEPTED, \"state != OrderState.ORDER_STATUS_ACCEPTED\");\r\n    //require(token != address(0), \"invalid token\");\r\n    require(token == partnerOrderBook[partnerId][borrower][hash].token_get, \"invalid repay token\");\r\n    //还款数量，为借款数量加上利息加上项目方手续费+合作方手续费\r\n    require(repayAmount == lenderAmount + offcialFeeAmount + partnerFeeAmount, \"invalid repay amount\");\r\n    require(lenderAmount >= partnerOrderBook[partnerId][borrower][hash].amount_get, \"invalid lender amount\");\r\n    require(msg.sender == partnerOrderBook[partnerId][borrower][hash].borrower, \"invalid repayer, must be borrower\");\r\n    uint status = 1;\r\n\r\n    if (token != address(0)) {\r\n        //允许contract花费借款者的所借的token+利息token\r\n        if (EIP20Interface(token).allowance(msg.sender, address(this)) < repayAmount) {\r\n            return fail(\"repay\", Error.REPAY_ALLOWANCE_ERROR);\r\n        }\r\n        \r\n        if (EIP20Interface(token).balanceOf(msg.sender) < repayAmount) {\r\n            return fail(\"repay\", Error.REPAY_BALANCE_ERROR);\r\n        }\r\n\r\n        if (!EIP20Interface(token).asmTransferFrom(msg.sender, partnerOrderBook[partnerId][borrower][hash].lender, lenderAmount)) {\r\n            return fail(\"repay\", Error.REPAY_TX_ERROR);\r\n        }\r\n\r\n        if (!EIP20Interface(token).asmTransferFrom(msg.sender, offcialFeeAccount, offcialFeeAmount)) {\r\n            return fail(\"repay\", Error.REPAY_TX_ERROR);\r\n        }\r\n\r\n        if (!EIP20Interface(token).asmTransferFrom(msg.sender, partnerAccounts[partnerId], partnerFeeAmount)) {\r\n            return fail(\"repay\", Error.REPAY_TX_ERROR);\r\n        }\r\n\r\n        if (partnerOrderBook[partnerId][borrower][hash].token_pledge != address(0)) {\r\n        \t  status = withdrawToken(partnerId, partnerOrderBook[partnerId][borrower][hash].token_pledge, partnerOrderBook[partnerId][borrower][hash].amount_pledge);\r\n        } else {\r\n            require(sendEth(partnerId, msg.sender, partnerOrderBook[partnerId][borrower][hash].token_pledge, partnerOrderBook[partnerId][borrower][hash].amount_pledge), \"sendEth error\");\r\n\t\t\t      status = 0;\r\n        }\r\n\r\n    } else {\r\n        //还款ETH\r\n        require(repayAmount == msg.value, \"amount must be msg.value\");\r\n        deposit(partnerId);\r\n        if (!sendEth(partnerId, partnerOrderBook[partnerId][borrower][hash].lender, token, partnerOrderBook[partnerId][borrower][hash].amount_get)) {\r\n            return fail(\"repay\", Error.REPAY_SEND_ETH_ERROR);\r\n        }\r\n        if (!sendEth(partnerId, partnerAccounts[partnerId], token, partnerFeeAmount)) {\r\n            return fail(\"repay\", Error.REPAY_SEND_ETH_ERROR);\r\n        }\r\n        if (!sendEth(partnerId, offcialFeeAccount, token, offcialFeeAmount)) {\r\n            return fail(\"repay\", Error.REPAY_SEND_ETH_ERROR);\r\n        }\r\n        status = withdrawToken(partnerId, partnerOrderBook[partnerId][borrower][hash].token_pledge, partnerOrderBook[partnerId][borrower][hash].amount_pledge);\r\n    }\r\n    \r\n    if (status == 0) {\r\n        delete partnerOrderBook[partnerId][borrower][hash];\r\n    \temit Repay(partnerId, borrower, hash, token, repayAmount, msg.sender);\r\n    } else {\r\n    \treturn fail(\"repay\", Error.REPAY_ERROR);\r\n    }\r\n\r\n    return status;\r\n  }\r\n\r\n  //逾期强制归还，由合约管理者调用，非borrower，非lender调用，borrower需要支付抵押资产给出借人（本金+利息），平台合作方（手续费）和项目方（手续费），如果还有剩余，剩余部分归还给A\r\n  function forcerepay(bytes32 partnerId, address borrower, bytes32 hash, address token, uint lenderAmount, uint offcialFeeAmount, uint partnerFeeAmount) public returns (uint){\r\n    require(partnerAccounts[partnerId] != address(0), \"parnerId must add first\");\r\n    \r\n    require(partnerOrderBook[partnerId][borrower][hash].borrower != address(0), \"order not found\");\r\n    //require(token != address(0), \"invalid forcerepay token address\");\r\n    require(token == partnerOrderBook[partnerId][borrower][hash].token_pledge, \"invalid forcerepay token\");\r\n    require(partnerOrderBook[partnerId][borrower][hash].state == OrderState.ORDER_STATUS_ACCEPTED, \"state != OrderState.ORDER_STATUS_ACCEPTED\");\r\n    require(msg.sender == admin, \"forcerepay must be admin\");\r\n    require(now > partnerOrderBook[partnerId][borrower][hash].deadline, \"cannot forcerepay before deadline\");\r\n    uint status = 0;\r\n    \r\n    if (token != 0) {\r\n        //合约管理员发送抵押资产到出借人,数量由上层传入\r\n        partnerTokens[partnerId][token][borrower] = safeSub(partnerTokens[partnerId][token][borrower], lenderAmount);\r\n        if (!EIP20Interface(token).asmTransfer(partnerOrderBook[partnerId][borrower][hash].lender, lenderAmount)) {\r\n            return fail(\"forcerepay\", Error.FORCE_REPAY_TX_ERROR);\r\n        }\r\n\r\n        //合约管理员发送抵押资产到平台合作方,数量由上层传入\r\n        partnerTokens[partnerId][token][borrower] = safeSub(partnerTokens[partnerId][token][borrower], partnerFeeAmount);\r\n        if (!EIP20Interface(token).asmTransfer(partnerAccounts[partnerId], partnerFeeAmount)) {\r\n            return fail(\"forcerepay\", Error.FORCE_REPAY_TX_ERROR);\r\n        }\r\n\r\n        //合约管理员发送抵押资产到项目方,数量由上层传入\r\n        partnerTokens[partnerId][token][borrower] = safeSub(partnerTokens[partnerId][token][borrower], offcialFeeAmount);\r\n        if (!EIP20Interface(token).asmTransfer(offcialFeeAccount, offcialFeeAmount)) {\r\n            return fail(\"forcerepay\", Error.FORCE_REPAY_TX_ERROR);\r\n        }\r\n\r\n        //合约管理员发送剩余抵押资产到借款方\r\n        if (partnerTokens[partnerId][token][borrower] > 0) {\r\n          if (!EIP20Interface(token).asmTransfer(borrower, partnerTokens[partnerId][token][borrower])) {\r\n              return fail(\"forcerepay\", Error.FORCE_REPAY_TX_ERROR);\r\n          } else {\r\n            partnerTokens[partnerId][token][borrower] = 0;\r\n          }\r\n        }\r\n    } else {\r\n        //eth pledge\r\n        if (!sendEth(partnerId, partnerOrderBook[partnerId][borrower][hash].lender, token, lenderAmount)) {\r\n            return fail(\"repay\", Error.FORCE_REPAY_SEND_ETH_ERROR);\r\n        }\r\n        if (!sendEth(partnerId, partnerAccounts[partnerId], token, partnerFeeAmount)) {\r\n            return fail(\"repay\", Error.FORCE_REPAY_SEND_ETH_ERROR);\r\n        }\r\n        if (!sendEth(partnerId, offcialFeeAccount, token, offcialFeeAmount)) {\r\n            return fail(\"repay\", Error.FORCE_REPAY_SEND_ETH_ERROR);\r\n        }\r\n\r\n        bool ok = sendEth(partnerId, borrower, token, partnerTokens[partnerId][token][borrower]);\r\n        if (ok) {\r\n            status = 0;\r\n        }\r\n    }\r\n    if (status == 0) {\r\n        delete partnerOrderBook[partnerId][borrower][hash];\r\n        emit Forcerepay(partnerId, borrower, hash, token, msg.sender);\r\n    } else {\r\n      return fail(\"forcerepay\", Error.FORCE_REPAY_ERROR);\r\n    }\r\n\r\n    return status;\r\n  }\r\n\r\n  //价格波动平仓，borrower需要支付抵押资产给出借人（本金+利息），项目方（手续费）和平台合作方（手续费），如果还有剩余，剩余部分归还给A\r\n  function closepstion(bytes32 partnerId, address borrower, bytes32 hash, address token, uint lenderAmount, uint offcialFeeAmount, uint partnerFeeAmount) public returns (uint){\r\n    require(partnerAccounts[partnerId] != address(0), \"parnerId must add first\");\r\n    \r\n    require(partnerOrderBook[partnerId][borrower][hash].borrower != address(0), \"order not found\");\r\n    //require(token != address(0), \"invalid token\");\r\n    require(token == partnerOrderBook[partnerId][borrower][hash].token_pledge, \"invalid token\");\r\n    require(partnerOrderBook[partnerId][borrower][hash].state == OrderState.ORDER_STATUS_ACCEPTED, \"state != OrderState.ORDER_STATUS_ACCEPTED\");\r\n    require(msg.sender == admin, \"closepstion must be admin\");\r\n    uint8 status = 0;\r\n\r\n    //未逾期\r\n    if (partnerOrderBook[partnerId][borrower][hash].deadline > now) {\r\n      if (msg.sender != admin) {\r\n        //only admin of this contract can do this operation before deadline\r\n        return fail(\"closepstion\", Error.CLOSE_POSITION_MUST_ADMIN_BEFORE_DEADLINE);\r\n      }\r\n    } else {\r\n      if (!(msg.sender == admin || msg.sender == partnerOrderBook[partnerId][borrower][hash].lender)) {\r\n        //only lender or admin of this contract can do this operation\r\n        return fail(\"closepstion\", Error.CLOSE_POSITION_MUST_ADMIN_OR_LENDER_AFTER_DEADLINE);\r\n      }\r\n    }\r\n\r\n    if (token != 0) {\r\n        //合约管理员发送抵押资产到出借人,数量由上层传入\r\n        partnerTokens[partnerId][token][borrower] = safeSub(partnerTokens[partnerId][token][borrower], lenderAmount);\r\n        if (!EIP20Interface(token).asmTransfer(partnerOrderBook[partnerId][borrower][hash].lender, lenderAmount)) {\r\n            return fail(\"closepstion\", Error.CLOSE_POSITION_TX_ERROR);\r\n        }\r\n\r\n        //合约管理员发送抵押资产到平台合作方,数量由上层传入\r\n        partnerTokens[partnerId][token][borrower] = safeSub(partnerTokens[partnerId][token][borrower], partnerFeeAmount);\r\n        if (!EIP20Interface(token).asmTransfer(partnerAccounts[partnerId], partnerFeeAmount)) {\r\n            return fail(\"closepstion\", Error.CLOSE_POSITION_TX_ERROR);\r\n        }\r\n\r\n        //合约管理员发送抵押资产到项目方,数量由上层传入\r\n        partnerTokens[partnerId][token][borrower] = safeSub(partnerTokens[partnerId][token][borrower], offcialFeeAmount);\r\n        if (!EIP20Interface(token).asmTransfer(offcialFeeAccount, offcialFeeAmount)) {\r\n            return fail(\"closepstion\", Error.CLOSE_POSITION_TX_ERROR);\r\n        }\r\n\r\n        //合约管理员发送剩余抵押资产到借款方,数量由上层传入\r\n        if (partnerTokens[partnerId][token][borrower] > 0) {\r\n          if (!EIP20Interface(token).asmTransfer(borrower, partnerTokens[partnerId][token][borrower])) {\r\n              return fail(\"closepstion\", Error.CLOSE_POSITION_TX_ERROR);\r\n          } else {\r\n            partnerTokens[partnerId][token][borrower] = 0;\r\n          }\r\n        }\r\n    } else {\r\n        //eth pledge\r\n        if (!sendEth(partnerId, partnerOrderBook[partnerId][borrower][hash].lender, token, lenderAmount)) {\r\n            return fail(\"repay\", Error.FORCE_REPAY_SEND_ETH_ERROR);\r\n        }\r\n        if (!sendEth(partnerId, partnerAccounts[partnerId], token, partnerFeeAmount)) {\r\n            return fail(\"repay\", Error.FORCE_REPAY_SEND_ETH_ERROR);\r\n        }\r\n        if (!sendEth(partnerId, offcialFeeAccount, token, offcialFeeAmount)) {\r\n            return fail(\"repay\", Error.FORCE_REPAY_SEND_ETH_ERROR);\r\n        }\r\n\r\n        bool ok = sendEth(partnerId, borrower, token, partnerTokens[partnerId][token][borrower]);\r\n        if (ok) {\r\n            status = 0;\r\n        }\r\n    }\r\n\r\n    delete partnerOrderBook[partnerId][borrower][hash];\r\n\r\n    emit Closepstion(partnerId, borrower, hash, token, address(this));\r\n\r\n    return 0;\r\n  }\r\n\r\n    //ADDITIONAL HELPERS ADDED FOR TESTING\r\n    function hash(\r\n        bytes32 partnerId,\r\n        address tokenGet,\r\n        uint amountGet,\r\n        address tokenGive,\r\n        uint amountGive,\r\n        uint nonce,\r\n        uint lendingCycle,\r\n        uint pledgeRate,\r\n        uint interestRate,\r\n        uint feeRate\r\n    )\r\n        public\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        //return sha256(this, tokenGet, amountGet, tokenGive, amountGive, nonce, lendingCycle, pledgeRate, interestRate, feeRate);\r\n        return sha256(abi.encodePacked(address(this), partnerId, tokenGet, amountGet, tokenGive, amountGive, nonce, lendingCycle, pledgeRate, interestRate, feeRate));\r\n    }\r\n}",
  "imports": [
    {
      "name": "TheForceLending.sol",
      "contents": "/**\r\n *Submitted for verification at Etherscan.io on 2019-09-26\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2019-09-20\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2019-09-17\r\n*/\r\npragma solidity ^0.4.24;\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) pure internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) pure internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) pure internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\ncontract EIP20Interface {\r\n    /* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n    // solhint-disable-next-line no-simple-event-func-name\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract ErrorReporter {\r\n\r\n    /**\r\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\r\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\r\n      **/\r\n    event Failure(string name, uint error);\r\n\r\n    enum Error {\r\n        NO_ERROR,\r\n        INVALIDE_ADMIN,\r\n        WITHDRAW_TOKEN_AMOUNT_ERROR,\r\n        WITHDRAW_TOKEN_TRANSER_ERROR,\r\n        TOKEN_INSUFFICIENT_ALLOWANCE,\r\n        TOKEN_INSUFFICIENT_BALANCE,\r\n        TRANSFER_FROM_ERROR,\r\n        LENDER_INSUFFICIENT_BORROW_ALLOWANCE,\r\n        LENDER_INSUFFICIENT_BORROWER_BALANCE,\r\n        LENDER_TRANSFER_FROM_BORROW_ERROR,\r\n        LENDER_INSUFFICIENT_ADMIN_ALLOWANCE,\r\n        LENDER_INSUFFICIENT_ADMIN_BALANCE,\r\n        LENDER_TRANSFER_FROM_ADMIN_ERROR,\r\n        CALL_MARGIN_ALLOWANCE_ERROR,\r\n        CALL_MARGIN_BALANCE_ERROR,\r\n        CALL_MARGIN_TRANSFER_ERROR,\r\n        REPAY_ALLOWANCE_ERROR,\r\n        REPAY_BALANCE_ERROR,\r\n        REPAY_TX_ERROR,\r\n        FORCE_REPAY_ALLOWANCE_ERROR,\r\n        FORCE_REPAY_BALANCE_ERROR,\r\n        FORCE_REPAY_TX_ERROR,\r\n        CLOSE_POSITION_ALLOWANCE_ERROR,\r\n        CLOSE_POSITION_TX_ERROR,\r\n        CLOSE_POSITION_MUST_ADMIN_BEFORE_DEADLINE,\r\n        CLOSE_POSITION_MUST_ADMIN_OR_LENDER_AFTER_DEADLINE,\r\n        LENDER_TEST_TRANSFER_ADMIN_ERROR,\r\n        LENDER_TEST_TRANSFER_BORROWR_ERROR,\r\n        LENDER_TEST_TRANSFERFROM_ADMIN_ERROR,\r\n        LENDER_TEST_TRANSFERFROM_BORROWR_ERROR,\r\n        SEND_TOKEN_AMOUNT_ERROR,\r\n        SEND_TOKEN_TRANSER_ERROR,\r\n        DEPOSIT_TOKEN,\r\n        CANCEL_ORDER,\r\n        REPAY_ERROR,\r\n        FORCE_REPAY_ERROR,\r\n        LENDER_SEND_ETH_ERROR,\r\n        REPAY_SEND_ETH_ERROR,\r\n        FORCE_REPAY_SEND_ETH_ERROR\r\n    }\r\n\r\n    /**\r\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\r\n      */\r\n    function fail(string name, Error err) internal returns (uint) {\r\n        emit Failure(name, uint(err));\r\n\r\n        return uint(err);\r\n    }\r\n}\r\n\r\nlibrary ERC20AsmFn {\r\n\r\n    function isContract(address addr)view internal {\r\n        assembly {\r\n            if iszero(extcodesize(addr)) { revert(0, 0) }\r\n        }\r\n    }\r\n\r\n    function handleReturnData()pure internal returns (bool result) {\r\n        assembly {\r\n            switch returndatasize()\r\n            case 0 { // not a std erc20\r\n                result := 1\r\n            }\r\n            case 32 { // std erc20\r\n                returndatacopy(0, 0, 32)\r\n                result := mload(0)\r\n            }\r\n            default { // anything else, should revert for safety\r\n                revert(0, 0)\r\n            }\r\n        }\r\n    }\r\n\r\n    function asmTransfer(address _erc20Addr, address _to, uint256 _value) internal returns (bool result) {\r\n\r\n        // Must be a contract addr first!\r\n        isContract(_erc20Addr);\r\n\r\n        // call return false when something wrong\r\n        require(_erc20Addr.call(bytes4(keccak256(\"transfer(address,uint256)\")), _to, _value), \"asmTransfer error\");\r\n\r\n        // handle returndata\r\n        return handleReturnData();\r\n    }\r\n\r\n    function asmTransferFrom(address _erc20Addr, address _from, address _to, uint256 _value) internal returns (bool result) {\r\n\r\n        // Must be a contract addr first!\r\n        isContract(_erc20Addr);\r\n\r\n        // call return false when something wrong\r\n        require(_erc20Addr.call(bytes4(keccak256(\"transferFrom(address,address,uint256)\")), _from, _to, _value), \"asmTransferFrom error\");\r\n\r\n        // handle returndata\r\n        return handleReturnData();\r\n    }\r\n\r\n}\r\n\r\ncontract TheForceLending is SafeMath, ErrorReporter {\r\n  using ERC20AsmFn for EIP20Interface;\r\n\r\n  enum OrderState {\r\n    ORDER_STATUS_PENDING,\r\n    ORDER_STATUS_ACCEPTED\r\n  }\r\n\r\n  struct Order_t {\r\n    bytes32 partner_id;\r\n    uint deadline;\r\n    OrderState state;\r\n\r\n    address borrower;\r\n    address lender;\r\n\r\n    uint lending_cycle;\r\n\r\n    address token_get;\r\n    uint amount_get;\r\n\r\n    address token_pledge;//tokenGive\r\n    uint amount_pledge;//amountGive\r\n\r\n    uint _nonce;\r\n\r\n    uint pledge_rate;\r\n    uint interest_rate;\r\n    uint fee_rate;\r\n  }\r\n\r\n  address public admin; //the admin address\r\n  address public offcialFeeAccount; //the account that will receive fees\r\n\r\n   mapping (bytes32 => address) public partnerAccounts;// bytes32-> address, eg: platformA->0xa{40}, platfromB->0xb{40}\r\n   mapping (bytes32 => mapping (address => mapping (address => uint))) public partnerTokens;// platform->tokenContract->address->balance\r\n   mapping (bytes32 => mapping (address => mapping (bytes32 => Order_t))) public partnerOrderBook;// platform->address->hash->order_t\r\n   mapping (bytes32 => mapping (address => bytes32[])) partnerOrderHash;\r\n\r\n  function numHash(bytes32 partnerId, address usr) public view returns (uint) {\r\n      return partnerOrderHash[partnerId][usr].length;\r\n  }\r\n\r\n  function listHash(bytes32 partnerId, address usr) public view returns (bytes32[]) {\r\n      return partnerOrderHash[partnerId][usr];\r\n  }\r\n\r\n  event Borrow(bytes32 partnerId,\r\n                address tokenGet,\r\n                  uint amountGet,\r\n                  address tokenGive,\r\n                  uint amountGive,\r\n                  uint nonce,\r\n                  uint lendingCycle,\r\n                  uint pledgeRate,\r\n                  uint interestRate,\r\n                  uint feeRate,\r\n                  address user,\r\n                  bytes32 hash,\r\n                  uint status);\r\n  event Lend(bytes32 partnerId, bytes32 lenderPartnerId, address borrower, bytes32 txId, address token, uint amount, address give);//txId为借款单txId\r\n  event CancelOrder(bytes32 partnerId, address borrower, bytes32 txId, address by);//取消借款单，只能被borrower或者合约取消\r\n  event Callmargin(bytes32 partnerId, address borrower, bytes32 txId, address token, uint amount, address by);\r\n  event Repay(bytes32 partnerId, address borrower, bytes32 txId, address token, uint amount, address by);\r\n  event Closepstion(bytes32 partnerId, address borrower, bytes32 txId, address token, address by);\r\n  event Forcerepay(bytes32 partnerId, address borrower, bytes32 txId, address token, address by);\r\n  event Deposit(bytes32 partnerId, address token, address user, uint256 amount, uint256 balance);\r\n  event SendEth(bytes32 partnerId, address token, address user, uint256 amount, uint256 balance);\r\n\r\n  constructor(address admin_, address offcialFeeAccount_) public {\r\n    admin = admin_;\r\n    offcialFeeAccount = offcialFeeAccount_;\r\n  }\r\n\r\n  function() public payable {\r\n    revert(\"fallback can't be payable\");\r\n }\r\n\r\n  modifier onlyAdmin() {\r\n    require(msg.sender == admin, \"only admin can do this!\");\r\n    _;\r\n  }\r\n\r\n  function changeAdmin(address admin_) public onlyAdmin {\r\n    admin = admin_;\r\n  }\r\n\r\n  function changeFeeAccount(address offcialFeeAccount_) public onlyAdmin {\r\n    offcialFeeAccount = offcialFeeAccount_;\r\n  }\r\n\r\n  //增\r\n  function addPartner(bytes32 partnerId, address partner) public onlyAdmin {\r\n    require(partnerAccounts[partnerId] == address(0), \"already exists!\");\r\n    partnerAccounts[partnerId] = partner;\r\n  }\r\n\r\n  //删\r\n  function delPartner(bytes32 partnerId) public onlyAdmin {\r\n    delete partnerAccounts[partnerId];\r\n  }\r\n\r\n  //改\r\n  function modPartner(bytes32 partnerId, address partner) public onlyAdmin {\r\n    require(partnerAccounts[partnerId] != address(0), \"not exists!\");\r\n    partnerAccounts[partnerId] = partner;\r\n  }\r\n\r\n  //查\r\n  function getPartner(bytes32 partnerId) public view returns (address) {\r\n    return partnerAccounts[partnerId];\r\n  }\r\n  \r\n  //充值ETH\r\n  function deposit(bytes32 partnerId) public payable  {\r\n    partnerTokens[partnerId][address(0)][msg.sender] = safeAdd(partnerTokens[partnerId][address(0)][msg.sender], msg.value);\r\n    emit Deposit(partnerId, address(0), msg.sender, msg.value, partnerTokens[partnerId][address(0)][msg.sender]);\r\n  }\r\n\r\n  function sendEth(bytes32 partnerId, address dst, address token, uint256 amount) internal returns (bool success) {\r\n    if (token != 0) revert(\"invalid token address!\");\r\n    if (partnerTokens[partnerId][token][msg.sender] < amount) revert(\"invalid amount\");//lend时，dst没有eth，所以取消判断\r\n    partnerTokens[partnerId][token][msg.sender] = safeSub(partnerTokens[partnerId][token][msg.sender], amount);\r\n    dst.transfer(amount);\r\n\r\n    emit SendEth(partnerId, token, dst, amount, partnerTokens[partnerId][token][msg.sender]);\r\n    return true;\r\n  }\r\n\r\n\r\n  function depositToken(bytes32 partnerId, address token, uint amount) internal returns (uint){\r\n    //remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\r\n    require(partnerAccounts[partnerId] != address(0), \"parnerId must add first\");\r\n\r\n    if (token == 0) revert(\"invalid token address!\");\r\n\r\n    if (EIP20Interface(token).allowance(msg.sender, address(this)) < amount) {\r\n        return uint(Error.TOKEN_INSUFFICIENT_ALLOWANCE);\r\n    }\r\n    \r\n    if (EIP20Interface(token).balanceOf(msg.sender) < amount) {\r\n        return uint(Error.TOKEN_INSUFFICIENT_ALLOWANCE);\r\n    }\r\n\r\n    if (!EIP20Interface(token).asmTransferFrom(msg.sender, address(this), amount)) {\r\n        return uint(Error.TRANSFER_FROM_ERROR);\r\n    }\r\n    partnerTokens[partnerId][token][msg.sender] = safeAdd(partnerTokens[partnerId][token][msg.sender], amount);\r\n  \r\n    return 0;\r\n  }\r\n\r\n  function withdrawToken(bytes32 partnerId, address token, uint amount) internal returns (uint) {\r\n    require(partnerAccounts[partnerId] != address(0), \"parnerId must add first\");\r\n\r\n    if (token == 0) revert(\"invalid token address\");\r\n    if (partnerTokens[partnerId][token][msg.sender] < amount) {\r\n        return uint(Error.WITHDRAW_TOKEN_AMOUNT_ERROR);\r\n    }\r\n    partnerTokens[partnerId][token][msg.sender] = safeSub(partnerTokens[partnerId][token][msg.sender], amount);\r\n    if (!EIP20Interface(token).asmTransfer(msg.sender, amount)) {\r\n        return uint(Error.WITHDRAW_TOKEN_TRANSER_ERROR);\r\n    }\r\n    return 0;\r\n  }\r\n  \r\n  function sendToken(bytes32 partnerId, address token, address to, uint amount) internal returns (uint) {\r\n    require(partnerAccounts[partnerId] != address(0), \"parnerId must add first\");\r\n\r\n    if (token==0 || to == 0 || amount == 0) revert(\"invalid token address or amount\");\r\n    if (partnerTokens[partnerId][token][to] < amount) {\r\n        return uint(Error.SEND_TOKEN_AMOUNT_ERROR);\r\n    }\r\n    partnerTokens[partnerId][token][to] = safeSub(partnerTokens[partnerId][token][to], amount);\r\n    if (!EIP20Interface(token).asmTransfer(to, amount)) {\r\n        return uint(Error.SEND_TOKEN_TRANSER_ERROR);\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  function balanceOf(bytes32 partnerId, address token, address user) public view returns (uint) {\r\n    return partnerTokens[partnerId][token][user];\r\n  }\r\n\r\n  function borrow(bytes32 partnerId,//平台标记\r\n                  address tokenGet, //借出币种地址\r\n                  uint amountGet, //借出币种数量\r\n                  address tokenGive, //抵押币种地址\r\n                  uint amountGive,//抵押币种数量\r\n                  uint nonce,\r\n                  uint lendingCycle,\r\n                  uint pledgeRate,\r\n                  uint interestRate,\r\n                  uint feeRate) public payable returns (uint){\r\n    require(partnerAccounts[partnerId] != address(0), \"parnerId must add first\");\r\n    bytes32 txid = hash(partnerId, tokenGet, amountGet, tokenGive, amountGive, nonce, lendingCycle, pledgeRate, interestRate, feeRate);\r\n    require(partnerOrderBook[partnerId][msg.sender][txid].borrower == address(0), \"order already exists\");\r\n\r\n    uint status = 0;\r\n\r\n    partnerOrderBook[partnerId][msg.sender][txid] = Order_t({\r\n      partner_id: partnerId,\r\n      deadline: 0,\r\n      state: OrderState.ORDER_STATUS_PENDING,\r\n      borrower: msg.sender,\r\n      lender: address(0),\r\n      lending_cycle: lendingCycle,\r\n      token_get: tokenGet,\r\n      amount_get: amountGet,\r\n      token_pledge: tokenGive,\r\n      amount_pledge: amountGive,\r\n      _nonce: nonce,\r\n      pledge_rate: pledgeRate,\r\n      interest_rate: interestRate,\r\n      fee_rate: feeRate\r\n    });\r\n    \r\n    partnerOrderHash[partnerId][msg.sender].push(txid);\r\n\r\n    if (tokenGive != 0) {\r\n        require(msg.value == 0, \"msg.value must be zero for non eth give\");\r\n    \tstatus = depositToken(partnerId, tokenGive, amountGive);\r\n    } else {\r\n      //deposit eth\r\n      require(amountGive == msg.value, \"amountGive must equal msg.value\");\r\n      deposit(partnerId);\r\n    }\r\n    if (status != 0) {\r\n      return fail(\"borrow\", Error.DEPOSIT_TOKEN);\r\n    }\r\n\r\n    emit Borrow(partnerId, tokenGet, amountGet, tokenGive, amountGive, nonce, lendingCycle, pledgeRate, interestRate, feeRate, msg.sender, txid, status);\r\n    return 0;\r\n  }\r\n\r\n  //A借款，B出借，A到账数量为申请数量，无砍头息，B出借的数量包括A的申请数量+手续费(项目方手续费+平台合作方手续费，手续费可能为0)\r\n  function lend(bytes32 partnerId, bytes32 lenderPartnerId, address borrower, bytes32 hash, address token, uint lenderAmount, uint offcialFeeAmount, uint partnerFeeAmount) public payable returns (uint) {\r\n    require(partnerAccounts[partnerId] != address(0), \"parnerId must add first\");\r\n    require(partnerAccounts[lenderPartnerId] != address(0), \"lenderPartnerId must add first\");\r\n\r\n    require(partnerOrderBook[partnerId][borrower][hash].borrower != address(0), \"order not found\");//order not found\r\n    require(partnerOrderBook[partnerId][borrower][hash].borrower != msg.sender, \"cannot lend to self\");//cannot lend to self\r\n    require(partnerOrderBook[partnerId][borrower][hash].token_get == token, \"attempt to use an invalid type of token\");//attempt to use an invalid type of token\r\n    require(partnerOrderBook[partnerId][borrower][hash].amount_get == lenderAmount - offcialFeeAmount - partnerFeeAmount, \"amount_get != amount - offcialFeeAmount - partnerFeeAmount\");//单个出借金额不足，后续可以考虑多个出借人，现在只考虑一个出借人\r\n    require(partnerOrderBook[partnerId][borrower][hash].state == OrderState.ORDER_STATUS_PENDING, \"state != OrderState.ORDER_STATUS_PENDING\");\r\n\r\n    if (token != 0) {\r\n        require(msg.value == 0, \"msg.value must be zero for non eth lend\");\r\n        if (EIP20Interface(token).allowance(msg.sender, address(this)) < lenderAmount) {\r\n            return fail(\"lend\", Error.TOKEN_INSUFFICIENT_ALLOWANCE);\r\n        }\r\n        if (EIP20Interface(token).balanceOf(msg.sender) < lenderAmount) {\r\n            return fail(\"lend\", Error.LENDER_INSUFFICIENT_BORROWER_BALANCE);\r\n        }\r\n        if (!EIP20Interface(token).asmTransferFrom(msg.sender, partnerOrderBook[partnerId][borrower][hash].borrower, partnerOrderBook[partnerId][borrower][hash].amount_get)) {\r\n            return fail(\"lend\", Error.LENDER_TRANSFER_FROM_BORROW_ERROR);\r\n        }\r\n\r\n        if (offcialFeeAmount != 0) {\r\n          if (EIP20Interface(token).allowance(msg.sender, address(this)) < offcialFeeAmount) {\r\n              return fail(\"lend\", Error.LENDER_INSUFFICIENT_ADMIN_ALLOWANCE);\r\n          }\r\n          if (EIP20Interface(token).balanceOf(msg.sender) < offcialFeeAmount) {\r\n              return fail(\"lend\", Error.LENDER_INSUFFICIENT_ADMIN_BALANCE);\r\n          }\r\n          if (!EIP20Interface(token).asmTransferFrom(msg.sender, offcialFeeAccount, offcialFeeAmount)) {\r\n              return fail(\"lend\", Error.LENDER_TRANSFER_FROM_ADMIN_ERROR);\r\n          }\r\n        }\r\n\r\n\t    if (partnerFeeAmount != 0) {\r\n\t      if (EIP20Interface(token).allowance(msg.sender, address(this)) < partnerFeeAmount) {\r\n\t          return fail(\"lend\", Error.LENDER_INSUFFICIENT_ADMIN_ALLOWANCE);\r\n\t      }\r\n\t      if (EIP20Interface(token).balanceOf(msg.sender) < partnerFeeAmount) {\r\n\t          return fail(\"lend\", Error.LENDER_INSUFFICIENT_ADMIN_BALANCE);\r\n\t      }\r\n\t      if (!EIP20Interface(token).asmTransferFrom(msg.sender, partnerAccounts[lenderPartnerId], partnerFeeAmount)) {\r\n\t          return fail(\"lend\", Error.LENDER_TRANSFER_FROM_ADMIN_ERROR);\r\n\t      }\r\n\t    }\r\n    } else {\r\n        require(lenderAmount == msg.value, \"lenderAmount must be msg.value\");\r\n        deposit(lenderPartnerId);\r\n        if (!sendEth(lenderPartnerId, partnerOrderBook[partnerId][borrower][hash].borrower, token, partnerOrderBook[partnerId][borrower][hash].amount_get)) {\r\n            return fail(\"lend\", Error.LENDER_SEND_ETH_ERROR);\r\n        }\r\n        if (!sendEth(lenderPartnerId, partnerAccounts[lenderPartnerId], token, partnerFeeAmount)) {\r\n                return fail(\"lend\", Error.LENDER_SEND_ETH_ERROR);\r\n        }\r\n        if (!sendEth(lenderPartnerId, offcialFeeAccount, token, offcialFeeAmount)) {\r\n            return fail(\"lend\", Error.LENDER_SEND_ETH_ERROR);\r\n        }\r\n    }\r\n\r\n    partnerOrderBook[partnerId][borrower][hash].deadline = now + partnerOrderBook[partnerId][borrower][hash].lending_cycle * (1 minutes);\r\n    partnerOrderBook[partnerId][borrower][hash].lender = msg.sender;\r\n    partnerOrderBook[partnerId][borrower][hash].state = OrderState.ORDER_STATUS_ACCEPTED;\r\n\r\n    emit Lend(partnerId, lenderPartnerId, borrower, hash, token, lenderAmount, msg.sender);\r\n    return 0;\r\n  }\r\n\r\n  function cancelOrder(bytes32 partnerId, address borrower, bytes32 hash) public {\r\n    require(partnerAccounts[partnerId] != address(0), \"parnerId must add first\");\r\n    \r\n    require(partnerOrderBook[partnerId][borrower][hash].borrower != address(0), \"order not found\");//order not found\r\n    require(partnerOrderBook[partnerId][borrower][hash].borrower == msg.sender || msg.sender == admin,\r\n      \"only borrower or admin can do this operation\");//only borrower or contract can do this operation\r\n    require(partnerOrderBook[partnerId][borrower][hash].state == OrderState.ORDER_STATUS_PENDING, \"state != OrderState.ORDER_STATUS_PENDING\");\r\n    uint status = 1;\r\n    \r\n    if (partnerOrderBook[partnerId][borrower][hash].token_pledge != 0) {\r\n    \tstatus = sendToken(partnerId, partnerOrderBook[partnerId][borrower][hash].token_pledge, partnerOrderBook[partnerId][borrower][hash].borrower, partnerOrderBook[partnerId][borrower][hash].amount_pledge);\r\n    } else {\r\n        bool ok = sendEth(partnerId, partnerOrderBook[partnerId][borrower][hash].borrower, partnerOrderBook[partnerId][borrower][hash].token_pledge, partnerOrderBook[partnerId][borrower][hash].amount_pledge);\r\n        if (ok) {\r\n            status = 0;\r\n        }\r\n    }\r\n\r\n    if (status == 0) {\r\n        delete partnerOrderBook[partnerId][borrower][hash];\r\n\t    emit CancelOrder(partnerId, borrower, hash, msg.sender);\r\n    } else {\r\n    \tfail(\"cancelOrder\", Error.CANCEL_ORDER);\r\n    }\r\n  }\r\n\r\n  function callmargin(bytes32 partnerId, address borrower, bytes32 hash, address token, uint amount) public payable returns (uint){\r\n    require(partnerAccounts[partnerId] != address(0), \"parnerId must add first\");\r\n\r\n    require(partnerOrderBook[partnerId][borrower][hash].borrower != address(0), \"order not found\");\r\n    require(amount > 0, \"amount must >0\");\r\n\r\n    require(partnerOrderBook[partnerId][borrower][hash].state == OrderState.ORDER_STATUS_ACCEPTED, \"state != OrderState.ORDER_STATUS_ACCEPTED\");\r\n    require(partnerOrderBook[partnerId][borrower][hash].token_pledge == token, \"invalid pledge token\");\r\n\r\n    if (token != 0) {\r\n        require(msg.value == 0, \"msg.value must be zero for non eth callmargin\");\r\n        if (EIP20Interface(token).allowance(msg.sender, address(this)) < amount) {\r\n            return fail(\"callmargin\", Error.CALL_MARGIN_ALLOWANCE_ERROR);\r\n        }\r\n        \r\n        partnerOrderBook[partnerId][borrower][hash].amount_pledge += amount;\r\n        partnerTokens[partnerId][token][borrower] = safeAdd(partnerTokens[partnerId][token][borrower], amount);\r\n        \r\n        if (EIP20Interface(token).balanceOf(msg.sender) < amount) {\r\n            return fail(\"callmargin\", Error.CALL_MARGIN_BALANCE_ERROR);\r\n        }\r\n\r\n        if (!EIP20Interface(token).asmTransferFrom(msg.sender, address(this), amount)) {\r\n            return fail(\"callmargin\", Error.CALL_MARGIN_TRANSFER_ERROR);\r\n        }\r\n    } else {\r\n        require(amount == msg.value, \"amount must equal msg.value\");\r\n        partnerOrderBook[partnerId][borrower][hash].amount_pledge += amount;\r\n        partnerTokens[partnerId][token][borrower] = safeAdd(partnerTokens[partnerId][token][borrower], amount);\r\n    }\r\n\r\n    emit Callmargin(partnerId, borrower, hash, token, amount, msg.sender);\r\n    return 0;\r\n  }\r\n\r\n  //A还款，需要支付本金+利息给出借方，给项目方和平台合作方手续费\r\n  function repay(bytes32 partnerId, address borrower, bytes32 hash, address token, uint repayAmount, uint lenderAmount, uint offcialFeeAmount, uint partnerFeeAmount) public payable returns (uint){\r\n    require(partnerAccounts[partnerId] != address(0), \"parnerId must add first\");\r\n\r\n    require(partnerOrderBook[partnerId][borrower][hash].borrower != address(0), \"order not found\");\r\n    require(partnerOrderBook[partnerId][borrower][hash].state == OrderState.ORDER_STATUS_ACCEPTED, \"state != OrderState.ORDER_STATUS_ACCEPTED\");\r\n    //require(token != address(0), \"invalid token\");\r\n    require(token == partnerOrderBook[partnerId][borrower][hash].token_get, \"invalid repay token\");\r\n    //还款数量，为借款数量加上利息加上项目方手续费+合作方手续费\r\n    require(repayAmount == lenderAmount + offcialFeeAmount + partnerFeeAmount, \"invalid repay amount\");\r\n    require(lenderAmount >= partnerOrderBook[partnerId][borrower][hash].amount_get, \"invalid lender amount\");\r\n    require(msg.sender == partnerOrderBook[partnerId][borrower][hash].borrower, \"invalid repayer, must be borrower\");\r\n    uint status = 1;\r\n\r\n    if (token != address(0)) {\r\n        //允许contract花费借款者的所借的token+利息token\r\n        if (EIP20Interface(token).allowance(msg.sender, address(this)) < repayAmount) {\r\n            return fail(\"repay\", Error.REPAY_ALLOWANCE_ERROR);\r\n        }\r\n        \r\n        if (EIP20Interface(token).balanceOf(msg.sender) < repayAmount) {\r\n            return fail(\"repay\", Error.REPAY_BALANCE_ERROR);\r\n        }\r\n\r\n        if (!EIP20Interface(token).asmTransferFrom(msg.sender, partnerOrderBook[partnerId][borrower][hash].lender, lenderAmount)) {\r\n            return fail(\"repay\", Error.REPAY_TX_ERROR);\r\n        }\r\n\r\n        if (!EIP20Interface(token).asmTransferFrom(msg.sender, offcialFeeAccount, offcialFeeAmount)) {\r\n            return fail(\"repay\", Error.REPAY_TX_ERROR);\r\n        }\r\n\r\n        if (!EIP20Interface(token).asmTransferFrom(msg.sender, partnerAccounts[partnerId], partnerFeeAmount)) {\r\n            return fail(\"repay\", Error.REPAY_TX_ERROR);\r\n        }\r\n\r\n        if (partnerOrderBook[partnerId][borrower][hash].token_pledge != address(0)) {\r\n        \t  status = withdrawToken(partnerId, partnerOrderBook[partnerId][borrower][hash].token_pledge, partnerOrderBook[partnerId][borrower][hash].amount_pledge);\r\n        } else {\r\n            require(sendEth(partnerId, msg.sender, partnerOrderBook[partnerId][borrower][hash].token_pledge, partnerOrderBook[partnerId][borrower][hash].amount_pledge), \"sendEth error\");\r\n\t\t\t      status = 0;\r\n        }\r\n\r\n    } else {\r\n        //还款ETH\r\n        require(repayAmount == msg.value, \"amount must be msg.value\");\r\n        deposit(partnerId);\r\n        if (!sendEth(partnerId, partnerOrderBook[partnerId][borrower][hash].lender, token, partnerOrderBook[partnerId][borrower][hash].amount_get)) {\r\n            return fail(\"repay\", Error.REPAY_SEND_ETH_ERROR);\r\n        }\r\n        if (!sendEth(partnerId, partnerAccounts[partnerId], token, partnerFeeAmount)) {\r\n            return fail(\"repay\", Error.REPAY_SEND_ETH_ERROR);\r\n        }\r\n        if (!sendEth(partnerId, offcialFeeAccount, token, offcialFeeAmount)) {\r\n            return fail(\"repay\", Error.REPAY_SEND_ETH_ERROR);\r\n        }\r\n        status = withdrawToken(partnerId, partnerOrderBook[partnerId][borrower][hash].token_pledge, partnerOrderBook[partnerId][borrower][hash].amount_pledge);\r\n    }\r\n    \r\n    if (status == 0) {\r\n        delete partnerOrderBook[partnerId][borrower][hash];\r\n    \temit Repay(partnerId, borrower, hash, token, repayAmount, msg.sender);\r\n    } else {\r\n    \treturn fail(\"repay\", Error.REPAY_ERROR);\r\n    }\r\n\r\n    return status;\r\n  }\r\n\r\n  //逾期强制归还，由合约管理者调用，非borrower，非lender调用，borrower需要支付抵押资产给出借人（本金+利息），平台合作方（手续费）和项目方（手续费），如果还有剩余，剩余部分归还给A\r\n  function forcerepay(bytes32 partnerId, address borrower, bytes32 hash, address token, uint lenderAmount, uint offcialFeeAmount, uint partnerFeeAmount) public returns (uint){\r\n    require(partnerAccounts[partnerId] != address(0), \"parnerId must add first\");\r\n    \r\n    require(partnerOrderBook[partnerId][borrower][hash].borrower != address(0), \"order not found\");\r\n    //require(token != address(0), \"invalid forcerepay token address\");\r\n    require(token == partnerOrderBook[partnerId][borrower][hash].token_pledge, \"invalid forcerepay token\");\r\n    require(partnerOrderBook[partnerId][borrower][hash].state == OrderState.ORDER_STATUS_ACCEPTED, \"state != OrderState.ORDER_STATUS_ACCEPTED\");\r\n    require(msg.sender == admin, \"forcerepay must be admin\");\r\n    require(now > partnerOrderBook[partnerId][borrower][hash].deadline, \"cannot forcerepay before deadline\");\r\n    uint status = 0;\r\n    \r\n    if (token != 0) {\r\n        //合约管理员发送抵押资产到出借人,数量由上层传入\r\n        partnerTokens[partnerId][token][borrower] = safeSub(partnerTokens[partnerId][token][borrower], lenderAmount);\r\n        if (!EIP20Interface(token).asmTransfer(partnerOrderBook[partnerId][borrower][hash].lender, lenderAmount)) {\r\n            return fail(\"forcerepay\", Error.FORCE_REPAY_TX_ERROR);\r\n        }\r\n\r\n        //合约管理员发送抵押资产到平台合作方,数量由上层传入\r\n        partnerTokens[partnerId][token][borrower] = safeSub(partnerTokens[partnerId][token][borrower], partnerFeeAmount);\r\n        if (!EIP20Interface(token).asmTransfer(partnerAccounts[partnerId], partnerFeeAmount)) {\r\n            return fail(\"forcerepay\", Error.FORCE_REPAY_TX_ERROR);\r\n        }\r\n\r\n        //合约管理员发送抵押资产到项目方,数量由上层传入\r\n        partnerTokens[partnerId][token][borrower] = safeSub(partnerTokens[partnerId][token][borrower], offcialFeeAmount);\r\n        if (!EIP20Interface(token).asmTransfer(offcialFeeAccount, offcialFeeAmount)) {\r\n            return fail(\"forcerepay\", Error.FORCE_REPAY_TX_ERROR);\r\n        }\r\n\r\n        //合约管理员发送剩余抵押资产到借款方\r\n        if (partnerTokens[partnerId][token][borrower] > 0) {\r\n          if (!EIP20Interface(token).asmTransfer(borrower, partnerTokens[partnerId][token][borrower])) {\r\n              return fail(\"forcerepay\", Error.FORCE_REPAY_TX_ERROR);\r\n          } else {\r\n            partnerTokens[partnerId][token][borrower] = 0;\r\n          }\r\n        }\r\n    } else {\r\n        //eth pledge\r\n        if (!sendEth(partnerId, partnerOrderBook[partnerId][borrower][hash].lender, token, lenderAmount)) {\r\n            return fail(\"repay\", Error.FORCE_REPAY_SEND_ETH_ERROR);\r\n        }\r\n        if (!sendEth(partnerId, partnerAccounts[partnerId], token, partnerFeeAmount)) {\r\n            return fail(\"repay\", Error.FORCE_REPAY_SEND_ETH_ERROR);\r\n        }\r\n        if (!sendEth(partnerId, offcialFeeAccount, token, offcialFeeAmount)) {\r\n            return fail(\"repay\", Error.FORCE_REPAY_SEND_ETH_ERROR);\r\n        }\r\n\r\n        bool ok = sendEth(partnerId, borrower, token, partnerTokens[partnerId][token][borrower]);\r\n        if (ok) {\r\n            status = 0;\r\n        }\r\n    }\r\n    if (status == 0) {\r\n        delete partnerOrderBook[partnerId][borrower][hash];\r\n        emit Forcerepay(partnerId, borrower, hash, token, msg.sender);\r\n    } else {\r\n      return fail(\"forcerepay\", Error.FORCE_REPAY_ERROR);\r\n    }\r\n\r\n    return status;\r\n  }\r\n\r\n  //价格波动平仓，borrower需要支付抵押资产给出借人（本金+利息），项目方（手续费）和平台合作方（手续费），如果还有剩余，剩余部分归还给A\r\n  function closepstion(bytes32 partnerId, address borrower, bytes32 hash, address token, uint lenderAmount, uint offcialFeeAmount, uint partnerFeeAmount) public returns (uint){\r\n    require(partnerAccounts[partnerId] != address(0), \"parnerId must add first\");\r\n    \r\n    require(partnerOrderBook[partnerId][borrower][hash].borrower != address(0), \"order not found\");\r\n    //require(token != address(0), \"invalid token\");\r\n    require(token == partnerOrderBook[partnerId][borrower][hash].token_pledge, \"invalid token\");\r\n    require(partnerOrderBook[partnerId][borrower][hash].state == OrderState.ORDER_STATUS_ACCEPTED, \"state != OrderState.ORDER_STATUS_ACCEPTED\");\r\n    require(msg.sender == admin, \"closepstion must be admin\");\r\n    uint8 status = 0;\r\n\r\n    //未逾期\r\n    if (partnerOrderBook[partnerId][borrower][hash].deadline > now) {\r\n      if (msg.sender != admin) {\r\n        //only admin of this contract can do this operation before deadline\r\n        return fail(\"closepstion\", Error.CLOSE_POSITION_MUST_ADMIN_BEFORE_DEADLINE);\r\n      }\r\n    } else {\r\n      if (!(msg.sender == admin || msg.sender == partnerOrderBook[partnerId][borrower][hash].lender)) {\r\n        //only lender or admin of this contract can do this operation\r\n        return fail(\"closepstion\", Error.CLOSE_POSITION_MUST_ADMIN_OR_LENDER_AFTER_DEADLINE);\r\n      }\r\n    }\r\n\r\n    if (token != 0) {\r\n        //合约管理员发送抵押资产到出借人,数量由上层传入\r\n        partnerTokens[partnerId][token][borrower] = safeSub(partnerTokens[partnerId][token][borrower], lenderAmount);\r\n        if (!EIP20Interface(token).asmTransfer(partnerOrderBook[partnerId][borrower][hash].lender, lenderAmount)) {\r\n            return fail(\"closepstion\", Error.CLOSE_POSITION_TX_ERROR);\r\n        }\r\n\r\n        //合约管理员发送抵押资产到平台合作方,数量由上层传入\r\n        partnerTokens[partnerId][token][borrower] = safeSub(partnerTokens[partnerId][token][borrower], partnerFeeAmount);\r\n        if (!EIP20Interface(token).asmTransfer(partnerAccounts[partnerId], partnerFeeAmount)) {\r\n            return fail(\"closepstion\", Error.CLOSE_POSITION_TX_ERROR);\r\n        }\r\n\r\n        //合约管理员发送抵押资产到项目方,数量由上层传入\r\n        partnerTokens[partnerId][token][borrower] = safeSub(partnerTokens[partnerId][token][borrower], offcialFeeAmount);\r\n        if (!EIP20Interface(token).asmTransfer(offcialFeeAccount, offcialFeeAmount)) {\r\n            return fail(\"closepstion\", Error.CLOSE_POSITION_TX_ERROR);\r\n        }\r\n\r\n        //合约管理员发送剩余抵押资产到借款方,数量由上层传入\r\n        if (partnerTokens[partnerId][token][borrower] > 0) {\r\n          if (!EIP20Interface(token).asmTransfer(borrower, partnerTokens[partnerId][token][borrower])) {\r\n              return fail(\"closepstion\", Error.CLOSE_POSITION_TX_ERROR);\r\n          } else {\r\n            partnerTokens[partnerId][token][borrower] = 0;\r\n          }\r\n        }\r\n    } else {\r\n        //eth pledge\r\n        if (!sendEth(partnerId, partnerOrderBook[partnerId][borrower][hash].lender, token, lenderAmount)) {\r\n            return fail(\"repay\", Error.FORCE_REPAY_SEND_ETH_ERROR);\r\n        }\r\n        if (!sendEth(partnerId, partnerAccounts[partnerId], token, partnerFeeAmount)) {\r\n            return fail(\"repay\", Error.FORCE_REPAY_SEND_ETH_ERROR);\r\n        }\r\n        if (!sendEth(partnerId, offcialFeeAccount, token, offcialFeeAmount)) {\r\n            return fail(\"repay\", Error.FORCE_REPAY_SEND_ETH_ERROR);\r\n        }\r\n\r\n        bool ok = sendEth(partnerId, borrower, token, partnerTokens[partnerId][token][borrower]);\r\n        if (ok) {\r\n            status = 0;\r\n        }\r\n    }\r\n\r\n    delete partnerOrderBook[partnerId][borrower][hash];\r\n\r\n    emit Closepstion(partnerId, borrower, hash, token, address(this));\r\n\r\n    return 0;\r\n  }\r\n\r\n    //ADDITIONAL HELPERS ADDED FOR TESTING\r\n    function hash(\r\n        bytes32 partnerId,\r\n        address tokenGet,\r\n        uint amountGet,\r\n        address tokenGive,\r\n        uint amountGive,\r\n        uint nonce,\r\n        uint lendingCycle,\r\n        uint pledgeRate,\r\n        uint interestRate,\r\n        uint feeRate\r\n    )\r\n        public\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        //return sha256(this, tokenGet, amountGet, tokenGive, amountGive, nonce, lendingCycle, pledgeRate, interestRate, feeRate);\r\n        return sha256(abi.encodePacked(address(this), partnerId, tokenGet, amountGet, tokenGive, amountGive, nonce, lendingCycle, pledgeRate, interestRate, feeRate));\r\n    }\r\n}",
      "file": "TheForceLending.sol"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0xc458668352c6086e819008675b382988ea1c49efc6810d99e51716ad5093d3b7",
    "blockNumber": 314710,
    "transactionHash": "0x2527f4db6a273c10927730fba069a177487f1c6a2afd751421abed6848a1a7ff",
    "timestamp": 1571970201
  },
  "constructorArguments": [
    "0x9957887a260c7db1d4cb1fa67c0ce43d9b1d72c5",
    "0x9957887a260c7db1d4cb1fa67c0ce43d9b1d72c5"
  ]
}