{
  "address": "0x695e0653bd662ed0deb7e9ecd480cf51a9c1ef12",
  "net": {
    "id": "31",
    "name": "RSK Testnet"
  },
  "name": "DynamicCryptoFund",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "metadata",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ]
      }
    }
  },
  "version": "0.6.9+commit.3e3065ac",
  "source": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.9;\n\n\n//////////////////////////////////////////////////////////////\n//                                                          //\n//         Dynamic Diverse Open End Crypto Fund             //\n//                                                          //\n//////////////////////////////////////////////////////////////\n\n\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n      if (a == 0) {\n          return 0;\n      }\n      uint256 c = a * b;\n      require(c / a == b, \"SafeMath: multiplication overflow\");\n      return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n      return div(a, b, \"SafeMath: division by zero\");\n  }\n\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n      require(b > 0, errorMessage);\n      uint256 c = a / b;\n      return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n      return sub(a, b, \"SafeMath: subtraction overflow\");\n  }\n\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n      require(b <= a, errorMessage);\n      uint256 c = a - b;\n      return c;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n      uint256 c = a + b;\n      require(c >= a, \"SafeMath: addition overflow\");\n      return c;\n  }\n}\n\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        // silence state mutability warning without generating bytecode\n        this;\n        return msg.data;\n    }\n}\n\n\ncontract OwnableContract is Context {\n      address internal owner;\n      event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n      constructor () internal {\n          address msgSender = _msgSender();\n          owner = msgSender;\n          emit OwnershipTransferred(address(0), msgSender);\n      }\n\n      modifier onlyOwner() {\n          require(owner == _msgSender(), \"Ownable: caller is not the owner\");\n          _;\n      }\n\n      function getOwner() public view returns (address) {\n          return owner;\n      }\n\n      function transferOwnership(address newOwner) public virtual onlyOwner {\n          require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n          emit OwnershipTransferred(owner, newOwner);\n          owner = newOwner;\n      }\n}\n\n\ncontract Dynamic_RRC20 is OwnableContract {\n\n    using SafeMath for uint256;\n\n    string public constant standard = \"RRC-20 standard CIF Crypto-Investment Fund\";\n    // Hardcoded to be a constant\n    //uint8 public constant decimals = 8;\n    uint8 public decimals;\n    uint256 public totalSupply;\n    string public name;\n    string public symbol;\n    uint256 public holdTime;\n    uint256 public holdMax;\n    uint256 public maxSupply;\n\n    mapping (address => uint256) internal balances;\n    mapping (address => uint256) public redemptionRequests;\n    mapping (address => mapping (address => uint256)) internal allowed;\n    mapping (address => timeHold) holded;\n    struct timeHold{\n        uint256[] amount;\n        uint256[] time;\n        uint256 length;\n    }\n\n    event LogTokenTransfer(address indexed from, address indexed to, uint256 value);\n    event LogApproval(address indexed owner, address indexed spender, uint256 value);\n    event LogVariationPrice(uint256 value);\n\n    function tokenBalanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function holdedAmountOf(address _owner, uint256 n) public view returns (uint256) {\n        return holded[_owner].amount[n];\n    }\n\n    function holdedTimeOf(address _owner, uint256 n) public view returns (uint256) {\n    return holded[_owner].time[n];\n    }\n\n    function holdedLenghtOf(address _owner) public view returns (uint256) {\n        return holded[_owner].length;\n    }\n\n    function redemptionRequestsOf(address _owner) public view returns (uint256) {\n        return redemptionRequests[_owner];\n    }\n\n    function hold(address _to, uint256 _value) internal {\n        holded[_to].amount.push(_value);\n        holded[_to].time.push(block.number);\n        holded[_to].length++;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[msg.sender]);\n        // SafeMath.sub will throw if there is not enough balance.\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        delete holded[msg.sender];\n\t\thold(msg.sender, balances[msg.sender]);\n        hold(_to,_value);\n        balances[_to] = balances[_to].add(_value);\n        emit LogTokenTransfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n        balances[_from] = balances[_from].sub(_value);\n        delete holded[_from];\n\t\thold(_from, balances[_from]);  \n        hold(_to,_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit LogTokenTransfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit LogApproval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n        emit LogApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n        uint oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit LogApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\n            return true;\n        }\n    }\n}\n\n\ninterface tokenRecipient {\n    function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external ;\n}\n\n\ncontract DynamicCryptoFund is Dynamic_RRC20 {\n\n    uint256 public tokenPrice = 0;\n    // constant to simplify conversion of token amounts into integer form\n    uint256 public tokenUnit = uint256(10)**decimals;\n    uint256 public contractFunds = 0;\n\n    mapping(address => uint256) internal funds;\n\n    event LogDeposit(address sender, uint amount);\n    event LogWithdrawal(address receiver, uint amount);\n    event LogRequestedRedemption(address sender, uint value);\n\n    constructor(uint8 decimals_, uint256 initialSupply, uint256 contractHoldTime, uint256 contractHoldMax, uint256 contractMaxSupply, address contractOwner) public {\n        name = \"Dynamic Diverse Crypto Fund\";\n        symbol = \"D2\";\n        decimals = decimals_;\n        totalSupply = initialSupply;\n        holdTime = contractHoldTime;\n        holdMax = contractHoldMax;\n        maxSupply = contractMaxSupply;\n        owner = contractOwner;\n        balances[contractOwner] = balances[contractOwner].add(totalSupply);\n    }\n\n    function _setupDecimals(uint8 decimals_) internal {\n        decimals = decimals_;\n    }\n\n\n    receive() external payable {\n        buy();\n        contractFunds = address(this).balance;\n    }\n\n    function depositFunds() external payable onlyOwner returns(bool success) {\n        // Check for overflows;\n        assert(address(this).balance + msg.value >= address(this).balance);\n        contractFunds = address(this).balance;\n        emit LogDeposit(msg.sender, msg.value);\n        return true;\n    }\n\n    function withdrawRedemption() external {\n        uint i = 0;\n        uint256 ethAmount = 0;\n        uint256 request = 0;\n        uint256 len = holded[msg.sender].length;\n        while (i <= len - 1){\n            if (block.number - holded[msg.sender].time[i] > holdTime && block.number - holded[msg.sender].time[i] < holdMax){\n                ethAmount += tokenPrice * holded[msg.sender].amount[i];\n            }\n            i++;\n        }\n        require(ethAmount > 0);\n        require(ethAmount>=(tokenPrice*redemptionRequests[msg.sender]));\n        totalSupply = totalSupply.sub(redemptionRequests[msg.sender]);\n        balances[msg.sender] = balances[msg.sender].sub(redemptionRequests[msg.sender]);\n        contractFunds = address(this).balance.sub(tokenPrice*redemptionRequests[msg.sender]/tokenUnit);\n        emit LogTokenTransfer(msg.sender, address(this), redemptionRequests[msg.sender]);\n        delete holded[msg.sender];\n        hold(msg.sender,balances[msg.sender]);\n        request = redemptionRequests[msg.sender];\n        msg.sender.transfer(tokenPrice*redemptionRequests[msg.sender]/tokenUnit);\n        delete redemptionRequests[msg.sender];\n    }\n\n    function setPrice(uint256 _value) public onlyOwner {\n      tokenPrice = _value;\n      emit LogVariationPrice(_value);\n    }\n\n    function requestRedemption(uint value) public {\n      require(value <= balances[msg.sender]);\n      delete holded[msg.sender];\n      hold(msg.sender, value);\n      redemptionRequests[msg.sender]=value;\n      emit LogRequestedRedemption(msg.sender, value);\n    }\n\n    function buy() public payable {\n        require(totalSupply <= maxSupply);\n        require(msg.value > 0);\n        uint256 tokenAmount = (msg.value * tokenUnit) / tokenPrice ;\n        contractFunds = address(this).balance;\n        transferBuy(msg.sender, tokenAmount);\n    }\n\n    function transferBuy(address _to, uint256 _value) internal returns (bool) {\n        require(_to != address(0));\n        // SafeMath.add will throw if there is not enough balance.\n        totalSupply = totalSupply.add(_value);\n        hold(_to,_value); \n        balances[_to] = balances[_to].add(_value);\n        emit LogTokenTransfer(address(this), _to, _value);\n        return true;\n    }\n\n    function withdrawFunds(uint _value) external onlyOwner returns(bool success) {\n        require(msg.sender == owner);\n        assert(address(this).balance + _value >= address(this).balance);\n        // Reentrancy guard\n        contractFunds = address(this).balance.sub(_value);\n        uint fund = address(this).balance;    \n        msg.sender.transfer(fund);\n        return true;\n    }\n    \n}",
  "imports": [
    {
      "name": "DynamicCryptoFund2.sol",
      "contents": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.9;\n\n\n//////////////////////////////////////////////////////////////\n//                                                          //\n//         Dynamic Diverse Open End Crypto Fund             //\n//                                                          //\n//////////////////////////////////////////////////////////////\n\n\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n      if (a == 0) {\n          return 0;\n      }\n      uint256 c = a * b;\n      require(c / a == b, \"SafeMath: multiplication overflow\");\n      return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n      return div(a, b, \"SafeMath: division by zero\");\n  }\n\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n      require(b > 0, errorMessage);\n      uint256 c = a / b;\n      return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n      return sub(a, b, \"SafeMath: subtraction overflow\");\n  }\n\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n      require(b <= a, errorMessage);\n      uint256 c = a - b;\n      return c;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n      uint256 c = a + b;\n      require(c >= a, \"SafeMath: addition overflow\");\n      return c;\n  }\n}\n\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        // silence state mutability warning without generating bytecode\n        this;\n        return msg.data;\n    }\n}\n\n\ncontract OwnableContract is Context {\n      address internal owner;\n      event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n      constructor () internal {\n          address msgSender = _msgSender();\n          owner = msgSender;\n          emit OwnershipTransferred(address(0), msgSender);\n      }\n\n      modifier onlyOwner() {\n          require(owner == _msgSender(), \"Ownable: caller is not the owner\");\n          _;\n      }\n\n      function getOwner() public view returns (address) {\n          return owner;\n      }\n\n      function transferOwnership(address newOwner) public virtual onlyOwner {\n          require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n          emit OwnershipTransferred(owner, newOwner);\n          owner = newOwner;\n      }\n}\n\n\ncontract Dynamic_RRC20 is OwnableContract {\n\n    using SafeMath for uint256;\n\n    string public constant standard = \"RRC-20 standard CIF Crypto-Investment Fund\";\n    // Hardcoded to be a constant\n    //uint8 public constant decimals = 8;\n    uint8 public decimals;\n    uint256 public totalSupply;\n    string public name;\n    string public symbol;\n    uint256 public holdTime;\n    uint256 public holdMax;\n    uint256 public maxSupply;\n\n    mapping (address => uint256) internal balances;\n    mapping (address => uint256) public redemptionRequests;\n    mapping (address => mapping (address => uint256)) internal allowed;\n    mapping (address => timeHold) holded;\n    struct timeHold{\n        uint256[] amount;\n        uint256[] time;\n        uint256 length;\n    }\n\n    event LogTokenTransfer(address indexed from, address indexed to, uint256 value);\n    event LogApproval(address indexed owner, address indexed spender, uint256 value);\n    event LogVariationPrice(uint256 value);\n\n    function tokenBalanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function holdedAmountOf(address _owner, uint256 n) public view returns (uint256) {\n        return holded[_owner].amount[n];\n    }\n\n    function holdedTimeOf(address _owner, uint256 n) public view returns (uint256) {\n    return holded[_owner].time[n];\n    }\n\n    function holdedLenghtOf(address _owner) public view returns (uint256) {\n        return holded[_owner].length;\n    }\n\n    function redemptionRequestsOf(address _owner) public view returns (uint256) {\n        return redemptionRequests[_owner];\n    }\n\n    function hold(address _to, uint256 _value) internal {\n        holded[_to].amount.push(_value);\n        holded[_to].time.push(block.number);\n        holded[_to].length++;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[msg.sender]);\n        // SafeMath.sub will throw if there is not enough balance.\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        delete holded[msg.sender];\n\t\thold(msg.sender, balances[msg.sender]);\n        hold(_to,_value);\n        balances[_to] = balances[_to].add(_value);\n        emit LogTokenTransfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n        balances[_from] = balances[_from].sub(_value);\n        delete holded[_from];\n\t\thold(_from, balances[_from]);  \n        hold(_to,_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit LogTokenTransfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit LogApproval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n        emit LogApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n        uint oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit LogApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\n            return true;\n        }\n    }\n}\n\n\ninterface tokenRecipient {\n    function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external ;\n}\n\n\ncontract DynamicCryptoFund is Dynamic_RRC20 {\n\n    uint256 public tokenPrice = 0;\n    // constant to simplify conversion of token amounts into integer form\n    uint256 public tokenUnit = uint256(10)**decimals;\n    uint256 public contractFunds = 0;\n\n    mapping(address => uint256) internal funds;\n\n    event LogDeposit(address sender, uint amount);\n    event LogWithdrawal(address receiver, uint amount);\n    event LogRequestedRedemption(address sender, uint value);\n\n    constructor(uint8 decimals_, uint256 initialSupply, uint256 contractHoldTime, uint256 contractHoldMax, uint256 contractMaxSupply, address contractOwner) public {\n        name = \"Dynamic Diverse Crypto Fund\";\n        symbol = \"D2\";\n        decimals = decimals_;\n        totalSupply = initialSupply;\n        holdTime = contractHoldTime;\n        holdMax = contractHoldMax;\n        maxSupply = contractMaxSupply;\n        owner = contractOwner;\n        balances[contractOwner] = balances[contractOwner].add(totalSupply);\n    }\n\n    function _setupDecimals(uint8 decimals_) internal {\n        decimals = decimals_;\n    }\n\n\n    receive() external payable {\n        buy();\n        contractFunds = address(this).balance;\n    }\n\n    function depositFunds() external payable onlyOwner returns(bool success) {\n        // Check for overflows;\n        assert(address(this).balance + msg.value >= address(this).balance);\n        contractFunds = address(this).balance;\n        emit LogDeposit(msg.sender, msg.value);\n        return true;\n    }\n\n    function withdrawRedemption() external {\n        uint i = 0;\n        uint256 ethAmount = 0;\n        uint256 request = 0;\n        uint256 len = holded[msg.sender].length;\n        while (i <= len - 1){\n            if (block.number - holded[msg.sender].time[i] > holdTime && block.number - holded[msg.sender].time[i] < holdMax){\n                ethAmount += tokenPrice * holded[msg.sender].amount[i];\n            }\n            i++;\n        }\n        require(ethAmount > 0);\n        require(ethAmount>=(tokenPrice*redemptionRequests[msg.sender]));\n        totalSupply = totalSupply.sub(redemptionRequests[msg.sender]);\n        balances[msg.sender] = balances[msg.sender].sub(redemptionRequests[msg.sender]);\n        contractFunds = address(this).balance.sub(tokenPrice*redemptionRequests[msg.sender]/tokenUnit);\n        emit LogTokenTransfer(msg.sender, address(this), redemptionRequests[msg.sender]);\n        delete holded[msg.sender];\n        hold(msg.sender,balances[msg.sender]);\n        request = redemptionRequests[msg.sender];\n        msg.sender.transfer(tokenPrice*redemptionRequests[msg.sender]/tokenUnit);\n        delete redemptionRequests[msg.sender];\n    }\n\n    function setPrice(uint256 _value) public onlyOwner {\n      tokenPrice = _value;\n      emit LogVariationPrice(_value);\n    }\n\n    function requestRedemption(uint value) public {\n      require(value <= balances[msg.sender]);\n      delete holded[msg.sender];\n      hold(msg.sender, value);\n      redemptionRequests[msg.sender]=value;\n      emit LogRequestedRedemption(msg.sender, value);\n    }\n\n    function buy() public payable {\n        require(totalSupply <= maxSupply);\n        require(msg.value > 0);\n        uint256 tokenAmount = (msg.value * tokenUnit) / tokenPrice ;\n        contractFunds = address(this).balance;\n        transferBuy(msg.sender, tokenAmount);\n    }\n\n    function transferBuy(address _to, uint256 _value) internal returns (bool) {\n        require(_to != address(0));\n        // SafeMath.add will throw if there is not enough balance.\n        totalSupply = totalSupply.add(_value);\n        hold(_to,_value); \n        balances[_to] = balances[_to].add(_value);\n        emit LogTokenTransfer(address(this), _to, _value);\n        return true;\n    }\n\n    function withdrawFunds(uint _value) external onlyOwner returns(bool success) {\n        require(msg.sender == owner);\n        assert(address(this).balance + _value >= address(this).balance);\n        // Reentrancy guard\n        contractFunds = address(this).balance.sub(_value);\n        uint fund = address(this).balance;    \n        msg.sender.transfer(fund);\n        return true;\n    }\n    \n}",
      "file": "DynamicCryptoFund2.sol"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x09f2f336ed05262da649369efce7f4e94504be6c28225eddf7edb6c068ffb6cd",
    "blockNumber": 930270,
    "transactionHash": "0x5e97cffbcae7da942e9a17573c236e384a576ceb7f8ffec44a374da76e1f8dce",
    "timestamp": 1592092881
  },
  "constructorArguments": [
    "8",
    "0",
    "1",
    "10",
    "1000000000000",
    "0xe644ec29654c47857d171d8f7bfe5822d41a61bb"
  ]
}