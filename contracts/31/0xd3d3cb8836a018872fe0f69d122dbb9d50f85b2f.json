{
  "address": "0xd3d3cb8836a018872fe0f69d122dbb9d50f85b2f",
  "net": {
    "id": "31",
    "name": "RSK Testnet"
  },
  "name": "DelayMachine",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    }
  },
  "version": "0.6.12+commit.27d51765",
  "source": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.6.12;\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n  @title ChangeContract\r\n  @notice This interface is the one used by the governance system.\r\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\r\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\r\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\r\n  system is fully in place.\r\n */\r\ninterface ChangeContract {\r\n    /**\r\n      @notice Override this function with a recipe of the changes to be done when this ChangeContract\r\n      is executed\r\n     */\r\n    function execute() external;\r\n}\r\n\r\n\r\n/**\r\n  @title Governor\r\n  @notice Governor interface. This functions should be overwritten to\r\n  enable the comunnication with the rest of the system\r\n  */\r\ninterface IGovernor {\r\n    /**\r\n      @notice Function to be called to make the changes in changeContract\r\n      @dev This function should be protected somehow to only execute changes that\r\n      benefit the system. This decision process is independent of this architechture\r\n      therefore is independent of this interface too\r\n      @param changeContract Address of the contract that will execute the changes\r\n     */\r\n    function executeChange(ChangeContract changeContract) external;\r\n\r\n    /**\r\n      @notice Function to be called to make the changes in changeContract\r\n      @param _changer Address of the contract that will execute the changes\r\n     */\r\n    function isAuthorizedChanger(address _changer) external view returns (bool);\r\n}\r\n\r\n\r\n/**\r\n  @title Governed\r\n  @notice Base contract to be inherited by governed contracts\r\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\r\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\r\n  governance aspect of the child contract\r\n  */\r\ncontract Governed {\r\n    /**\r\n      @notice The address of the contract which governs this one\r\n     */\r\n    IGovernor public governor;\r\n\r\n    string private constant NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\r\n\r\n    /**\r\n      @notice Modifier that protects the function\r\n      @dev You should use this modifier in any function that should be called through\r\n      the governance system\r\n     */\r\n    modifier onlyAuthorizedChanger() {\r\n        require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\r\n        _;\r\n    }\r\n\r\n    /**\r\n      @notice Initialize the contract with the basic settings\r\n      @dev This initialize replaces the constructor but it is not called automatically.\r\n      It is necessary because of the upgradeability of the contracts\r\n      @param _governor Governor address\r\n     */\r\n    function _initialize(IGovernor _governor) internal {\r\n        governor = _governor;\r\n    }\r\n\r\n    /**\r\n      @notice Change the contract's governor. Should be called through the old governance system\r\n      @param newIGovernor New governor address\r\n     */\r\n    function changeIGovernor(IGovernor newIGovernor) external onlyAuthorizedChanger {\r\n        governor = newIGovernor;\r\n    }\r\n\r\n    /**\r\n      @notice This method is used by a change contract to access the storage freely even without a setter.\r\n      @param data the serialized function arguments\r\n     */\r\n    function delegateCallToChanger(bytes calldata data)\r\n        external\r\n        onlyAuthorizedChanger\r\n        returns (bytes memory)\r\n    {\r\n        address changerContrat = msg.sender;\r\n        (bool success, bytes memory result) = changerContrat.delegatecall(\r\n            abi.encodeWithSignature(\"impersonate(bytes)\", data)\r\n        );\r\n        require(success, \"Error in delegate call\");\r\n        return result;\r\n    }\r\n\r\n    // Leave a gap betweeen inherited contracts variables in order to be\r\n    // able to add more variables in them later\r\n    uint256[50] private upgradeGap;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/// @title This contract provides an interface for feeding prices from oracles, and\r\n///        get the current price. One contract must be instanced per supported coin pair,\r\n///        and registered through OracleManager global contract.\r\n/// This contract has two lists:\r\n/// 1) A subscribed list (EnumerableSet.AddressSet) oracles owner addresses, this list has a max size (30).\r\n/// 2) A selected list, EnumerableSet.AddressSet of oracles owner addresses that are selected to participate in\r\n/// current publication round (10 entries max size).\r\n///\r\n/// Oracles are subscribed by adding them to the subscribed oracle list. When the list is full\r\n/// the oracle with less stake can be removed by a new oracle that is trying to\r\n/// subscribe (if its stake is greater than his).\r\n/// On each round switch the list of selected oracles is populated with the 10 Oracles with more stake. An oracle\r\n/// can unsubscribe itself from the subscribed list in the middle of the round, in this case, the oracle is still\r\n/// listed in the selected list until the round ends.\r\n/// If an oracle withdraw some stake then his participation in the round is put into consideration: If the\r\n/// oracle ends up having less stake than the next oracle in the subscribed list (but not in the selected list) then\r\n/// it is removed from the selected list and the point he accumulated during the round are lost (set to zero).\r\n\r\ninterface ICoinPairPrice {\r\n    // getOracleOwnerAddress: Given an Oracle address return the Oracle Owner address.\r\n    // Used during publication, the servers sign with the oracle address, but the list of selected oracles\r\n    // is by oracle owner address.\r\n    // getOracleOwnerStake: Get the stake stored in the supporters smart-contract\r\n    // prettier-ignore\r\n    struct CoinPairPriceCallbacks {\r\n        function (address) external view returns (address) getOracleOwnerAddress;\r\n        function (address) external view returns (uint256) getOracleOwnerStake;\r\n    }\r\n\r\n    /// @notice subscribe an oracle to this coin pair, allowing it to be selected in the next round.\r\n    /// If the subscribed list is full and the current oracle has more stake than one with minimum stake in the\r\n    /// subscribed list, then the one with minimum stake is replaced.\r\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\r\n    /// @dev This is designed to be called from OracleManager.\r\n    function subscribe(address oracleOwnerAddr) external;\r\n\r\n    /// @notice Unsubscribe an oracle from this coin pair. The oracle won't be selected in the next round.\r\n    /// After the round end, the oracle can withdraw stake without having the risk of loosing won points.\r\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\r\n    /// @dev This is designed to be called from OracleManager.\r\n    function unsubscribe(address oracleOwnerAddr) external;\r\n\r\n    /// @notice Returns true if an oracle is subscribed to this contract' coin pair\r\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\r\n    /// @dev This is designed to be called from OracleManager.\r\n    function isSubscribed(address oracleOwnerAddr) external view returns (bool);\r\n\r\n    /// @notice Publish a price. (The message contain oracleAddresses that must be converted to owner addresses).\r\n    /// @param _version Version number of message format (3)\r\n    /// @param _coinpair The coin pair to report (must match this contract)\r\n    /// @param _price Price to report.\r\n    /// @param _votedOracle The address of the oracle voted as a publisher by the network.\r\n    /// @param _blockNumber The blocknumber acting as nonce to prevent replay attacks.\r\n    /// @param _sigV The array of V-component of Oracle signatures.\r\n    /// @param _sigR The array of R-component of Oracle signatures.\r\n    /// @param _sigS The array of S-component of Oracle signatures.\r\n    function publishPrice(\r\n        uint256 _version,\r\n        bytes32 _coinpair,\r\n        uint256 _price,\r\n        address _votedOracle,\r\n        uint256 _blockNumber,\r\n        uint8[] calldata _sigV,\r\n        bytes32[] calldata _sigR,\r\n        bytes32[] calldata _sigS\r\n    ) external;\r\n\r\n    /// @notice Publish a price without signature validation (when there is an emergecy!!!).\r\n    /// @param _price Price to report.\r\n    function emergencyPublish(uint256 _price) external;\r\n\r\n    /// @notice The oracle owner has withdrawn some stake.\r\n    /// Must check if the oracle is part of current round and if he lost his place with the\r\n    /// new stake value (the stake is global and is saved in the supporters contract).\r\n    /// @param oracleOwnerAddr the oracle owner that is trying to withdraw\r\n    function onWithdraw(address oracleOwnerAddr) external returns (uint256);\r\n\r\n    /// @notice Switch contract context to a new round. With the objective of\r\n    /// being a decentralized solution, this can be called by *anyone* if current\r\n    /// round lock period is expired.\r\n    /// This method search the subscribed list and choose the 10 with more stake.\r\n    function switchRound() external;\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS\r\n\r\n    /// @notice Return the available reward fees\r\n    ///\r\n    function getAvailableRewardFees() external view returns (uint256);\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS TO GET CURRENT PRICE\r\n    // MUST BE WHITELISTED\r\n    /// @notice Return the current price, compatible with old MOC Oracle\r\n    function peek() external view returns (bytes32, bool);\r\n\r\n    /// @notice Return the current price\r\n    function getPrice() external view returns (uint256);\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////// GETTERS TO GET CURRENT PRICE END\r\n\r\n    /// @notice Return current round information\r\n    function getRoundInfo()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 round,\r\n            uint256 startBlock,\r\n            uint256 lockPeriodTimestamp,\r\n            uint256 totalPoints,\r\n            address[] memory selectedOwners,\r\n            address[] memory selectedOracles\r\n        );\r\n\r\n    /// @notice Return round information for specific oracle\r\n    function getOracleRoundInfo(address addr)\r\n        external\r\n        view\r\n        returns (uint256 points, bool selectedInCurrentRound);\r\n\r\n    // The maximum count of oracles selected to participate each round\r\n    function maxOraclesPerRound() external view returns (uint256);\r\n\r\n    // The round lock period in secs\r\n    function roundLockPeriodSecs() external view returns (uint256);\r\n\r\n    function isOracleInCurrentRound(address oracleAddr) external view returns (bool);\r\n\r\n    /// @notice Returns the amount of oracles subscribed to this coin pair.\r\n    function getSubscribedOraclesLen() external view returns (uint256);\r\n\r\n    /// @notice Returns the oracle owner address that is subscribed to this coin pair\r\n    /// @param idx index to query.\r\n    function getSubscribedOracleAtIndex(uint256 idx) external view returns (address ownerAddr);\r\n\r\n    // Public variable\r\n    function getMaxSubscribedOraclesPerRound() external view returns (uint256);\r\n\r\n    // Public variable\r\n    function getCoinPair() external view returns (bytes32);\r\n\r\n    // Public variable\r\n    function getLastPublicationBlock() external view returns (uint256);\r\n\r\n    // Public variable\r\n    function getValidPricePeriodInBlocks() external view returns (uint256);\r\n\r\n    // Public variable\r\n    function getEmergencyPublishingPeriodInBlocks() external view returns (uint256);\r\n\r\n    // Public variable\r\n    function getOracleManager() external view returns (IOracleManager);\r\n\r\n    // Public variable\r\n    function getToken() external view returns (IERC20);\r\n}\r\n\r\n\r\n/// This contract manages the Oracle and CoinPair registration info.\r\n/// The Oracle python server interacts with this contract:\r\n/// - Coin pair registration\r\n/// - Oracle registration to coin pairs\r\n/// - Access Oracle info (oracle address + url) indexed by oracle owner address\r\n/// - Get the oracle information (url + the specifics of some coin pair rounds) from an oracle address\r\n/// - Get the oracle address from the owner address.\r\ninterface IOracleManager {\r\n    // getOracleOwnerStake: Get the stake stored in the supporters smart-contract\r\n    // prettier-ignore\r\n    struct OracleManagerCallbacks {\r\n        function (address) external view returns (uint256) getOracleOwnerStake;\r\n    }\r\n\r\n    /// @notice Register a new coin pair contract (the contract must be created separately).\r\n    /// Once created the coin pairs cannot be removed.\r\n    /// @param coinPair The bytes32-encoded coinpair string (e.g. BTCUSD)\r\n    /// @param addr The contract address associated to the coin pair.\r\n    function registerCoinPair(bytes32 coinPair, address addr) external;\r\n\r\n    /// Register an oracle in the system must be called by the oracle owner.\r\n    /// @notice Registers the oracle and transfer the specified caller's MOC token stake.\r\n    /// @param oracleOwnerAddr The address of the owner of the oracle.\r\n    /// @param oracleAddr Address of the Oracle to register.\r\n    /// @param internetName Public Internet name of this Oracle.\r\n    function registerOracle(\r\n        address oracleOwnerAddr,\r\n        address oracleAddr,\r\n        string calldata internetName\r\n    ) external;\r\n\r\n    /// @notice Change the oracle \"internet\" name (URI), called by the owner.\r\n    /// @param oracleOwnerAddr The address of the owner of the oracle.\r\n    /// @param name The new name to set.\r\n    function setOracleName(address oracleOwnerAddr, string calldata name) external;\r\n\r\n    /// @notice Change the oracle address, called by the owner.\r\n    /// @param oracleOwnerAddr The address of the owner of the oracle.\r\n    /// @param oracleAddr new value for the address of the oracle\r\n    function setOracleAddress(address oracleOwnerAddr, address oracleAddr) external;\r\n\r\n    /// @notice Removes the oracle registration info. Must be called by the owner\r\n    /// The oracle must be previously unregistered from all coin pairs.\r\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\r\n    function removeOracle(address oracleOwnerAddr) external;\r\n\r\n    /// @notice Subscribe a registered oracle to participate in the next round of a registered coin-pair.\r\n    /// @param oracleOwnerAddr Address of oracle owner\r\n    function subscribeToCoinPair(address oracleOwnerAddr, bytes32 coinPair) external;\r\n\r\n    /// @notice Unsubscribe a registered oracle from participating in rounds of a registered coin-pair.\r\n    /// The oracle is flagged so it is not selected in the next round.\r\n    /// @param oracleOwnerAddr Address of oracle owner\r\n    function unSubscribeFromCoinPair(address oracleOwnerAddr, bytes32 coinPair) external;\r\n\r\n    /// @notice The oracle owner did a partial withdrawal of funds\r\n    /// 1. The oracle address is searched by the owner address.\r\n    /// 2. Each coin pair to which the oracle is subscribed is consulted to:\r\n    ///   - Check if the new amount is enough to stay in the current round.\r\n    ///       If not the oracle is replaced and lost his points.\r\n    ///   - Get the timestamp for the round end.\r\n    /// The return value is the maximum timestamp from all the coin pairs.\r\n    /// @param oracleOwnerAddr Address of oracle owner\r\n    /// @return the timestamp until which the funds must be locked.\r\n    function onWithdraw(address oracleOwnerAddr) external returns (uint256);\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS USED BY COINPAIR\r\n    /// @notice Used by the coin pair to get the oracle address from the oracleOwnerAddress.\r\n    /// @param  oracleOwnerAddr the address of the owner of the oracle.\r\n    /// @return oracleAddr Address of oracle\r\n    function getOracleAddress(address oracleOwnerAddr) external view returns (address oracleAddr);\r\n\r\n    /// @notice Returns true if oracle is registered.\r\n    /// @param ownerAddr The address of the oracle's owner.\r\n    function isRegistered(address ownerAddr) external view returns (bool);\r\n\r\n    /// @notice Used by CoinPair\r\n    /// @param oracleAddr The oracle address not the owner address.\r\n    function getOracleOwner(address oracleAddr) external view returns (address);\r\n\r\n    /// @notice Returns the amount of owners registered.\r\n    function getRegisteredOraclesLen() external view returns (uint256);\r\n\r\n    /// @notice Returns the oracle name and address at index.\r\n    /// @param idx index to query.\r\n    function getRegisteredOracleAtIndex(uint256 idx)\r\n        external\r\n        view\r\n        returns (\r\n            address ownerAddr,\r\n            address oracleAddr,\r\n            string memory url\r\n        );\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS USED BY COINPAIR END\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS\r\n\r\n    // TODO: Check what is the minimum amount of getters the python server needs.\r\n\r\n    /// @notice Returns true if an oracle is subscribed to a coin pair\r\n    function isSubscribed(address oracleAddr, bytes32 coinPair) external view returns (bool);\r\n\r\n    /// @notice Return true if the oracle is registered on this coin-pair\r\n    /// @param oracleAddr addr The address of the Oracle check for.\r\n    function isOracleRegistered(address oracleAddr) external view returns (bool);\r\n\r\n    /// @notice Returns registration information for a registered Oracle.\r\n    /// @param oracleAddr addr The address of the Oracle to query for.\r\n    function getOracleRegistrationInfo(address oracleAddr)\r\n        external\r\n        view\r\n        returns (\r\n            string memory internetName,\r\n            uint256 stake,\r\n            address _owner\r\n        );\r\n\r\n    /// @notice Returns round information for a registered oracle in a specific coin-pair.\r\n    /// @param oracleAddr address of the oracle to query for.\r\n    /// @param coinpair The coin pair to lookup.\r\n    function getOracleRoundInfo(address oracleAddr, bytes32 coinpair)\r\n        external\r\n        view\r\n        returns (uint256 points, bool selectedInCurrentRound);\r\n\r\n    /// @notice Returns true if an oracle satisfies conditions to be removed from system.\r\n    /// @param oracleAddr the oracle address to lookup.\r\n    function canRemoveOracle(address oracleAddr) external view returns (bool);\r\n\r\n    /// @notice Get the stake in MOCs that an oracle has.\r\n    /// @param oracleAddr The address of the oracle.\r\n    function getStake(address oracleAddr) external view returns (uint256 balance);\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////// GETTER TO LIST COIN PAIRS\r\n\r\n    /// @notice Returns the count of registered coin pairs.\r\n    /// Keep in mind that Deleted coin-pairs will contain zeroed addresses.\r\n    function getCoinPairCount() external view returns (uint256);\r\n\r\n    /// @notice Returns the coin pair at index.\r\n    /// @param i index to query.\r\n    function getCoinPairAtIndex(uint256 i) external view returns (bytes32);\r\n\r\n    /// @notice Return the contract address for a specified registered coin pair.\r\n    /// @param coinpair Coin-pair string to lookup (e.g: BTCUSD)\r\n    /// @return address Address of contract or zero if does not exist or was deleted.\r\n    function getContractAddress(bytes32 coinpair) external view returns (address);\r\n\r\n    /// @notice Searches a coinpair in coinPairList\r\n    /// @param coinPair The bytes32-encoded coinpair string (e.g. BTCUSD)\r\n    /// @param hint Optional hint to start traversing the coinPairList array, zero is to search all the array.\r\n    function getCoinPairIndex(bytes32 coinPair, uint256 hint) external view returns (uint256);\r\n\r\n    function getMaxStake(address[] calldata addresses) external view returns (address, uint256);\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////// GETTER TO LIST COIN PAIRS END\r\n\r\n    // Public variable\r\n    function getStakingContract() external view returns (IStakingMachine);\r\n\r\n    // Public variable\r\n    function getMinCPSubscriptionStake() external view returns (uint256);\r\n}\r\n\r\n\r\n\r\ninterface IDelayMachine {\r\n    /// @notice Accept a deposit from an account.\r\n    /// @param mocs token quantity\r\n    /// @param expiration the expiration date for this deposit\r\n    /// @return id the transaction id\r\n    function deposit(\r\n        uint256 mocs,\r\n        address destination,\r\n        uint256 expiration\r\n    ) external returns (uint256 id);\r\n\r\n    /// @notice Cancel a transaction returning the funds to the source\r\n    /// @param id transaction id\r\n    function cancel(uint256 id) external;\r\n\r\n    /// @notice Withdraw stake, send it to the delay machine.\r\n    /// @param id transaction id\r\n    function withdraw(uint256 id) external;\r\n\r\n    /// @notice Returns the list of transaction for some account\r\n    /// @return ids transaction ids\r\n    /// @return amounts token quantity\r\n    /// @return expirations expiration dates\r\n    function getTransactions(address account)\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory ids,\r\n            uint256[] memory amounts,\r\n            uint256[] memory expirations\r\n        );\r\n\r\n    /// @notice Returns the total balance in MOCs for an account\r\n    function getBalance(address account) external view returns (uint256);\r\n\r\n    // Public variable\r\n    function getToken() external view returns (IERC20);\r\n\r\n    // Public variable\r\n    function getLastId() external view returns (uint256);\r\n\r\n    // Public variable\r\n    function getSource() external view returns (address);\r\n}\r\n\r\n\r\ninterface IStakingMachine {\r\n    /// @notice Used by the voting machine to lock the current balance of MOCs.\r\n    /// @param mocHolder the moc holder whose mocs will be locked.\r\n    /// @param untilTimestamp timestamp until which the mocs will be locked.\r\n    function lockMocs(address mocHolder, uint256 untilTimestamp) external;\r\n\r\n    /// @notice Accept a deposit from an account.\r\n    /// Delegate to the Supporters smart contract.\r\n    /// @param mocs token quantity\r\n    /// @param destination the destination account of this deposit.\r\n    function deposit(uint256 mocs, address destination) external;\r\n\r\n    /// @notice Accept a deposit from an account.\r\n    /// @param mocs token quantity\r\n    /// @param destination the destination account of this deposit.\r\n    /// @param source the address that approved the transfer\r\n    function depositFrom(\r\n        uint256 mocs,\r\n        address destination,\r\n        address source\r\n    ) external;\r\n\r\n    /// @notice Withdraw stake, send it to the delay machine.\r\n    /// @param mocs token quantity\r\n    function withdraw(uint256 mocs) external;\r\n\r\n    /// @notice Reports the balance of MOCs for a specific user.\r\n    /// @param user user address\r\n    function getBalance(address user) external view returns (uint256);\r\n\r\n    /// @notice Reports the locked balance of MOCs for a specific user.\r\n    /// @param user user address\r\n    function getLockedBalance(address user) external view returns (uint256);\r\n\r\n    /// @notice Reports the balance of locked MOCs for a specific user.\r\n    /// Delegates to the Supporters smart contract.\r\n    /// @param user user address\r\n    /// @return amount the amount of mocs locked\r\n    /// @return untilTimestamp the timestamp that corresponds to the locking date.\r\n    function getLockingInfo(address user)\r\n        external\r\n        view\r\n        returns (uint256 amount, uint256 untilTimestamp);\r\n\r\n    // Public variable\r\n    function getSupporters() external view returns (address);\r\n\r\n    // Public variable\r\n    function getOracleManager() external view returns (IOracleManager);\r\n\r\n    // Public variable\r\n    function getMocToken() external view returns (IERC20);\r\n\r\n    // Public variable\r\n    function getDelayMachine() external view returns (IDelayMachine);\r\n\r\n    // Public variable\r\n    function getWithdrawLockTime() external view returns (uint256);\r\n}\r\n\r\ninterface IStakingMachineOracles {\r\n    /// @notice Register an oracle\r\n    /// @param oracleAddr address of the oracle (from which we publish prices)\r\n    /// @param url url used by the oracle server\r\n    function registerOracle(address oracleAddr, string calldata url) external;\r\n\r\n    /// @notice Change the oracle \"internet\" name (URI)\r\n    /// @param url The new url to set.\r\n    function setOracleName(string calldata url) external;\r\n\r\n    /// @notice Change the oracle address\r\n    /// @param oracleAddr The new oracle address\r\n    function setOracleAddress(address oracleAddr) external;\r\n\r\n    /// @notice Return true if the oracle is registered.\r\n    /// @param oracleAddr addr The address of the Oracle check for.\r\n    function isOracleRegistered(address oracleAddr) external view returns (bool);\r\n\r\n    /// @notice Returns true if an oracle satisfies conditions to be removed from system.\r\n    /// @param oracleAddr the oracle address to lookup.\r\n    function canRemoveOracle(address oracleAddr) external view returns (bool);\r\n\r\n    /// @notice Remove an oracle.\r\n    function removeOracle() external;\r\n\r\n    /// @notice Returns the count of registered coin pairs.\r\n    /// Keep in mind that Deleted coin-pairs will contain zeroed addresses.\r\n    function getCoinPairCount() external view returns (uint256);\r\n\r\n    /// @notice Returns the coin pair at index.\r\n    /// @param i index to query.\r\n    function getCoinPairAtIndex(uint256 i) external view returns (bytes32);\r\n\r\n    /// @notice Return the contract address for a specified registered coin pair.\r\n    /// @param coinpair Coin-pair string to lookup (e.g: BTCUSD)\r\n    /// @return address Address of contract or zero if does not exist or was deleted.\r\n    function getContractAddress(bytes32 coinpair) external view returns (address);\r\n\r\n    /// @notice Searches a coinpair in coinPairList\r\n    /// @param coinPair The bytes32-encoded coinpair string (e.g. BTCUSD)\r\n    /// @param hint Optional hint to start traversing the coinPairList array, zero is to search all the array.\r\n    function getCoinPairIndex(bytes32 coinPair, uint256 hint) external view returns (uint256);\r\n\r\n    /// @notice Subscribe an oracle to a coin pair.\r\n    /// @param coinPair coin pair to subscribe, for example BTCUSD\r\n    function subscribeToCoinPair(bytes32 coinPair) external;\r\n\r\n    /// @notice Unsubscribe an oracle from a coin pair.\r\n    /// @param coinPair coin pair to unsubscribe, for example BTCUSD\r\n    function unSubscribeFromCoinPair(bytes32 coinPair) external;\r\n\r\n    /// @notice Returns true if an oracle is subscribed to a coin pair\r\n    /// @param oracleAddr address of the oracle\r\n    /// @param coinPair coin pair to unsubscribe, for example BTCUSD\r\n    function isSubscribed(address oracleAddr, bytes32 coinPair) external view returns (bool);\r\n\r\n    /// @notice Returns the amount of owners registered.\r\n    /// Delegates to the Oracle Manager smart contract.\r\n    function getRegisteredOraclesLen() external view returns (uint256);\r\n\r\n    /// @notice Returns the oracle name and address at index.\r\n    /// Delegates to the Oracle Manager smart contract.\r\n    /// @param idx index to query.\r\n    function getRegisteredOracleAtIndex(uint256 idx)\r\n        external\r\n        view\r\n        returns (\r\n            address ownerAddr,\r\n            address oracleAddr,\r\n            string memory url\r\n        );\r\n}\r\n\r\n\r\n// prettier-ignore\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\r\n * (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n            // Move the last value to the index where the value to delete is\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            // Update the index for the moved value\r\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint256(_at(set._inner, index)));\r\n    }\r\n\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n\r\n\r\ncontract DelayMachineStorage is Initializable, Governed {\r\n    using SafeMath for uint256;\r\n    using EnumerableSet for EnumerableSet.UintSet;\r\n\r\n    struct Payment {\r\n        uint256 expiration;\r\n        uint256 amount;\r\n    }\r\n\r\n    struct Owner {\r\n        EnumerableSet.UintSet ids;\r\n    }\r\n\r\n    uint256 internal _id;\r\n    IERC20 internal _token;\r\n    address internal _source;\r\n    mapping(address => Owner) internal owners;\r\n    mapping(uint256 => Payment) internal payments;\r\n\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    // solhint-disable-next-line no-empty-blocks\r\n    constructor() internal {}\r\n\r\n    // Reserved storage space to allow for layout changes in the future.\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n\r\ncontract DelayMachine is DelayMachineStorage, IDelayMachine {\r\n    using SafeMath for uint256;\r\n\r\n    event PaymentDeposit(\r\n        uint256 indexed id,\r\n        address source,\r\n        address destination,\r\n        uint256 amount,\r\n        uint256 expiration\r\n    );\r\n    event PaymentCancel(uint256 indexed id, address source, address destination, uint256 amount);\r\n    event PaymentWithdraw(uint256 indexed id, address source, address destination, uint256 amount);\r\n\r\n    /// @notice Construct this contract.\r\n    /// @param governor The minimum amount of tokens required as stake for a coin pair subscription.\r\n    /// @param token the Supporters contract contract address.\r\n    function initialize(\r\n        IGovernor governor,\r\n        IERC20 token,\r\n        address source\r\n    ) external initializer {\r\n        _token = token;\r\n        _source = source;\r\n        Governed._initialize(governor);\r\n    }\r\n\r\n    /// @notice Accept a deposit from an account.\r\n    /// @param mocs token quantity\r\n    /// @param destination the destination address which can control the funds.\r\n    /// @param expiration the expiration date for this deposit\r\n    /// @return id the transaction id\r\n    function deposit(\r\n        uint256 mocs,\r\n        address destination,\r\n        uint256 expiration\r\n    ) external override returns (uint256 id) {\r\n        require(msg.sender == _source, \"Wrong source\");\r\n        bool done = _token.transferFrom(_source, address(this), mocs);\r\n        require(done, \"Token transfer failed.\");\r\n        _id = _id + 1;\r\n        payments[_id].expiration = block.timestamp + expiration;\r\n        // solhint-disable-previous-line not-rely-on-time\r\n        payments[_id].amount = mocs;\r\n        owners[destination].ids.add(_id);\r\n        emit PaymentDeposit(_id, _source, destination, mocs, expiration);\r\n        return _id;\r\n    }\r\n\r\n    /// @notice Cancel a transaction returning the funds to the source\r\n    /// @param id transaction id\r\n    function cancel(uint256 id) external override {\r\n        require(owners[msg.sender].ids.contains(id), \"Invalid ID\");\r\n        owners[msg.sender].ids.remove(id);\r\n        bool done = _token.approve(_source, payments[id].amount);\r\n        require(done, \"Token approve failed.\");\r\n        IStakingMachine(_source).depositFrom(payments[id].amount, msg.sender, address(this));\r\n        uint256 amount = payments[id].amount;\r\n        delete (payments[id]);\r\n        emit PaymentCancel(id, _source, msg.sender, amount);\r\n    }\r\n\r\n    /// @notice Withdraw stake, send it to the delay machine.\r\n    /// @param id transaction id\r\n    function withdraw(uint256 id) external override {\r\n        require(owners[msg.sender].ids.contains(id), \"Invalid ID\");\r\n        owners[msg.sender].ids.remove(id);\r\n        require(payments[id].expiration < block.timestamp, \"Not expired\");\r\n        // solhint-disable-previous-line not-rely-on-time\r\n        bool done = _token.transfer(msg.sender, payments[id].amount);\r\n        require(done, \"Token transfer failed.\");\r\n        uint256 amount = payments[id].amount;\r\n        delete (payments[id]);\r\n        emit PaymentWithdraw(id, _source, msg.sender, amount);\r\n    }\r\n\r\n    /// @notice Returns the list of transaction for some account\r\n    /// @param account destination address\r\n    /// @return ids transaction ids\r\n    /// @return amounts token quantity\r\n    /// @return expirations expiration dates\r\n    function getTransactions(address account)\r\n        external\r\n        override\r\n        view\r\n        returns (\r\n            uint256[] memory ids,\r\n            uint256[] memory amounts,\r\n            uint256[] memory expirations\r\n        )\r\n    {\r\n        uint256 len = owners[account].ids.length();\r\n        ids = new uint256[](len);\r\n        amounts = new uint256[](len);\r\n        expirations = new uint256[](len);\r\n        for (uint256 i = 0; i < len; i++) {\r\n            ids[i] = owners[account].ids.at(i);\r\n            amounts[i] = payments[owners[account].ids.at(i)].amount;\r\n            expirations[i] = payments[owners[account].ids.at(i)].expiration;\r\n        }\r\n    }\r\n\r\n    /// @notice Returns the total balance in MOCs for an account\r\n    /// @param account destination address\r\n    /// @return balance token quantity\r\n    function getBalance(address account) external override view returns (uint256) {\r\n        uint256 len = owners[account].ids.length();\r\n        uint256 balance;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            balance = balance + payments[owners[account].ids.at(i)].amount;\r\n        }\r\n        return balance;\r\n    }\r\n\r\n    // Public variable\r\n    function getToken() external override view returns (IERC20) {\r\n        return _token;\r\n    }\r\n\r\n    // Public variable\r\n    function getLastId() external override view returns (uint256) {\r\n        return _id;\r\n    }\r\n\r\n    // Public variable\r\n    function getSource() external override view returns (address) {\r\n        return _source;\r\n    }\r\n}\r\n\r\n",
  "imports": [
    {
      "name": "output2-delay.sol",
      "contents": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.6.12;\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n  @title ChangeContract\r\n  @notice This interface is the one used by the governance system.\r\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\r\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\r\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\r\n  system is fully in place.\r\n */\r\ninterface ChangeContract {\r\n    /**\r\n      @notice Override this function with a recipe of the changes to be done when this ChangeContract\r\n      is executed\r\n     */\r\n    function execute() external;\r\n}\r\n\r\n\r\n/**\r\n  @title Governor\r\n  @notice Governor interface. This functions should be overwritten to\r\n  enable the comunnication with the rest of the system\r\n  */\r\ninterface IGovernor {\r\n    /**\r\n      @notice Function to be called to make the changes in changeContract\r\n      @dev This function should be protected somehow to only execute changes that\r\n      benefit the system. This decision process is independent of this architechture\r\n      therefore is independent of this interface too\r\n      @param changeContract Address of the contract that will execute the changes\r\n     */\r\n    function executeChange(ChangeContract changeContract) external;\r\n\r\n    /**\r\n      @notice Function to be called to make the changes in changeContract\r\n      @param _changer Address of the contract that will execute the changes\r\n     */\r\n    function isAuthorizedChanger(address _changer) external view returns (bool);\r\n}\r\n\r\n\r\n/**\r\n  @title Governed\r\n  @notice Base contract to be inherited by governed contracts\r\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\r\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\r\n  governance aspect of the child contract\r\n  */\r\ncontract Governed {\r\n    /**\r\n      @notice The address of the contract which governs this one\r\n     */\r\n    IGovernor public governor;\r\n\r\n    string private constant NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\r\n\r\n    /**\r\n      @notice Modifier that protects the function\r\n      @dev You should use this modifier in any function that should be called through\r\n      the governance system\r\n     */\r\n    modifier onlyAuthorizedChanger() {\r\n        require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\r\n        _;\r\n    }\r\n\r\n    /**\r\n      @notice Initialize the contract with the basic settings\r\n      @dev This initialize replaces the constructor but it is not called automatically.\r\n      It is necessary because of the upgradeability of the contracts\r\n      @param _governor Governor address\r\n     */\r\n    function _initialize(IGovernor _governor) internal {\r\n        governor = _governor;\r\n    }\r\n\r\n    /**\r\n      @notice Change the contract's governor. Should be called through the old governance system\r\n      @param newIGovernor New governor address\r\n     */\r\n    function changeIGovernor(IGovernor newIGovernor) external onlyAuthorizedChanger {\r\n        governor = newIGovernor;\r\n    }\r\n\r\n    /**\r\n      @notice This method is used by a change contract to access the storage freely even without a setter.\r\n      @param data the serialized function arguments\r\n     */\r\n    function delegateCallToChanger(bytes calldata data)\r\n        external\r\n        onlyAuthorizedChanger\r\n        returns (bytes memory)\r\n    {\r\n        address changerContrat = msg.sender;\r\n        (bool success, bytes memory result) = changerContrat.delegatecall(\r\n            abi.encodeWithSignature(\"impersonate(bytes)\", data)\r\n        );\r\n        require(success, \"Error in delegate call\");\r\n        return result;\r\n    }\r\n\r\n    // Leave a gap betweeen inherited contracts variables in order to be\r\n    // able to add more variables in them later\r\n    uint256[50] private upgradeGap;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/// @title This contract provides an interface for feeding prices from oracles, and\r\n///        get the current price. One contract must be instanced per supported coin pair,\r\n///        and registered through OracleManager global contract.\r\n/// This contract has two lists:\r\n/// 1) A subscribed list (EnumerableSet.AddressSet) oracles owner addresses, this list has a max size (30).\r\n/// 2) A selected list, EnumerableSet.AddressSet of oracles owner addresses that are selected to participate in\r\n/// current publication round (10 entries max size).\r\n///\r\n/// Oracles are subscribed by adding them to the subscribed oracle list. When the list is full\r\n/// the oracle with less stake can be removed by a new oracle that is trying to\r\n/// subscribe (if its stake is greater than his).\r\n/// On each round switch the list of selected oracles is populated with the 10 Oracles with more stake. An oracle\r\n/// can unsubscribe itself from the subscribed list in the middle of the round, in this case, the oracle is still\r\n/// listed in the selected list until the round ends.\r\n/// If an oracle withdraw some stake then his participation in the round is put into consideration: If the\r\n/// oracle ends up having less stake than the next oracle in the subscribed list (but not in the selected list) then\r\n/// it is removed from the selected list and the point he accumulated during the round are lost (set to zero).\r\n\r\ninterface ICoinPairPrice {\r\n    // getOracleOwnerAddress: Given an Oracle address return the Oracle Owner address.\r\n    // Used during publication, the servers sign with the oracle address, but the list of selected oracles\r\n    // is by oracle owner address.\r\n    // getOracleOwnerStake: Get the stake stored in the supporters smart-contract\r\n    // prettier-ignore\r\n    struct CoinPairPriceCallbacks {\r\n        function (address) external view returns (address) getOracleOwnerAddress;\r\n        function (address) external view returns (uint256) getOracleOwnerStake;\r\n    }\r\n\r\n    /// @notice subscribe an oracle to this coin pair, allowing it to be selected in the next round.\r\n    /// If the subscribed list is full and the current oracle has more stake than one with minimum stake in the\r\n    /// subscribed list, then the one with minimum stake is replaced.\r\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\r\n    /// @dev This is designed to be called from OracleManager.\r\n    function subscribe(address oracleOwnerAddr) external;\r\n\r\n    /// @notice Unsubscribe an oracle from this coin pair. The oracle won't be selected in the next round.\r\n    /// After the round end, the oracle can withdraw stake without having the risk of loosing won points.\r\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\r\n    /// @dev This is designed to be called from OracleManager.\r\n    function unsubscribe(address oracleOwnerAddr) external;\r\n\r\n    /// @notice Returns true if an oracle is subscribed to this contract' coin pair\r\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\r\n    /// @dev This is designed to be called from OracleManager.\r\n    function isSubscribed(address oracleOwnerAddr) external view returns (bool);\r\n\r\n    /// @notice Publish a price. (The message contain oracleAddresses that must be converted to owner addresses).\r\n    /// @param _version Version number of message format (3)\r\n    /// @param _coinpair The coin pair to report (must match this contract)\r\n    /// @param _price Price to report.\r\n    /// @param _votedOracle The address of the oracle voted as a publisher by the network.\r\n    /// @param _blockNumber The blocknumber acting as nonce to prevent replay attacks.\r\n    /// @param _sigV The array of V-component of Oracle signatures.\r\n    /// @param _sigR The array of R-component of Oracle signatures.\r\n    /// @param _sigS The array of S-component of Oracle signatures.\r\n    function publishPrice(\r\n        uint256 _version,\r\n        bytes32 _coinpair,\r\n        uint256 _price,\r\n        address _votedOracle,\r\n        uint256 _blockNumber,\r\n        uint8[] calldata _sigV,\r\n        bytes32[] calldata _sigR,\r\n        bytes32[] calldata _sigS\r\n    ) external;\r\n\r\n    /// @notice Publish a price without signature validation (when there is an emergecy!!!).\r\n    /// @param _price Price to report.\r\n    function emergencyPublish(uint256 _price) external;\r\n\r\n    /// @notice The oracle owner has withdrawn some stake.\r\n    /// Must check if the oracle is part of current round and if he lost his place with the\r\n    /// new stake value (the stake is global and is saved in the supporters contract).\r\n    /// @param oracleOwnerAddr the oracle owner that is trying to withdraw\r\n    function onWithdraw(address oracleOwnerAddr) external returns (uint256);\r\n\r\n    /// @notice Switch contract context to a new round. With the objective of\r\n    /// being a decentralized solution, this can be called by *anyone* if current\r\n    /// round lock period is expired.\r\n    /// This method search the subscribed list and choose the 10 with more stake.\r\n    function switchRound() external;\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS\r\n\r\n    /// @notice Return the available reward fees\r\n    ///\r\n    function getAvailableRewardFees() external view returns (uint256);\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS TO GET CURRENT PRICE\r\n    // MUST BE WHITELISTED\r\n    /// @notice Return the current price, compatible with old MOC Oracle\r\n    function peek() external view returns (bytes32, bool);\r\n\r\n    /// @notice Return the current price\r\n    function getPrice() external view returns (uint256);\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////// GETTERS TO GET CURRENT PRICE END\r\n\r\n    /// @notice Return current round information\r\n    function getRoundInfo()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 round,\r\n            uint256 startBlock,\r\n            uint256 lockPeriodTimestamp,\r\n            uint256 totalPoints,\r\n            address[] memory selectedOwners,\r\n            address[] memory selectedOracles\r\n        );\r\n\r\n    /// @notice Return round information for specific oracle\r\n    function getOracleRoundInfo(address addr)\r\n        external\r\n        view\r\n        returns (uint256 points, bool selectedInCurrentRound);\r\n\r\n    // The maximum count of oracles selected to participate each round\r\n    function maxOraclesPerRound() external view returns (uint256);\r\n\r\n    // The round lock period in secs\r\n    function roundLockPeriodSecs() external view returns (uint256);\r\n\r\n    function isOracleInCurrentRound(address oracleAddr) external view returns (bool);\r\n\r\n    /// @notice Returns the amount of oracles subscribed to this coin pair.\r\n    function getSubscribedOraclesLen() external view returns (uint256);\r\n\r\n    /// @notice Returns the oracle owner address that is subscribed to this coin pair\r\n    /// @param idx index to query.\r\n    function getSubscribedOracleAtIndex(uint256 idx) external view returns (address ownerAddr);\r\n\r\n    // Public variable\r\n    function getMaxSubscribedOraclesPerRound() external view returns (uint256);\r\n\r\n    // Public variable\r\n    function getCoinPair() external view returns (bytes32);\r\n\r\n    // Public variable\r\n    function getLastPublicationBlock() external view returns (uint256);\r\n\r\n    // Public variable\r\n    function getValidPricePeriodInBlocks() external view returns (uint256);\r\n\r\n    // Public variable\r\n    function getEmergencyPublishingPeriodInBlocks() external view returns (uint256);\r\n\r\n    // Public variable\r\n    function getOracleManager() external view returns (IOracleManager);\r\n\r\n    // Public variable\r\n    function getToken() external view returns (IERC20);\r\n}\r\n\r\n\r\n/// This contract manages the Oracle and CoinPair registration info.\r\n/// The Oracle python server interacts with this contract:\r\n/// - Coin pair registration\r\n/// - Oracle registration to coin pairs\r\n/// - Access Oracle info (oracle address + url) indexed by oracle owner address\r\n/// - Get the oracle information (url + the specifics of some coin pair rounds) from an oracle address\r\n/// - Get the oracle address from the owner address.\r\ninterface IOracleManager {\r\n    // getOracleOwnerStake: Get the stake stored in the supporters smart-contract\r\n    // prettier-ignore\r\n    struct OracleManagerCallbacks {\r\n        function (address) external view returns (uint256) getOracleOwnerStake;\r\n    }\r\n\r\n    /// @notice Register a new coin pair contract (the contract must be created separately).\r\n    /// Once created the coin pairs cannot be removed.\r\n    /// @param coinPair The bytes32-encoded coinpair string (e.g. BTCUSD)\r\n    /// @param addr The contract address associated to the coin pair.\r\n    function registerCoinPair(bytes32 coinPair, address addr) external;\r\n\r\n    /// Register an oracle in the system must be called by the oracle owner.\r\n    /// @notice Registers the oracle and transfer the specified caller's MOC token stake.\r\n    /// @param oracleOwnerAddr The address of the owner of the oracle.\r\n    /// @param oracleAddr Address of the Oracle to register.\r\n    /// @param internetName Public Internet name of this Oracle.\r\n    function registerOracle(\r\n        address oracleOwnerAddr,\r\n        address oracleAddr,\r\n        string calldata internetName\r\n    ) external;\r\n\r\n    /// @notice Change the oracle \"internet\" name (URI), called by the owner.\r\n    /// @param oracleOwnerAddr The address of the owner of the oracle.\r\n    /// @param name The new name to set.\r\n    function setOracleName(address oracleOwnerAddr, string calldata name) external;\r\n\r\n    /// @notice Change the oracle address, called by the owner.\r\n    /// @param oracleOwnerAddr The address of the owner of the oracle.\r\n    /// @param oracleAddr new value for the address of the oracle\r\n    function setOracleAddress(address oracleOwnerAddr, address oracleAddr) external;\r\n\r\n    /// @notice Removes the oracle registration info. Must be called by the owner\r\n    /// The oracle must be previously unregistered from all coin pairs.\r\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\r\n    function removeOracle(address oracleOwnerAddr) external;\r\n\r\n    /// @notice Subscribe a registered oracle to participate in the next round of a registered coin-pair.\r\n    /// @param oracleOwnerAddr Address of oracle owner\r\n    function subscribeToCoinPair(address oracleOwnerAddr, bytes32 coinPair) external;\r\n\r\n    /// @notice Unsubscribe a registered oracle from participating in rounds of a registered coin-pair.\r\n    /// The oracle is flagged so it is not selected in the next round.\r\n    /// @param oracleOwnerAddr Address of oracle owner\r\n    function unSubscribeFromCoinPair(address oracleOwnerAddr, bytes32 coinPair) external;\r\n\r\n    /// @notice The oracle owner did a partial withdrawal of funds\r\n    /// 1. The oracle address is searched by the owner address.\r\n    /// 2. Each coin pair to which the oracle is subscribed is consulted to:\r\n    ///   - Check if the new amount is enough to stay in the current round.\r\n    ///       If not the oracle is replaced and lost his points.\r\n    ///   - Get the timestamp for the round end.\r\n    /// The return value is the maximum timestamp from all the coin pairs.\r\n    /// @param oracleOwnerAddr Address of oracle owner\r\n    /// @return the timestamp until which the funds must be locked.\r\n    function onWithdraw(address oracleOwnerAddr) external returns (uint256);\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS USED BY COINPAIR\r\n    /// @notice Used by the coin pair to get the oracle address from the oracleOwnerAddress.\r\n    /// @param  oracleOwnerAddr the address of the owner of the oracle.\r\n    /// @return oracleAddr Address of oracle\r\n    function getOracleAddress(address oracleOwnerAddr) external view returns (address oracleAddr);\r\n\r\n    /// @notice Returns true if oracle is registered.\r\n    /// @param ownerAddr The address of the oracle's owner.\r\n    function isRegistered(address ownerAddr) external view returns (bool);\r\n\r\n    /// @notice Used by CoinPair\r\n    /// @param oracleAddr The oracle address not the owner address.\r\n    function getOracleOwner(address oracleAddr) external view returns (address);\r\n\r\n    /// @notice Returns the amount of owners registered.\r\n    function getRegisteredOraclesLen() external view returns (uint256);\r\n\r\n    /// @notice Returns the oracle name and address at index.\r\n    /// @param idx index to query.\r\n    function getRegisteredOracleAtIndex(uint256 idx)\r\n        external\r\n        view\r\n        returns (\r\n            address ownerAddr,\r\n            address oracleAddr,\r\n            string memory url\r\n        );\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS USED BY COINPAIR END\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS\r\n\r\n    // TODO: Check what is the minimum amount of getters the python server needs.\r\n\r\n    /// @notice Returns true if an oracle is subscribed to a coin pair\r\n    function isSubscribed(address oracleAddr, bytes32 coinPair) external view returns (bool);\r\n\r\n    /// @notice Return true if the oracle is registered on this coin-pair\r\n    /// @param oracleAddr addr The address of the Oracle check for.\r\n    function isOracleRegistered(address oracleAddr) external view returns (bool);\r\n\r\n    /// @notice Returns registration information for a registered Oracle.\r\n    /// @param oracleAddr addr The address of the Oracle to query for.\r\n    function getOracleRegistrationInfo(address oracleAddr)\r\n        external\r\n        view\r\n        returns (\r\n            string memory internetName,\r\n            uint256 stake,\r\n            address _owner\r\n        );\r\n\r\n    /// @notice Returns round information for a registered oracle in a specific coin-pair.\r\n    /// @param oracleAddr address of the oracle to query for.\r\n    /// @param coinpair The coin pair to lookup.\r\n    function getOracleRoundInfo(address oracleAddr, bytes32 coinpair)\r\n        external\r\n        view\r\n        returns (uint256 points, bool selectedInCurrentRound);\r\n\r\n    /// @notice Returns true if an oracle satisfies conditions to be removed from system.\r\n    /// @param oracleAddr the oracle address to lookup.\r\n    function canRemoveOracle(address oracleAddr) external view returns (bool);\r\n\r\n    /// @notice Get the stake in MOCs that an oracle has.\r\n    /// @param oracleAddr The address of the oracle.\r\n    function getStake(address oracleAddr) external view returns (uint256 balance);\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////// GETTER TO LIST COIN PAIRS\r\n\r\n    /// @notice Returns the count of registered coin pairs.\r\n    /// Keep in mind that Deleted coin-pairs will contain zeroed addresses.\r\n    function getCoinPairCount() external view returns (uint256);\r\n\r\n    /// @notice Returns the coin pair at index.\r\n    /// @param i index to query.\r\n    function getCoinPairAtIndex(uint256 i) external view returns (bytes32);\r\n\r\n    /// @notice Return the contract address for a specified registered coin pair.\r\n    /// @param coinpair Coin-pair string to lookup (e.g: BTCUSD)\r\n    /// @return address Address of contract or zero if does not exist or was deleted.\r\n    function getContractAddress(bytes32 coinpair) external view returns (address);\r\n\r\n    /// @notice Searches a coinpair in coinPairList\r\n    /// @param coinPair The bytes32-encoded coinpair string (e.g. BTCUSD)\r\n    /// @param hint Optional hint to start traversing the coinPairList array, zero is to search all the array.\r\n    function getCoinPairIndex(bytes32 coinPair, uint256 hint) external view returns (uint256);\r\n\r\n    function getMaxStake(address[] calldata addresses) external view returns (address, uint256);\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////// GETTER TO LIST COIN PAIRS END\r\n\r\n    // Public variable\r\n    function getStakingContract() external view returns (IStakingMachine);\r\n\r\n    // Public variable\r\n    function getMinCPSubscriptionStake() external view returns (uint256);\r\n}\r\n\r\n\r\n\r\ninterface IDelayMachine {\r\n    /// @notice Accept a deposit from an account.\r\n    /// @param mocs token quantity\r\n    /// @param expiration the expiration date for this deposit\r\n    /// @return id the transaction id\r\n    function deposit(\r\n        uint256 mocs,\r\n        address destination,\r\n        uint256 expiration\r\n    ) external returns (uint256 id);\r\n\r\n    /// @notice Cancel a transaction returning the funds to the source\r\n    /// @param id transaction id\r\n    function cancel(uint256 id) external;\r\n\r\n    /// @notice Withdraw stake, send it to the delay machine.\r\n    /// @param id transaction id\r\n    function withdraw(uint256 id) external;\r\n\r\n    /// @notice Returns the list of transaction for some account\r\n    /// @return ids transaction ids\r\n    /// @return amounts token quantity\r\n    /// @return expirations expiration dates\r\n    function getTransactions(address account)\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory ids,\r\n            uint256[] memory amounts,\r\n            uint256[] memory expirations\r\n        );\r\n\r\n    /// @notice Returns the total balance in MOCs for an account\r\n    function getBalance(address account) external view returns (uint256);\r\n\r\n    // Public variable\r\n    function getToken() external view returns (IERC20);\r\n\r\n    // Public variable\r\n    function getLastId() external view returns (uint256);\r\n\r\n    // Public variable\r\n    function getSource() external view returns (address);\r\n}\r\n\r\n\r\ninterface IStakingMachine {\r\n    /// @notice Used by the voting machine to lock the current balance of MOCs.\r\n    /// @param mocHolder the moc holder whose mocs will be locked.\r\n    /// @param untilTimestamp timestamp until which the mocs will be locked.\r\n    function lockMocs(address mocHolder, uint256 untilTimestamp) external;\r\n\r\n    /// @notice Accept a deposit from an account.\r\n    /// Delegate to the Supporters smart contract.\r\n    /// @param mocs token quantity\r\n    /// @param destination the destination account of this deposit.\r\n    function deposit(uint256 mocs, address destination) external;\r\n\r\n    /// @notice Accept a deposit from an account.\r\n    /// @param mocs token quantity\r\n    /// @param destination the destination account of this deposit.\r\n    /// @param source the address that approved the transfer\r\n    function depositFrom(\r\n        uint256 mocs,\r\n        address destination,\r\n        address source\r\n    ) external;\r\n\r\n    /// @notice Withdraw stake, send it to the delay machine.\r\n    /// @param mocs token quantity\r\n    function withdraw(uint256 mocs) external;\r\n\r\n    /// @notice Reports the balance of MOCs for a specific user.\r\n    /// @param user user address\r\n    function getBalance(address user) external view returns (uint256);\r\n\r\n    /// @notice Reports the locked balance of MOCs for a specific user.\r\n    /// @param user user address\r\n    function getLockedBalance(address user) external view returns (uint256);\r\n\r\n    /// @notice Reports the balance of locked MOCs for a specific user.\r\n    /// Delegates to the Supporters smart contract.\r\n    /// @param user user address\r\n    /// @return amount the amount of mocs locked\r\n    /// @return untilTimestamp the timestamp that corresponds to the locking date.\r\n    function getLockingInfo(address user)\r\n        external\r\n        view\r\n        returns (uint256 amount, uint256 untilTimestamp);\r\n\r\n    // Public variable\r\n    function getSupporters() external view returns (address);\r\n\r\n    // Public variable\r\n    function getOracleManager() external view returns (IOracleManager);\r\n\r\n    // Public variable\r\n    function getMocToken() external view returns (IERC20);\r\n\r\n    // Public variable\r\n    function getDelayMachine() external view returns (IDelayMachine);\r\n\r\n    // Public variable\r\n    function getWithdrawLockTime() external view returns (uint256);\r\n}\r\n\r\ninterface IStakingMachineOracles {\r\n    /// @notice Register an oracle\r\n    /// @param oracleAddr address of the oracle (from which we publish prices)\r\n    /// @param url url used by the oracle server\r\n    function registerOracle(address oracleAddr, string calldata url) external;\r\n\r\n    /// @notice Change the oracle \"internet\" name (URI)\r\n    /// @param url The new url to set.\r\n    function setOracleName(string calldata url) external;\r\n\r\n    /// @notice Change the oracle address\r\n    /// @param oracleAddr The new oracle address\r\n    function setOracleAddress(address oracleAddr) external;\r\n\r\n    /// @notice Return true if the oracle is registered.\r\n    /// @param oracleAddr addr The address of the Oracle check for.\r\n    function isOracleRegistered(address oracleAddr) external view returns (bool);\r\n\r\n    /// @notice Returns true if an oracle satisfies conditions to be removed from system.\r\n    /// @param oracleAddr the oracle address to lookup.\r\n    function canRemoveOracle(address oracleAddr) external view returns (bool);\r\n\r\n    /// @notice Remove an oracle.\r\n    function removeOracle() external;\r\n\r\n    /// @notice Returns the count of registered coin pairs.\r\n    /// Keep in mind that Deleted coin-pairs will contain zeroed addresses.\r\n    function getCoinPairCount() external view returns (uint256);\r\n\r\n    /// @notice Returns the coin pair at index.\r\n    /// @param i index to query.\r\n    function getCoinPairAtIndex(uint256 i) external view returns (bytes32);\r\n\r\n    /// @notice Return the contract address for a specified registered coin pair.\r\n    /// @param coinpair Coin-pair string to lookup (e.g: BTCUSD)\r\n    /// @return address Address of contract or zero if does not exist or was deleted.\r\n    function getContractAddress(bytes32 coinpair) external view returns (address);\r\n\r\n    /// @notice Searches a coinpair in coinPairList\r\n    /// @param coinPair The bytes32-encoded coinpair string (e.g. BTCUSD)\r\n    /// @param hint Optional hint to start traversing the coinPairList array, zero is to search all the array.\r\n    function getCoinPairIndex(bytes32 coinPair, uint256 hint) external view returns (uint256);\r\n\r\n    /// @notice Subscribe an oracle to a coin pair.\r\n    /// @param coinPair coin pair to subscribe, for example BTCUSD\r\n    function subscribeToCoinPair(bytes32 coinPair) external;\r\n\r\n    /// @notice Unsubscribe an oracle from a coin pair.\r\n    /// @param coinPair coin pair to unsubscribe, for example BTCUSD\r\n    function unSubscribeFromCoinPair(bytes32 coinPair) external;\r\n\r\n    /// @notice Returns true if an oracle is subscribed to a coin pair\r\n    /// @param oracleAddr address of the oracle\r\n    /// @param coinPair coin pair to unsubscribe, for example BTCUSD\r\n    function isSubscribed(address oracleAddr, bytes32 coinPair) external view returns (bool);\r\n\r\n    /// @notice Returns the amount of owners registered.\r\n    /// Delegates to the Oracle Manager smart contract.\r\n    function getRegisteredOraclesLen() external view returns (uint256);\r\n\r\n    /// @notice Returns the oracle name and address at index.\r\n    /// Delegates to the Oracle Manager smart contract.\r\n    /// @param idx index to query.\r\n    function getRegisteredOracleAtIndex(uint256 idx)\r\n        external\r\n        view\r\n        returns (\r\n            address ownerAddr,\r\n            address oracleAddr,\r\n            string memory url\r\n        );\r\n}\r\n\r\n\r\n// prettier-ignore\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\r\n * (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n            // Move the last value to the index where the value to delete is\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            // Update the index for the moved value\r\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint256(_at(set._inner, index)));\r\n    }\r\n\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n\r\n\r\ncontract DelayMachineStorage is Initializable, Governed {\r\n    using SafeMath for uint256;\r\n    using EnumerableSet for EnumerableSet.UintSet;\r\n\r\n    struct Payment {\r\n        uint256 expiration;\r\n        uint256 amount;\r\n    }\r\n\r\n    struct Owner {\r\n        EnumerableSet.UintSet ids;\r\n    }\r\n\r\n    uint256 internal _id;\r\n    IERC20 internal _token;\r\n    address internal _source;\r\n    mapping(address => Owner) internal owners;\r\n    mapping(uint256 => Payment) internal payments;\r\n\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    // solhint-disable-next-line no-empty-blocks\r\n    constructor() internal {}\r\n\r\n    // Reserved storage space to allow for layout changes in the future.\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n\r\ncontract DelayMachine is DelayMachineStorage, IDelayMachine {\r\n    using SafeMath for uint256;\r\n\r\n    event PaymentDeposit(\r\n        uint256 indexed id,\r\n        address source,\r\n        address destination,\r\n        uint256 amount,\r\n        uint256 expiration\r\n    );\r\n    event PaymentCancel(uint256 indexed id, address source, address destination, uint256 amount);\r\n    event PaymentWithdraw(uint256 indexed id, address source, address destination, uint256 amount);\r\n\r\n    /// @notice Construct this contract.\r\n    /// @param governor The minimum amount of tokens required as stake for a coin pair subscription.\r\n    /// @param token the Supporters contract contract address.\r\n    function initialize(\r\n        IGovernor governor,\r\n        IERC20 token,\r\n        address source\r\n    ) external initializer {\r\n        _token = token;\r\n        _source = source;\r\n        Governed._initialize(governor);\r\n    }\r\n\r\n    /// @notice Accept a deposit from an account.\r\n    /// @param mocs token quantity\r\n    /// @param destination the destination address which can control the funds.\r\n    /// @param expiration the expiration date for this deposit\r\n    /// @return id the transaction id\r\n    function deposit(\r\n        uint256 mocs,\r\n        address destination,\r\n        uint256 expiration\r\n    ) external override returns (uint256 id) {\r\n        require(msg.sender == _source, \"Wrong source\");\r\n        bool done = _token.transferFrom(_source, address(this), mocs);\r\n        require(done, \"Token transfer failed.\");\r\n        _id = _id + 1;\r\n        payments[_id].expiration = block.timestamp + expiration;\r\n        // solhint-disable-previous-line not-rely-on-time\r\n        payments[_id].amount = mocs;\r\n        owners[destination].ids.add(_id);\r\n        emit PaymentDeposit(_id, _source, destination, mocs, expiration);\r\n        return _id;\r\n    }\r\n\r\n    /// @notice Cancel a transaction returning the funds to the source\r\n    /// @param id transaction id\r\n    function cancel(uint256 id) external override {\r\n        require(owners[msg.sender].ids.contains(id), \"Invalid ID\");\r\n        owners[msg.sender].ids.remove(id);\r\n        bool done = _token.approve(_source, payments[id].amount);\r\n        require(done, \"Token approve failed.\");\r\n        IStakingMachine(_source).depositFrom(payments[id].amount, msg.sender, address(this));\r\n        uint256 amount = payments[id].amount;\r\n        delete (payments[id]);\r\n        emit PaymentCancel(id, _source, msg.sender, amount);\r\n    }\r\n\r\n    /// @notice Withdraw stake, send it to the delay machine.\r\n    /// @param id transaction id\r\n    function withdraw(uint256 id) external override {\r\n        require(owners[msg.sender].ids.contains(id), \"Invalid ID\");\r\n        owners[msg.sender].ids.remove(id);\r\n        require(payments[id].expiration < block.timestamp, \"Not expired\");\r\n        // solhint-disable-previous-line not-rely-on-time\r\n        bool done = _token.transfer(msg.sender, payments[id].amount);\r\n        require(done, \"Token transfer failed.\");\r\n        uint256 amount = payments[id].amount;\r\n        delete (payments[id]);\r\n        emit PaymentWithdraw(id, _source, msg.sender, amount);\r\n    }\r\n\r\n    /// @notice Returns the list of transaction for some account\r\n    /// @param account destination address\r\n    /// @return ids transaction ids\r\n    /// @return amounts token quantity\r\n    /// @return expirations expiration dates\r\n    function getTransactions(address account)\r\n        external\r\n        override\r\n        view\r\n        returns (\r\n            uint256[] memory ids,\r\n            uint256[] memory amounts,\r\n            uint256[] memory expirations\r\n        )\r\n    {\r\n        uint256 len = owners[account].ids.length();\r\n        ids = new uint256[](len);\r\n        amounts = new uint256[](len);\r\n        expirations = new uint256[](len);\r\n        for (uint256 i = 0; i < len; i++) {\r\n            ids[i] = owners[account].ids.at(i);\r\n            amounts[i] = payments[owners[account].ids.at(i)].amount;\r\n            expirations[i] = payments[owners[account].ids.at(i)].expiration;\r\n        }\r\n    }\r\n\r\n    /// @notice Returns the total balance in MOCs for an account\r\n    /// @param account destination address\r\n    /// @return balance token quantity\r\n    function getBalance(address account) external override view returns (uint256) {\r\n        uint256 len = owners[account].ids.length();\r\n        uint256 balance;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            balance = balance + payments[owners[account].ids.at(i)].amount;\r\n        }\r\n        return balance;\r\n    }\r\n\r\n    // Public variable\r\n    function getToken() external override view returns (IERC20) {\r\n        return _token;\r\n    }\r\n\r\n    // Public variable\r\n    function getLastId() external override view returns (uint256) {\r\n        return _id;\r\n    }\r\n\r\n    // Public variable\r\n    function getSource() external override view returns (address) {\r\n        return _source;\r\n    }\r\n}\r\n\r\n",
      "file": "output2-delay.sol"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x89367406a4238d0a8d9605df1168d9c557c419ce99f322c2b02881ff7dc4e63c",
    "blockNumber": 1330881,
    "transactionHash": "0x968ba510a512f884f8b8775265b28bef0fc53fcc4441656ce07e6ca90618b04c",
    "timestamp": 1604960484
  }
}