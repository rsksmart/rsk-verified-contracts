{
    "address": "0xefa41246458567a2ae2dda4dc742e2e6ecb142e2",
    "net": {
        "id": "31",
        "name": "RSK Testnet"
    },
    "name": "CommissionSplitterChangerDeploy",
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": "1"
        },
        "evmVersion": "byzantium"
    },
    "version": "0.5.8+commit.23d335f2",
    "source": "\n// File: moc-governance/contracts/Governance/ChangeContract.sol\n\npragma solidity ^0.5.8;\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n\n  /**\n    @notice Override this function with a recipe of the changes to be done when this ChangeContract\n    is executed\n   */\n  function execute() external;\n}\n\n// File: moc-governance/contracts/Governance/IGovernor.sol\n\npragma solidity ^0.5.8;\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor{\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @dev This function should be protected somehow to only execute changes that\n    benefit the system. This decision process is independent of this architechture\n    therefore is independent of this interface too\n    @param changeContract Address of the contract that will execute the changes\n   */\n  function executeChange(ChangeContract changeContract) external;\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @param _changer Address of the contract that will execute the changes\n   */\n  function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n// File: zos-lib/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.6.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: moc-governance/contracts/Governance/Governed.sol\n\npragma solidity ^0.5.8;\n\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed is Initializable {\n\n  /**\n    @notice The address of the contract which governs this one\n   */\n  IGovernor public governor;\n\n  string constant private NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n  /**\n    @notice Modifier that protects the function\n    @dev You should use this modifier in any function that should be called through\n    the governance system\n   */\n  modifier onlyAuthorizedChanger() {\n    require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n    _;\n  }\n\n  /**\n    @notice Initialize the contract with the basic settings\n    @dev This initialize replaces the constructor but it is not called automatically.\n    It is necessary because of the upgradeability of the contracts\n    @param _governor Governor address\n   */\n  function initialize(IGovernor _governor) public initializer {\n    governor = _governor;\n  }\n\n  /**\n    @notice Change the contract's governor. Should be called through the old governance system\n    @param newIGovernor New governor address\n   */\n  function changeIGovernor(IGovernor newIGovernor) public onlyAuthorizedChanger {\n    governor = newIGovernor;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/interface/IMoC.sol\n\npragma solidity 0.5.8;\n\ninterface IMoC {\n    function() external payable;\n\n    function sendToAddress(address payable receiver, uint256 btcAmount) external returns(bool);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n// File: openzeppelin-eth/contracts/utils/ReentrancyGuard.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @title Helps contracts guard against reentrancy attacks.\n * @author Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io>\n * @dev If you mark a function `nonReentrant`, you should also\n * mark it `external`.\n */\ncontract ReentrancyGuard is Initializable {\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    function initialize() public initializer {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter);\n    }\n\n    uint256[50] private ______gap;\n}\n\n// File: contracts/auxiliar/CommissionSplitter.sol\n\npragma solidity 0.5.8;\n\n\n\n\n\n\n\n/**\n  @dev Contract that split his balance between two addresses based on a\n  proportion defined by Governance. One of those addresses should\n  be a Money on Chain main contract.\n */\ncontract CommissionSplitter is Governed, ReentrancyGuard {\n  event SplitExecuted(uint256 commissionAmount, uint256 mocAmount, uint256 mocTokenCommissionAmount);\n  // Math\n  using SafeMath for uint256;\n  uint256 public constant PRECISION = 10**18;\n\n  // Final receiver address\n  address payable public commissionsAddress;\n  // Proportion of the balance to send to moc\n  uint256 public mocProportion;\n\n  // Contracts\n  IMoC public moc;\n\n  IERC20 public mocToken;\n  address public mocTokenCommissionsAddress;\n\n  /**\n    @dev Initialize commission splitter contract\n    @param _mocAddress the address of MoC contract\n    @param _commissionsAddress the address in which the remaining commissions (profit ones) are sent\n    @param _mocProportion the proportion of commission that moc will keep, it should have PRECISION precision\n    @param _governor the address of the IGovernor contract\n    @param _mocToken the address of MoC Token contract\n    @param _mocTokenCommissionsAddress the address in which the Moc Token commissions are sent\n   */\n  function initialize(\n    IMoC _mocAddress,\n    address payable _commissionsAddress,\n    uint256 _mocProportion,\n    IGovernor _governor,\n    IERC20 _mocToken,\n    address _mocTokenCommissionsAddress\n  ) public initializer {\n    _setMocProportion(_mocProportion);\n    moc = _mocAddress;\n    commissionsAddress = _commissionsAddress;\n    mocToken = _mocToken;\n    mocTokenCommissionsAddress = _mocTokenCommissionsAddress;\n\n    Governed.initialize(_governor);\n  }\n\n  /**\n  @dev Split current balance of the contract, and sends one part\n  to destination address and the other to MoC Reserves.\n   */\n  function split() public nonReentrant {\n    uint256 currentBalance = address(this).balance;\n    uint256 mocAmount = currentBalance.mul(mocProportion).div(PRECISION);\n    uint256 commissionAmount = currentBalance.sub(mocAmount);\n\n    _sendReservesToMoC(mocAmount);\n    _sendReserves(commissionAmount, commissionsAddress);\n\n    uint256 mocTokenAmount = mocToken.balanceOf(address(this));\n    if (mocTokenAmount > 0) {\n      mocToken.transfer(mocTokenCommissionsAddress, mocTokenAmount);\n    }\n\n    emit SplitExecuted(commissionAmount, mocAmount, mocTokenAmount);\n  }\n\n  // Governance Setters\n  function setCommissionAddress(address payable _commissionsAddress)\n    public\n    onlyAuthorizedChanger\n  {\n    commissionsAddress = _commissionsAddress;\n  }\n\n  function setMocProportion(uint256 _mocProportion)\n    public\n    onlyAuthorizedChanger\n  {\n    _setMocProportion(_mocProportion);\n  }\n\n  function setMocToken(address _mocToken) public onlyAuthorizedChanger {\n    require(_mocToken != address(0), \"MocToken must not be 0x0\");\n    mocToken = IERC20(_mocToken);\n  }\n\n  function setMocTokenCommissionAddress(address _mocTokenCommissionsAddress) public onlyAuthorizedChanger {\n    require(_mocTokenCommissionsAddress != address(0), \"MocTokenCommissionAddress must not be 0x0\");\n    mocTokenCommissionsAddress = _mocTokenCommissionsAddress;\n  }\n\n  function _setMocProportion(uint256 _mocProportion) internal {\n    require(\n      _mocProportion <= PRECISION,\n      \"Proportion should not be higher than precision\"\n    );\n    mocProportion = _mocProportion;\n  }\n\n  /**\n  @dev Sends tokens to Money on chain reserves\n   */\n  function _sendReservesToMoC(uint256 amount) internal {\n    _sendReserves(amount, address(moc));\n  }\n\n  /**\n  @dev Sends reserves to address reserves\n   */\n  function _sendReserves(uint256 amount, address payable receiver) internal {\n    // solium-disable-next-line security/no-call-value\n    (bool success, ) = address(receiver).call.value(amount)(\"\");\n    require(success, \"Failed while sending reserves\");\n  }\n\n  function() external payable {}\n\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: contracts/changers/CommissionSplitterChanger.sol\n\npragma solidity 0.5.8;\n\n\n\n/**\n * @dev This contract is used to update the configuration of MocInrate\n * with MoC --- governance.\n */\n\ncontract CommissionSplitterChanger is ChangeContract, Ownable {\n  CommissionSplitter public commissionSplitter;\n  address payable public commissionsAddress;\n  uint256 public mocProportion;\n  address public mocToken;\n  address public mocTokenCommissionsAddress;\n\n  constructor(\n    CommissionSplitter _commissionSplitter,\n    address payable _commissionsAddress,\n    uint256 _mocProportion,\n    address _mocToken,\n    address _mocTokenCommissionsAddress\n  ) public {\n    commissionSplitter = _commissionSplitter;\n    commissionsAddress = _commissionsAddress;\n    mocProportion = _mocProportion;\n    mocToken = _mocToken;\n    mocTokenCommissionsAddress = _mocTokenCommissionsAddress;\n  }\n\n  function execute() external {\n    commissionSplitter.setCommissionAddress(commissionsAddress);\n    commissionSplitter.setMocProportion(mocProportion);\n    commissionSplitter.setMocToken(mocToken);\n    commissionSplitter.setMocTokenCommissionAddress(mocTokenCommissionsAddress);\n  }\n\n  function setCommissionAddress(address payable _commissionsAddress) public onlyOwner() {\n    commissionsAddress = _commissionsAddress;\n  }\n\n  function setMocProportion(uint256 _mocProportion) public onlyOwner() {\n    mocProportion = _mocProportion;\n  }\n\n  function setMocTokenCommissionAddress(address _mocTokenCommissionsAddress) public onlyOwner() {\n    mocTokenCommissionsAddress = _mocTokenCommissionsAddress;\n  }\n\n\n}\n\n// File: contracts/changers/deploy/20210308/CommissionSplitterChangerDeploy.sol\n\npragma solidity 0.5.8;\npragma experimental ABIEncoderV2;\n\n\n/**\n * @dev This contract is used to update the configuration of MocInrate\n * with MoC --- governance.\n * Use for deploy only\n */\ncontract CommissionSplitterChangerDeploy is CommissionSplitterChanger {\n  constructor(\n      CommissionSplitter _commissionSplitter,\n      address _mocToken,\n      address _mocTokenCommissionsAddress\n    )\n    CommissionSplitterChanger(\n      _commissionSplitter,\n      address(0),\n      0,\n      _mocToken,\n      _mocTokenCommissionsAddress\n    )\n  public { }\n\n  function execute() external {\n    /** UPDATE: 08/03/2021 - Upgrade to support moc token commission **/\n    commissionSplitter.setMocToken(mocToken);\n    commissionSplitter.setMocTokenCommissionAddress(mocTokenCommissionsAddress);\n  }\n}\n",
    "imports": [
        {
            "name": "CommissionSplitterChangerDeploy-flat.sol",
            "contents": "\n// File: moc-governance/contracts/Governance/ChangeContract.sol\n\npragma solidity ^0.5.8;\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n\n  /**\n    @notice Override this function with a recipe of the changes to be done when this ChangeContract\n    is executed\n   */\n  function execute() external;\n}\n\n// File: moc-governance/contracts/Governance/IGovernor.sol\n\npragma solidity ^0.5.8;\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor{\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @dev This function should be protected somehow to only execute changes that\n    benefit the system. This decision process is independent of this architechture\n    therefore is independent of this interface too\n    @param changeContract Address of the contract that will execute the changes\n   */\n  function executeChange(ChangeContract changeContract) external;\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @param _changer Address of the contract that will execute the changes\n   */\n  function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n// File: zos-lib/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.6.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: moc-governance/contracts/Governance/Governed.sol\n\npragma solidity ^0.5.8;\n\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed is Initializable {\n\n  /**\n    @notice The address of the contract which governs this one\n   */\n  IGovernor public governor;\n\n  string constant private NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n  /**\n    @notice Modifier that protects the function\n    @dev You should use this modifier in any function that should be called through\n    the governance system\n   */\n  modifier onlyAuthorizedChanger() {\n    require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n    _;\n  }\n\n  /**\n    @notice Initialize the contract with the basic settings\n    @dev This initialize replaces the constructor but it is not called automatically.\n    It is necessary because of the upgradeability of the contracts\n    @param _governor Governor address\n   */\n  function initialize(IGovernor _governor) public initializer {\n    governor = _governor;\n  }\n\n  /**\n    @notice Change the contract's governor. Should be called through the old governance system\n    @param newIGovernor New governor address\n   */\n  function changeIGovernor(IGovernor newIGovernor) public onlyAuthorizedChanger {\n    governor = newIGovernor;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/interface/IMoC.sol\n\npragma solidity 0.5.8;\n\ninterface IMoC {\n    function() external payable;\n\n    function sendToAddress(address payable receiver, uint256 btcAmount) external returns(bool);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n// File: openzeppelin-eth/contracts/utils/ReentrancyGuard.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @title Helps contracts guard against reentrancy attacks.\n * @author Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io>\n * @dev If you mark a function `nonReentrant`, you should also\n * mark it `external`.\n */\ncontract ReentrancyGuard is Initializable {\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    function initialize() public initializer {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter);\n    }\n\n    uint256[50] private ______gap;\n}\n\n// File: contracts/auxiliar/CommissionSplitter.sol\n\npragma solidity 0.5.8;\n\n\n\n\n\n\n\n/**\n  @dev Contract that split his balance between two addresses based on a\n  proportion defined by Governance. One of those addresses should\n  be a Money on Chain main contract.\n */\ncontract CommissionSplitter is Governed, ReentrancyGuard {\n  event SplitExecuted(uint256 commissionAmount, uint256 mocAmount, uint256 mocTokenCommissionAmount);\n  // Math\n  using SafeMath for uint256;\n  uint256 public constant PRECISION = 10**18;\n\n  // Final receiver address\n  address payable public commissionsAddress;\n  // Proportion of the balance to send to moc\n  uint256 public mocProportion;\n\n  // Contracts\n  IMoC public moc;\n\n  IERC20 public mocToken;\n  address public mocTokenCommissionsAddress;\n\n  /**\n    @dev Initialize commission splitter contract\n    @param _mocAddress the address of MoC contract\n    @param _commissionsAddress the address in which the remaining commissions (profit ones) are sent\n    @param _mocProportion the proportion of commission that moc will keep, it should have PRECISION precision\n    @param _governor the address of the IGovernor contract\n    @param _mocToken the address of MoC Token contract\n    @param _mocTokenCommissionsAddress the address in which the Moc Token commissions are sent\n   */\n  function initialize(\n    IMoC _mocAddress,\n    address payable _commissionsAddress,\n    uint256 _mocProportion,\n    IGovernor _governor,\n    IERC20 _mocToken,\n    address _mocTokenCommissionsAddress\n  ) public initializer {\n    _setMocProportion(_mocProportion);\n    moc = _mocAddress;\n    commissionsAddress = _commissionsAddress;\n    mocToken = _mocToken;\n    mocTokenCommissionsAddress = _mocTokenCommissionsAddress;\n\n    Governed.initialize(_governor);\n  }\n\n  /**\n  @dev Split current balance of the contract, and sends one part\n  to destination address and the other to MoC Reserves.\n   */\n  function split() public nonReentrant {\n    uint256 currentBalance = address(this).balance;\n    uint256 mocAmount = currentBalance.mul(mocProportion).div(PRECISION);\n    uint256 commissionAmount = currentBalance.sub(mocAmount);\n\n    _sendReservesToMoC(mocAmount);\n    _sendReserves(commissionAmount, commissionsAddress);\n\n    uint256 mocTokenAmount = mocToken.balanceOf(address(this));\n    if (mocTokenAmount > 0) {\n      mocToken.transfer(mocTokenCommissionsAddress, mocTokenAmount);\n    }\n\n    emit SplitExecuted(commissionAmount, mocAmount, mocTokenAmount);\n  }\n\n  // Governance Setters\n  function setCommissionAddress(address payable _commissionsAddress)\n    public\n    onlyAuthorizedChanger\n  {\n    commissionsAddress = _commissionsAddress;\n  }\n\n  function setMocProportion(uint256 _mocProportion)\n    public\n    onlyAuthorizedChanger\n  {\n    _setMocProportion(_mocProportion);\n  }\n\n  function setMocToken(address _mocToken) public onlyAuthorizedChanger {\n    require(_mocToken != address(0), \"MocToken must not be 0x0\");\n    mocToken = IERC20(_mocToken);\n  }\n\n  function setMocTokenCommissionAddress(address _mocTokenCommissionsAddress) public onlyAuthorizedChanger {\n    require(_mocTokenCommissionsAddress != address(0), \"MocTokenCommissionAddress must not be 0x0\");\n    mocTokenCommissionsAddress = _mocTokenCommissionsAddress;\n  }\n\n  function _setMocProportion(uint256 _mocProportion) internal {\n    require(\n      _mocProportion <= PRECISION,\n      \"Proportion should not be higher than precision\"\n    );\n    mocProportion = _mocProportion;\n  }\n\n  /**\n  @dev Sends tokens to Money on chain reserves\n   */\n  function _sendReservesToMoC(uint256 amount) internal {\n    _sendReserves(amount, address(moc));\n  }\n\n  /**\n  @dev Sends reserves to address reserves\n   */\n  function _sendReserves(uint256 amount, address payable receiver) internal {\n    // solium-disable-next-line security/no-call-value\n    (bool success, ) = address(receiver).call.value(amount)(\"\");\n    require(success, \"Failed while sending reserves\");\n  }\n\n  function() external payable {}\n\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: contracts/changers/CommissionSplitterChanger.sol\n\npragma solidity 0.5.8;\n\n\n\n/**\n * @dev This contract is used to update the configuration of MocInrate\n * with MoC --- governance.\n */\n\ncontract CommissionSplitterChanger is ChangeContract, Ownable {\n  CommissionSplitter public commissionSplitter;\n  address payable public commissionsAddress;\n  uint256 public mocProportion;\n  address public mocToken;\n  address public mocTokenCommissionsAddress;\n\n  constructor(\n    CommissionSplitter _commissionSplitter,\n    address payable _commissionsAddress,\n    uint256 _mocProportion,\n    address _mocToken,\n    address _mocTokenCommissionsAddress\n  ) public {\n    commissionSplitter = _commissionSplitter;\n    commissionsAddress = _commissionsAddress;\n    mocProportion = _mocProportion;\n    mocToken = _mocToken;\n    mocTokenCommissionsAddress = _mocTokenCommissionsAddress;\n  }\n\n  function execute() external {\n    commissionSplitter.setCommissionAddress(commissionsAddress);\n    commissionSplitter.setMocProportion(mocProportion);\n    commissionSplitter.setMocToken(mocToken);\n    commissionSplitter.setMocTokenCommissionAddress(mocTokenCommissionsAddress);\n  }\n\n  function setCommissionAddress(address payable _commissionsAddress) public onlyOwner() {\n    commissionsAddress = _commissionsAddress;\n  }\n\n  function setMocProportion(uint256 _mocProportion) public onlyOwner() {\n    mocProportion = _mocProportion;\n  }\n\n  function setMocTokenCommissionAddress(address _mocTokenCommissionsAddress) public onlyOwner() {\n    mocTokenCommissionsAddress = _mocTokenCommissionsAddress;\n  }\n\n\n}\n\n// File: contracts/changers/deploy/20210308/CommissionSplitterChangerDeploy.sol\n\npragma solidity 0.5.8;\npragma experimental ABIEncoderV2;\n\n\n/**\n * @dev This contract is used to update the configuration of MocInrate\n * with MoC --- governance.\n * Use for deploy only\n */\ncontract CommissionSplitterChangerDeploy is CommissionSplitterChanger {\n  constructor(\n      CommissionSplitter _commissionSplitter,\n      address _mocToken,\n      address _mocTokenCommissionsAddress\n    )\n    CommissionSplitterChanger(\n      _commissionSplitter,\n      address(0),\n      0,\n      _mocToken,\n      _mocTokenCommissionsAddress\n    )\n  public { }\n\n  function execute() external {\n    /** UPDATE: 08/03/2021 - Upgrade to support moc token commission **/\n    commissionSplitter.setMocToken(mocToken);\n    commissionSplitter.setMocTokenCommissionAddress(mocTokenCommissionsAddress);\n  }\n}\n",
            "file": "CommissionSplitterChangerDeploy-flat.sol"
        }
    ],
    "libraries": {},
    "constructorArguments": [
        "0x97dff2039a3b0ab6ad6a315507f8cabd83a9cb05",
        "0x0399c7f7b37e21cb9dae04fb57e24c68ed0b4635",
        "0xb998c3da8d24295406d308ea42c85c8acda880ba"
    ],
    "creationData": {
        "blockHash": "0x9096d7bb51740e6ab1ba50ca6700e3fa68ac5c92a29345ccf499c81eb2c98a25",
        "blockNumber": 1856669,
        "transactionHash": "0x1ce98c1be7181df766eb65dabc2186bb9699f0afe662406dc7a2eea5d7faf843",
        "timestamp": 1621447808
    }
}