{
  "address": "0xff7b012657f18ea185d5eeae92f63e90ab13a238",
  "net": {
    "id": "31",
    "name": "RSK Testnet"
  },
  "name": "Certifications",
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    }
  },
  "version": "0.5.1+commit.c8a2cb62",
  "source": "\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: truffle/contracts/ECDSA.sol\n\n/*\n**  Blockdemy Certifications | A library to recover signature addresses with ECDSA\n**  Authors: Blockchain Academy México @blockdemy, Ernesto García @ernestognw\n**  22-July-2019\n**  blockchainacademy.mx\n*/\n\n\npragma solidity ^0.5.1;\n\nlibrary ECDSA {\n    /**\n    * @dev Recovers the address of who signed the hash sent to the function\n    * @param _fingerprint bytes32. Is the sha3 hash of document. Generated with web3.\n    * @param _signature bytes. Signature of the sha3 fingerprint of the file.\n    */\n    function recoverAddress(bytes32 _fingerprint, bytes memory _signature) internal pure returns (address) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        require(_signature.length == 65, \"Invalid signature\");\n\n        // Divide the signature in r, s and v variables with inline assembly.\n        assembly {\n          r := mload(add(_signature, 0x20))\n          s := mload(add(_signature, 0x40))\n          v := byte(0, mload(add(_signature, 0x60)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n          v += 27;\n        }\n        \n        require(v == 27 || v == 28, \"Invalid signature\");\n        return ecrecover(toEthSignedMessageHash(_fingerprint), v, r, s);\n    }\n    \n    /**\n    * toEthSignedMessageHash\n    * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\" and hash the result\n    * @param _fingerprint bytes32. Is the sha3 hash of document. Generated with web3.\n    */\n    function toEthSignedMessageHash(bytes32 _fingerprint) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _fingerprint)\n        );\n    } \n}\n\n// File: truffle/contracts/Certifications.sol\n\n/*\n**  Blockdemy Certifications | A contract to store digital documents certifications\n**  Authors: Blockchain Academy México @blockdemy, Ernesto García @ernestognw\n**  22-July-2019\n**  blockchainacademy.mx\n*/\n\npragma solidity 0.5.1;\n\n\n\ncontract Certifications is Ownable {\n    using ECDSA for bytes32;\n    \n    mapping(bytes32 => Certificate) public fingerprints; \n    \n    struct Certificate {\n        address owner;\n        mapping(address => bytes) signatures;\n        uint issued;\n        uint expires;\n        bool exists;\n    }\n    \n    constructor() public {}\n    \n    /**\n    * @dev Certificate a document fingerprint into blockchain\n    * @param _fingerprint bytes32. Is the sha3 hash of document. Generated with web3.\n    * @param _owner address. The address of who is being certificated. The owner of document.\n    * @param _issued uint. The unix miliseconds date of certificate issuing.\n    * @param _expires uint. The unix miliseconds date of certificate expiration.\n    */\n    function addCertificate(\n        bytes32 _fingerprint,\n        address _owner,\n        uint _issued,\n        uint _expires\n    ) onlyOwner() public returns(bool) {\n        require(_issued < _expires, \"Issuing date can not be less than expiring date\");\n        require(_expires > now, \"This certificate has already expired\");\n        require(!fingerprints[_fingerprint].exists, \"File has already been certified\");\n        fingerprints[_fingerprint].owner = _owner;\n        fingerprints[_fingerprint].issued = _issued;\n        fingerprints[_fingerprint].expires = _expires;\n        fingerprints[_fingerprint].exists = true;\n        return true;\n    }\n    \n    /**\n    * @dev Function to sign a previously generated certificate\n    * @param _signer address. The address of who is signing the certificate.\n    * @param _fingerprint bytes32. Is the sha3 hash of document. Generated with web3.\n    * @param _signature bytes. Signature of the sha3 fingerprint of the file.\n    */\n    function addSignatureToCertificate(address _signer, bytes32 _fingerprint, bytes memory _signature) onlyOwner() public returns(bool) {\n       address signer = _fingerprint.recoverAddress(_signature);\n       require(fingerprints[_fingerprint].exists, \"Certificate does not exists\");\n       require(_signer == signer, \"Signature does not corresponds to signer\");\n       fingerprints[_fingerprint].signatures[_signer] = _signature;\n       return true;\n    }\n    \n    /**\n    * @dev Returns the corresponding signature to a certificate and signer, used to verify signatures\n    * @param _signer address. The address of who supposedly signed the certificate.\n    * @param _fingerprint bytes32. Is the sha3 hash of document. Generated with web3.\n    */\n    function getSignature(address _signer, bytes32 _fingerprint) public view returns(bytes memory) {\n        return fingerprints[_fingerprint].signatures[_signer];\n    }\n}\n",
  "imports": [
    {
      "name": "CertificationsFlattened.sol",
      "contents": "\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: truffle/contracts/ECDSA.sol\n\n/*\n**  Blockdemy Certifications | A library to recover signature addresses with ECDSA\n**  Authors: Blockchain Academy México @blockdemy, Ernesto García @ernestognw\n**  22-July-2019\n**  blockchainacademy.mx\n*/\n\n\npragma solidity ^0.5.1;\n\nlibrary ECDSA {\n    /**\n    * @dev Recovers the address of who signed the hash sent to the function\n    * @param _fingerprint bytes32. Is the sha3 hash of document. Generated with web3.\n    * @param _signature bytes. Signature of the sha3 fingerprint of the file.\n    */\n    function recoverAddress(bytes32 _fingerprint, bytes memory _signature) internal pure returns (address) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        require(_signature.length == 65, \"Invalid signature\");\n\n        // Divide the signature in r, s and v variables with inline assembly.\n        assembly {\n          r := mload(add(_signature, 0x20))\n          s := mload(add(_signature, 0x40))\n          v := byte(0, mload(add(_signature, 0x60)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n          v += 27;\n        }\n        \n        require(v == 27 || v == 28, \"Invalid signature\");\n        return ecrecover(toEthSignedMessageHash(_fingerprint), v, r, s);\n    }\n    \n    /**\n    * toEthSignedMessageHash\n    * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\" and hash the result\n    * @param _fingerprint bytes32. Is the sha3 hash of document. Generated with web3.\n    */\n    function toEthSignedMessageHash(bytes32 _fingerprint) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _fingerprint)\n        );\n    } \n}\n\n// File: truffle/contracts/Certifications.sol\n\n/*\n**  Blockdemy Certifications | A contract to store digital documents certifications\n**  Authors: Blockchain Academy México @blockdemy, Ernesto García @ernestognw\n**  22-July-2019\n**  blockchainacademy.mx\n*/\n\npragma solidity 0.5.1;\n\n\n\ncontract Certifications is Ownable {\n    using ECDSA for bytes32;\n    \n    mapping(bytes32 => Certificate) public fingerprints; \n    \n    struct Certificate {\n        address owner;\n        mapping(address => bytes) signatures;\n        uint issued;\n        uint expires;\n        bool exists;\n    }\n    \n    constructor() public {}\n    \n    /**\n    * @dev Certificate a document fingerprint into blockchain\n    * @param _fingerprint bytes32. Is the sha3 hash of document. Generated with web3.\n    * @param _owner address. The address of who is being certificated. The owner of document.\n    * @param _issued uint. The unix miliseconds date of certificate issuing.\n    * @param _expires uint. The unix miliseconds date of certificate expiration.\n    */\n    function addCertificate(\n        bytes32 _fingerprint,\n        address _owner,\n        uint _issued,\n        uint _expires\n    ) onlyOwner() public returns(bool) {\n        require(_issued < _expires, \"Issuing date can not be less than expiring date\");\n        require(_expires > now, \"This certificate has already expired\");\n        require(!fingerprints[_fingerprint].exists, \"File has already been certified\");\n        fingerprints[_fingerprint].owner = _owner;\n        fingerprints[_fingerprint].issued = _issued;\n        fingerprints[_fingerprint].expires = _expires;\n        fingerprints[_fingerprint].exists = true;\n        return true;\n    }\n    \n    /**\n    * @dev Function to sign a previously generated certificate\n    * @param _signer address. The address of who is signing the certificate.\n    * @param _fingerprint bytes32. Is the sha3 hash of document. Generated with web3.\n    * @param _signature bytes. Signature of the sha3 fingerprint of the file.\n    */\n    function addSignatureToCertificate(address _signer, bytes32 _fingerprint, bytes memory _signature) onlyOwner() public returns(bool) {\n       address signer = _fingerprint.recoverAddress(_signature);\n       require(fingerprints[_fingerprint].exists, \"Certificate does not exists\");\n       require(_signer == signer, \"Signature does not corresponds to signer\");\n       fingerprints[_fingerprint].signatures[_signer] = _signature;\n       return true;\n    }\n    \n    /**\n    * @dev Returns the corresponding signature to a certificate and signer, used to verify signatures\n    * @param _signer address. The address of who supposedly signed the certificate.\n    * @param _fingerprint bytes32. Is the sha3 hash of document. Generated with web3.\n    */\n    function getSignature(address _signer, bytes32 _fingerprint) public view returns(bytes memory) {\n        return fingerprints[_fingerprint].signatures[_signer];\n    }\n}\n",
      "file": "CertificationsFlattened.sol"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x523ef5f27cea608b45bb3a44cd48ef4003e83c0ec20e231d7d3d44c840ed443f",
    "blockNumber": 395869,
    "transactionHash": "0xfa6d4fadb4e17f81abdb4260f806afb64e34dad72903372a7d4b7ccbfeb3a528",
    "timestamp": 1574631049
  }
}