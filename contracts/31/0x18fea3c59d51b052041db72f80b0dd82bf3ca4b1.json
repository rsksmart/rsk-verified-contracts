{
  "address": "0x18fea3c59d51b052041db72f80b0dd82bf3ca4b1",
  "net": {
    "id": "31",
    "name": "RSK Testnet"
  },
  "name": "DynamicCryptoFund",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "metadata",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ]
      }
    }
  },
  "version": "0.6.9+commit.3e3065ac",
  "source": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.9;\n\n//////////////////////////////////////////////////////////////\n//                                                          //\n//         Dynamic Diverse Open End Crypto Fund             //\n//                                                          //\n//////////////////////////////////////////////////////////////\n\n\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n      if (a == 0) {\n          return 0;\n      }\n      uint256 c = a * b;\n      require(c / a == b, \"SafeMath: multiplication overflow\");\n      return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n      return div(a, b, \"SafeMath: division by zero\");\n  }\n\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n      require(b > 0, errorMessage);\n      uint256 c = a / b;\n      return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n      return sub(a, b, \"SafeMath: subtraction overflow\");\n  }\n\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n      require(b <= a, errorMessage);\n      uint256 c = a - b;\n      return c;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n      uint256 c = a + b;\n      require(c >= a, \"SafeMath: addition overflow\");\n      return c;\n  }\n}\n\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this;\n        return msg.data;\n    }\n}\n\n\ncontract OwnableContract is Context {\n      address internal owner;\n      event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n      constructor () internal {\n          address msgSender = _msgSender();\n          owner = msgSender;\n          emit OwnershipTransferred(address(0), msgSender);\n      }\n\n      modifier onlyOwner() {\n          require(owner == _msgSender(), \"Ownable: caller is not the owner\");\n          _;\n      }\n\n      function getOwner() public view returns (address) {\n          return owner;\n      }\n\n      function transferOwnership(address newOwner) public virtual onlyOwner {\n          require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n          emit OwnershipTransferred(owner, newOwner);\n          owner = newOwner;\n      }\n}\n\n\ncontract DynamicToken is OwnableContract {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) internal balances;\n    mapping (address => uint256) internal redemptionRequests;\n    mapping (address => mapping (address => uint256)) internal allowed;\n    mapping (address => timeHold) holded;\n\n    struct timeHold{\n        uint256[] amount;\n        uint256[] time;\n        uint256 length;\n    }\n\n    string public constant standard = \"RRC20 Crypto Investment Fund\";\n    // hardcoded to be a constant\n    uint8 public constant decimals = 8; \n    uint256 public totalSupply;\n    string public name;\n    string public symbol;\n    uint256 public holdTime;\n    uint256 public holdMax;\n    uint256 public maxSupply;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function redemptionRequestsOf(address _owner) public view onlyOwner returns (uint256) {\n        return redemptionRequests[_owner];\n    }\n\n    function hold(address _to, uint256 _value) internal {\n        holded[_to].amount.push(_value);\n        holded[_to].time.push(block.number);\n        holded[_to].length++;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[msg.sender]);\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        delete holded[msg.sender];\n\t\thold(msg.sender, balances[msg.sender]);\n        hold(_to,_value);\n        balances[_to] = balances[_to].add(_value);\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n        balances[_from] = balances[_from].sub(_value);\n        delete holded[_from];\n\t\thold(_from, balances[_from]);\n        hold(_to,_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n        uint oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\n            return true;\n        }\n    }\n}\n\n\ninterface tokenRecipient {\n    function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external ;\n}\n\n\ncontract DynamicCryptoFund is DynamicToken {\n\n    uint256 public tokenPrice = 0;\n    // constant to simplify conversion of token amounts into integer form\n    uint256 internal tokenUnit = uint256(10)**decimals;\n\n    //Declare logging events\n    event LogDeposit(address sender, uint amount);\n    event LogTokenTransfer(address indexed from, address indexed to, uint256 value);\n    event LogRequestedRedemption(address sender, uint value);\n    event LogWithdrawal(address receiver, uint amount);\n\n    constructor(uint256 initialSupply, uint256 contractHoldTime, uint256 contractHoldMax, uint256 contractMaxSupply, address contractOwner) public {\n        name = \"Dynamic Diverse Crypto Fund\";\n        symbol = \"D2\";\n        totalSupply = initialSupply;\n        holdTime = contractHoldTime;\n        holdMax = contractHoldMax;\n        maxSupply = contractMaxSupply;\n        owner = contractOwner;\n        balances[contractOwner] = balances[contractOwner].add(totalSupply);\n    }\n\n    receive() external payable {\n        buy();\n    }\n\n    function contractBalance() public view onlyOwner returns (uint256 amount) {\n        return address(this).balance;\n    }\n\n    function depositFunds() external payable onlyOwner returns(bool success) {\n        // Check for overflows;\n        assert(address(this).balance + msg.value >= address(this).balance);\n        emit LogDeposit(msg.sender, msg.value);\n        return true;\n    }\n\n    function withdrawReward() external {\n        uint i = 0;\n        uint256 ethAmount = 0;\n        uint256 request = 0;\n        uint256 len = holded[msg.sender].length;\n        while (i <= len - 1){\n            if (block.number - holded[msg.sender].time[i] > holdTime && block.number - holded[msg.sender].time[i] < holdMax){\n                ethAmount += tokenPrice * holded[msg.sender].amount[i];\n            }\n            i++;\n        }\n        require(ethAmount > 0, \"You're out of your holding period\");\n        require(ethAmount>=(tokenPrice*redemptionRequests[msg.sender]));\n        totalSupply = totalSupply.sub(redemptionRequests[msg.sender]);\n        balances[msg.sender] = balances[msg.sender].sub(redemptionRequests[msg.sender]);\n        emit LogTokenTransfer(msg.sender, address(this), redemptionRequests[msg.sender]);\n        delete holded[msg.sender];\n        hold(msg.sender,balances[msg.sender]);\n        request = redemptionRequests[msg.sender];\n        msg.sender.transfer(tokenPrice*redemptionRequests[msg.sender]/tokenUnit);\n        delete redemptionRequests[msg.sender];\n    }\n\n    function setPrice(uint256 _value) public onlyOwner {\n      require(msg.sender == owner);\n      tokenPrice = _value;\n    }\n\n    function requestWithdraw(uint value) public {\n      require(value <= balances[msg.sender], \"You don't have enough balance\");\n      delete holded[msg.sender];\n      hold(msg.sender, value);\n      redemptionRequests[msg.sender]=value;\n      emit LogRequestedRedemption(msg.sender, value);\n    }\n\n    function buy() public payable {\n    require(totalSupply <= maxSupply, \"Maximum supply has been reached!\");\n    require(msg.value > 0);\n    uint256 tokenAmount = (msg.value * tokenUnit) / tokenPrice ;\n    transferBuy(msg.sender, tokenAmount);\n    }\n\n    function transferBuy(address _to, uint256 _value) internal returns (bool) {\n        require(_to != address(0));\n        // SafeMath.add will throw if there is not enough balance.\n        totalSupply = totalSupply.add(_value);\n        hold(_to,_value); \n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(address(this), _to, _value);\n        return true;\n    }\n\n    function withdrawFunds(uint _value) external onlyOwner returns(bool success) {\n        require(msg.sender == owner);\n        assert(address(this).balance + _value >= address(this).balance);\n        // Reentrancy guard\n        uint fund = address(this).balance;    \n        msg.sender.transfer(fund);\n        return true;\n    }\n    \n}\n",
  "imports": [
    {
      "name": "DynamicCryptoFund.sol",
      "contents": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.9;\n\n//////////////////////////////////////////////////////////////\n//                                                          //\n//         Dynamic Diverse Open End Crypto Fund             //\n//                                                          //\n//////////////////////////////////////////////////////////////\n\n\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n      if (a == 0) {\n          return 0;\n      }\n      uint256 c = a * b;\n      require(c / a == b, \"SafeMath: multiplication overflow\");\n      return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n      return div(a, b, \"SafeMath: division by zero\");\n  }\n\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n      require(b > 0, errorMessage);\n      uint256 c = a / b;\n      return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n      return sub(a, b, \"SafeMath: subtraction overflow\");\n  }\n\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n      require(b <= a, errorMessage);\n      uint256 c = a - b;\n      return c;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n      uint256 c = a + b;\n      require(c >= a, \"SafeMath: addition overflow\");\n      return c;\n  }\n}\n\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this;\n        return msg.data;\n    }\n}\n\n\ncontract OwnableContract is Context {\n      address internal owner;\n      event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n      constructor () internal {\n          address msgSender = _msgSender();\n          owner = msgSender;\n          emit OwnershipTransferred(address(0), msgSender);\n      }\n\n      modifier onlyOwner() {\n          require(owner == _msgSender(), \"Ownable: caller is not the owner\");\n          _;\n      }\n\n      function getOwner() public view returns (address) {\n          return owner;\n      }\n\n      function transferOwnership(address newOwner) public virtual onlyOwner {\n          require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n          emit OwnershipTransferred(owner, newOwner);\n          owner = newOwner;\n      }\n}\n\n\ncontract DynamicToken is OwnableContract {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) internal balances;\n    mapping (address => uint256) internal redemptionRequests;\n    mapping (address => mapping (address => uint256)) internal allowed;\n    mapping (address => timeHold) holded;\n\n    struct timeHold{\n        uint256[] amount;\n        uint256[] time;\n        uint256 length;\n    }\n\n    string public constant standard = \"RRC20 Crypto Investment Fund\";\n    // hardcoded to be a constant\n    uint8 public constant decimals = 8; \n    uint256 public totalSupply;\n    string public name;\n    string public symbol;\n    uint256 public holdTime;\n    uint256 public holdMax;\n    uint256 public maxSupply;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function redemptionRequestsOf(address _owner) public view onlyOwner returns (uint256) {\n        return redemptionRequests[_owner];\n    }\n\n    function hold(address _to, uint256 _value) internal {\n        holded[_to].amount.push(_value);\n        holded[_to].time.push(block.number);\n        holded[_to].length++;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[msg.sender]);\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        delete holded[msg.sender];\n\t\thold(msg.sender, balances[msg.sender]);\n        hold(_to,_value);\n        balances[_to] = balances[_to].add(_value);\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n        balances[_from] = balances[_from].sub(_value);\n        delete holded[_from];\n\t\thold(_from, balances[_from]);\n        hold(_to,_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n        uint oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\n            return true;\n        }\n    }\n}\n\n\ninterface tokenRecipient {\n    function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external ;\n}\n\n\ncontract DynamicCryptoFund is DynamicToken {\n\n    uint256 public tokenPrice = 0;\n    // constant to simplify conversion of token amounts into integer form\n    uint256 internal tokenUnit = uint256(10)**decimals;\n\n    //Declare logging events\n    event LogDeposit(address sender, uint amount);\n    event LogTokenTransfer(address indexed from, address indexed to, uint256 value);\n    event LogRequestedRedemption(address sender, uint value);\n    event LogWithdrawal(address receiver, uint amount);\n\n    constructor(uint256 initialSupply, uint256 contractHoldTime, uint256 contractHoldMax, uint256 contractMaxSupply, address contractOwner) public {\n        name = \"Dynamic Diverse Crypto Fund\";\n        symbol = \"D2\";\n        totalSupply = initialSupply;\n        holdTime = contractHoldTime;\n        holdMax = contractHoldMax;\n        maxSupply = contractMaxSupply;\n        owner = contractOwner;\n        balances[contractOwner] = balances[contractOwner].add(totalSupply);\n    }\n\n    receive() external payable {\n        buy();\n    }\n\n    function contractBalance() public view onlyOwner returns (uint256 amount) {\n        return address(this).balance;\n    }\n\n    function depositFunds() external payable onlyOwner returns(bool success) {\n        // Check for overflows;\n        assert(address(this).balance + msg.value >= address(this).balance);\n        emit LogDeposit(msg.sender, msg.value);\n        return true;\n    }\n\n    function withdrawReward() external {\n        uint i = 0;\n        uint256 ethAmount = 0;\n        uint256 request = 0;\n        uint256 len = holded[msg.sender].length;\n        while (i <= len - 1){\n            if (block.number - holded[msg.sender].time[i] > holdTime && block.number - holded[msg.sender].time[i] < holdMax){\n                ethAmount += tokenPrice * holded[msg.sender].amount[i];\n            }\n            i++;\n        }\n        require(ethAmount > 0, \"You're out of your holding period\");\n        require(ethAmount>=(tokenPrice*redemptionRequests[msg.sender]));\n        totalSupply = totalSupply.sub(redemptionRequests[msg.sender]);\n        balances[msg.sender] = balances[msg.sender].sub(redemptionRequests[msg.sender]);\n        emit LogTokenTransfer(msg.sender, address(this), redemptionRequests[msg.sender]);\n        delete holded[msg.sender];\n        hold(msg.sender,balances[msg.sender]);\n        request = redemptionRequests[msg.sender];\n        msg.sender.transfer(tokenPrice*redemptionRequests[msg.sender]/tokenUnit);\n        delete redemptionRequests[msg.sender];\n    }\n\n    function setPrice(uint256 _value) public onlyOwner {\n      require(msg.sender == owner);\n      tokenPrice = _value;\n    }\n\n    function requestWithdraw(uint value) public {\n      require(value <= balances[msg.sender], \"You don't have enough balance\");\n      delete holded[msg.sender];\n      hold(msg.sender, value);\n      redemptionRequests[msg.sender]=value;\n      emit LogRequestedRedemption(msg.sender, value);\n    }\n\n    function buy() public payable {\n    require(totalSupply <= maxSupply, \"Maximum supply has been reached!\");\n    require(msg.value > 0);\n    uint256 tokenAmount = (msg.value * tokenUnit) / tokenPrice ;\n    transferBuy(msg.sender, tokenAmount);\n    }\n\n    function transferBuy(address _to, uint256 _value) internal returns (bool) {\n        require(_to != address(0));\n        // SafeMath.add will throw if there is not enough balance.\n        totalSupply = totalSupply.add(_value);\n        hold(_to,_value); \n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(address(this), _to, _value);\n        return true;\n    }\n\n    function withdrawFunds(uint _value) external onlyOwner returns(bool success) {\n        require(msg.sender == owner);\n        assert(address(this).balance + _value >= address(this).balance);\n        // Reentrancy guard\n        uint fund = address(this).balance;    \n        msg.sender.transfer(fund);\n        return true;\n    }\n    \n}\n",
      "file": "DynamicCryptoFund.sol"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x490482d971fd1de9df23ba9dd4a61b3b7158724b68acae7cc6f46db7dd5f29ce",
    "blockNumber": 951984,
    "transactionHash": "0xffaa40eb95efc70737594aed80e78197101d7eea73daaaf715be22e1b91cadbe",
    "timestamp": 1592781936
  },
  "constructorArguments": [
    "0",
    "1",
    "10",
    "1000000000000000",
    "0x24e4ec7d0ed02fd25d3e555532cd40ad01728275"
  ]
}