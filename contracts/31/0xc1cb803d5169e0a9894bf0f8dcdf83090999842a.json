{
  "address": "0xc1cb803d5169e0a9894bf0f8dcdf83090999842a",
  "net": {
    "id": "31",
    "name": "RSK Testnet"
  },
  "name": "ReverseRegistrar",
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "metadata",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ]
      }
    }
  },
  "version": "0.5.12+commit.7709ece9",
  "source": "pragma solidity ^0.5.0;\n\nimport \"@rsksmart/rns-artifacts/contracts/registry/AbstractRNS.sol\";\nimport \"./NameResolver.sol\";\n\ncontract ReverseRegistrar {\n    // namehash('addr.reverse')\n    bytes32 public constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n\n    AbstractRNS public rns;\n\n    /// @dev Constructor\n    /// @param rnsAddr The address of the RNS registry.\n    constructor(AbstractRNS rnsAddr) public {\n        rns = rnsAddr;\n    }\n\n    /// @notice Sets the name record on that name to the specified name\n    /// @dev Sets the resolver for the name hex(msg.sender).addr.reverse to a default resolver\n    /// @param name The name to set for this address.\n    /// @return The RNS node hash of the reverse record.\n    function setName(string memory name) public returns (bytes32 node) {\n        node = claim(address(this));\n        NameResolver(rns.resolver(node)).setName(node, name);\n    }\n\n    /// @notice Transfer ownership of the name hex(msg.sender).addr.reverse\n    /// @dev Allows the caller to specify an owner other than themselves.\n    /// The resulting account has `name()` resolver.\n    /// @param owner The address to set as the owner of the reverse record in RNS.\n    /// @return The RNS node hash of the reverse record.\n    function claim(address owner) public returns (bytes32 node) {\n        bytes32 label = sha3HexAddress(msg.sender);\n        rns.setSubnodeOwner(ADDR_REVERSE_NODE, label, owner);\n        node = keccak256(abi.encodePacked(ADDR_REVERSE_NODE, label));\n    }\n\n    /// @notice Sets the resolver of the name hex(msg.sender).addr.reverse to the specified resolver\n    /// @dev Transfer ownership of the name to the provided address.\n    /// @param owner The address to set as the owner of the reverse record in RNS.\n    /// @param resolver The address of the resolver to set; 0 to leave default.\n    /// @return The RNS node hash of the reverse record.\n    function claimWithResolver(address owner, address resolver) public returns (bytes32 node) {\n        bytes32 label = sha3HexAddress(msg.sender);\n        node = keccak256(abi.encodePacked(ADDR_REVERSE_NODE, label));\n\n        if (rns.owner(node) != address(this))\n            rns.setSubnodeOwner(ADDR_REVERSE_NODE, label, address(this));\n        // registrar owns the node, with default resolver\n\n        if (resolver != address(0x0) && resolver != rns.resolver(ADDR_REVERSE_NODE))\n            rns.setResolver(node, resolver);\n        // node has default resolver for 0x00 or resolver value\n\n        if (owner != address(this))\n            rns.setOwner(node, owner);\n        // owner owns node\n    }\n\n    /// @dev Returns the node hash for a given account's reverse records.\n    /// @param addr The address to hash\n    /// @return The RNS node hash.\n    function node(address addr) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr)));\n    }\n\n    /// @dev An optimised function to compute the sha3 of the lower-case\n    /// hexadecimal representation of an Ethereum address.\n    /// @param addr The address to hash\n    /// @return The SHA3 hash of the lower-case hexadecimal encoding of the\n    /// input address.\n    function sha3HexAddress(address addr) private pure returns (bytes32 ret) {\n        addr;\n        ret; // Stop warning us about unused variables\n        assembly {\n            let lookup := 0x3031323334353637383961626364656600000000000000000000000000000000\n\n            for { let i := 40 } gt(i, 0) { } {\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n            }\n\n            ret := keccak256(0, 40)\n        }\n    }\n}\n",
  "imports": [
    {
      "name": "ReverseRegistrar.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"@rsksmart/rns-artifacts/contracts/registry/AbstractRNS.sol\";\nimport \"./NameResolver.sol\";\n\ncontract ReverseRegistrar {\n    // namehash('addr.reverse')\n    bytes32 public constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n\n    AbstractRNS public rns;\n\n    /// @dev Constructor\n    /// @param rnsAddr The address of the RNS registry.\n    constructor(AbstractRNS rnsAddr) public {\n        rns = rnsAddr;\n    }\n\n    /// @notice Sets the name record on that name to the specified name\n    /// @dev Sets the resolver for the name hex(msg.sender).addr.reverse to a default resolver\n    /// @param name The name to set for this address.\n    /// @return The RNS node hash of the reverse record.\n    function setName(string memory name) public returns (bytes32 node) {\n        node = claim(address(this));\n        NameResolver(rns.resolver(node)).setName(node, name);\n    }\n\n    /// @notice Transfer ownership of the name hex(msg.sender).addr.reverse\n    /// @dev Allows the caller to specify an owner other than themselves.\n    /// The resulting account has `name()` resolver.\n    /// @param owner The address to set as the owner of the reverse record in RNS.\n    /// @return The RNS node hash of the reverse record.\n    function claim(address owner) public returns (bytes32 node) {\n        bytes32 label = sha3HexAddress(msg.sender);\n        rns.setSubnodeOwner(ADDR_REVERSE_NODE, label, owner);\n        node = keccak256(abi.encodePacked(ADDR_REVERSE_NODE, label));\n    }\n\n    /// @notice Sets the resolver of the name hex(msg.sender).addr.reverse to the specified resolver\n    /// @dev Transfer ownership of the name to the provided address.\n    /// @param owner The address to set as the owner of the reverse record in RNS.\n    /// @param resolver The address of the resolver to set; 0 to leave default.\n    /// @return The RNS node hash of the reverse record.\n    function claimWithResolver(address owner, address resolver) public returns (bytes32 node) {\n        bytes32 label = sha3HexAddress(msg.sender);\n        node = keccak256(abi.encodePacked(ADDR_REVERSE_NODE, label));\n\n        if (rns.owner(node) != address(this))\n            rns.setSubnodeOwner(ADDR_REVERSE_NODE, label, address(this));\n        // registrar owns the node, with default resolver\n\n        if (resolver != address(0x0) && resolver != rns.resolver(ADDR_REVERSE_NODE))\n            rns.setResolver(node, resolver);\n        // node has default resolver for 0x00 or resolver value\n\n        if (owner != address(this))\n            rns.setOwner(node, owner);\n        // owner owns node\n    }\n\n    /// @dev Returns the node hash for a given account's reverse records.\n    /// @param addr The address to hash\n    /// @return The RNS node hash.\n    function node(address addr) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr)));\n    }\n\n    /// @dev An optimised function to compute the sha3 of the lower-case\n    /// hexadecimal representation of an Ethereum address.\n    /// @param addr The address to hash\n    /// @return The SHA3 hash of the lower-case hexadecimal encoding of the\n    /// input address.\n    function sha3HexAddress(address addr) private pure returns (bytes32 ret) {\n        addr;\n        ret; // Stop warning us about unused variables\n        assembly {\n            let lookup := 0x3031323334353637383961626364656600000000000000000000000000000000\n\n            for { let i := 40 } gt(i, 0) { } {\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n            }\n\n            ret := keccak256(0, 40)\n        }\n    }\n}\n",
      "file": "ReverseRegistrar.sol"
    },
    {
      "name": "Migrations.sol",
      "contents": "pragma solidity >=0.4.21 <0.6.0;\n\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n"
    },
    {
      "name": "NameResolver.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"./ResolverBase.sol\";\nimport \"@rsksmart/rns-artifacts/contracts/registry/AbstractRNS.sol\";\n\n/// source: https://github.com/ensdomains/resolvers/blob/master/contracts/profiles/NameResolver.sol\ncontract NameResolver is ResolverBase {\n    bytes4 constant private NAME_INTERFACE_ID = 0x691f3431;\n    AbstractRNS rns;\n\n    event NameChanged(bytes32 indexed node, string name);\n\n    mapping(bytes32=>string) names;\n\n    modifier onlyOwner (bytes32 node) {\n        require(msg.sender == rns.owner(node), \"Only owner\");\n        _;\n    }\n\n    constructor (AbstractRNS _rns) public {\n        rns = _rns;\n    }\n\n    /// @notice Sets the name associated with an RNS node, for reverse records.\n    /// @dev May only be called by the owner of that node in the RNS registry.\n    /// @param node The node to update.\n    /// @param name The name to set.\n    function setName(bytes32 node, string calldata name) external onlyOwner(node) {\n        names[node] = name;\n        emit NameChanged(node, name);\n    }\n\n    /// @notice Returns the name associated with an RNS node, for reverse records.\n    /// @dev Defined in EIP181.\n    /// @param node The node to query.\n    /// @return The associated name.\n    function name(bytes32 node) external view returns (string memory) {\n        return names[node];\n    }\n\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\n        return interfaceID == NAME_INTERFACE_ID || super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    {
      "name": "ResolverBase.sol",
      "contents": "pragma solidity ^0.5.0;\n\n/// source: https://github.com/ensdomains/resolvers/blob/master/contracts/ResolverBase.sol\ncontract ResolverBase {\n    bytes4 private constant INTERFACE_META_ID = 0x01ffc9a7;\n\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\n        return interfaceID == INTERFACE_META_ID;\n    }\n}\n"
    },
    {
      "name": "ReverseSetup.sol",
      "contents": "pragma solidity ^0.5.0;\n\nimport \"@rsksmart/rns-artifacts/contracts/registry/AbstractRNS.sol\";\n\ncontract ReverseSetup {\n    AbstractRNS rns;\n    address nameResolver;\n    address reverseRegistrar;\n    address payable reverseOwner;\n\n    bytes32 constant REVERSE = 0xa097f6721ce401e757d1223a763fef49b8b5f90bb18567ddb86fd205dff71d34;\n    bytes32 constant ADDR_REVERSE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n\n    constructor (\n        AbstractRNS _rns,\n        address _nameResolver,\n        address _reverseRegistrar,\n        address payable _reverseOwner\n    ) public {\n        rns = _rns;\n        nameResolver = _nameResolver;\n        reverseRegistrar = _reverseRegistrar;\n        reverseOwner = _reverseOwner;\n    }\n\n   function run() public {\n        require(rns.owner(REVERSE) == address(this), \"Not reverse owner\");\n\n        // run\n        rns.setResolver(REVERSE, nameResolver);\n        rns.setSubnodeOwner(REVERSE, keccak256('addr'), reverseRegistrar);\n        rns.setOwner(REVERSE, reverseOwner);\n\n        // assert\n        assert(rns.owner(REVERSE) == reverseOwner);\n        assert(rns.owner(ADDR_REVERSE) == reverseRegistrar);\n        assert(rns.resolver(REVERSE) == nameResolver);\n        assert(rns.resolver(ADDR_REVERSE) == nameResolver);\n\n        // self destruct\n        selfdestruct(reverseOwner);\n   }\n}\n"
    },
    {
      "name": "AbstractRNS.sol",
      "contents": "pragma solidity ^0.5.2;\n\ncontract AbstractRNS {\n    function owner(bytes32 node) public view returns(address);\n    function resolver(bytes32 node) public view returns(address);\n    function ttl(bytes32 node) public view returns(uint64);\n    function setOwner(bytes32 node, address ownerAddress) public;\n    function setSubnodeOwner(bytes32 node, bytes32 label, address ownerAddress) public;\n    function setResolver(bytes32 node, address resolverAddress) public;\n    function setTTL(bytes32 node, uint64 ttlValue) public;\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address ownerAddress);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address ownerAddress);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolverAddress);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttlValue);\n}\n"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x11dc0daf207c9c07caac1f1fbce0f38f59e48c1d44310dd88b4cafe6f4face3e",
    "blockNumber": 419976,
    "transactionHash": "0x101b6c56db12f47701c69be57d96b716da78e5db6c3841c1d4c4f98df354dd58",
    "timestamp": 1575416269
  },
  "constructorArguments": [
    "0x7d284aaac6e925aad802a53c0c69efe3764597b8"
  ]
}