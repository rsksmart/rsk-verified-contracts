{
    "address": "0x0b9a0505f681b5ebdfca3265ea963f8cf6cf094c",
    "net": {
        "id": "31",
        "name": "RSK Testnet"
    },
    "name": "MoCInrate",
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": "1"
        },
        "evmVersion": "byzantium"
    },
    "version": "0.5.8+commit.23d335f2",
    "source": "\n// File: moc-governance/contracts/Governance/ChangeContract.sol\n\npragma solidity 0.5.8;\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n\n  /**\n    @notice Override this function with a recipe of the changes to be done when this ChangeContract\n    is executed\n   */\n  function execute() external;\n}\n\n// File: moc-governance/contracts/Governance/IGovernor.sol\n\npragma solidity 0.5.8;\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor{\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @dev This function should be protected somehow to only execute changes that\n    benefit the system. This decision process is independent of this architechture\n    therefore is independent of this interface too\n    @param changeContract Address of the contract that will execute the changes\n   */\n  function executeChange(ChangeContract changeContract) external;\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @param _changer Address of the contract that will execute the changes\n   */\n  function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n// File: zos-lib/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.6.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: moc-governance/contracts/Governance/Governed.sol\n\npragma solidity 0.5.8;\n\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed is Initializable {\n\n  /**\n    @notice The address of the contract which governs this one\n   */\n  IGovernor public governor;\n\n  string constant private NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n  /**\n    @notice Modifier that protects the function\n    @dev You should use this modifier in any function that should be called through\n    the governance system\n   */\n  modifier onlyAuthorizedChanger() {\n    require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n    _;\n  }\n\n  /**\n    @notice Initialize the contract with the basic settings\n    @dev This initialize replaces the constructor but it is not called automatically.\n    It is necessary because of the upgradeability of the contracts\n    @param _governor Governor address\n   */\n  function initialize(IGovernor _governor) public initializer {\n    governor = _governor;\n  }\n\n  /**\n    @notice Change the contract's governor. Should be called through the old governance system\n    @param newIGovernor New governor address\n   */\n  function changeIGovernor(IGovernor newIGovernor) public onlyAuthorizedChanger {\n    governor = newIGovernor;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n// File: contracts/MoCHelperLib.sol\n\npragma solidity 0.5.8;\n\n\nlibrary MoCHelperLib {\n\n  struct MocLibConfig {\n    uint256 reservePrecision;\n    uint256 dayPrecision;\n    uint256 mocPrecision;\n  }\n\n  using SafeMath for uint256;\n\n  uint256 constant UINT256_MAX = ~uint256(0);\n\n  /**\n    @dev Returns max uint256 value constant.\n    @return max uint256 value constant\n  */\n  function getMaxInt(MocLibConfig storage /*config*/) public pure returns(uint256) {\n    return UINT256_MAX;\n  }\n\n  /**\n    @dev Calculates average interest using integral function: T =  Rate = a * (x ** b) + c\n    @param tMax maxInterestRate [using mocPrecision]\n    @param power factor [using noPrecision]\n    @param tMin minInterestRate C0 stableToken amount [using mocPrecision]\n    @param abRat1 initial abundance ratio [using mocPrecision]\n    @param abRat2 final abundance ratio [using mocPrecision]\n    @return average interest rate [using mocPrecision]\n  */\n  function inrateAvg(MocLibConfig storage config, uint256 tMax, uint256 power, uint256 tMin, uint256 abRat1, uint256 abRat2)\n  public view returns(uint256) {\n    require(tMax > tMin, \"Max inrate should be bigger than Min inrate\");\n    uint256 abRat1Comp = config.mocPrecision.sub(abRat1);\n    uint256 abRat2Comp = config.mocPrecision.sub(abRat2);\n\n    if (abRat1 == abRat2) {\n      return potential(config, tMax, power, tMin, abRat1Comp);\n    }\n    else if (abRat2 < abRat1) {\n      return avgInt(config, tMax, power, tMin, abRat1Comp, abRat2Comp);\n    }\n    else {\n      return avgInt(config, tMax, power, tMin, abRat2Comp, abRat1Comp);\n    }\n  }\n\n  /**\n    @dev Calculates spot interest rate that RiskProx owners should pay to RiskPro owners: Rate = tMax * (abRatio ** power) + tMin\n    @param tMin min interest rate [using mocPrecision]\n    @param power power to use in the formula [using NoPrecision]\n    @param tMax max interest rate [using mocPrecision]\n    @param abRatio bucket C0  abundance Ratio [using mocPrecision]\n\n   */\n  function spotInrate(\n    MocLibConfig storage config, uint256 tMax, uint256 power, uint256 tMin, uint256 abRatio\n  ) public view returns(uint256) {\n    uint256 abRatioComp = config.mocPrecision.sub(abRatio);\n\n    return potential(config, tMax, power, tMin, abRatioComp);\n  }\n\n  /**\n    @dev Calculates potential interests function with given parameters: Rate = a * (x ** b) + c\n    @param a maxInterestRate [using mocPrecision]\n    @param b factor [using NoPrecision]\n    @param c minInterestRate C0 stableToken amount [using mocPrecision]\n    @param value global stableToken amount [using mocPrecision]\n  */\n  function potential(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value)\n  public view returns(uint256) {\n    // value ** b\n    // [MOC] ** [] = [MOC]\n    uint256 aux1 = pow(value, b, config.mocPrecision);\n    // (a * aux1) + c\n    // [MOC] [MOC] / [MOC] + [MOC] = [MOC]\n    return a.mul(aux1).div(config.mocPrecision).add(c);\n  }\n\n    /**\n    @dev Calculates average of the integral function:\n     T = (\n              (c * xf + ((a * (xf ** (b + 1))) / (b + 1))) -\n              (c * xi + ((a * (xi ** (b + 1))) / (b + 1)))\n             ) / (xf - xi)\n    @param a maxInterestRate [using mocPrecision]\n    @param b factor [using NoPrecision]\n    @param c minInterestRate C0 stableToken amount [using mocPrecision]\n    @param value1 value to put in the function [using mocPrecision]\n    @param value2 value to put in the function [using mocPrecision]\n    @return average interest rate [using mocPrecision]\n   */\n  function avgInt(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value1, uint256 value2)\n  public view returns(uint256) {\n    // value2 - value1\n    // [MOC]\n    uint256 diff = value2.sub(value1);\n    // ((c * (1 - value1) + ((a * ((1 - value1) ** (b + 1))) / (b + 1)))\n    uint256 intV1 = integral(config, a, b, c, value1);\n    // ((c * (1 - value2) + ((a * ((1 - value2) ** (b + 1))) / (b + 1)))\n    uint256 intV2 = integral(config,  a, b, c, value2);\n    // (secOp - first) / diff\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\n    return intV2.sub(intV1).div(diff);\n  }\n\n  /**\n    @dev Calculates integral of the exponential function: T = c * (value) + (a * value ** (b + 1)) / (b + 1))\n    @param a maxInterestRate [using mocPrecision]\n    @param b factor [using NoPrecision]\n    @param c minInterestRate C0 stableToken amount [using mocPrecision]\n    @param value value to put in the function [using mocPrecision]\n    @return integration result [using mocPrecision]\n  */\n  function integral(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value)\n  public view returns(uint256) {\n    // b + 1\n    // [NONE]\n    uint256 b2 = b.add(1);\n    // c * value\n    // [MOC][MOC]\n    uint256 firstOp = c.mul(value);\n    // [MOC]\n    uint256 pow = pow(value, b2, config.mocPrecision);\n    // (a * value ** b2) / b2)\n    // [MOC][MOC]\n    uint256 secOp = a.mul(pow).div(b2);\n    // (firstOp + secOp)\n    // [MOC][MOC] + [MOC][MOC] = [MOC][MOC]\n    return firstOp.add(secOp);\n  }\n\n  /**\n  * @dev Relation between stableTokens in bucket 0 and StableToken total supply\n  * @param stableToken0 stableToken count in bucket 0 [using mocPrecision]\n  * @param stableTokent total stableToken supply [using mocPrecision]\n  * @return abundance ratio [using mocPrecision]\n  */\n  function abundanceRatio(MocLibConfig storage config, uint256 stableToken0, uint256 stableTokent)\n  public view returns(uint256) {\n    if (stableTokent == 0) {\n      return config.mocPrecision;\n    }\n    // [DOC] [MOC] / [DOC] = [MOC]\n    return stableToken0.mul(config.mocPrecision).div(stableTokent);\n  }\n\n  /**\n    @dev Returns the Ratio to apply to RiskPro Price in discount situations: SpotDiscountRate = TPD * (utpdu - cob) / (uptdu -liq)\n    @param riskProLiqDiscountRate Discount rate applied at Liquidation level coverage [using mocPrecision]\n    @param liq Liquidation coverage threshold [using mocPrecision]\n    @param utpdu Discount coverage threshold [using mocPrecision]\n    @param cov Actual global Coverage threshold [using mocPrecision]\n    @return Spot discount rate [using mocPrecision]\n  */\n  function riskProSpotDiscountRate(\n    MocLibConfig storage libConfig, uint256 riskProLiqDiscountRate,\n    uint256 liq, uint256 utpdu, uint256 cov\n  ) public view returns(uint256) {\n    require(riskProLiqDiscountRate < libConfig.mocPrecision, \"Discount rate should be lower than 1\");\n\n    if (cov >= utpdu) {\n      return 0;\n    }\n\n    // utpdu - liq\n    // [MOC] - [MOC] = [MOC]\n    uint256 utpduLiqDiff = utpdu.sub(liq);\n\n    // utpdu - cov\n    // [MOC] - [MOC] = [MOC]\n    uint256 utpduCovDiff = utpdu.sub(cov);\n\n    // TPD * utpduCovDiff / utpduLiqDiff\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    return riskProLiqDiscountRate.mul(utpduCovDiff).div(utpduLiqDiff);\n  }\n\n  /**\n    @dev Max amount of RiskPro to available with discount: MaxRiskProWithDiscount = (uTPDU * nStableToken * PEG - (nReserve * B)) / (TPusd * TPD)\n    @param nReserve Total ReserveTokens amount [using reservePrecision]\n    @param nStableToken StableToken amount [using mocPrecision]\n    @param utpdu Discount coverage threshold [using mocPrecision]\n    @param peg peg value\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @param riskProUsdPrice riskProUsdPrice [using mocPrecision]\n    @param spotDiscount spot discount [using mocPrecision]\n    @return Total RiskPro amount [using mocPrecision]\n  */\n  function maxRiskProWithDiscount(\n    MocLibConfig storage libConfig, uint256 nReserve, uint256 nStableToken, uint256 utpdu,\n    uint256 peg, uint256 reservePrice, uint256 riskProUsdPrice, uint256 spotDiscount\n  ) public view returns(uint256)  {\n    require(spotDiscount < libConfig.mocPrecision, \"Discount Rate should be lower than 1\");\n\n    if (spotDiscount == 0) {\n      return 0;\n    }\n\n    // nReserve * B\n    // [RES] * [MOC] / [RES] = [MOC]\n    uint256 nbUsdValue = nReserve.mul(reservePrice).div(libConfig.reservePrecision);\n\n    // (TPusd * (1 - TPD))\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 riskProDiscountPrice = riskProUsdPrice.mul(libConfig.mocPrecision.sub(spotDiscount))\n      .div(libConfig.mocPrecision);\n\n    return maxRiskProWithDiscountAux(libConfig, nbUsdValue, nStableToken, utpdu, peg, riskProDiscountPrice);\n  }\n\n  /**\n    @dev Max amount of RiskPro to available with discount: MaxRiskProWithDiscount = (uTPDU * nStableToken * PEG - (nReserve * B)) / (TPusd * TPD)\n    @param nbUsdValue Total amount of ReserveTokens in USD [using mocPrecision]\n    @param nStableToken StableToken amount [using mocPrecision]\n    @param utpdu Discount coverage threshold [using mocPrecision]\n    @param riskProDiscountPrice riskProUsdPrice with discount applied [using mocPrecision]\n    @param peg peg value\n    @return Total RiskPro amount [using reservePrecision]\n  */\n  function maxRiskProWithDiscountAux(\n    MocLibConfig storage libConfig, uint256 nbUsdValue, uint256 nStableToken,\n    uint256 utpdu, uint256 peg, uint256 riskProDiscountPrice\n  ) internal view returns(uint256) {\n\n    // uTPDU * nStableToken * PEG\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 coverageUSDAmount = utpdu.mul(nStableToken).mul(peg).div(libConfig.mocPrecision);\n\n    // This case only occurs with Coverage below 1\n    if (coverageUSDAmount <= nbUsdValue) {\n      return 0;\n    }\n\n    // ([MOC] - [MOC]) * [RES] / [MOC] = [RES]\n    return coverageUSDAmount.sub(nbUsdValue).mul(libConfig.reservePrecision).div(riskProDiscountPrice);\n  }\n\n  /**\n    @dev Calculates Locked ReserveTokens\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @param nStableToken StableTokens amount [using mocPrecision]\n    @param peg peg value\n    @return Locked ReserveTokens [using reservePrecision]\n  */\n  function lockedReserveTokens(MocLibConfig storage libConfig, uint256 reservePrice, uint256 nStableToken, uint256 peg)\n    public view returns (uint256)\n  {\n    return nStableToken.mul(peg).mul(libConfig.reservePrecision).div(reservePrice);\n  }\n\n  /**\n    @dev Calculates price at liquidation event as a relation between the stableToken total supply\n    and the amount of ReserveTokens available to distribute\n    @param resTokenAmount ReserveTokens to distribute [using reservePrecision]\n    @param nStableToken StableTokens amount [using mocPrecision]\n    @return Price at liquidation event [using mocPrecision]\n  */\n  function liquidationPrice(MocLibConfig storage libConfig, uint256 resTokenAmount, uint256 nStableToken)\n  public view returns(uint256) {\n    // [MOC] * [RES] / [RES]\n    return nStableToken.mul(libConfig.reservePrecision).div(resTokenAmount);\n  }\n\n  /**\n    @dev Calculates RiskPro ReserveTokens: (nReserve-LB) / nTP\n    @param nReserve Total ReserveTokens amount [using reservePrecision]\n    @param lb Locked ReserveTokens amount [using reservePrecision]\n    @param nTP RiskPro amount [using mocPrecision]\n    @return RiskPro ReserveTokens price [using reservePrecision]\n  */\n  function riskProTecPrice(MocLibConfig storage libConfig, uint256 nReserve, uint256 lb, uint256 nTP)\n  public view returns (uint256) {\n    // Liquidation happens before this condition turns true\n    if (nReserve < lb) {\n      return 0;\n    }\n\n    if (nTP == 0) {\n      return libConfig.mocPrecision;\n    }\n    // ([RES] - [RES]) * [MOC] / [MOC]\n    return nReserve.sub(lb).mul(libConfig.mocPrecision).div(nTP);\n  }\n\n  /**\n    @dev Calculates RiskPro ReserveToken price: RiskProxInRiskPro = riskProxTecPrice / riskProPrice\n    @param riskProxTecPrice RiskProx ReserveTokens price [using reservePrecision]\n    @param riskProPrice Trog ReserveTokens price [using reservePrecision]\n    @return RiskProx price in RiskPro [using mocPrecision]\n  */\n  function riskProxRiskProPrice(\n    MocLibConfig storage libConfig, uint256 riskProxTecPrice, uint256 riskProPrice\n  ) public view returns (uint256) {\n    // [RES] * [MOC] / [RES] = [MOC]\n    return riskProxTecPrice.mul(libConfig.mocPrecision).div(riskProPrice);\n  }\n\n  /**\n    @dev Returns a new value with the discountRate applied: (price)* (1 - discountRate)\n    @param price Price [using SomePrecision]\n    @param discountRate Discount rate to apply [using mocPrecision]\n    @return Price with discount applied [using SomePrecision]\n  */\n  function applyDiscountRate(MocLibConfig storage libConfig, uint256 price, uint256 discountRate)\n    public view returns(uint256) {\n\n    uint256 discountCoeff = libConfig.mocPrecision.sub(discountRate);\n\n    return price.mul(discountCoeff).div(libConfig.mocPrecision);\n  }\n\n  /**\n    @dev Returns the amount of interest to pay: = price * interestRate\n    @param value Cost to apply interest [using SomePrecision]\n    @param interestRate Interest rate to apply [using mocPrecision]\n    @return Interest cost based on the value and interestRate [using SomePrecision]\n  */\n  function getInterestCost(MocLibConfig storage libConfig, uint256 value, uint256 interestRate)\n    public view returns(uint256) {\n    // [ORIGIN] * [MOC] / [MOC] = [ORIGIN]\n    return value.mul(interestRate).div(libConfig.mocPrecision);\n  }\n\n  /**\n    @dev Calculates Coverage: nReserve / LB\n    @param nReserve Total ReserveTokens amount [using reservePrecision]\n    @param lB Locked ReserveTokens amount [using reservePrecision]\n    @return Coverage [using mocPrecision]\n  */\n  function coverage(MocLibConfig storage libConfig, uint256 nReserve, uint256 lB) public view\n    returns(uint256) {\n    if (lB == 0) {\n      return UINT256_MAX;\n    }\n\n    return nReserve.mul(libConfig.mocPrecision).div(lB);\n  }\n\n /**\n    @dev Calculates Leverage from Coverage: Leverage = C / (C - 1)\n    @param cov Coverage [using mocPrecision]\n    @return Leverage [using mocPrecision]\n  */\n  function leverageFromCoverage(MocLibConfig storage libConfig, uint256 cov)\n  public view returns(uint256) {\n    if (cov == UINT256_MAX) {\n      return libConfig.mocPrecision;\n    }\n\n    if (cov <= libConfig.mocPrecision) {\n      return UINT256_MAX;\n    }\n\n    return cov.mul(libConfig.mocPrecision).div(cov.sub(libConfig.mocPrecision));\n  }\n\n /**\n    @dev Calculates Leverage: Leverage = nReserve / (nReserve - lB)\n    @param nReserve Total ReserveTokens amount [using reservePrecision]\n    @param lB Locked ReserveTokens amount [using reservePrecision]\n    @return Leverage [using mocPrecision]\n  */\n  function leverage(MocLibConfig storage libConfig, uint256 nReserve,uint256 lB)\n  public view returns(uint256) {\n    if (lB == 0) {\n      return libConfig.mocPrecision;\n    }\n\n    if (nReserve <= lB) {\n      return UINT256_MAX;\n    }\n\n    return nReserve.mul(libConfig.mocPrecision).div(nReserve.sub(lB));\n  }\n\n  /**\n    @dev Price in ReserveTokens of the amount of StableTokens\n    @param amount Total ReserveTokens amount [using reservePrecision]\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @return Total value [using reservePrecision]\n  */\n  function stableTokensResTokensValue(\n    MocLibConfig storage libConfig, uint256 amount, uint256 peg, uint256 reservePrice\n  ) public view returns (uint256) {\n    require(reservePrice > 0, \"Price should be more than zero\");\n    require(libConfig.reservePrecision > 0, \"Precision should be more than zero\");\n    //Total = amount / satoshi price\n    //Total = amount / (reservePrice / precision)\n    // [RES] * [MOC] / [MOC]\n    uint256 stableTokenResTokenTotal = amount.mul(libConfig.mocPrecision).mul(peg).div(reservePrice);\n\n    return stableTokenResTokenTotal;\n  }\n\n  /**\n    @dev Price in ReserveTokens of the amount of RiskPros\n    @param riskProAmount amount of RiskPro [using mocPrecision]\n    @param riskProResTokenPrice RiskPro price in ReserveTokens [using reservePrecision]\n    @return Total value [using reservePrecision]\n  */\n  function riskProResTokensValuet(MocLibConfig storage libConfig, uint256 riskProAmount, uint256 riskProResTokenPrice)\n    public view returns (uint256) {\n    require(libConfig.reservePrecision > 0, \"Precision should be more than zero\");\n\n    // [MOC] * [RES] / [MOC] =  [RES]\n    uint256 riskProResTokenTotal = riskProAmount.mul(riskProResTokenPrice).div(libConfig.mocPrecision);\n\n    return riskProResTokenTotal;\n  }\n\n  /**\n    @dev Max amount of Docs to issue: MaxStableToken = ((nReserve*B)-(Cobj*B/Bcons*nStableToken*PEG))/(PEG*(Cobj*B/BCons-1))\n    @param nReserve Total ReserveTokens amount [using reservePrecision]\n    @param cobj Target Coverage [using mocPrecision]\n    @param nStableToken StableToken amount [using mocPrecision]\n    @param peg peg value\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @param bCons ReserveTokens conservative price [using mocPrecision]\n    @return Total StableTokens amount [using mocPrecision]\n  */\n  function maxStableToken(\n    MocLibConfig storage libConfig, uint256 nReserve,\n    uint256 cobj, uint256 nStableToken, uint256 peg, uint256 reservePrice, uint256 bCons\n  ) public view returns(uint256) {\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\n\n    // If cobj is less than 1, just return zero\n    if (cobj < libConfig.mocPrecision)\n      return 0;\n\n    // Cobj * B / BCons\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 adjCobj = cobj.mul(reservePrice).div(bCons);\n\n    return maxStableTokenAux(libConfig, nReserve, adjCobj, nStableToken, peg, reservePrice);\n  }\n\n  function maxStableTokenAux(\n    MocLibConfig storage libConfig, uint256 nReserve, uint256 adjCobj, uint256 nStableToken, uint256 peg, uint256 reservePrice\n  ) internal view returns(uint256) {\n    // (nReserve*B)\n    // [RES] [MOC] [MOC] / [RES] = [MOC] [MOC]\n    uint256 firstOperand = nReserve.mul(reservePrice).mul(libConfig.mocPrecision).div(libConfig.reservePrecision);\n    // (adjCobj*nStableToken*PEG)\n    // [MOC] [MOC]\n    uint256 secOperand = adjCobj.mul(nStableToken).mul(peg);\n    // (PEG*(adjCobj-1)\n    // [MOC]\n    uint256 denom = adjCobj.sub(libConfig.mocPrecision).mul(peg);\n\n    if (firstOperand <= secOperand)\n      return 0;\n\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\n    return (firstOperand.sub(secOperand)).div(denom);\n  }\n\n  /**\n    @dev Max amount of RiskPro to redeem: MaxRiskPro = ((nReserve*B)-(Cobj*nStableToken*PEG))/TPusd\n    @param nReserve Total ReserveTokens amount [using reservePrecision]\n    @param cobj Target Coverage [using mocPrecision]\n    @param nStableToken Target Coverage [using mocPrecision]\n    @param peg peg value\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @param bCons ReserveTokens conservative price [using mocPrecision]\n    @param riskProUsdPrice riskProUsdPrice [using mocPrecision]\n    @return Total RiskPro amount [using mocPrecision]\n  */\n  function maxRiskPro(\n    MocLibConfig storage libConfig, uint256 nReserve, uint256 cobj,\n    uint256 nStableToken, uint256 peg, uint256 reservePrice, uint256 bCons, uint256 riskProUsdPrice\n  ) public view returns(uint256) {\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\n\n    // Cobj * reservePrice / BCons\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 adjCobj = cobj.mul(reservePrice).div(bCons);\n    // (nReserve * reservePrice)\n    // [RES] * [MOC] * [MOC] / [RES] = [MOC] [MOC]\n    uint256 firstOperand = nReserve.mul(reservePrice)\n      .mul(libConfig.mocPrecision)\n      .div(libConfig.reservePrecision);\n    // (adjCobj * nStableToken * PEG)\n    // [MOC] * [MOC]\n    uint256 secOperand = adjCobj.mul(nStableToken).mul(peg);\n\n    if (firstOperand <= secOperand)\n      return 0;\n\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\n    return (firstOperand.sub(secOperand)).div(riskProUsdPrice);\n  }\n\n  /**\n    @dev Calculates the total ReserveTokens price of the amount of RiskPros\n    @param amount Amount of RiskPro [using mocPrecision]\n    @param riskProPrice RiskPro ReserveTokens Price [using reservePrecision]\n    @return RiskPro total value in ReserveTokens [using reservePrecision]\n  */\n  function totalRiskProInResTokens(\n    MocLibConfig storage libConfig, uint256 amount, uint256 riskProPrice\n  ) public view returns(uint256) {\n    // [RES] * [MOC] / [MOC] = [RES]\n    return riskProPrice.mul(amount).div(libConfig.mocPrecision);\n  }\n\n  /**\n    @dev Calculates the equivalent in StableTokens of the resTokensAmount\n    @param resTokensAmount ReserveTokens  amount [using reservePrecision]\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @return Equivalent StableToken amount [using mocPrecision]\n  */\n  function maxStableTokensWithResTokens(\n    MocLibConfig storage libConfig, uint256 resTokensAmount, uint256 reservePrice\n  ) public view returns(uint256) {\n    // [RES] * [MOC] / [RES] = [MOC]\n    return resTokensAmount.mul(reservePrice).div(libConfig.reservePrecision);\n  }\n\n  /**\n    @dev Calculates the equivalent in RiskPro of the resTokensAmount\n    @param resTokensAmount ReserveTokens amount [using reservePrecision]\n    @param riskProPrice RiskPro ReserveTokens price [using reservePrecision]\n    @return Equivalent RiskPro amount [using mocPrecision]\n  */\n  function maxRiskProWithResTokens(\n    MocLibConfig storage libConfig, uint256 resTokensAmount, uint256 riskProPrice\n  ) public view returns(uint256) {\n    if (riskProPrice == 0) {\n      return 0;\n    }\n\n    // [RES] * [MOC] / [RES]\n    return resTokensAmount.mul(libConfig.mocPrecision).div(riskProPrice);\n  }\n\n  /**\n    @dev Calculates the ResToken amount to move from C0 bucket to\n    an L bucket when a RiskProx minting occurs: toMove = resTokensAmount * (lev - 1)\n    @param resTokensAmount Total ReserveTokens amount [using reservePrecision]\n    @param lev L bucket leverage [using mocPrecision]\n    @return resTokens to move [using reservePrecision]\n  */\n  function bucketTransferAmount(\n    MocLibConfig storage libConfig, uint256 resTokensAmount, uint256 lev\n  ) public view returns(uint256) {\n    require(lev > libConfig.mocPrecision, \"Leverage should be more than 1\");\n\n    if (lev == UINT256_MAX || resTokensAmount == 0) {\n      return 0;\n    }\n\n    // (lev-1)\n    uint256 levSubOne = lev.sub(libConfig.mocPrecision);\n\n    // Intentionally avaoid SafeMath\n    // [RES] * [MOC]\n    uint256 transferAmount = resTokensAmount * levSubOne;\n    if (transferAmount / resTokensAmount != levSubOne)\n      return 0;\n\n    // [RES] * [MOC] / [MOC] = [RES]\n    return transferAmount.div(libConfig.mocPrecision);\n  }\n\n   /**\n    @dev Max amount of ReserveTokens allowed to be used to mint riskProx: MaxriskProx = nStableToken/ (PEG*B*(lev-1))\n    @param nStableToken number of StableToken [using mocPrecision]\n    @param peg peg value\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @param lev leverage [using mocPrecision]\n    @return Max riskProx ReserveTokens value [using reservePrecision]\n  */\n  function maxRiskProxResTokenValue(\n    MocLibConfig storage libConfig, uint256 nStableToken, uint256 peg, uint256 reservePrice, uint256 lev\n  ) public view returns(uint256)  {\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\n\n    if (lev <= libConfig.mocPrecision) {\n      return 0;\n    }\n    // (lev-1)\n    // [MOC]\n    uint256 levSubOne = lev.sub(libConfig.mocPrecision);\n\n    // PEG * ResTokenPrice\n    // [MOC]\n    uint256 pegTimesPrice = peg.mul(reservePrice);\n\n    // This intentionally avoid using safeMath to handle overflow case\n    // PEG * ResTokenPrice * (lev - 1)\n    // [MOC] * [MOC]\n    uint256 dividend = pegTimesPrice * levSubOne;\n\n    if (dividend / pegTimesPrice != levSubOne)\n      return 0; // INFINIT dividend means 0\n\n    // nStableToken adjusted with precisions\n    // [MOC] [RES]\n    uint256 divider = nStableToken.mul(libConfig.reservePrecision);\n\n    // [MOC] [RES] [MOC] / [MOC] [MOC]\n    return divider.mul(libConfig.mocPrecision).div(dividend);\n  }\n\n  /**\n    @dev Calculates the equivalent in MoC of the reserve token\n    @param resTokensAmount Total ReserveTokens amount\n    @param reservePrice ReserveTokens price\n    @param mocPrice MoC price\n    @return Equivalent MoC amount\n  */\n  function maxMoCWithReserveToken(\n    MocLibConfig storage /*libConfig*/, uint256 resTokensAmount, uint256 reservePrice, uint256 mocPrice\n  ) public pure returns(uint256) {\n    return reservePrice.mul(resTokensAmount).div(mocPrice);\n  }\n\n  /**\n    @dev Calculates the equivalent in reserve token of the MoC amount\n    @param amount MoC amount\n    @param reservePrice ReserveTokens price\n    @param mocPrice MoC price\n    @return Equivalent ReserveToken amount\n  */\n  function mocReserveTokenValue(\n    MocLibConfig storage /*libConfig*/, uint256 amount, uint256 reservePrice, uint256 mocPrice\n  ) public pure returns(uint256) {\n    require(reservePrice > 0,\"ReserveToken price should be more than zero\");\n    require(mocPrice > 0,\"MoC price should be more than zero\");\n\n    uint256 mocReserveTokenTotal = amount.mul(mocPrice).div(reservePrice);\n\n    return mocReserveTokenTotal;\n  }\n\n  /**\n    @dev Rounding product adapted from DSMath but with custom precision\n    @param x Multiplicand\n    @param y Multiplier\n    @return Product\n  */\n  function mulr(uint x, uint y, uint256 precision) internal pure returns (uint z) {\n    return x.mul(y).add(precision.div(2)).div(precision);\n  }\n\n  /**\n    @dev Potentiation by squaring adapted from DSMath but with custom precision\n    @param x Base\n    @param n Exponent\n    @return power\n  */\n  function pow(uint256 x, uint256 n, uint256 precision) internal pure returns (uint z) {\n    uint256 x2 = x;\n    z = n % 2 != 0 ? x : precision;\n\n    for (n /= 2; n != 0; n /= 2) {\n      x2 = mulr(x2, x2, precision);\n\n      if (n % 2 != 0) {\n        z = mulr(z, x2, precision);\n      }\n    }\n  }\n}\n\n// File: contracts/MoCLibConnection.sol\n\npragma solidity 0.5.8;\n\n\n/**\n  @dev Interface with MocHelperLib\n */\ncontract MoCLibConnection {\n  using MoCHelperLib for MoCHelperLib.MocLibConfig;\n  MoCHelperLib.MocLibConfig internal mocLibConfig;\n\n  /*\n  * Precision getters\n  */\n  function getMocPrecision() public view returns(uint256) {\n    return mocLibConfig.mocPrecision;\n  }\n\n  function getReservePrecision() public view returns(uint256) {\n    return mocLibConfig.reservePrecision;\n  }\n\n  function getDayPrecision() public view returns(uint256) {\n    return mocLibConfig.dayPrecision;\n  }\n\n  function initializePrecisions() internal {\n    mocLibConfig = MoCHelperLib.MocLibConfig({\n      reservePrecision: 10 ** 18,\n      mocPrecision: 10 ** 18,\n      dayPrecision: 1\n    });\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/interface/IMoCState.sol\n\npragma solidity 0.5.8;\n\ninterface IMoCState {\n\n     /******STATE MACHINE*********/\n    enum States {\n        // State 0\n        Liquidated,\n        // State 1\n        RiskProDiscount,\n        // State 2\n        BelowCobj,\n        // State 3\n        AboveCobj\n    }\n\n\n    function addToReserves(uint256 reserveAmount) external;\n\n    function substractFromReserves(uint256 reserveAmount) external;\n\n    function coverage(bytes32 bucket) external view returns(uint256);\n\n    function getReservesRemainder() external view returns(uint256);\n\n    function liq() external view returns(uint256);\n\n    function state() external view returns(States);\n\n    function peg() external view returns(uint256);\n\n    function dayBlockSpan() external view returns(uint256);\n\n    function getReserveTokenPrice() external view returns(uint256);\n\n    function getMoCPrice() external view returns(uint256);\n\n    function getProtected() external view returns(uint256);\n\n    function globalCoverage() external view returns(uint256);\n\n    function getMoCVendors() external view returns(address);\n\n    function getMoCToken() external view returns(address);\n\n    function nextState() external;\n\n    function maxRiskProWithDiscount() external view returns(uint256);\n\n    function absoluteMaxRiskPro() external view returns(uint256);\n\n    function absoluteMaxStableToken() external view returns(uint256);\n\n    function freeStableToken() external view returns(uint256);\n\n    function riskProTecPrice() external view returns(uint256);\n\n    function riskProSpotDiscountRate() external view returns(uint256);\n\n    function riskProDiscountPrice() external view returns(uint256);\n\n    function bucketRiskProTecPrice(bytes32 bucket) external view returns(uint256);\n\n    function currentAbundanceRatio() external view returns(uint256);\n\n    function abundanceRatio(uint256 stableToken0) external view returns(uint256);\n\n    function daysToSettlement() external view returns(uint256);\n\n    function leverage(bytes32 bucket) external view returns(uint256);\n\n    function getBucketNReserve(bytes32 bucket) external view returns(uint256);\n\n    function getLiquidationPrice() external view returns(uint256);\n\n    function maxRiskProxResTokenValue(bytes32 bucket) external view returns(uint256);\n\n    function bucketRiskProTecPriceHelper(bytes32 bucket) external view returns(uint256);\n}\n\n// File: contracts/base/MoCWhitelist.sol\n\npragma solidity 0.5.8;\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCWhitelist {\n  mapping(address => bool) whitelist;\n\n  /**\n   * @dev Check if an account is whitelisted\n   * @return Bool\n   */\n  function isWhitelisted(address account)\n    public\n    view\n    returns (bool)\n  {\n    require(account != address(0), \"Account must not be 0x0\");\n    return whitelist[account];\n  }\n\n  /**\n   * @dev Add account to whitelist\n   */\n  function add(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(!isWhitelisted(account), \"Account not allowed to add accounts into white list\");\n    whitelist[account] = true;\n  }\n\n  /**\n   * @dev Remove account from whitelist\n   */\n  function remove(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(isWhitelisted(account), \"Account is not allowed to remove address from the white list\");\n\n    whitelist[account] = false;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/base/MoCConnector.sol\n\npragma solidity 0.5.8;\n\n\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCConnector is MoCWhitelist, Initializable {\n  // References\n  address payable public moc;\n  address public stableToken;\n  address public riskProToken;\n  address public riskProxManager;\n  address public mocState;\n  address public mocConverter;\n  address public mocSettlement;\n  address public mocExchange;\n  address public mocInrate;\n  /** DEPRECATED mocBurnout **/\n  address public mocBurnout;\n  address public reserveToken;\n\n  bool internal initialized;\n\n  /**\n    @dev Initializes the contract\n    @param mocAddress MoC contract address\n    @param stableTokenAddress Stable token contract address\n    @param riskProAddress RiskPro token contract address\n    @param riskProxAddress RiskProxManager contract address\n    @param stateAddress MoCState contract address\n    @param settlementAddress MoCSettlement contract address\n    @param converterAddress MoCConverter contract address\n    @param exchangeAddress MoCExchange contract address\n    @param inrateAddress MoCInrate contract address\n    @param burnoutBookAddress (DEPRECATED) MoCBurnout contract address. DO NOT USE.\n    @param reserveTokenAddress Reserve token contract address\n  */\n  function initialize(\n    address payable mocAddress,\n    address stableTokenAddress,\n    address riskProAddress,\n    address riskProxAddress,\n    address stateAddress,\n    address settlementAddress,\n    address converterAddress,\n    address exchangeAddress,\n    address inrateAddress,\n    address burnoutBookAddress,\n    address reserveTokenAddress\n  ) public initializer {\n    moc = mocAddress;\n    stableToken = stableTokenAddress;\n    riskProToken = riskProAddress;\n    riskProxManager = riskProxAddress;\n    mocState = stateAddress;\n    mocSettlement = settlementAddress;\n    mocConverter = converterAddress;\n    mocExchange = exchangeAddress;\n    mocInrate = inrateAddress;\n    mocBurnout = burnoutBookAddress;\n    reserveToken = reserveTokenAddress;\n\n    // Add to Whitelist\n    add(mocAddress);\n    add(stableTokenAddress);\n    add(riskProAddress);\n    add(riskProxAddress);\n    add(stateAddress);\n    add(settlementAddress);\n    add(converterAddress);\n    add(exchangeAddress);\n    add(inrateAddress);\n    add(burnoutBookAddress);\n    add(reserveTokenAddress);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/base/MoCConstants.sol\n\npragma solidity 0.5.8;\n\n/**\n * @dev Defines special constants to use along all the MoC System\n */\ncontract MoCConstants {\n  bytes32 constant public BUCKET_X2 = \"X2\";\n  bytes32 constant public BUCKET_C0 = \"C0\";\n}\n\n// File: contracts/base/MoCBase.sol\n\npragma solidity 0.5.8;\n\n\n\n\n/**\n  @dev General usefull modifiers and functions\n */\ncontract MoCBase is MoCConstants, Initializable {\n  // Contracts\n  MoCConnector public connector;\n\n  bool internal initialized;\n\n  function initializeBase(address connectorAddress) internal initializer {\n    connector = MoCConnector(connectorAddress);\n  }\n\n  modifier onlyWhitelisted(address account) {\n    require(connector.isWhitelisted(account), \"Address is not whitelisted\");\n    _;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: openzeppelin-solidity/contracts/math/Math.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n\n// File: contracts/MoCBucketContainer.sol\n\npragma solidity 0.5.8;\n\n\n\n\n\n\ncontract MoCBucketContainer is MoCBase, Governed {\n  using SafeMath for uint256;\n  using Math for uint256;\n\n  struct RiskProxBalance {\n    uint256 value;\n    uint256 index; // Index start in 1, zero is reserved for NULL\n  }\n\n  struct MoCBucket {\n    bytes32 name;\n    bool isBase;\n    uint256 nStable;\n    uint256 nRiskPro;\n    uint256 nReserve;\n    uint256 cobj;\n    // Should only be used in X buckets\n    mapping(address => RiskProxBalance) riskProxBalances;\n    address payable[] activeBalances;\n    uint256 activeBalancesLength;\n    // Should only be used in Base buckets (C0)\n    uint256 inrateBag;\n    bool available;\n  }\n\n  event BucketMovement(\n    bytes32 from,\n    bytes32 to,\n    uint256 reserves,\n    uint256 stableTokens\n  );\n\n  event BucketCreation(\n    bytes32 name,\n    uint256 cobj\n  );\n\n  event BucketStateUpdate(\n    bytes32 name,\n    uint256 nReserve,\n    uint256 nStable,\n    uint256 nRiskProx,\n    uint256 inrateBag\n  );\n\n  mapping(bytes32 => MoCBucket) internal mocBuckets;\n\n  /**\n   GETTERS\n   */\n  function getBucketNReserve(bytes32 bucket) public view returns (uint256) {\n    return mocBuckets[bucket].nReserve;\n  }\n\n  function getBucketNRiskPro(bytes32 bucket) public view returns (uint256) {\n    return mocBuckets[bucket].nRiskPro;\n  }\n\n  function getBucketNStableToken(bytes32 bucket) public view returns (uint256) {\n    return mocBuckets[bucket].nStable;\n  }\n\n  function getBucketCobj(bytes32 bucket) public view returns (uint256) {\n    return mocBuckets[bucket].cobj;\n  }\n\n  function getInrateBag(bytes32 bucket) public view returns (uint256) {\n    return mocBuckets[bucket].inrateBag;\n  }\n\n  /**\n   * @dev Sets the objective coverage (cobj) on an specficied bucket.\n   * @param  _bucket - name of the bucket\n   * @param  _cobj - new value of cobj\n   */\n  function setBucketCobj(bytes32 _bucket, uint256 _cobj) public onlyAuthorizedChanger() {\n    //TODO: It is necessary to analyze the impact in the model it has when changing X2. This\n    mocBuckets[_bucket].cobj = _cobj;\n  }\n\n  /**\n    @dev returns true if the bucket is a base bucket\n    @param bucket Name of the bucket\n  **/\n  function isBucketBase(bytes32 bucket) public view returns (bool) {\n    return mocBuckets[bucket].isBase;\n  }\n\n  /**\n    @dev returns true if the bucket have stableTokens in it\n    @param bucket Name of the bucket\n  **/\n  function isBucketEmpty(bytes32 bucket) public view returns (bool) {\n    return mocBuckets[bucket].nStable == 0;\n  }\n\n  /**\n    @dev Returns all the address that currently have riskProx position for this bucket\n    @param bucket bucket of the active address\n  */\n  function getActiveAddresses(bytes32 bucket) public view returns (address payable[] memory) {\n    return mocBuckets[bucket].activeBalances;\n  }\n\n  /**\n    @dev Returns all the address that currently have riskProx position for this bucket\n    @param bucket bucket of the active address\n  */\n  function getActiveAddressesCount(bytes32 bucket) public view returns (uint256 count) {\n    return mocBuckets[bucket].activeBalancesLength;\n  }\n\n  /**\n    @dev Add values to all variables of the bucket\n    @param bucketName Name of the bucket\n    @param reserveTokens ReserveToken amount [using reservePrecision]\n    @param stableToken StableToken amount [using mocPrecision]\n    @param riskProx RiskProx amount [using mocPrecision]\n  */\n  function addValuesToBucket(bytes32 bucketName, uint256 reserveTokens, uint256 stableToken, uint256 riskProx)\n  public onlyWhitelisted(msg.sender) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    bucket.nReserve = bucket.nReserve.add(reserveTokens);\n    bucket.nStable = bucket.nStable.add(stableToken);\n    bucket.nRiskPro = bucket.nRiskPro.add(riskProx);\n  }\n\n  /**\n    @dev Substract values to all variables of the bucket\n    @param bucketName Name of the bucket\n    @param reserve ReserveToken amount [using reservePrecision]\n    @param stableToken StableToken amount [using mocPrecision]\n    @param riskProx RiskProx amount [using mocPrecision]\n  */\n  function substractValuesFromBucket(bytes32 bucketName, uint256 reserve, uint256 stableToken, uint256 riskProx)\n  public onlyWhitelisted(msg.sender) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    bucket.nReserve = bucket.nReserve.sub(reserve);\n    bucket.nStable = bucket.nStable.sub(stableToken);\n    bucket.nRiskPro = bucket.nRiskPro.sub(riskProx);\n  }\n\n  /**\n    @dev Moves ReserveTokens from inrateBag to main ReserveTokens bucket bag\n    @param bucketName Name of the bucket to operate\n    @param amount value to move from inrateBag to main bag [using reservePrecision]\n   */\n  function deliverInrate(bytes32 bucketName, uint256 amount) public\n   onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) bucketStateUpdate(bucketName) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    uint256 toMove = Math.min(bucket.inrateBag, amount);\n\n    bucket.inrateBag = bucket.inrateBag.sub(toMove);\n    bucket.nReserve = bucket.nReserve.add(toMove);\n  }\n\n  /**\n    @dev Removes Interests rate from Inrate bag\n    @param bucketName Name of the bucket to operate\n    @param amount value to move from inrateBag to main bag [using reservePrecision]\n    @return Retrieved value\n   */\n  function recoverInrate(bytes32 bucketName, uint256 amount) public\n  onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) bucketStateUpdate(bucketName) returns(uint256) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    uint256 toRetrieve = Math.min(bucket.inrateBag, amount);\n\n    bucket.inrateBag = bucket.inrateBag.sub(toRetrieve);\n\n    return toRetrieve;\n  }\n\n  /**\n    @dev Moves ReserveTokens from origin bucket to destination bucket inrateBag\n    @param bucketName name of the bucket to from which takes\n    @param reserveAmount value to add to main bag [using reservePrecision]\n  */\n  function payInrate(bytes32 bucketName, uint256 reserveAmount) public\n  onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n    bucket.inrateBag = bucket.inrateBag.add(reserveAmount);\n  }\n\n  /**\n    @dev Move ReserveTokens and StableTokens from one bucket to another\n    @param from Name of bucket from where the ReserveTokens will be removed\n    @param to Name of bucket from where the ReserveTokens will be added\n    @param reserve ReserveTokens amount [using reservePrecision]\n    @param stableTokens StableTokens amount [using mocPrecision]\n  **/\n  function moveResTokensAndStableTokens(bytes32 from, bytes32 to, uint256 reserve, uint256 stableTokens) public\n  onlyWhitelisted(msg.sender) bucketStateUpdate(from) bucketStateUpdate(to) {\n    MoCBucket storage bucketFrom = mocBuckets[from];\n    MoCBucket storage bucketTo = mocBuckets[to];\n\n    bucketFrom.nReserve = bucketFrom.nReserve.sub(reserve);\n    bucketTo.nReserve = bucketTo.nReserve.add(reserve);\n\n    bucketFrom.nStable = bucketFrom.nStable.sub(stableTokens);\n    bucketTo.nStable = bucketTo.nStable.add(stableTokens);\n\n    emit BucketMovement(from, to, reserve, stableTokens);\n  }\n\n  /**\n    @dev Clears completely the origin bucket, removing all StableTokens, ReserveTokens and riskProxs\n    @param toLiquidate Bucket to be cleared out\n    @param destination Bucket that will receive the StableTokens and ReserveTokens\n   */\n  function liquidateBucket(bytes32 toLiquidate, bytes32 destination) public onlyWhitelisted(msg.sender) {\n    require(!isBucketBase(toLiquidate), \"Cannot liquidate a base bucket\");\n\n    clearBucketBalances(toLiquidate);\n    emptyBucket(toLiquidate, destination);\n  }\n\n  /**\n    @dev Clears StableTokens and ReserveTokens from bucket origin and sends them to destination bucket\n    @param origin Bucket to clear out\n    @param destination Destination bucket\n  **/\n  function emptyBucket(bytes32 origin, bytes32 destination) public onlyWhitelisted(msg.sender) {\n    moveResTokensAndStableTokens(origin, destination, mocBuckets[origin].nReserve, mocBuckets[origin].nStable);\n  }\n\n  /**\n   * @dev checks if a bucket exists\n   * @param bucket name of the bucket\n   */\n  function isAvailableBucket(bytes32 bucket) public view returns (bool) {\n    return mocBuckets[bucket].available;\n  }\n\n  /**\n    @dev Put all bucket RiskProx balances in zero\n    @param bucketName Bucket to clear out\n   */\n  function clearBucketBalances(bytes32 bucketName) public onlyWhitelisted(msg.sender) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n    bucket.nRiskPro = 0;\n    bucket.activeBalancesLength = 0;\n  }\n\n  /**\n    @dev Creates bucket\n    @param name Name of the bucket\n    @param cobj Target Coverage of the bucket\n    @param isBase Indicates if it is a base bucket (true) or not (false)\n  */\n  function createBucket(bytes32 name, uint256 cobj, bool isBase) internal {\n    mocBuckets[name].name = name;\n    mocBuckets[name].nStable = 0;\n    mocBuckets[name].nRiskPro = 0;\n    mocBuckets[name].nReserve = 0;\n    mocBuckets[name].cobj = cobj;\n    mocBuckets[name].isBase = isBase;\n    mocBuckets[name].available = true;\n    emit BucketCreation(name, cobj);\n  }\n\n  modifier onlyBaseBucket(bytes32 bucket) {\n    require(isBucketBase(bucket), \"Bucket should be a base type bucket\");\n    _;\n  }\n\n  modifier bucketStateUpdate(bytes32 bucket) {\n    _;\n    emit BucketStateUpdate(\n      bucket,\n      mocBuckets[bucket].nReserve,\n      mocBuckets[bucket].nStable,\n      mocBuckets[bucket].nRiskPro,\n      mocBuckets[bucket].inrateBag\n    );\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/MoCRiskProxManager.sol\n\npragma solidity 0.5.8;\n\n\n\n\n\ncontract MoCRiskProxManager is MoCBucketContainer {\n  using SafeMath for uint256;\n  uint256 constant MIN_ALLOWED_BALANCE = 0;\n\n  function initialize(address connectorAddress, address _governor, uint256 _c0Cobj, uint256 _x2Cobj) public initializer {\n    initializeBase(connectorAddress);\n    initializeValues(_governor);\n    createBucket(BUCKET_C0, _c0Cobj, true);\n    createBucket(BUCKET_X2, _x2Cobj, false);\n  }\n\n  /**\n    @dev returns user balance\n    @param bucket RiskProx corresponding bucket to get balance from\n    @param userAddress user address to get balance from\n    @return total balance for the userAddress\n  */\n  function riskProxBalanceOf(bytes32 bucket, address userAddress) public view returns (uint256) {\n    RiskProxBalance memory userBalance = mocBuckets[bucket].riskProxBalances[userAddress];\n    if (!hasValidBalance(bucket, userAddress, userBalance.index)) return 0;\n    return userBalance.value;\n  }\n\n  /**\n    @dev verifies that this user has assigned balance for the given bucket\n    @param bucket corresponding Leveraged bucket to get balance from\n    @param userAddress user address to verify balance for\n    @param index index, starting from 1, where the address of the user is being kept\n    @return true if the user has assigned balance\n  */\n  function hasValidBalance(bytes32 bucket, address userAddress, uint256 index) public view returns (bool) {\n    return (index != 0) && (index <= getActiveAddressesCount(bucket)) && (mocBuckets[bucket].activeBalances[index - 1] == userAddress);\n  }\n\n  /**\n    @dev  Assigns the amount of RiskProx\n    @param bucket bucket from which the RiskProx will be removed\n    @param account user address to redeem for\n    @param riskProxAmount riskProx amount to redeem [using mocPresicion]\n    @param totalCost ReserveToken value of riskProxAmount [using reservePrecision]\n  */\n  function assignRiskProx(bytes32 bucket, address payable account, uint256 riskProxAmount, uint256 totalCost)\n    public\n    onlyWhitelisted(msg.sender)\n  {\n    uint256 currentBalance = riskProxBalanceOf(bucket, account);\n\n    setRiskProxBalanceOf(bucket, account, currentBalance.add(riskProxAmount));\n    addValuesToBucket(bucket, totalCost, 0, riskProxAmount);\n  }\n\n  /**\n    @dev  Removes the amount of RiskProx and substract ReserveTokens from bucket\n    @param bucket bucket from which the RiskProx will be removed\n    @param userAddress user address to redeem for\n    @param riskProxAmount riskProx amount to redeem [using mocPresicion]\n    @param totalCost reserveToken value of riskProxAmount [using reservePrecision]\n  */\n  function removeRiskProx(bytes32 bucket, address payable userAddress, uint256 riskProxAmount, uint256 totalCost)\n    public\n    onlyWhitelisted(msg.sender)\n  {\n    uint256 currentBalance = riskProxBalanceOf(bucket, userAddress);\n\n    setRiskProxBalanceOf(bucket, userAddress, currentBalance.sub(riskProxAmount));\n    substractValuesFromBucket(bucket, totalCost, 0, riskProxAmount);\n  }\n\n  /**\n    @dev Sets the amount of RiskProx\n    @param bucket bucket from which the RiskProx will be setted\n    @param userAddress user address to redeem for\n    @param value riskProx amount to redeem [using mocPresicion]\n  */\n  function setRiskProxBalanceOf(bytes32 bucket, address payable userAddress, uint256 value) public onlyWhitelisted(msg.sender) {\n    mocBuckets[bucket].riskProxBalances[userAddress].value = value;\n\n    uint256 index = mocBuckets[bucket].riskProxBalances[userAddress].index;\n    if (!hasValidBalance(bucket, userAddress, index)) index = 0;\n\n    bool hasBalance = value > MIN_ALLOWED_BALANCE;\n    // The address is not in the array\n    if (index == 0) {\n      if (hasBalance) {\n        if (mocBuckets[bucket].activeBalances.length == mocBuckets[bucket].activeBalancesLength) {\n          mocBuckets[bucket].activeBalances.length += 1;\n        }\n        uint256 currentIndex = mocBuckets[bucket].activeBalancesLength++;\n        mocBuckets[bucket].activeBalances[currentIndex] = userAddress;\n        mocBuckets[bucket].riskProxBalances[userAddress].index = mocBuckets[bucket].activeBalancesLength;\n      }\n    } else {\n      if (!hasBalance) {\n        // We need to delete this address from the tracker\n        uint256 lastActiveIndex = mocBuckets[bucket].activeBalancesLength;\n        address payable keyToMove = mocBuckets[bucket].activeBalances[lastActiveIndex - 1];\n        mocBuckets[bucket].activeBalances[index - 1] = keyToMove;\n        // Alternative index and array decreases lenght to prevent gas limit\n        mocBuckets[bucket].activeBalancesLength--;\n        // Update moved key index\n        mocBuckets[bucket].riskProxBalances[keyToMove].index = index;\n        // Disable empty account index (0 == NULL)\n        mocBuckets[bucket].riskProxBalances[userAddress].index = 0;\n      }\n    }\n  }\n\n  /**\n   * @dev intializes values of the contract\n   */\n  function initializeValues(address _governor) internal {\n    governor = IGovernor(_governor);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/MoCConverter.sol\n\npragma solidity 0.5.8;\n\n\n\n\ncontract MoCConverter is MoCBase, MoCLibConnection {\n  IMoCState internal mocState;\n\n  function initialize(address connectorAddress) public initializer {\n    initializePrecisions();\n    initializeBase(connectorAddress);\n    mocState = IMoCState(connector.mocState());\n  }\n\n  /**\n  * @dev ReserveTokens equivalent for the amount of riskPros given\n  * @param amount Amount of RiskPro to calculate the total price\n  * @return total ReserveTokens Price of the amount RiskPros [using reservePrecision].\n  */\n  function riskProToResToken(uint256 amount) public view returns (uint256) {\n    uint256 tecPrice = mocState.riskProTecPrice();\n\n    return mocLibConfig.totalRiskProInResTokens(amount, tecPrice);\n  }\n\n  /**\n  * @dev Converts Reserve to RiskPro\n  * @param resTokensAmount Reserve amount\n  * @return RiskPro amount\n  */\n  function resTokenToRiskPro(uint256 resTokensAmount) public view returns (uint256) {\n    return mocLibConfig.maxRiskProWithResTokens(resTokensAmount, mocState.riskProTecPrice());\n  }\n\n  /**\n  * @dev ReserveTokens equivalent for the amount of riskPro given applying the spotDiscountRate\n  * @param amount amount of RiskPro [using reservePrecision]\n  * @return Reserve amount\n  */\n  function riskProDiscToResToken(uint256 amount) public view returns(uint256) {\n    uint256 discountRate = mocState.riskProSpotDiscountRate();\n    uint256 totalResTokensValuet = riskProToResToken(amount);\n\n    return mocLibConfig.applyDiscountRate(totalResTokensValuet, discountRate);\n  }\n\n  function resTokenToRiskProDisc(uint256 resTokensAmount) public view returns (uint256) {\n    return mocLibConfig.maxRiskProWithResTokens(resTokensAmount, mocState.riskProDiscountPrice());\n  }\n\n  function stableTokensToResToken(uint256 stableTokenAmount) public view returns (uint256) {\n    return mocLibConfig.stableTokensResTokensValue(stableTokenAmount, mocState.peg(), mocState.getReserveTokenPrice());\n  }\n\n  function stableTokensToResTokenWithPrice(uint256 stableTokenAmount, uint256 reservePrice) public view returns (uint256) {\n    return mocLibConfig.stableTokensResTokensValue(stableTokenAmount, mocState.peg(), reservePrice);\n  }\n\n  function resTokenToStableToken(uint256 resTokensAmount) public view returns (uint256) {\n    return mocLibConfig.maxStableTokensWithResTokens(resTokensAmount, mocState.getReserveTokenPrice());\n  }\n\n  function riskProxToResToken(uint256 riskProxAmount, bytes32 bucket) public view returns (uint256) {\n    return mocLibConfig.riskProResTokensValuet(riskProxAmount, mocState.bucketRiskProTecPrice(bucket));\n  }\n\n  function riskProxToResTokenHelper(uint256 riskProxAmount, bytes32 bucket) public view returns(uint256) {\n    return mocLibConfig.riskProResTokensValuet(riskProxAmount, mocState.bucketRiskProTecPriceHelper(bucket));\n  }\n\n  function resTokenToRiskProx(uint256 resTokensAmount, bytes32 bucket) public view returns (uint256) {\n    return mocLibConfig.maxRiskProWithResTokens(resTokensAmount, mocState.bucketRiskProTecPrice(bucket));\n  }\n\n  function resTokenToRiskProWithPrice(uint256 resTokensAmount, uint256 price) public view returns (uint256) {\n    return mocLibConfig.maxRiskProWithResTokens(resTokensAmount, price);\n  }\n\n  function riskProToResTokenWithPrice(uint256 riskProAmount, uint256 riskProPrice) public view returns (uint256) {\n    return mocLibConfig.riskProResTokensValuet(riskProAmount, riskProPrice);\n  }\n\n  function mocToResToken(uint256 mocAmount) public view returns(uint256) {\n    return mocLibConfig.mocReserveTokenValue(mocAmount, mocState.getReserveTokenPrice(), mocState.getMoCPrice());\n  }\n\n  function resTokenToMoC(uint256 resTokensAmount) public view returns(uint256) {\n    return mocLibConfig.maxMoCWithReserveToken(resTokensAmount, mocState.getReserveTokenPrice(), mocState.getMoCPrice());\n  }\n\n  function mocToResTokenWithPrice(uint256 mocAmount, uint256 reservePrice, uint256 mocPrice) public view returns(uint256) {\n    return mocLibConfig.mocReserveTokenValue(mocAmount, reservePrice, mocPrice);\n  }\n\n  function resTokenToMoCWithPrice(uint256 resTokensAmount, uint256 reservePrice, uint256 mocPrice) public view returns(uint256) {\n    return mocLibConfig.maxMoCWithReserveToken(resTokensAmount, reservePrice, mocPrice);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/interface/IMoCVendors.sol\n\npragma solidity 0.5.8;\n\ninterface IMoCVendors {\n    function resetTotalPaidInMoC() external;\n\n    function getIsActive(address account) external view\n    returns (bool);\n\n    function getTotalPaidInMoC(address account) external view\n    returns (uint256);\n\n    function getStaking(address account) external view\n    returns (uint256);\n\n    function getMarkup(address account) external view\n    returns (uint256);\n\n    function updatePaidMarkup(address account, uint256 mocAmount, uint256 reserveAmount, uint256 totalMoCAmount) external;\n}\n\n// File: contracts/interface/IMoCInrate.sol\n\npragma solidity 0.5.8;\n\ninterface IMoCInrate {\n    // Transaction types\n    function MINT_RISKPRO_FEES_RESERVE() external view returns(uint8);\n    function REDEEM_RISKPRO_FEES_RESERVE() external view returns(uint8);\n    function MINT_STABLETOKEN_FEES_RESERVE() external view returns(uint8);\n    function REDEEM_STABLETOKEN_FEES_RESERVE() external view returns(uint8);\n    function MINT_RISKPROX_FEES_RESERVE() external view returns(uint8);\n    function REDEEM_RISKPROX_FEES_RESERVE() external view returns(uint8);\n    function MINT_RISKPRO_FEES_MOC() external view returns(uint8);\n    function REDEEM_RISKPRO_FEES_MOC() external view returns(uint8);\n    function MINT_STABLETOKEN_FEES_MOC() external view returns(uint8);\n    function REDEEM_STABLETOKEN_FEES_MOC() external view returns(uint8);\n    function MINT_RISKPROX_FEES_MOC() external view returns(uint8);\n    function REDEEM_RISKPROX_FEES_MOC() external view returns(uint8);\n\n    function dailyInratePayment() external returns(uint256);\n\n    function payRiskProHoldersInterestPayment() external returns(uint256);\n\n    function calculateRiskProHoldersInterest() external view returns(uint256, uint256);\n\n    function getRiskProInterestAddress() external view returns(address payable);\n\n    function getRiskProRate() external view returns(uint256);\n\n    function getRiskProInterestBlockSpan() external view returns(uint256);\n\n    function isDailyEnabled() external view returns(bool);\n\n    function isRiskProInterestEnabled() external view returns(bool);\n\n    function commissionsAddress() external view returns(address payable);\n\n    function calcCommissionValue(uint256 reserveAmount, uint8 txType) external view returns(uint256);\n\n    function calculateVendorMarkup(address vendorAccount, uint256 amount) external view returns (uint256 markup);\n\n    function calcStableTokenRedInterestValues(uint256 STABLETOKENAmount, uint256 reserveAmount) external view returns(uint256);\n\n    function calcMintInterestValues(bytes32 bucket, uint256 reserveAmount) external view returns(uint256);\n\n    function calcFinalRedeemInterestValue(bytes32 bucket, uint256 reserveToRedeem) external view returns(uint256);\n\n    function setRiskProInterestBlockSpan(uint256 newBitProBlockSpan) external;\n}\n\n// File: contracts/MoCInrate.sol\n\npragma solidity 0.5.8;\n\n\n\n\n\n\n\n\n\n\ncontract MoCInrateEvents {\n  event InrateDailyPay(uint256 amount, uint256 daysToSettlement, uint256 nReserveBucketC0);\n  event RiskProHoldersInterestPay(uint256 amount, uint256 nReserveBucketC0BeforePay);\n}\n\ncontract MoCInrateStructs {\n  struct InrateParams {\n    uint256 tMax;\n    uint256 tMin;\n    uint256 power;\n  }\n\n  InrateParams riskProxParams = InrateParams({\n    tMax: 261157876067800,\n    tMin: 0,\n    power: 1\n  });\n}\n\n\ncontract MoCInrate is MoCInrateEvents, MoCInrateStructs, MoCBase, MoCLibConnection, Governed, IMoCInrate {\n  using SafeMath for uint256;\n\n  // Last block when a payment was executed\n  uint256 public lastDailyPayBlock;\n  // Absolute  RiskPro holders rate for the given riskProInterestBlockSpan time span. [using mocPrecision]\n  uint256 public riskProRate;\n  // Target address to transfer RiskPro holders interests\n  address payable public riskProInterestAddress;\n  // Last block when an RiskPro holders instereste was calculated\n  uint256 public lastRiskProInterestBlock;\n  // RiskPro interest Blockspan to configure blocks between payments\n  uint256 public riskProInterestBlockSpan;\n\n  // Target addres to transfer commissions of mint/redeem\n  address payable public commissionsAddress;\n  /** UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n  /** DEPRECATED **/\n  // commissionRate [using mocPrecision]\n  // solium-disable-next-line mixedcase\n  uint256 public DEPRECATED_commissionRate;\n\n  /************************************/\n  /***** UPGRADE v017       ***********/\n  /************************************/\n\n  /** START UPDATE V017: 01/11/2019 **/\n\n  // Upgrade to support redeem stable inrate parameter\n  uint256 public stableTmin;\n  uint256 public stablePower;\n  uint256 public stableTmax;\n\n  /**CONTRACTS**/\n  IMoCState internal mocState;\n  MoCConverter internal mocConverter;\n  MoCRiskProxManager internal riskProxManager;\n\n  function setStableTmin(uint256 _stableTmin) public onlyAuthorizedChanger() {\n    stableTmin = _stableTmin;\n  }\n\n  function setStableTmax(uint256 _stableTmax) public onlyAuthorizedChanger() {\n    stableTmax = _stableTmax;\n  }\n\n  function setStablePower(uint256 _stablePower) public onlyAuthorizedChanger() {\n    stablePower = _stablePower;\n  }\n\n  function getStableTmin() public view returns (uint256) {\n    return stableTmin;\n  }\n\n  function getStableTmax() public view returns (uint256) {\n    return stableTmax;\n  }\n\n  function getStablePower() public view returns (uint256) {\n    return stablePower;\n  }\n\n  /**\n    @dev Calculates an average interest rate between after and before free stableToken Redemption\n    @param stableTokenRedeem StableTokens to redeem [using mocPrecision]\n    @return Interest rate value [using mocPrecision]\n   */\n  function stableTokenInrateAvg(uint256 stableTokenRedeem) public view returns (uint256) {\n    uint256 preAbRatio = mocState.currentAbundanceRatio();\n    uint256 posAbRatio = mocState.abundanceRatio(riskProxManager.getBucketNStableToken(BUCKET_C0).sub(stableTokenRedeem));\n\n    return mocLibConfig.inrateAvg(stableTmax, stablePower, stableTmin, preAbRatio, posAbRatio);\n  }\n\n  /** END UPDATE V017: 01/11/2019 **/\n\n  /**\n    @dev Initializes the contract\n    @param connectorAddress MoCConnector contract address\n    @param _governor Governor contract address\n    @param riskProxTmin  Minimum interest rate [using mocPrecision]\n    @param riskProxPower Power is a parameter for interest rate calculation [using noPrecision]\n    @param riskProxTmax Maximun interest rate [using mocPrecision]\n    @param _riskProRate BitPro holder interest rate [using mocPrecision]\n    @param blockSpanRiskPro BitPro blockspan to configure payments periods[using mocPrecision]\n    @param riskProInterestTargetAddress Target address to transfer the weekly BitPro holders interest\n    @param commissionsAddressTarget Target addres to transfer commissions of mint/redeem\n    @param _stableTmin Upgrade to support red stable inrate parameter\n    @param _stablePower Upgrade to support red stable inrate parameter\n    @param _stableTmax Upgrade to support red stable inrate parameter\n  */\n  function initialize(\n    address connectorAddress,\n    address _governor,\n    uint256 riskProxTmin,\n    uint256 riskProxPower,\n    uint256 riskProxTmax,\n    uint256 _riskProRate,\n    uint256 blockSpanRiskPro,\n    address payable riskProInterestTargetAddress,\n    address payable commissionsAddressTarget,\n    //uint256 commissionRateParam,\n    uint256 _stableTmin,\n    uint256 _stablePower,\n    uint256 _stableTmax\n  ) public initializer {\n    initializePrecisions();\n    initializeBase(connectorAddress);\n    initializeContracts();\n    initializeValues(\n      _governor,\n      riskProxTmin,\n      riskProxPower,\n      riskProxTmax,\n      _riskProRate,\n      commissionsAddressTarget,\n      //commissionRateParam,\n      blockSpanRiskPro,\n      riskProInterestTargetAddress,\n      _stableTmin,\n      _stablePower,\n      _stableTmax\n    );\n  }\n\n/**\n   * @dev gets tMin param of RiskProx tokens\n   * @return returns tMin of RiskProx\n   */\n  function getRiskProxTmin() public view returns (uint256) {\n    return riskProxParams.tMin;\n  }\n\n  /**\n   * @dev gets tMax param of RiskProx tokens\n   * @return returns tMax of RiskProx\n   */\n  function getRiskProxTmax() public view returns (uint256) {\n    return riskProxParams.tMax;\n  }\n\n  /**\n   * @dev gets power param of RiskProx tokens\n   * @return returns power of RiskProx\n   */\n  function getRiskProxPower() public view returns (uint256) {\n    return riskProxParams.power;\n  }\n\n  /**\n   * @dev Gets the blockspan of RiskPro that represents the frecuency of RiskPro holders intereset payment\n   * @return returns power of riskProInterestBlockSpan\n   */\n  function getRiskProInterestBlockSpan() public view returns (uint256) {\n    return riskProInterestBlockSpan;\n  }\n\n  /**\n   * @dev sets tMin param of RiskProx tokens\n   * @param _btxcTmin tMin of RiskProx\n   */\n  function setRiskProxTmin(uint256 _btxcTmin) public onlyAuthorizedChanger() {\n    riskProxParams.tMin = _btxcTmin;\n  }\n\n  /**\n   * @dev sets tMax param of RiskProx tokens\n   * @param _btxcTax tMax of RiskProx\n   */\n  function setRiskProxTmax(uint256 _btxcTax) public onlyAuthorizedChanger() {\n    riskProxParams.tMax = _btxcTax;\n  }\n\n  /**\n   * @dev sets power param of RiskProx tokens\n   * @param _btxcPower power of RiskProx\n   */\n  function setRiskProxPower(uint256 _btxcPower) public onlyAuthorizedChanger() {\n    riskProxParams.power = _btxcPower;\n  }\n\n  /**\n   @dev Gets the rate for RiskPro Holders\n   @return RiskPro Rate\n  */\n  function getRiskProRate() public view returns (uint256) {\n    return riskProRate;\n  }\n\n  // function getCommissionRate() public view returns(uint256) {\n  //   return commissionRate;\n  // }\n\n   /**\n    @dev Sets RiskPro Holders rate\n    @param newRiskProRate New RiskPro rate\n   */\n  function setRiskProRate(uint256 newRiskProRate) public onlyAuthorizedChanger() {\n    riskProRate = newRiskProRate;\n  }\n\n   /**\n    @dev Sets the blockspan RiskPro Intereset rate payment is enable to be executed\n    @param newRiskProBlockSpan New RiskPro Block span\n   */\n  function setRiskProInterestBlockSpan(uint256 newRiskProBlockSpan) public onlyAuthorizedChanger() {\n    riskProInterestBlockSpan = newRiskProBlockSpan;\n  }\n\n  /**\n   @dev Gets the target address to transfer RiskPro Holders rate\n   @return Target address to transfer RiskPro Holders interest\n  */\n  function getRiskProInterestAddress() public view returns (address payable) {\n    return riskProInterestAddress;\n  }\n\n  /**\n   @dev Sets the target address to transfer RiskPro Holders rate\n   @param newRiskProInterestAddress New RiskPro rate\n  */\n  function setRiskProInterestAddress(address payable newRiskProInterestAddress) public onlyAuthorizedChanger() {\n    riskProInterestAddress = newRiskProInterestAddress;\n  }\n\n  /**\n   @dev Sets the target address to transfer commissions of Mint/Redeem transactions\n   @param newCommissionsAddress New commisions address\n  */\n  function setCommissionsAddress(address payable newCommissionsAddress) public onlyAuthorizedChanger() {\n    commissionsAddress = newCommissionsAddress;\n  }\n\n  //  /**\n  //   @dev Sets the commission rate for Mint/Redeem transactions\n  //   @param newCommissionRate New commission rate\n  //  */\n  // function setCommissionRate(uint256 newCommissionRate) public onlyAuthorizedChanger() {\n  //   commissionRate = newCommissionRate;\n  // }\n\n  /**\n    @dev Calculates interest rate for RiskProx Minting, redeem and Free StableToken Redeem\n    @return Interest rate value [using RatePrecsion]\n   */\n  function spotInrate() public view returns (uint256) {\n    uint256 abRatio = mocState.currentAbundanceRatio();\n\n    return mocLibConfig.spotInrate(riskProxParams.tMax, riskProxParams.power, riskProxParams.tMin, abRatio);\n  }\n\n  /**\n    @dev Calculates an average interest rate between after and before mint/redeem\n    @param bucket Name of the bucket involved in the operation\n    @param resTokensAmount Value of the operation from which calculates the inrate [using reservePrecision]\n    @param onMinting Value that represents if the calculation is based on mint or on redeem\n    @return Interest rate value [using mocPrecision]\n   */\n  function riskProxInrateAvg(bytes32 bucket, uint256 resTokensAmount, bool onMinting) public view returns (uint256) {\n    uint256 preAbRatio = mocState.currentAbundanceRatio();\n    uint256 posAbRatio = mocState.abundanceRatio(simulateStableTokenMovement(bucket, resTokensAmount, onMinting));\n\n    return mocLibConfig.inrateAvg(riskProxParams.tMax, riskProxParams.power, riskProxParams.tMin, preAbRatio, posAbRatio);\n  }\n\n  /**\n    @dev returns the amount of ReserveTokens to pay in concept of interest to bucket C0\n   */\n  function dailyInrate() public view returns(uint256) {\n    uint256 daysToSettl = mocState.daysToSettlement();\n    uint256 totalInrateInBag = riskProxManager.getInrateBag(BUCKET_C0);\n\n    if (daysToSettl < mocLibConfig.dayPrecision) {\n      return totalInrateInBag;\n    }\n\n    // ([RES] * [DAY] / ([DAY] + [DAY])) = [RES]\n    // inrateBag / (daysToSettlement + 1)\n    uint256 toPay = totalInrateInBag\n      .mul(mocLibConfig.dayPrecision)\n      .div(daysToSettl.add(mocLibConfig.dayPrecision));\n\n    return toPay;\n  }\n\n  /**\n    @dev Extract the inrate from the passed ReserveTokens value for RiskProx minting operation\n    @param bucket Bucket to use to calculate inters\n    @param reserveTokenAmount Total value from which extract the interest rate [using reservePrecision]\n    @return ReserveTokens to pay in concept of interests [using reservePrecision]\n  */\n  function calcMintInterestValues(bytes32 bucket, uint256 reserveTokenAmount) public view returns (uint256) {\n    // Calculate Reserves to move in the operation\n    uint256 reservesToMove = mocLibConfig.bucketTransferAmount(reserveTokenAmount, mocState.leverage(bucket));\n    // Calculate interest rate\n    uint256 inrateValue = riskProxInrateAvg(bucket, reserveTokenAmount, true); // Minting\n    uint256 finalInrate = inrateToSettlement(inrateValue, true); // Minting\n\n    // Final interest\n    return mocLibConfig.getInterestCost(reservesToMove, finalInrate);\n  }\n\n  /**\n    @dev Extract the inrate from the passed ReserveTokens value for the StableToken Redeem operation\n    @param stableTokenAmount StableToken amount of the redemption [using mocPrecision]\n    @param reserveTokenAmount Total value from which extract the interest rate [using reservePrecision]\n    @return finalInterest\n  */\n  function calcStableTokenRedInterestValues(uint256 stableTokenAmount, uint256 reserveTokenAmount) public view returns (uint256) {\n    uint256 rate = stableTokenInrateAvg(stableTokenAmount);\n    uint256 finalInrate = inrateToSettlement(rate, true);\n    uint256 interests = mocLibConfig.getInterestCost(reserveTokenAmount, finalInrate);\n\n    return interests;\n  }\n\n  /**\n    @dev This function calculates the interest to return to the user\n    in a RiskProx redemption. It uses a mechanism to counteract the effect\n    of free stableTokens redemption. It will be replaced with FreeStableToken redemption\n    interests in the future\n    @param bucket Bucket to use to calculate interest\n    @param reserveTokenToRedeem Total value from which calculate interest [using reservePrecision]\n    @return Reserves to recover in concept of interests [using reservePrecision]\n  */\n  function calcFinalRedeemInterestValue(bytes32 bucket, uint256 reserveTokenToRedeem) public view returns (uint256) {\n    // Get interests to return for redemption\n    uint256 redeemInterest = calcRedeemInterestValue(bucket, reserveTokenToRedeem); // Redeem\n    uint256 proportionalInterest = calcProportionalInterestValue(bucket, redeemInterest);\n\n    return Math.min(proportionalInterest, redeemInterest);\n  }\n\n  /************************************/\n  /***** UPGRADE v0110      ***********/\n  /************************************/\n\n  /** START UPDATE V0110: 24/09/2020  **/\n  /** Upgrade to support multiple commission rates **/\n  /** Public functions **/\n\n  /**\n    @dev calculates the Commission rate from the passed ReserveTokens amount for mint/redeem operations\n    @param reserveTokenAmount Total value from which apply the Commission rate [using reservePrecision]\n    @param txType Transaction type according to constant values defined in this contract\n    @return finalCommissionAmount [using reservePrecision]\n  */\n  function calcCommissionValue(uint256 reserveTokenAmount, uint8 txType)\n  public view returns(uint256) {\n    // Validate txType\n    require (txType > 0, \"Invalid transaction type 'txType'\");\n\n    uint256 finalCommissionAmount = reserveTokenAmount.mul(commissionRatesByTxType[txType]).div(mocLibConfig.mocPrecision);\n    return finalCommissionAmount;\n  }\n\n  /**\n    @dev calculates the vendor markup rate from the passed vendor account and amount\n    @param vendorAccount Vendor address\n    @param amount Total value from which apply the vendor markup rate [using reservePrecision]\n    @return finalCommissionAmount [using reservePrecision]\n  */\n  function calculateVendorMarkup(address vendorAccount, uint256 amount) public view\n    returns (uint256 markup) {\n    // Calculate according to vendor markup\n    if (vendorAccount != address(0)) {\n      IMoCVendors mocVendors = IMoCVendors(mocState.getMoCVendors());\n\n      markup = amount.mul(mocVendors.getMarkup(vendorAccount)).div(mocLibConfig.mocPrecision);\n    }\n\n    return markup;\n  }\n\n  /** END UPDATE V0110: 24/09/2020 **/\n\n  /**\n    @dev Calculates ReserveTokens value to return to the user in concept of interests\n    @param bucket Bucket to use to calculate interest\n    @param reserveTokenToRedeem Total value from which calculate interest [using reservePrecision]\n    @return Reserves to recover in concept of interests [using reservePrecision]\n  */\n  function calcRedeemInterestValue(bytes32 bucket, uint256 reserveTokenToRedeem) public view returns (uint256) {\n    // Calculate Reserves to move in the operation\n    uint256 reservesToMove = mocLibConfig.bucketTransferAmount(reserveTokenToRedeem, mocState.leverage(bucket));\n    // Get interests to return for redemption\n    uint256 inrate = riskProxInrateAvg(bucket, reserveTokenToRedeem, false); // Redeem\n    uint256 finalInrate = inrateToSettlement(inrate, false); // Redeem\n\n    // Calculate interest for the redemption\n    return mocLibConfig.getInterestCost(reservesToMove, finalInrate);\n  }\n\n  /**\n    @dev Moves the daily amount of interest rate to C0 bucket\n  */\n  function dailyInratePayment() public\n  onlyWhitelisted(msg.sender) onlyOnceADay() returns(uint256) {\n    uint256 toPay = dailyInrate();\n    lastDailyPayBlock = block.number;\n\n    if (toPay != 0) {\n      riskProxManager.deliverInrate(BUCKET_C0, toPay);\n    }\n\n    emit InrateDailyPay(toPay, mocState.daysToSettlement(), mocState.getBucketNReserve(BUCKET_C0));\n  }\n\n  function isDailyEnabled() public view returns (bool) {\n    return lastDailyPayBlock == 0 || block.number > lastDailyPayBlock + mocState.dayBlockSpan();\n  }\n\n  function isRiskProInterestEnabled() public view returns (bool) {\n    return lastRiskProInterestBlock == 0 || block.number > (lastRiskProInterestBlock + riskProInterestBlockSpan);\n  }\n\n  /**\n   * @dev Calculates RiskPro Holders interest rates\n   * @return toPay interest in ReserveTokens [using reservePrecsion]\n   * @return bucketBtnc0 RTBC on bucket0 used to calculate de interest [using reservePrecsion]\n   */\n  function calculateRiskProHoldersInterest() public view returns (uint256, uint256) {\n    uint256 bucketBtnc0 = riskProxManager.getBucketNReserve(BUCKET_C0);\n    uint256 toPay = (bucketBtnc0.mul(riskProRate).div(mocLibConfig.mocPrecision));\n    return (toPay, bucketBtnc0);\n  }\n\n  /**\n   * @dev Pays the RiskPro Holders interest rates\n   * @return interest payed in ReserveTokens [using reservePrecsion]\n   */\n  function payRiskProHoldersInterestPayment() public\n  onlyWhitelisted(msg.sender)\n  onlyWhenRiskProInterestsIsEnabled() returns(uint256) {\n    (uint256 riskProInterest, uint256 bucketBtnc0) = calculateRiskProHoldersInterest();\n    lastRiskProInterestBlock = block.number;\n    emit RiskProHoldersInterestPay(riskProInterest, bucketBtnc0);\n    return riskProInterest;\n  }\n\n  /************************************/\n  /***** UPGRADE v0110      ***********/\n  /************************************/\n\n  /** START UPDATE V0110: 24/09/2020  **/\n  /** Upgrade to support multiple commission rates **/\n  /** Public functions **/\n  /**\n    @dev Sets the commission rate to a particular transaction type\n    @param txType Transaction type according to constant values defined in this contract\n    @param value Commission rate\n  */\n  function setCommissionRateByTxType(uint8 txType, uint256 value) public onlyAuthorizedChanger() {\n    commissionRatesByTxType[txType] = value;\n  }\n\n  /** END UPDATE V0110: 24/09/2020 **/\n\n  /**\n    @dev Calculates the interest rate to pay until the settlement day\n    @param inrate Spot interest rate\n    @param countAllDays Value that represents if the calculation will use all days or one day less\n    @return Interest rate value [using mocPrecision]\n   */\n  function inrateToSettlement(uint256 inrate, bool countAllDays) internal view returns (uint256) {\n    uint256 dayCount = inrateDayCount(countAllDays);\n\n    return inrate.mul(dayCount).div(mocLibConfig.dayPrecision);\n  }\n\n  /**\n    @dev This function calculates the interest to return to a user redeeming\n    RiskProx as a proportion of the amount in the interestBag.\n    @param bucket Bucket to use to calculate interest\n    @param redeemInterest Total value from which calculate interest [using reservePrecision]\n    @return InterestsInBag * (RedeemInterests / FullRedeemInterest) [using reservePrecision]\n  */\n  function calcProportionalInterestValue(bytes32 bucket, uint256 redeemInterest) internal view returns (uint256) {\n    uint256 fullRedeemInterest = calcFullRedeemInterestValue(bucket);\n    uint256 interestsInBag = riskProxManager.getInrateBag(BUCKET_C0);\n\n    if (fullRedeemInterest == 0) {\n      return 0;\n    }\n\n    // Proportional interests amount\n    return redeemInterest.mul(interestsInBag).div(fullRedeemInterest); // [RES] * [RES] / [RES]\n  }\n\n  /**\n    @dev This function calculates the interest to return if a user redeem all RiskProx in existance\n    @param bucket Bucket to use to calculate interest\n    @return Interests [using reservePrecision]\n  */\n  function calcFullRedeemInterestValue(bytes32 bucket) internal view returns (uint256) {\n    // Value in ReserveTokens of all RiskProxs in the bucket\n    uint256 fullRiskProxReserveTokenValue = mocConverter.riskProxToResToken(riskProxManager.getBucketNRiskPro(bucket), bucket);\n    // Interests to return if a redemption of all RiskProx is done\n    return calcRedeemInterestValue(bucket, fullRiskProxReserveTokenValue); // Redeem\n  }\n\n  /**\n    @dev Calculates the final amount of Bucket 0 StableTokens on RiskProx mint/redeem\n    @param bucket Name of the bucket involved in the operation\n    @param resTokensAmount Value of the operation from which calculates the inrate [using reservePrecision]\n    @return Final bucket 0 StableToken amount\n   */\n  function simulateStableTokenMovement(bytes32 bucket, uint256 resTokensAmount, bool onMinting) internal view returns (uint256) {\n    // Calculates stableTokens to move\n    uint256 reserveTokenToMove = mocLibConfig.bucketTransferAmount(resTokensAmount, mocState.leverage(bucket));\n    uint256 stableTokensToMove = mocConverter.resTokenToStableToken(reserveTokenToMove);\n\n    if (onMinting) {\n      /* Should not happen when minting riskPro because it's\n      not possible to mint more than max riskProx but is\n      useful when trying to calculate inrate before minting */\n      return riskProxManager.getBucketNStableToken(BUCKET_C0) > stableTokensToMove\n        ? riskProxManager.getBucketNStableToken(BUCKET_C0).sub(stableTokensToMove)\n        : 0;\n    } else {\n      return riskProxManager.getBucketNStableToken(BUCKET_C0).add(Math.min(stableTokensToMove, riskProxManager.getBucketNStableToken(bucket)));\n    }\n  }\n\n  /**\n    @dev Returns the days to use for interests calculation\n    @param countAllDays Value that represents if the calculation is based on mint or on redeem\n    @return days [using dayPrecision]\n   */\n  function inrateDayCount(bool countAllDays) internal view returns(uint256) {\n    uint256 daysToSettl = mocState.daysToSettlement();\n\n    if (daysToSettl < mocLibConfig.dayPrecision) {\n      return 0;\n    }\n\n    if (countAllDays) {\n      return daysToSettl;\n    }\n\n    return daysToSettl.sub(mocLibConfig.dayPrecision);\n  }\n\n  modifier onlyOnceADay() {\n    require(isDailyEnabled(), \"Interest rate already payed today\");\n    _;\n  }\n\n  modifier onlyWhenRiskProInterestsIsEnabled() {\n    require(isRiskProInterestEnabled(), \"Interest rate of RiskPro holders already payed this week\");\n    _;\n  }\n\n  /**\n   * @dev Initialize the contracts with which it interacts\n   */\n  function initializeContracts() internal {\n    riskProxManager = MoCRiskProxManager(connector.riskProxManager());\n    mocState = IMoCState(connector.mocState());\n    mocConverter = MoCConverter(connector.mocConverter());\n  }\n\n  /**\n   * @dev Initialize the parameters of the contract\n   * @param _governor the address of the IGovernor contract\n   * @param riskProxMin Minimum interest rate [using mocPrecision]\n   * @param riskProxPower Power is a parameter for interest rate calculation [using noPrecision]\n   * @param riskProxMax Maximun interest rate [using mocPrecision]\n   * @param _riskProRate RiskPro holder interest rate [using mocPrecision]\n   * @param blockSpanRiskPro RiskPro blockspan to configure payments periods[using mocPrecision]\n   * @param riskProInterestsTarget Target address to transfer the weekly RiskPro holders interest\n   * @param _stableTmin Upgrade to support red stable inrate parameter\n   * @param _stablePower Upgrade to support red stable inrate parameter\n   * @param _stableTmax Upgrade to support red stable inrate parameter\n   */\n  function initializeValues(\n    address _governor,\n    uint256 riskProxMin,\n    uint256 riskProxPower,\n    uint256 riskProxMax,\n    uint256 _riskProRate,\n    address payable commissionsAddressTarget,\n    //uint256 commissionRateParam,\n    uint256 blockSpanRiskPro,\n    address payable riskProInterestsTarget,\n    uint256 _stableTmin,\n    uint256 _stablePower,\n    uint256 _stableTmax\n  ) internal {\n    governor = IGovernor(_governor);\n    riskProxParams.tMin = riskProxMin;\n    riskProxParams.power = riskProxPower;\n    riskProxParams.tMax = riskProxMax;\n    riskProRate = _riskProRate;\n    riskProInterestAddress = riskProInterestsTarget;\n    riskProInterestBlockSpan = blockSpanRiskPro;\n    //commissionRate = commissionRateParam;\n    commissionsAddress = commissionsAddressTarget;\n    stableTmin = _stableTmin;\n    stablePower = _stablePower;\n    stableTmax = _stableTmax;\n  }\n\n  /************************************/\n  /***** UPGRADE v0110      ***********/\n  /************************************/\n\n  /** START UPDATE V0110: 24/09/2020  **/\n  /** Upgrade to support multiple commission rates **/\n\n  // Transaction types\n  uint8 public constant MINT_RISKPRO_FEES_RESERVE = 1;\n  uint8 public constant REDEEM_RISKPRO_FEES_RESERVE = 2;\n  uint8 public constant MINT_STABLETOKEN_FEES_RESERVE = 3;\n  uint8 public constant REDEEM_STABLETOKEN_FEES_RESERVE = 4;\n  uint8 public constant MINT_RISKPROX_FEES_RESERVE = 5;\n  uint8 public constant REDEEM_RISKPROX_FEES_RESERVE = 6;\n  uint8 public constant MINT_RISKPRO_FEES_MOC = 7;\n  uint8 public constant REDEEM_RISKPRO_FEES_MOC = 8;\n  uint8 public constant MINT_STABLETOKEN_FEES_MOC = 9;\n  uint8 public constant REDEEM_STABLETOKEN_FEES_MOC = 10;\n  uint8 public constant MINT_RISKPROX_FEES_MOC = 11;\n  uint8 public constant REDEEM_RISKPROX_FEES_MOC = 12;\n\n  mapping(uint8 => uint256) public commissionRatesByTxType;\n\n  /** END UPDATE V0110: 24/09/2020 **/\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n",
    "imports": [
        {
            "name": "MoCInrate.sol",
            "contents": "\n// File: moc-governance/contracts/Governance/ChangeContract.sol\n\npragma solidity 0.5.8;\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n\n  /**\n    @notice Override this function with a recipe of the changes to be done when this ChangeContract\n    is executed\n   */\n  function execute() external;\n}\n\n// File: moc-governance/contracts/Governance/IGovernor.sol\n\npragma solidity 0.5.8;\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor{\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @dev This function should be protected somehow to only execute changes that\n    benefit the system. This decision process is independent of this architechture\n    therefore is independent of this interface too\n    @param changeContract Address of the contract that will execute the changes\n   */\n  function executeChange(ChangeContract changeContract) external;\n\n  /**\n    @notice Function to be called to make the changes in changeContract\n    @param _changer Address of the contract that will execute the changes\n   */\n  function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n// File: zos-lib/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.6.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: moc-governance/contracts/Governance/Governed.sol\n\npragma solidity 0.5.8;\n\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed is Initializable {\n\n  /**\n    @notice The address of the contract which governs this one\n   */\n  IGovernor public governor;\n\n  string constant private NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n  /**\n    @notice Modifier that protects the function\n    @dev You should use this modifier in any function that should be called through\n    the governance system\n   */\n  modifier onlyAuthorizedChanger() {\n    require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n    _;\n  }\n\n  /**\n    @notice Initialize the contract with the basic settings\n    @dev This initialize replaces the constructor but it is not called automatically.\n    It is necessary because of the upgradeability of the contracts\n    @param _governor Governor address\n   */\n  function initialize(IGovernor _governor) public initializer {\n    governor = _governor;\n  }\n\n  /**\n    @notice Change the contract's governor. Should be called through the old governance system\n    @param newIGovernor New governor address\n   */\n  function changeIGovernor(IGovernor newIGovernor) public onlyAuthorizedChanger {\n    governor = newIGovernor;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n// File: contracts/MoCHelperLib.sol\n\npragma solidity 0.5.8;\n\n\nlibrary MoCHelperLib {\n\n  struct MocLibConfig {\n    uint256 reservePrecision;\n    uint256 dayPrecision;\n    uint256 mocPrecision;\n  }\n\n  using SafeMath for uint256;\n\n  uint256 constant UINT256_MAX = ~uint256(0);\n\n  /**\n    @dev Returns max uint256 value constant.\n    @return max uint256 value constant\n  */\n  function getMaxInt(MocLibConfig storage /*config*/) public pure returns(uint256) {\n    return UINT256_MAX;\n  }\n\n  /**\n    @dev Calculates average interest using integral function: T =  Rate = a * (x ** b) + c\n    @param tMax maxInterestRate [using mocPrecision]\n    @param power factor [using noPrecision]\n    @param tMin minInterestRate C0 stableToken amount [using mocPrecision]\n    @param abRat1 initial abundance ratio [using mocPrecision]\n    @param abRat2 final abundance ratio [using mocPrecision]\n    @return average interest rate [using mocPrecision]\n  */\n  function inrateAvg(MocLibConfig storage config, uint256 tMax, uint256 power, uint256 tMin, uint256 abRat1, uint256 abRat2)\n  public view returns(uint256) {\n    require(tMax > tMin, \"Max inrate should be bigger than Min inrate\");\n    uint256 abRat1Comp = config.mocPrecision.sub(abRat1);\n    uint256 abRat2Comp = config.mocPrecision.sub(abRat2);\n\n    if (abRat1 == abRat2) {\n      return potential(config, tMax, power, tMin, abRat1Comp);\n    }\n    else if (abRat2 < abRat1) {\n      return avgInt(config, tMax, power, tMin, abRat1Comp, abRat2Comp);\n    }\n    else {\n      return avgInt(config, tMax, power, tMin, abRat2Comp, abRat1Comp);\n    }\n  }\n\n  /**\n    @dev Calculates spot interest rate that RiskProx owners should pay to RiskPro owners: Rate = tMax * (abRatio ** power) + tMin\n    @param tMin min interest rate [using mocPrecision]\n    @param power power to use in the formula [using NoPrecision]\n    @param tMax max interest rate [using mocPrecision]\n    @param abRatio bucket C0  abundance Ratio [using mocPrecision]\n\n   */\n  function spotInrate(\n    MocLibConfig storage config, uint256 tMax, uint256 power, uint256 tMin, uint256 abRatio\n  ) public view returns(uint256) {\n    uint256 abRatioComp = config.mocPrecision.sub(abRatio);\n\n    return potential(config, tMax, power, tMin, abRatioComp);\n  }\n\n  /**\n    @dev Calculates potential interests function with given parameters: Rate = a * (x ** b) + c\n    @param a maxInterestRate [using mocPrecision]\n    @param b factor [using NoPrecision]\n    @param c minInterestRate C0 stableToken amount [using mocPrecision]\n    @param value global stableToken amount [using mocPrecision]\n  */\n  function potential(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value)\n  public view returns(uint256) {\n    // value ** b\n    // [MOC] ** [] = [MOC]\n    uint256 aux1 = pow(value, b, config.mocPrecision);\n    // (a * aux1) + c\n    // [MOC] [MOC] / [MOC] + [MOC] = [MOC]\n    return a.mul(aux1).div(config.mocPrecision).add(c);\n  }\n\n    /**\n    @dev Calculates average of the integral function:\n     T = (\n              (c * xf + ((a * (xf ** (b + 1))) / (b + 1))) -\n              (c * xi + ((a * (xi ** (b + 1))) / (b + 1)))\n             ) / (xf - xi)\n    @param a maxInterestRate [using mocPrecision]\n    @param b factor [using NoPrecision]\n    @param c minInterestRate C0 stableToken amount [using mocPrecision]\n    @param value1 value to put in the function [using mocPrecision]\n    @param value2 value to put in the function [using mocPrecision]\n    @return average interest rate [using mocPrecision]\n   */\n  function avgInt(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value1, uint256 value2)\n  public view returns(uint256) {\n    // value2 - value1\n    // [MOC]\n    uint256 diff = value2.sub(value1);\n    // ((c * (1 - value1) + ((a * ((1 - value1) ** (b + 1))) / (b + 1)))\n    uint256 intV1 = integral(config, a, b, c, value1);\n    // ((c * (1 - value2) + ((a * ((1 - value2) ** (b + 1))) / (b + 1)))\n    uint256 intV2 = integral(config,  a, b, c, value2);\n    // (secOp - first) / diff\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\n    return intV2.sub(intV1).div(diff);\n  }\n\n  /**\n    @dev Calculates integral of the exponential function: T = c * (value) + (a * value ** (b + 1)) / (b + 1))\n    @param a maxInterestRate [using mocPrecision]\n    @param b factor [using NoPrecision]\n    @param c minInterestRate C0 stableToken amount [using mocPrecision]\n    @param value value to put in the function [using mocPrecision]\n    @return integration result [using mocPrecision]\n  */\n  function integral(MocLibConfig storage config, uint256 a, uint256 b, uint256 c, uint256 value)\n  public view returns(uint256) {\n    // b + 1\n    // [NONE]\n    uint256 b2 = b.add(1);\n    // c * value\n    // [MOC][MOC]\n    uint256 firstOp = c.mul(value);\n    // [MOC]\n    uint256 pow = pow(value, b2, config.mocPrecision);\n    // (a * value ** b2) / b2)\n    // [MOC][MOC]\n    uint256 secOp = a.mul(pow).div(b2);\n    // (firstOp + secOp)\n    // [MOC][MOC] + [MOC][MOC] = [MOC][MOC]\n    return firstOp.add(secOp);\n  }\n\n  /**\n  * @dev Relation between stableTokens in bucket 0 and StableToken total supply\n  * @param stableToken0 stableToken count in bucket 0 [using mocPrecision]\n  * @param stableTokent total stableToken supply [using mocPrecision]\n  * @return abundance ratio [using mocPrecision]\n  */\n  function abundanceRatio(MocLibConfig storage config, uint256 stableToken0, uint256 stableTokent)\n  public view returns(uint256) {\n    if (stableTokent == 0) {\n      return config.mocPrecision;\n    }\n    // [DOC] [MOC] / [DOC] = [MOC]\n    return stableToken0.mul(config.mocPrecision).div(stableTokent);\n  }\n\n  /**\n    @dev Returns the Ratio to apply to RiskPro Price in discount situations: SpotDiscountRate = TPD * (utpdu - cob) / (uptdu -liq)\n    @param riskProLiqDiscountRate Discount rate applied at Liquidation level coverage [using mocPrecision]\n    @param liq Liquidation coverage threshold [using mocPrecision]\n    @param utpdu Discount coverage threshold [using mocPrecision]\n    @param cov Actual global Coverage threshold [using mocPrecision]\n    @return Spot discount rate [using mocPrecision]\n  */\n  function riskProSpotDiscountRate(\n    MocLibConfig storage libConfig, uint256 riskProLiqDiscountRate,\n    uint256 liq, uint256 utpdu, uint256 cov\n  ) public view returns(uint256) {\n    require(riskProLiqDiscountRate < libConfig.mocPrecision, \"Discount rate should be lower than 1\");\n\n    if (cov >= utpdu) {\n      return 0;\n    }\n\n    // utpdu - liq\n    // [MOC] - [MOC] = [MOC]\n    uint256 utpduLiqDiff = utpdu.sub(liq);\n\n    // utpdu - cov\n    // [MOC] - [MOC] = [MOC]\n    uint256 utpduCovDiff = utpdu.sub(cov);\n\n    // TPD * utpduCovDiff / utpduLiqDiff\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    return riskProLiqDiscountRate.mul(utpduCovDiff).div(utpduLiqDiff);\n  }\n\n  /**\n    @dev Max amount of RiskPro to available with discount: MaxRiskProWithDiscount = (uTPDU * nStableToken * PEG - (nReserve * B)) / (TPusd * TPD)\n    @param nReserve Total ReserveTokens amount [using reservePrecision]\n    @param nStableToken StableToken amount [using mocPrecision]\n    @param utpdu Discount coverage threshold [using mocPrecision]\n    @param peg peg value\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @param riskProUsdPrice riskProUsdPrice [using mocPrecision]\n    @param spotDiscount spot discount [using mocPrecision]\n    @return Total RiskPro amount [using mocPrecision]\n  */\n  function maxRiskProWithDiscount(\n    MocLibConfig storage libConfig, uint256 nReserve, uint256 nStableToken, uint256 utpdu,\n    uint256 peg, uint256 reservePrice, uint256 riskProUsdPrice, uint256 spotDiscount\n  ) public view returns(uint256)  {\n    require(spotDiscount < libConfig.mocPrecision, \"Discount Rate should be lower than 1\");\n\n    if (spotDiscount == 0) {\n      return 0;\n    }\n\n    // nReserve * B\n    // [RES] * [MOC] / [RES] = [MOC]\n    uint256 nbUsdValue = nReserve.mul(reservePrice).div(libConfig.reservePrecision);\n\n    // (TPusd * (1 - TPD))\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 riskProDiscountPrice = riskProUsdPrice.mul(libConfig.mocPrecision.sub(spotDiscount))\n      .div(libConfig.mocPrecision);\n\n    return maxRiskProWithDiscountAux(libConfig, nbUsdValue, nStableToken, utpdu, peg, riskProDiscountPrice);\n  }\n\n  /**\n    @dev Max amount of RiskPro to available with discount: MaxRiskProWithDiscount = (uTPDU * nStableToken * PEG - (nReserve * B)) / (TPusd * TPD)\n    @param nbUsdValue Total amount of ReserveTokens in USD [using mocPrecision]\n    @param nStableToken StableToken amount [using mocPrecision]\n    @param utpdu Discount coverage threshold [using mocPrecision]\n    @param riskProDiscountPrice riskProUsdPrice with discount applied [using mocPrecision]\n    @param peg peg value\n    @return Total RiskPro amount [using reservePrecision]\n  */\n  function maxRiskProWithDiscountAux(\n    MocLibConfig storage libConfig, uint256 nbUsdValue, uint256 nStableToken,\n    uint256 utpdu, uint256 peg, uint256 riskProDiscountPrice\n  ) internal view returns(uint256) {\n\n    // uTPDU * nStableToken * PEG\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 coverageUSDAmount = utpdu.mul(nStableToken).mul(peg).div(libConfig.mocPrecision);\n\n    // This case only occurs with Coverage below 1\n    if (coverageUSDAmount <= nbUsdValue) {\n      return 0;\n    }\n\n    // ([MOC] - [MOC]) * [RES] / [MOC] = [RES]\n    return coverageUSDAmount.sub(nbUsdValue).mul(libConfig.reservePrecision).div(riskProDiscountPrice);\n  }\n\n  /**\n    @dev Calculates Locked ReserveTokens\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @param nStableToken StableTokens amount [using mocPrecision]\n    @param peg peg value\n    @return Locked ReserveTokens [using reservePrecision]\n  */\n  function lockedReserveTokens(MocLibConfig storage libConfig, uint256 reservePrice, uint256 nStableToken, uint256 peg)\n    public view returns (uint256)\n  {\n    return nStableToken.mul(peg).mul(libConfig.reservePrecision).div(reservePrice);\n  }\n\n  /**\n    @dev Calculates price at liquidation event as a relation between the stableToken total supply\n    and the amount of ReserveTokens available to distribute\n    @param resTokenAmount ReserveTokens to distribute [using reservePrecision]\n    @param nStableToken StableTokens amount [using mocPrecision]\n    @return Price at liquidation event [using mocPrecision]\n  */\n  function liquidationPrice(MocLibConfig storage libConfig, uint256 resTokenAmount, uint256 nStableToken)\n  public view returns(uint256) {\n    // [MOC] * [RES] / [RES]\n    return nStableToken.mul(libConfig.reservePrecision).div(resTokenAmount);\n  }\n\n  /**\n    @dev Calculates RiskPro ReserveTokens: (nReserve-LB) / nTP\n    @param nReserve Total ReserveTokens amount [using reservePrecision]\n    @param lb Locked ReserveTokens amount [using reservePrecision]\n    @param nTP RiskPro amount [using mocPrecision]\n    @return RiskPro ReserveTokens price [using reservePrecision]\n  */\n  function riskProTecPrice(MocLibConfig storage libConfig, uint256 nReserve, uint256 lb, uint256 nTP)\n  public view returns (uint256) {\n    // Liquidation happens before this condition turns true\n    if (nReserve < lb) {\n      return 0;\n    }\n\n    if (nTP == 0) {\n      return libConfig.mocPrecision;\n    }\n    // ([RES] - [RES]) * [MOC] / [MOC]\n    return nReserve.sub(lb).mul(libConfig.mocPrecision).div(nTP);\n  }\n\n  /**\n    @dev Calculates RiskPro ReserveToken price: RiskProxInRiskPro = riskProxTecPrice / riskProPrice\n    @param riskProxTecPrice RiskProx ReserveTokens price [using reservePrecision]\n    @param riskProPrice Trog ReserveTokens price [using reservePrecision]\n    @return RiskProx price in RiskPro [using mocPrecision]\n  */\n  function riskProxRiskProPrice(\n    MocLibConfig storage libConfig, uint256 riskProxTecPrice, uint256 riskProPrice\n  ) public view returns (uint256) {\n    // [RES] * [MOC] / [RES] = [MOC]\n    return riskProxTecPrice.mul(libConfig.mocPrecision).div(riskProPrice);\n  }\n\n  /**\n    @dev Returns a new value with the discountRate applied: (price)* (1 - discountRate)\n    @param price Price [using SomePrecision]\n    @param discountRate Discount rate to apply [using mocPrecision]\n    @return Price with discount applied [using SomePrecision]\n  */\n  function applyDiscountRate(MocLibConfig storage libConfig, uint256 price, uint256 discountRate)\n    public view returns(uint256) {\n\n    uint256 discountCoeff = libConfig.mocPrecision.sub(discountRate);\n\n    return price.mul(discountCoeff).div(libConfig.mocPrecision);\n  }\n\n  /**\n    @dev Returns the amount of interest to pay: = price * interestRate\n    @param value Cost to apply interest [using SomePrecision]\n    @param interestRate Interest rate to apply [using mocPrecision]\n    @return Interest cost based on the value and interestRate [using SomePrecision]\n  */\n  function getInterestCost(MocLibConfig storage libConfig, uint256 value, uint256 interestRate)\n    public view returns(uint256) {\n    // [ORIGIN] * [MOC] / [MOC] = [ORIGIN]\n    return value.mul(interestRate).div(libConfig.mocPrecision);\n  }\n\n  /**\n    @dev Calculates Coverage: nReserve / LB\n    @param nReserve Total ReserveTokens amount [using reservePrecision]\n    @param lB Locked ReserveTokens amount [using reservePrecision]\n    @return Coverage [using mocPrecision]\n  */\n  function coverage(MocLibConfig storage libConfig, uint256 nReserve, uint256 lB) public view\n    returns(uint256) {\n    if (lB == 0) {\n      return UINT256_MAX;\n    }\n\n    return nReserve.mul(libConfig.mocPrecision).div(lB);\n  }\n\n /**\n    @dev Calculates Leverage from Coverage: Leverage = C / (C - 1)\n    @param cov Coverage [using mocPrecision]\n    @return Leverage [using mocPrecision]\n  */\n  function leverageFromCoverage(MocLibConfig storage libConfig, uint256 cov)\n  public view returns(uint256) {\n    if (cov == UINT256_MAX) {\n      return libConfig.mocPrecision;\n    }\n\n    if (cov <= libConfig.mocPrecision) {\n      return UINT256_MAX;\n    }\n\n    return cov.mul(libConfig.mocPrecision).div(cov.sub(libConfig.mocPrecision));\n  }\n\n /**\n    @dev Calculates Leverage: Leverage = nReserve / (nReserve - lB)\n    @param nReserve Total ReserveTokens amount [using reservePrecision]\n    @param lB Locked ReserveTokens amount [using reservePrecision]\n    @return Leverage [using mocPrecision]\n  */\n  function leverage(MocLibConfig storage libConfig, uint256 nReserve,uint256 lB)\n  public view returns(uint256) {\n    if (lB == 0) {\n      return libConfig.mocPrecision;\n    }\n\n    if (nReserve <= lB) {\n      return UINT256_MAX;\n    }\n\n    return nReserve.mul(libConfig.mocPrecision).div(nReserve.sub(lB));\n  }\n\n  /**\n    @dev Price in ReserveTokens of the amount of StableTokens\n    @param amount Total ReserveTokens amount [using reservePrecision]\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @return Total value [using reservePrecision]\n  */\n  function stableTokensResTokensValue(\n    MocLibConfig storage libConfig, uint256 amount, uint256 peg, uint256 reservePrice\n  ) public view returns (uint256) {\n    require(reservePrice > 0, \"Price should be more than zero\");\n    require(libConfig.reservePrecision > 0, \"Precision should be more than zero\");\n    //Total = amount / satoshi price\n    //Total = amount / (reservePrice / precision)\n    // [RES] * [MOC] / [MOC]\n    uint256 stableTokenResTokenTotal = amount.mul(libConfig.mocPrecision).mul(peg).div(reservePrice);\n\n    return stableTokenResTokenTotal;\n  }\n\n  /**\n    @dev Price in ReserveTokens of the amount of RiskPros\n    @param riskProAmount amount of RiskPro [using mocPrecision]\n    @param riskProResTokenPrice RiskPro price in ReserveTokens [using reservePrecision]\n    @return Total value [using reservePrecision]\n  */\n  function riskProResTokensValuet(MocLibConfig storage libConfig, uint256 riskProAmount, uint256 riskProResTokenPrice)\n    public view returns (uint256) {\n    require(libConfig.reservePrecision > 0, \"Precision should be more than zero\");\n\n    // [MOC] * [RES] / [MOC] =  [RES]\n    uint256 riskProResTokenTotal = riskProAmount.mul(riskProResTokenPrice).div(libConfig.mocPrecision);\n\n    return riskProResTokenTotal;\n  }\n\n  /**\n    @dev Max amount of Docs to issue: MaxStableToken = ((nReserve*B)-(Cobj*B/Bcons*nStableToken*PEG))/(PEG*(Cobj*B/BCons-1))\n    @param nReserve Total ReserveTokens amount [using reservePrecision]\n    @param cobj Target Coverage [using mocPrecision]\n    @param nStableToken StableToken amount [using mocPrecision]\n    @param peg peg value\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @param bCons ReserveTokens conservative price [using mocPrecision]\n    @return Total StableTokens amount [using mocPrecision]\n  */\n  function maxStableToken(\n    MocLibConfig storage libConfig, uint256 nReserve,\n    uint256 cobj, uint256 nStableToken, uint256 peg, uint256 reservePrice, uint256 bCons\n  ) public view returns(uint256) {\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\n\n    // If cobj is less than 1, just return zero\n    if (cobj < libConfig.mocPrecision)\n      return 0;\n\n    // Cobj * B / BCons\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 adjCobj = cobj.mul(reservePrice).div(bCons);\n\n    return maxStableTokenAux(libConfig, nReserve, adjCobj, nStableToken, peg, reservePrice);\n  }\n\n  function maxStableTokenAux(\n    MocLibConfig storage libConfig, uint256 nReserve, uint256 adjCobj, uint256 nStableToken, uint256 peg, uint256 reservePrice\n  ) internal view returns(uint256) {\n    // (nReserve*B)\n    // [RES] [MOC] [MOC] / [RES] = [MOC] [MOC]\n    uint256 firstOperand = nReserve.mul(reservePrice).mul(libConfig.mocPrecision).div(libConfig.reservePrecision);\n    // (adjCobj*nStableToken*PEG)\n    // [MOC] [MOC]\n    uint256 secOperand = adjCobj.mul(nStableToken).mul(peg);\n    // (PEG*(adjCobj-1)\n    // [MOC]\n    uint256 denom = adjCobj.sub(libConfig.mocPrecision).mul(peg);\n\n    if (firstOperand <= secOperand)\n      return 0;\n\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\n    return (firstOperand.sub(secOperand)).div(denom);\n  }\n\n  /**\n    @dev Max amount of RiskPro to redeem: MaxRiskPro = ((nReserve*B)-(Cobj*nStableToken*PEG))/TPusd\n    @param nReserve Total ReserveTokens amount [using reservePrecision]\n    @param cobj Target Coverage [using mocPrecision]\n    @param nStableToken Target Coverage [using mocPrecision]\n    @param peg peg value\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @param bCons ReserveTokens conservative price [using mocPrecision]\n    @param riskProUsdPrice riskProUsdPrice [using mocPrecision]\n    @return Total RiskPro amount [using mocPrecision]\n  */\n  function maxRiskPro(\n    MocLibConfig storage libConfig, uint256 nReserve, uint256 cobj,\n    uint256 nStableToken, uint256 peg, uint256 reservePrice, uint256 bCons, uint256 riskProUsdPrice\n  ) public view returns(uint256) {\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\n\n    // Cobj * reservePrice / BCons\n    // [MOC] * [MOC] / [MOC] = [MOC]\n    uint256 adjCobj = cobj.mul(reservePrice).div(bCons);\n    // (nReserve * reservePrice)\n    // [RES] * [MOC] * [MOC] / [RES] = [MOC] [MOC]\n    uint256 firstOperand = nReserve.mul(reservePrice)\n      .mul(libConfig.mocPrecision)\n      .div(libConfig.reservePrecision);\n    // (adjCobj * nStableToken * PEG)\n    // [MOC] * [MOC]\n    uint256 secOperand = adjCobj.mul(nStableToken).mul(peg);\n\n    if (firstOperand <= secOperand)\n      return 0;\n\n    // ([MOC][MOC] - [MOC][MOC]) / [MOC] = [MOC]\n    return (firstOperand.sub(secOperand)).div(riskProUsdPrice);\n  }\n\n  /**\n    @dev Calculates the total ReserveTokens price of the amount of RiskPros\n    @param amount Amount of RiskPro [using mocPrecision]\n    @param riskProPrice RiskPro ReserveTokens Price [using reservePrecision]\n    @return RiskPro total value in ReserveTokens [using reservePrecision]\n  */\n  function totalRiskProInResTokens(\n    MocLibConfig storage libConfig, uint256 amount, uint256 riskProPrice\n  ) public view returns(uint256) {\n    // [RES] * [MOC] / [MOC] = [RES]\n    return riskProPrice.mul(amount).div(libConfig.mocPrecision);\n  }\n\n  /**\n    @dev Calculates the equivalent in StableTokens of the resTokensAmount\n    @param resTokensAmount ReserveTokens  amount [using reservePrecision]\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @return Equivalent StableToken amount [using mocPrecision]\n  */\n  function maxStableTokensWithResTokens(\n    MocLibConfig storage libConfig, uint256 resTokensAmount, uint256 reservePrice\n  ) public view returns(uint256) {\n    // [RES] * [MOC] / [RES] = [MOC]\n    return resTokensAmount.mul(reservePrice).div(libConfig.reservePrecision);\n  }\n\n  /**\n    @dev Calculates the equivalent in RiskPro of the resTokensAmount\n    @param resTokensAmount ReserveTokens amount [using reservePrecision]\n    @param riskProPrice RiskPro ReserveTokens price [using reservePrecision]\n    @return Equivalent RiskPro amount [using mocPrecision]\n  */\n  function maxRiskProWithResTokens(\n    MocLibConfig storage libConfig, uint256 resTokensAmount, uint256 riskProPrice\n  ) public view returns(uint256) {\n    if (riskProPrice == 0) {\n      return 0;\n    }\n\n    // [RES] * [MOC] / [RES]\n    return resTokensAmount.mul(libConfig.mocPrecision).div(riskProPrice);\n  }\n\n  /**\n    @dev Calculates the ResToken amount to move from C0 bucket to\n    an L bucket when a RiskProx minting occurs: toMove = resTokensAmount * (lev - 1)\n    @param resTokensAmount Total ReserveTokens amount [using reservePrecision]\n    @param lev L bucket leverage [using mocPrecision]\n    @return resTokens to move [using reservePrecision]\n  */\n  function bucketTransferAmount(\n    MocLibConfig storage libConfig, uint256 resTokensAmount, uint256 lev\n  ) public view returns(uint256) {\n    require(lev > libConfig.mocPrecision, \"Leverage should be more than 1\");\n\n    if (lev == UINT256_MAX || resTokensAmount == 0) {\n      return 0;\n    }\n\n    // (lev-1)\n    uint256 levSubOne = lev.sub(libConfig.mocPrecision);\n\n    // Intentionally avaoid SafeMath\n    // [RES] * [MOC]\n    uint256 transferAmount = resTokensAmount * levSubOne;\n    if (transferAmount / resTokensAmount != levSubOne)\n      return 0;\n\n    // [RES] * [MOC] / [MOC] = [RES]\n    return transferAmount.div(libConfig.mocPrecision);\n  }\n\n   /**\n    @dev Max amount of ReserveTokens allowed to be used to mint riskProx: MaxriskProx = nStableToken/ (PEG*B*(lev-1))\n    @param nStableToken number of StableToken [using mocPrecision]\n    @param peg peg value\n    @param reservePrice ReserveTokens price [using mocPrecision]\n    @param lev leverage [using mocPrecision]\n    @return Max riskProx ReserveTokens value [using reservePrecision]\n  */\n  function maxRiskProxResTokenValue(\n    MocLibConfig storage libConfig, uint256 nStableToken, uint256 peg, uint256 reservePrice, uint256 lev\n  ) public view returns(uint256)  {\n    require(libConfig.reservePrecision > 0, \"Invalid Precision\");\n    require(libConfig.mocPrecision > 0, \"Invalid Precision\");\n\n    if (lev <= libConfig.mocPrecision) {\n      return 0;\n    }\n    // (lev-1)\n    // [MOC]\n    uint256 levSubOne = lev.sub(libConfig.mocPrecision);\n\n    // PEG * ResTokenPrice\n    // [MOC]\n    uint256 pegTimesPrice = peg.mul(reservePrice);\n\n    // This intentionally avoid using safeMath to handle overflow case\n    // PEG * ResTokenPrice * (lev - 1)\n    // [MOC] * [MOC]\n    uint256 dividend = pegTimesPrice * levSubOne;\n\n    if (dividend / pegTimesPrice != levSubOne)\n      return 0; // INFINIT dividend means 0\n\n    // nStableToken adjusted with precisions\n    // [MOC] [RES]\n    uint256 divider = nStableToken.mul(libConfig.reservePrecision);\n\n    // [MOC] [RES] [MOC] / [MOC] [MOC]\n    return divider.mul(libConfig.mocPrecision).div(dividend);\n  }\n\n  /**\n    @dev Calculates the equivalent in MoC of the reserve token\n    @param resTokensAmount Total ReserveTokens amount\n    @param reservePrice ReserveTokens price\n    @param mocPrice MoC price\n    @return Equivalent MoC amount\n  */\n  function maxMoCWithReserveToken(\n    MocLibConfig storage /*libConfig*/, uint256 resTokensAmount, uint256 reservePrice, uint256 mocPrice\n  ) public pure returns(uint256) {\n    return reservePrice.mul(resTokensAmount).div(mocPrice);\n  }\n\n  /**\n    @dev Calculates the equivalent in reserve token of the MoC amount\n    @param amount MoC amount\n    @param reservePrice ReserveTokens price\n    @param mocPrice MoC price\n    @return Equivalent ReserveToken amount\n  */\n  function mocReserveTokenValue(\n    MocLibConfig storage /*libConfig*/, uint256 amount, uint256 reservePrice, uint256 mocPrice\n  ) public pure returns(uint256) {\n    require(reservePrice > 0,\"ReserveToken price should be more than zero\");\n    require(mocPrice > 0,\"MoC price should be more than zero\");\n\n    uint256 mocReserveTokenTotal = amount.mul(mocPrice).div(reservePrice);\n\n    return mocReserveTokenTotal;\n  }\n\n  /**\n    @dev Rounding product adapted from DSMath but with custom precision\n    @param x Multiplicand\n    @param y Multiplier\n    @return Product\n  */\n  function mulr(uint x, uint y, uint256 precision) internal pure returns (uint z) {\n    return x.mul(y).add(precision.div(2)).div(precision);\n  }\n\n  /**\n    @dev Potentiation by squaring adapted from DSMath but with custom precision\n    @param x Base\n    @param n Exponent\n    @return power\n  */\n  function pow(uint256 x, uint256 n, uint256 precision) internal pure returns (uint z) {\n    uint256 x2 = x;\n    z = n % 2 != 0 ? x : precision;\n\n    for (n /= 2; n != 0; n /= 2) {\n      x2 = mulr(x2, x2, precision);\n\n      if (n % 2 != 0) {\n        z = mulr(z, x2, precision);\n      }\n    }\n  }\n}\n\n// File: contracts/MoCLibConnection.sol\n\npragma solidity 0.5.8;\n\n\n/**\n  @dev Interface with MocHelperLib\n */\ncontract MoCLibConnection {\n  using MoCHelperLib for MoCHelperLib.MocLibConfig;\n  MoCHelperLib.MocLibConfig internal mocLibConfig;\n\n  /*\n  * Precision getters\n  */\n  function getMocPrecision() public view returns(uint256) {\n    return mocLibConfig.mocPrecision;\n  }\n\n  function getReservePrecision() public view returns(uint256) {\n    return mocLibConfig.reservePrecision;\n  }\n\n  function getDayPrecision() public view returns(uint256) {\n    return mocLibConfig.dayPrecision;\n  }\n\n  function initializePrecisions() internal {\n    mocLibConfig = MoCHelperLib.MocLibConfig({\n      reservePrecision: 10 ** 18,\n      mocPrecision: 10 ** 18,\n      dayPrecision: 1\n    });\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/interface/IMoCState.sol\n\npragma solidity 0.5.8;\n\ninterface IMoCState {\n\n     /******STATE MACHINE*********/\n    enum States {\n        // State 0\n        Liquidated,\n        // State 1\n        RiskProDiscount,\n        // State 2\n        BelowCobj,\n        // State 3\n        AboveCobj\n    }\n\n\n    function addToReserves(uint256 reserveAmount) external;\n\n    function substractFromReserves(uint256 reserveAmount) external;\n\n    function coverage(bytes32 bucket) external view returns(uint256);\n\n    function getReservesRemainder() external view returns(uint256);\n\n    function liq() external view returns(uint256);\n\n    function state() external view returns(States);\n\n    function peg() external view returns(uint256);\n\n    function dayBlockSpan() external view returns(uint256);\n\n    function getReserveTokenPrice() external view returns(uint256);\n\n    function getMoCPrice() external view returns(uint256);\n\n    function getProtected() external view returns(uint256);\n\n    function globalCoverage() external view returns(uint256);\n\n    function getMoCVendors() external view returns(address);\n\n    function getMoCToken() external view returns(address);\n\n    function nextState() external;\n\n    function maxRiskProWithDiscount() external view returns(uint256);\n\n    function absoluteMaxRiskPro() external view returns(uint256);\n\n    function absoluteMaxStableToken() external view returns(uint256);\n\n    function freeStableToken() external view returns(uint256);\n\n    function riskProTecPrice() external view returns(uint256);\n\n    function riskProSpotDiscountRate() external view returns(uint256);\n\n    function riskProDiscountPrice() external view returns(uint256);\n\n    function bucketRiskProTecPrice(bytes32 bucket) external view returns(uint256);\n\n    function currentAbundanceRatio() external view returns(uint256);\n\n    function abundanceRatio(uint256 stableToken0) external view returns(uint256);\n\n    function daysToSettlement() external view returns(uint256);\n\n    function leverage(bytes32 bucket) external view returns(uint256);\n\n    function getBucketNReserve(bytes32 bucket) external view returns(uint256);\n\n    function getLiquidationPrice() external view returns(uint256);\n\n    function maxRiskProxResTokenValue(bytes32 bucket) external view returns(uint256);\n\n    function bucketRiskProTecPriceHelper(bytes32 bucket) external view returns(uint256);\n}\n\n// File: contracts/base/MoCWhitelist.sol\n\npragma solidity 0.5.8;\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCWhitelist {\n  mapping(address => bool) whitelist;\n\n  /**\n   * @dev Check if an account is whitelisted\n   * @return Bool\n   */\n  function isWhitelisted(address account)\n    public\n    view\n    returns (bool)\n  {\n    require(account != address(0), \"Account must not be 0x0\");\n    return whitelist[account];\n  }\n\n  /**\n   * @dev Add account to whitelist\n   */\n  function add(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(!isWhitelisted(account), \"Account not allowed to add accounts into white list\");\n    whitelist[account] = true;\n  }\n\n  /**\n   * @dev Remove account from whitelist\n   */\n  function remove(address account) internal {\n    require(account != address(0), \"Account must not be 0x0\");\n    require(isWhitelisted(account), \"Account is not allowed to remove address from the white list\");\n\n    whitelist[account] = false;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/base/MoCConnector.sol\n\npragma solidity 0.5.8;\n\n\n\n/**\n  @dev Provides access control between all MoC Contracts\n */\ncontract MoCConnector is MoCWhitelist, Initializable {\n  // References\n  address payable public moc;\n  address public stableToken;\n  address public riskProToken;\n  address public riskProxManager;\n  address public mocState;\n  address public mocConverter;\n  address public mocSettlement;\n  address public mocExchange;\n  address public mocInrate;\n  /** DEPRECATED mocBurnout **/\n  address public mocBurnout;\n  address public reserveToken;\n\n  bool internal initialized;\n\n  /**\n    @dev Initializes the contract\n    @param mocAddress MoC contract address\n    @param stableTokenAddress Stable token contract address\n    @param riskProAddress RiskPro token contract address\n    @param riskProxAddress RiskProxManager contract address\n    @param stateAddress MoCState contract address\n    @param settlementAddress MoCSettlement contract address\n    @param converterAddress MoCConverter contract address\n    @param exchangeAddress MoCExchange contract address\n    @param inrateAddress MoCInrate contract address\n    @param burnoutBookAddress (DEPRECATED) MoCBurnout contract address. DO NOT USE.\n    @param reserveTokenAddress Reserve token contract address\n  */\n  function initialize(\n    address payable mocAddress,\n    address stableTokenAddress,\n    address riskProAddress,\n    address riskProxAddress,\n    address stateAddress,\n    address settlementAddress,\n    address converterAddress,\n    address exchangeAddress,\n    address inrateAddress,\n    address burnoutBookAddress,\n    address reserveTokenAddress\n  ) public initializer {\n    moc = mocAddress;\n    stableToken = stableTokenAddress;\n    riskProToken = riskProAddress;\n    riskProxManager = riskProxAddress;\n    mocState = stateAddress;\n    mocSettlement = settlementAddress;\n    mocConverter = converterAddress;\n    mocExchange = exchangeAddress;\n    mocInrate = inrateAddress;\n    mocBurnout = burnoutBookAddress;\n    reserveToken = reserveTokenAddress;\n\n    // Add to Whitelist\n    add(mocAddress);\n    add(stableTokenAddress);\n    add(riskProAddress);\n    add(riskProxAddress);\n    add(stateAddress);\n    add(settlementAddress);\n    add(converterAddress);\n    add(exchangeAddress);\n    add(inrateAddress);\n    add(burnoutBookAddress);\n    add(reserveTokenAddress);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/base/MoCConstants.sol\n\npragma solidity 0.5.8;\n\n/**\n * @dev Defines special constants to use along all the MoC System\n */\ncontract MoCConstants {\n  bytes32 constant public BUCKET_X2 = \"X2\";\n  bytes32 constant public BUCKET_C0 = \"C0\";\n}\n\n// File: contracts/base/MoCBase.sol\n\npragma solidity 0.5.8;\n\n\n\n\n/**\n  @dev General usefull modifiers and functions\n */\ncontract MoCBase is MoCConstants, Initializable {\n  // Contracts\n  MoCConnector public connector;\n\n  bool internal initialized;\n\n  function initializeBase(address connectorAddress) internal initializer {\n    connector = MoCConnector(connectorAddress);\n  }\n\n  modifier onlyWhitelisted(address account) {\n    require(connector.isWhitelisted(account), \"Address is not whitelisted\");\n    _;\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: openzeppelin-solidity/contracts/math/Math.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n\n// File: contracts/MoCBucketContainer.sol\n\npragma solidity 0.5.8;\n\n\n\n\n\n\ncontract MoCBucketContainer is MoCBase, Governed {\n  using SafeMath for uint256;\n  using Math for uint256;\n\n  struct RiskProxBalance {\n    uint256 value;\n    uint256 index; // Index start in 1, zero is reserved for NULL\n  }\n\n  struct MoCBucket {\n    bytes32 name;\n    bool isBase;\n    uint256 nStable;\n    uint256 nRiskPro;\n    uint256 nReserve;\n    uint256 cobj;\n    // Should only be used in X buckets\n    mapping(address => RiskProxBalance) riskProxBalances;\n    address payable[] activeBalances;\n    uint256 activeBalancesLength;\n    // Should only be used in Base buckets (C0)\n    uint256 inrateBag;\n    bool available;\n  }\n\n  event BucketMovement(\n    bytes32 from,\n    bytes32 to,\n    uint256 reserves,\n    uint256 stableTokens\n  );\n\n  event BucketCreation(\n    bytes32 name,\n    uint256 cobj\n  );\n\n  event BucketStateUpdate(\n    bytes32 name,\n    uint256 nReserve,\n    uint256 nStable,\n    uint256 nRiskProx,\n    uint256 inrateBag\n  );\n\n  mapping(bytes32 => MoCBucket) internal mocBuckets;\n\n  /**\n   GETTERS\n   */\n  function getBucketNReserve(bytes32 bucket) public view returns (uint256) {\n    return mocBuckets[bucket].nReserve;\n  }\n\n  function getBucketNRiskPro(bytes32 bucket) public view returns (uint256) {\n    return mocBuckets[bucket].nRiskPro;\n  }\n\n  function getBucketNStableToken(bytes32 bucket) public view returns (uint256) {\n    return mocBuckets[bucket].nStable;\n  }\n\n  function getBucketCobj(bytes32 bucket) public view returns (uint256) {\n    return mocBuckets[bucket].cobj;\n  }\n\n  function getInrateBag(bytes32 bucket) public view returns (uint256) {\n    return mocBuckets[bucket].inrateBag;\n  }\n\n  /**\n   * @dev Sets the objective coverage (cobj) on an specficied bucket.\n   * @param  _bucket - name of the bucket\n   * @param  _cobj - new value of cobj\n   */\n  function setBucketCobj(bytes32 _bucket, uint256 _cobj) public onlyAuthorizedChanger() {\n    //TODO: It is necessary to analyze the impact in the model it has when changing X2. This\n    mocBuckets[_bucket].cobj = _cobj;\n  }\n\n  /**\n    @dev returns true if the bucket is a base bucket\n    @param bucket Name of the bucket\n  **/\n  function isBucketBase(bytes32 bucket) public view returns (bool) {\n    return mocBuckets[bucket].isBase;\n  }\n\n  /**\n    @dev returns true if the bucket have stableTokens in it\n    @param bucket Name of the bucket\n  **/\n  function isBucketEmpty(bytes32 bucket) public view returns (bool) {\n    return mocBuckets[bucket].nStable == 0;\n  }\n\n  /**\n    @dev Returns all the address that currently have riskProx position for this bucket\n    @param bucket bucket of the active address\n  */\n  function getActiveAddresses(bytes32 bucket) public view returns (address payable[] memory) {\n    return mocBuckets[bucket].activeBalances;\n  }\n\n  /**\n    @dev Returns all the address that currently have riskProx position for this bucket\n    @param bucket bucket of the active address\n  */\n  function getActiveAddressesCount(bytes32 bucket) public view returns (uint256 count) {\n    return mocBuckets[bucket].activeBalancesLength;\n  }\n\n  /**\n    @dev Add values to all variables of the bucket\n    @param bucketName Name of the bucket\n    @param reserveTokens ReserveToken amount [using reservePrecision]\n    @param stableToken StableToken amount [using mocPrecision]\n    @param riskProx RiskProx amount [using mocPrecision]\n  */\n  function addValuesToBucket(bytes32 bucketName, uint256 reserveTokens, uint256 stableToken, uint256 riskProx)\n  public onlyWhitelisted(msg.sender) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    bucket.nReserve = bucket.nReserve.add(reserveTokens);\n    bucket.nStable = bucket.nStable.add(stableToken);\n    bucket.nRiskPro = bucket.nRiskPro.add(riskProx);\n  }\n\n  /**\n    @dev Substract values to all variables of the bucket\n    @param bucketName Name of the bucket\n    @param reserve ReserveToken amount [using reservePrecision]\n    @param stableToken StableToken amount [using mocPrecision]\n    @param riskProx RiskProx amount [using mocPrecision]\n  */\n  function substractValuesFromBucket(bytes32 bucketName, uint256 reserve, uint256 stableToken, uint256 riskProx)\n  public onlyWhitelisted(msg.sender) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    bucket.nReserve = bucket.nReserve.sub(reserve);\n    bucket.nStable = bucket.nStable.sub(stableToken);\n    bucket.nRiskPro = bucket.nRiskPro.sub(riskProx);\n  }\n\n  /**\n    @dev Moves ReserveTokens from inrateBag to main ReserveTokens bucket bag\n    @param bucketName Name of the bucket to operate\n    @param amount value to move from inrateBag to main bag [using reservePrecision]\n   */\n  function deliverInrate(bytes32 bucketName, uint256 amount) public\n   onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) bucketStateUpdate(bucketName) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    uint256 toMove = Math.min(bucket.inrateBag, amount);\n\n    bucket.inrateBag = bucket.inrateBag.sub(toMove);\n    bucket.nReserve = bucket.nReserve.add(toMove);\n  }\n\n  /**\n    @dev Removes Interests rate from Inrate bag\n    @param bucketName Name of the bucket to operate\n    @param amount value to move from inrateBag to main bag [using reservePrecision]\n    @return Retrieved value\n   */\n  function recoverInrate(bytes32 bucketName, uint256 amount) public\n  onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) bucketStateUpdate(bucketName) returns(uint256) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n\n    uint256 toRetrieve = Math.min(bucket.inrateBag, amount);\n\n    bucket.inrateBag = bucket.inrateBag.sub(toRetrieve);\n\n    return toRetrieve;\n  }\n\n  /**\n    @dev Moves ReserveTokens from origin bucket to destination bucket inrateBag\n    @param bucketName name of the bucket to from which takes\n    @param reserveAmount value to add to main bag [using reservePrecision]\n  */\n  function payInrate(bytes32 bucketName, uint256 reserveAmount) public\n  onlyWhitelisted(msg.sender) onlyBaseBucket(bucketName) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n    bucket.inrateBag = bucket.inrateBag.add(reserveAmount);\n  }\n\n  /**\n    @dev Move ReserveTokens and StableTokens from one bucket to another\n    @param from Name of bucket from where the ReserveTokens will be removed\n    @param to Name of bucket from where the ReserveTokens will be added\n    @param reserve ReserveTokens amount [using reservePrecision]\n    @param stableTokens StableTokens amount [using mocPrecision]\n  **/\n  function moveResTokensAndStableTokens(bytes32 from, bytes32 to, uint256 reserve, uint256 stableTokens) public\n  onlyWhitelisted(msg.sender) bucketStateUpdate(from) bucketStateUpdate(to) {\n    MoCBucket storage bucketFrom = mocBuckets[from];\n    MoCBucket storage bucketTo = mocBuckets[to];\n\n    bucketFrom.nReserve = bucketFrom.nReserve.sub(reserve);\n    bucketTo.nReserve = bucketTo.nReserve.add(reserve);\n\n    bucketFrom.nStable = bucketFrom.nStable.sub(stableTokens);\n    bucketTo.nStable = bucketTo.nStable.add(stableTokens);\n\n    emit BucketMovement(from, to, reserve, stableTokens);\n  }\n\n  /**\n    @dev Clears completely the origin bucket, removing all StableTokens, ReserveTokens and riskProxs\n    @param toLiquidate Bucket to be cleared out\n    @param destination Bucket that will receive the StableTokens and ReserveTokens\n   */\n  function liquidateBucket(bytes32 toLiquidate, bytes32 destination) public onlyWhitelisted(msg.sender) {\n    require(!isBucketBase(toLiquidate), \"Cannot liquidate a base bucket\");\n\n    clearBucketBalances(toLiquidate);\n    emptyBucket(toLiquidate, destination);\n  }\n\n  /**\n    @dev Clears StableTokens and ReserveTokens from bucket origin and sends them to destination bucket\n    @param origin Bucket to clear out\n    @param destination Destination bucket\n  **/\n  function emptyBucket(bytes32 origin, bytes32 destination) public onlyWhitelisted(msg.sender) {\n    moveResTokensAndStableTokens(origin, destination, mocBuckets[origin].nReserve, mocBuckets[origin].nStable);\n  }\n\n  /**\n   * @dev checks if a bucket exists\n   * @param bucket name of the bucket\n   */\n  function isAvailableBucket(bytes32 bucket) public view returns (bool) {\n    return mocBuckets[bucket].available;\n  }\n\n  /**\n    @dev Put all bucket RiskProx balances in zero\n    @param bucketName Bucket to clear out\n   */\n  function clearBucketBalances(bytes32 bucketName) public onlyWhitelisted(msg.sender) {\n    MoCBucket storage bucket = mocBuckets[bucketName];\n    bucket.nRiskPro = 0;\n    bucket.activeBalancesLength = 0;\n  }\n\n  /**\n    @dev Creates bucket\n    @param name Name of the bucket\n    @param cobj Target Coverage of the bucket\n    @param isBase Indicates if it is a base bucket (true) or not (false)\n  */\n  function createBucket(bytes32 name, uint256 cobj, bool isBase) internal {\n    mocBuckets[name].name = name;\n    mocBuckets[name].nStable = 0;\n    mocBuckets[name].nRiskPro = 0;\n    mocBuckets[name].nReserve = 0;\n    mocBuckets[name].cobj = cobj;\n    mocBuckets[name].isBase = isBase;\n    mocBuckets[name].available = true;\n    emit BucketCreation(name, cobj);\n  }\n\n  modifier onlyBaseBucket(bytes32 bucket) {\n    require(isBucketBase(bucket), \"Bucket should be a base type bucket\");\n    _;\n  }\n\n  modifier bucketStateUpdate(bytes32 bucket) {\n    _;\n    emit BucketStateUpdate(\n      bucket,\n      mocBuckets[bucket].nReserve,\n      mocBuckets[bucket].nStable,\n      mocBuckets[bucket].nRiskPro,\n      mocBuckets[bucket].inrateBag\n    );\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/MoCRiskProxManager.sol\n\npragma solidity 0.5.8;\n\n\n\n\n\ncontract MoCRiskProxManager is MoCBucketContainer {\n  using SafeMath for uint256;\n  uint256 constant MIN_ALLOWED_BALANCE = 0;\n\n  function initialize(address connectorAddress, address _governor, uint256 _c0Cobj, uint256 _x2Cobj) public initializer {\n    initializeBase(connectorAddress);\n    initializeValues(_governor);\n    createBucket(BUCKET_C0, _c0Cobj, true);\n    createBucket(BUCKET_X2, _x2Cobj, false);\n  }\n\n  /**\n    @dev returns user balance\n    @param bucket RiskProx corresponding bucket to get balance from\n    @param userAddress user address to get balance from\n    @return total balance for the userAddress\n  */\n  function riskProxBalanceOf(bytes32 bucket, address userAddress) public view returns (uint256) {\n    RiskProxBalance memory userBalance = mocBuckets[bucket].riskProxBalances[userAddress];\n    if (!hasValidBalance(bucket, userAddress, userBalance.index)) return 0;\n    return userBalance.value;\n  }\n\n  /**\n    @dev verifies that this user has assigned balance for the given bucket\n    @param bucket corresponding Leveraged bucket to get balance from\n    @param userAddress user address to verify balance for\n    @param index index, starting from 1, where the address of the user is being kept\n    @return true if the user has assigned balance\n  */\n  function hasValidBalance(bytes32 bucket, address userAddress, uint256 index) public view returns (bool) {\n    return (index != 0) && (index <= getActiveAddressesCount(bucket)) && (mocBuckets[bucket].activeBalances[index - 1] == userAddress);\n  }\n\n  /**\n    @dev  Assigns the amount of RiskProx\n    @param bucket bucket from which the RiskProx will be removed\n    @param account user address to redeem for\n    @param riskProxAmount riskProx amount to redeem [using mocPresicion]\n    @param totalCost ReserveToken value of riskProxAmount [using reservePrecision]\n  */\n  function assignRiskProx(bytes32 bucket, address payable account, uint256 riskProxAmount, uint256 totalCost)\n    public\n    onlyWhitelisted(msg.sender)\n  {\n    uint256 currentBalance = riskProxBalanceOf(bucket, account);\n\n    setRiskProxBalanceOf(bucket, account, currentBalance.add(riskProxAmount));\n    addValuesToBucket(bucket, totalCost, 0, riskProxAmount);\n  }\n\n  /**\n    @dev  Removes the amount of RiskProx and substract ReserveTokens from bucket\n    @param bucket bucket from which the RiskProx will be removed\n    @param userAddress user address to redeem for\n    @param riskProxAmount riskProx amount to redeem [using mocPresicion]\n    @param totalCost reserveToken value of riskProxAmount [using reservePrecision]\n  */\n  function removeRiskProx(bytes32 bucket, address payable userAddress, uint256 riskProxAmount, uint256 totalCost)\n    public\n    onlyWhitelisted(msg.sender)\n  {\n    uint256 currentBalance = riskProxBalanceOf(bucket, userAddress);\n\n    setRiskProxBalanceOf(bucket, userAddress, currentBalance.sub(riskProxAmount));\n    substractValuesFromBucket(bucket, totalCost, 0, riskProxAmount);\n  }\n\n  /**\n    @dev Sets the amount of RiskProx\n    @param bucket bucket from which the RiskProx will be setted\n    @param userAddress user address to redeem for\n    @param value riskProx amount to redeem [using mocPresicion]\n  */\n  function setRiskProxBalanceOf(bytes32 bucket, address payable userAddress, uint256 value) public onlyWhitelisted(msg.sender) {\n    mocBuckets[bucket].riskProxBalances[userAddress].value = value;\n\n    uint256 index = mocBuckets[bucket].riskProxBalances[userAddress].index;\n    if (!hasValidBalance(bucket, userAddress, index)) index = 0;\n\n    bool hasBalance = value > MIN_ALLOWED_BALANCE;\n    // The address is not in the array\n    if (index == 0) {\n      if (hasBalance) {\n        if (mocBuckets[bucket].activeBalances.length == mocBuckets[bucket].activeBalancesLength) {\n          mocBuckets[bucket].activeBalances.length += 1;\n        }\n        uint256 currentIndex = mocBuckets[bucket].activeBalancesLength++;\n        mocBuckets[bucket].activeBalances[currentIndex] = userAddress;\n        mocBuckets[bucket].riskProxBalances[userAddress].index = mocBuckets[bucket].activeBalancesLength;\n      }\n    } else {\n      if (!hasBalance) {\n        // We need to delete this address from the tracker\n        uint256 lastActiveIndex = mocBuckets[bucket].activeBalancesLength;\n        address payable keyToMove = mocBuckets[bucket].activeBalances[lastActiveIndex - 1];\n        mocBuckets[bucket].activeBalances[index - 1] = keyToMove;\n        // Alternative index and array decreases lenght to prevent gas limit\n        mocBuckets[bucket].activeBalancesLength--;\n        // Update moved key index\n        mocBuckets[bucket].riskProxBalances[keyToMove].index = index;\n        // Disable empty account index (0 == NULL)\n        mocBuckets[bucket].riskProxBalances[userAddress].index = 0;\n      }\n    }\n  }\n\n  /**\n   * @dev intializes values of the contract\n   */\n  function initializeValues(address _governor) internal {\n    governor = IGovernor(_governor);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/MoCConverter.sol\n\npragma solidity 0.5.8;\n\n\n\n\ncontract MoCConverter is MoCBase, MoCLibConnection {\n  IMoCState internal mocState;\n\n  function initialize(address connectorAddress) public initializer {\n    initializePrecisions();\n    initializeBase(connectorAddress);\n    mocState = IMoCState(connector.mocState());\n  }\n\n  /**\n  * @dev ReserveTokens equivalent for the amount of riskPros given\n  * @param amount Amount of RiskPro to calculate the total price\n  * @return total ReserveTokens Price of the amount RiskPros [using reservePrecision].\n  */\n  function riskProToResToken(uint256 amount) public view returns (uint256) {\n    uint256 tecPrice = mocState.riskProTecPrice();\n\n    return mocLibConfig.totalRiskProInResTokens(amount, tecPrice);\n  }\n\n  /**\n  * @dev Converts Reserve to RiskPro\n  * @param resTokensAmount Reserve amount\n  * @return RiskPro amount\n  */\n  function resTokenToRiskPro(uint256 resTokensAmount) public view returns (uint256) {\n    return mocLibConfig.maxRiskProWithResTokens(resTokensAmount, mocState.riskProTecPrice());\n  }\n\n  /**\n  * @dev ReserveTokens equivalent for the amount of riskPro given applying the spotDiscountRate\n  * @param amount amount of RiskPro [using reservePrecision]\n  * @return Reserve amount\n  */\n  function riskProDiscToResToken(uint256 amount) public view returns(uint256) {\n    uint256 discountRate = mocState.riskProSpotDiscountRate();\n    uint256 totalResTokensValuet = riskProToResToken(amount);\n\n    return mocLibConfig.applyDiscountRate(totalResTokensValuet, discountRate);\n  }\n\n  function resTokenToRiskProDisc(uint256 resTokensAmount) public view returns (uint256) {\n    return mocLibConfig.maxRiskProWithResTokens(resTokensAmount, mocState.riskProDiscountPrice());\n  }\n\n  function stableTokensToResToken(uint256 stableTokenAmount) public view returns (uint256) {\n    return mocLibConfig.stableTokensResTokensValue(stableTokenAmount, mocState.peg(), mocState.getReserveTokenPrice());\n  }\n\n  function stableTokensToResTokenWithPrice(uint256 stableTokenAmount, uint256 reservePrice) public view returns (uint256) {\n    return mocLibConfig.stableTokensResTokensValue(stableTokenAmount, mocState.peg(), reservePrice);\n  }\n\n  function resTokenToStableToken(uint256 resTokensAmount) public view returns (uint256) {\n    return mocLibConfig.maxStableTokensWithResTokens(resTokensAmount, mocState.getReserveTokenPrice());\n  }\n\n  function riskProxToResToken(uint256 riskProxAmount, bytes32 bucket) public view returns (uint256) {\n    return mocLibConfig.riskProResTokensValuet(riskProxAmount, mocState.bucketRiskProTecPrice(bucket));\n  }\n\n  function riskProxToResTokenHelper(uint256 riskProxAmount, bytes32 bucket) public view returns(uint256) {\n    return mocLibConfig.riskProResTokensValuet(riskProxAmount, mocState.bucketRiskProTecPriceHelper(bucket));\n  }\n\n  function resTokenToRiskProx(uint256 resTokensAmount, bytes32 bucket) public view returns (uint256) {\n    return mocLibConfig.maxRiskProWithResTokens(resTokensAmount, mocState.bucketRiskProTecPrice(bucket));\n  }\n\n  function resTokenToRiskProWithPrice(uint256 resTokensAmount, uint256 price) public view returns (uint256) {\n    return mocLibConfig.maxRiskProWithResTokens(resTokensAmount, price);\n  }\n\n  function riskProToResTokenWithPrice(uint256 riskProAmount, uint256 riskProPrice) public view returns (uint256) {\n    return mocLibConfig.riskProResTokensValuet(riskProAmount, riskProPrice);\n  }\n\n  function mocToResToken(uint256 mocAmount) public view returns(uint256) {\n    return mocLibConfig.mocReserveTokenValue(mocAmount, mocState.getReserveTokenPrice(), mocState.getMoCPrice());\n  }\n\n  function resTokenToMoC(uint256 resTokensAmount) public view returns(uint256) {\n    return mocLibConfig.maxMoCWithReserveToken(resTokensAmount, mocState.getReserveTokenPrice(), mocState.getMoCPrice());\n  }\n\n  function mocToResTokenWithPrice(uint256 mocAmount, uint256 reservePrice, uint256 mocPrice) public view returns(uint256) {\n    return mocLibConfig.mocReserveTokenValue(mocAmount, reservePrice, mocPrice);\n  }\n\n  function resTokenToMoCWithPrice(uint256 resTokensAmount, uint256 reservePrice, uint256 mocPrice) public view returns(uint256) {\n    return mocLibConfig.maxMoCWithReserveToken(resTokensAmount, reservePrice, mocPrice);\n  }\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n\n// File: contracts/interface/IMoCVendors.sol\n\npragma solidity 0.5.8;\n\ninterface IMoCVendors {\n    function resetTotalPaidInMoC() external;\n\n    function getIsActive(address account) external view\n    returns (bool);\n\n    function getTotalPaidInMoC(address account) external view\n    returns (uint256);\n\n    function getStaking(address account) external view\n    returns (uint256);\n\n    function getMarkup(address account) external view\n    returns (uint256);\n\n    function updatePaidMarkup(address account, uint256 mocAmount, uint256 reserveAmount, uint256 totalMoCAmount) external;\n}\n\n// File: contracts/interface/IMoCInrate.sol\n\npragma solidity 0.5.8;\n\ninterface IMoCInrate {\n    // Transaction types\n    function MINT_RISKPRO_FEES_RESERVE() external view returns(uint8);\n    function REDEEM_RISKPRO_FEES_RESERVE() external view returns(uint8);\n    function MINT_STABLETOKEN_FEES_RESERVE() external view returns(uint8);\n    function REDEEM_STABLETOKEN_FEES_RESERVE() external view returns(uint8);\n    function MINT_RISKPROX_FEES_RESERVE() external view returns(uint8);\n    function REDEEM_RISKPROX_FEES_RESERVE() external view returns(uint8);\n    function MINT_RISKPRO_FEES_MOC() external view returns(uint8);\n    function REDEEM_RISKPRO_FEES_MOC() external view returns(uint8);\n    function MINT_STABLETOKEN_FEES_MOC() external view returns(uint8);\n    function REDEEM_STABLETOKEN_FEES_MOC() external view returns(uint8);\n    function MINT_RISKPROX_FEES_MOC() external view returns(uint8);\n    function REDEEM_RISKPROX_FEES_MOC() external view returns(uint8);\n\n    function dailyInratePayment() external returns(uint256);\n\n    function payRiskProHoldersInterestPayment() external returns(uint256);\n\n    function calculateRiskProHoldersInterest() external view returns(uint256, uint256);\n\n    function getRiskProInterestAddress() external view returns(address payable);\n\n    function getRiskProRate() external view returns(uint256);\n\n    function getRiskProInterestBlockSpan() external view returns(uint256);\n\n    function isDailyEnabled() external view returns(bool);\n\n    function isRiskProInterestEnabled() external view returns(bool);\n\n    function commissionsAddress() external view returns(address payable);\n\n    function calcCommissionValue(uint256 reserveAmount, uint8 txType) external view returns(uint256);\n\n    function calculateVendorMarkup(address vendorAccount, uint256 amount) external view returns (uint256 markup);\n\n    function calcStableTokenRedInterestValues(uint256 STABLETOKENAmount, uint256 reserveAmount) external view returns(uint256);\n\n    function calcMintInterestValues(bytes32 bucket, uint256 reserveAmount) external view returns(uint256);\n\n    function calcFinalRedeemInterestValue(bytes32 bucket, uint256 reserveToRedeem) external view returns(uint256);\n\n    function setRiskProInterestBlockSpan(uint256 newBitProBlockSpan) external;\n}\n\n// File: contracts/MoCInrate.sol\n\npragma solidity 0.5.8;\n\n\n\n\n\n\n\n\n\n\ncontract MoCInrateEvents {\n  event InrateDailyPay(uint256 amount, uint256 daysToSettlement, uint256 nReserveBucketC0);\n  event RiskProHoldersInterestPay(uint256 amount, uint256 nReserveBucketC0BeforePay);\n}\n\ncontract MoCInrateStructs {\n  struct InrateParams {\n    uint256 tMax;\n    uint256 tMin;\n    uint256 power;\n  }\n\n  InrateParams riskProxParams = InrateParams({\n    tMax: 261157876067800,\n    tMin: 0,\n    power: 1\n  });\n}\n\n\ncontract MoCInrate is MoCInrateEvents, MoCInrateStructs, MoCBase, MoCLibConnection, Governed, IMoCInrate {\n  using SafeMath for uint256;\n\n  // Last block when a payment was executed\n  uint256 public lastDailyPayBlock;\n  // Absolute  RiskPro holders rate for the given riskProInterestBlockSpan time span. [using mocPrecision]\n  uint256 public riskProRate;\n  // Target address to transfer RiskPro holders interests\n  address payable public riskProInterestAddress;\n  // Last block when an RiskPro holders instereste was calculated\n  uint256 public lastRiskProInterestBlock;\n  // RiskPro interest Blockspan to configure blocks between payments\n  uint256 public riskProInterestBlockSpan;\n\n  // Target addres to transfer commissions of mint/redeem\n  address payable public commissionsAddress;\n  /** UPDATE V0110: 24/09/2020 - Upgrade to support multiple commission rates **/\n  /** DEPRECATED **/\n  // commissionRate [using mocPrecision]\n  // solium-disable-next-line mixedcase\n  uint256 public DEPRECATED_commissionRate;\n\n  /************************************/\n  /***** UPGRADE v017       ***********/\n  /************************************/\n\n  /** START UPDATE V017: 01/11/2019 **/\n\n  // Upgrade to support redeem stable inrate parameter\n  uint256 public stableTmin;\n  uint256 public stablePower;\n  uint256 public stableTmax;\n\n  /**CONTRACTS**/\n  IMoCState internal mocState;\n  MoCConverter internal mocConverter;\n  MoCRiskProxManager internal riskProxManager;\n\n  function setStableTmin(uint256 _stableTmin) public onlyAuthorizedChanger() {\n    stableTmin = _stableTmin;\n  }\n\n  function setStableTmax(uint256 _stableTmax) public onlyAuthorizedChanger() {\n    stableTmax = _stableTmax;\n  }\n\n  function setStablePower(uint256 _stablePower) public onlyAuthorizedChanger() {\n    stablePower = _stablePower;\n  }\n\n  function getStableTmin() public view returns (uint256) {\n    return stableTmin;\n  }\n\n  function getStableTmax() public view returns (uint256) {\n    return stableTmax;\n  }\n\n  function getStablePower() public view returns (uint256) {\n    return stablePower;\n  }\n\n  /**\n    @dev Calculates an average interest rate between after and before free stableToken Redemption\n    @param stableTokenRedeem StableTokens to redeem [using mocPrecision]\n    @return Interest rate value [using mocPrecision]\n   */\n  function stableTokenInrateAvg(uint256 stableTokenRedeem) public view returns (uint256) {\n    uint256 preAbRatio = mocState.currentAbundanceRatio();\n    uint256 posAbRatio = mocState.abundanceRatio(riskProxManager.getBucketNStableToken(BUCKET_C0).sub(stableTokenRedeem));\n\n    return mocLibConfig.inrateAvg(stableTmax, stablePower, stableTmin, preAbRatio, posAbRatio);\n  }\n\n  /** END UPDATE V017: 01/11/2019 **/\n\n  /**\n    @dev Initializes the contract\n    @param connectorAddress MoCConnector contract address\n    @param _governor Governor contract address\n    @param riskProxTmin  Minimum interest rate [using mocPrecision]\n    @param riskProxPower Power is a parameter for interest rate calculation [using noPrecision]\n    @param riskProxTmax Maximun interest rate [using mocPrecision]\n    @param _riskProRate BitPro holder interest rate [using mocPrecision]\n    @param blockSpanRiskPro BitPro blockspan to configure payments periods[using mocPrecision]\n    @param riskProInterestTargetAddress Target address to transfer the weekly BitPro holders interest\n    @param commissionsAddressTarget Target addres to transfer commissions of mint/redeem\n    @param _stableTmin Upgrade to support red stable inrate parameter\n    @param _stablePower Upgrade to support red stable inrate parameter\n    @param _stableTmax Upgrade to support red stable inrate parameter\n  */\n  function initialize(\n    address connectorAddress,\n    address _governor,\n    uint256 riskProxTmin,\n    uint256 riskProxPower,\n    uint256 riskProxTmax,\n    uint256 _riskProRate,\n    uint256 blockSpanRiskPro,\n    address payable riskProInterestTargetAddress,\n    address payable commissionsAddressTarget,\n    //uint256 commissionRateParam,\n    uint256 _stableTmin,\n    uint256 _stablePower,\n    uint256 _stableTmax\n  ) public initializer {\n    initializePrecisions();\n    initializeBase(connectorAddress);\n    initializeContracts();\n    initializeValues(\n      _governor,\n      riskProxTmin,\n      riskProxPower,\n      riskProxTmax,\n      _riskProRate,\n      commissionsAddressTarget,\n      //commissionRateParam,\n      blockSpanRiskPro,\n      riskProInterestTargetAddress,\n      _stableTmin,\n      _stablePower,\n      _stableTmax\n    );\n  }\n\n/**\n   * @dev gets tMin param of RiskProx tokens\n   * @return returns tMin of RiskProx\n   */\n  function getRiskProxTmin() public view returns (uint256) {\n    return riskProxParams.tMin;\n  }\n\n  /**\n   * @dev gets tMax param of RiskProx tokens\n   * @return returns tMax of RiskProx\n   */\n  function getRiskProxTmax() public view returns (uint256) {\n    return riskProxParams.tMax;\n  }\n\n  /**\n   * @dev gets power param of RiskProx tokens\n   * @return returns power of RiskProx\n   */\n  function getRiskProxPower() public view returns (uint256) {\n    return riskProxParams.power;\n  }\n\n  /**\n   * @dev Gets the blockspan of RiskPro that represents the frecuency of RiskPro holders intereset payment\n   * @return returns power of riskProInterestBlockSpan\n   */\n  function getRiskProInterestBlockSpan() public view returns (uint256) {\n    return riskProInterestBlockSpan;\n  }\n\n  /**\n   * @dev sets tMin param of RiskProx tokens\n   * @param _btxcTmin tMin of RiskProx\n   */\n  function setRiskProxTmin(uint256 _btxcTmin) public onlyAuthorizedChanger() {\n    riskProxParams.tMin = _btxcTmin;\n  }\n\n  /**\n   * @dev sets tMax param of RiskProx tokens\n   * @param _btxcTax tMax of RiskProx\n   */\n  function setRiskProxTmax(uint256 _btxcTax) public onlyAuthorizedChanger() {\n    riskProxParams.tMax = _btxcTax;\n  }\n\n  /**\n   * @dev sets power param of RiskProx tokens\n   * @param _btxcPower power of RiskProx\n   */\n  function setRiskProxPower(uint256 _btxcPower) public onlyAuthorizedChanger() {\n    riskProxParams.power = _btxcPower;\n  }\n\n  /**\n   @dev Gets the rate for RiskPro Holders\n   @return RiskPro Rate\n  */\n  function getRiskProRate() public view returns (uint256) {\n    return riskProRate;\n  }\n\n  // function getCommissionRate() public view returns(uint256) {\n  //   return commissionRate;\n  // }\n\n   /**\n    @dev Sets RiskPro Holders rate\n    @param newRiskProRate New RiskPro rate\n   */\n  function setRiskProRate(uint256 newRiskProRate) public onlyAuthorizedChanger() {\n    riskProRate = newRiskProRate;\n  }\n\n   /**\n    @dev Sets the blockspan RiskPro Intereset rate payment is enable to be executed\n    @param newRiskProBlockSpan New RiskPro Block span\n   */\n  function setRiskProInterestBlockSpan(uint256 newRiskProBlockSpan) public onlyAuthorizedChanger() {\n    riskProInterestBlockSpan = newRiskProBlockSpan;\n  }\n\n  /**\n   @dev Gets the target address to transfer RiskPro Holders rate\n   @return Target address to transfer RiskPro Holders interest\n  */\n  function getRiskProInterestAddress() public view returns (address payable) {\n    return riskProInterestAddress;\n  }\n\n  /**\n   @dev Sets the target address to transfer RiskPro Holders rate\n   @param newRiskProInterestAddress New RiskPro rate\n  */\n  function setRiskProInterestAddress(address payable newRiskProInterestAddress) public onlyAuthorizedChanger() {\n    riskProInterestAddress = newRiskProInterestAddress;\n  }\n\n  /**\n   @dev Sets the target address to transfer commissions of Mint/Redeem transactions\n   @param newCommissionsAddress New commisions address\n  */\n  function setCommissionsAddress(address payable newCommissionsAddress) public onlyAuthorizedChanger() {\n    commissionsAddress = newCommissionsAddress;\n  }\n\n  //  /**\n  //   @dev Sets the commission rate for Mint/Redeem transactions\n  //   @param newCommissionRate New commission rate\n  //  */\n  // function setCommissionRate(uint256 newCommissionRate) public onlyAuthorizedChanger() {\n  //   commissionRate = newCommissionRate;\n  // }\n\n  /**\n    @dev Calculates interest rate for RiskProx Minting, redeem and Free StableToken Redeem\n    @return Interest rate value [using RatePrecsion]\n   */\n  function spotInrate() public view returns (uint256) {\n    uint256 abRatio = mocState.currentAbundanceRatio();\n\n    return mocLibConfig.spotInrate(riskProxParams.tMax, riskProxParams.power, riskProxParams.tMin, abRatio);\n  }\n\n  /**\n    @dev Calculates an average interest rate between after and before mint/redeem\n    @param bucket Name of the bucket involved in the operation\n    @param resTokensAmount Value of the operation from which calculates the inrate [using reservePrecision]\n    @param onMinting Value that represents if the calculation is based on mint or on redeem\n    @return Interest rate value [using mocPrecision]\n   */\n  function riskProxInrateAvg(bytes32 bucket, uint256 resTokensAmount, bool onMinting) public view returns (uint256) {\n    uint256 preAbRatio = mocState.currentAbundanceRatio();\n    uint256 posAbRatio = mocState.abundanceRatio(simulateStableTokenMovement(bucket, resTokensAmount, onMinting));\n\n    return mocLibConfig.inrateAvg(riskProxParams.tMax, riskProxParams.power, riskProxParams.tMin, preAbRatio, posAbRatio);\n  }\n\n  /**\n    @dev returns the amount of ReserveTokens to pay in concept of interest to bucket C0\n   */\n  function dailyInrate() public view returns(uint256) {\n    uint256 daysToSettl = mocState.daysToSettlement();\n    uint256 totalInrateInBag = riskProxManager.getInrateBag(BUCKET_C0);\n\n    if (daysToSettl < mocLibConfig.dayPrecision) {\n      return totalInrateInBag;\n    }\n\n    // ([RES] * [DAY] / ([DAY] + [DAY])) = [RES]\n    // inrateBag / (daysToSettlement + 1)\n    uint256 toPay = totalInrateInBag\n      .mul(mocLibConfig.dayPrecision)\n      .div(daysToSettl.add(mocLibConfig.dayPrecision));\n\n    return toPay;\n  }\n\n  /**\n    @dev Extract the inrate from the passed ReserveTokens value for RiskProx minting operation\n    @param bucket Bucket to use to calculate inters\n    @param reserveTokenAmount Total value from which extract the interest rate [using reservePrecision]\n    @return ReserveTokens to pay in concept of interests [using reservePrecision]\n  */\n  function calcMintInterestValues(bytes32 bucket, uint256 reserveTokenAmount) public view returns (uint256) {\n    // Calculate Reserves to move in the operation\n    uint256 reservesToMove = mocLibConfig.bucketTransferAmount(reserveTokenAmount, mocState.leverage(bucket));\n    // Calculate interest rate\n    uint256 inrateValue = riskProxInrateAvg(bucket, reserveTokenAmount, true); // Minting\n    uint256 finalInrate = inrateToSettlement(inrateValue, true); // Minting\n\n    // Final interest\n    return mocLibConfig.getInterestCost(reservesToMove, finalInrate);\n  }\n\n  /**\n    @dev Extract the inrate from the passed ReserveTokens value for the StableToken Redeem operation\n    @param stableTokenAmount StableToken amount of the redemption [using mocPrecision]\n    @param reserveTokenAmount Total value from which extract the interest rate [using reservePrecision]\n    @return finalInterest\n  */\n  function calcStableTokenRedInterestValues(uint256 stableTokenAmount, uint256 reserveTokenAmount) public view returns (uint256) {\n    uint256 rate = stableTokenInrateAvg(stableTokenAmount);\n    uint256 finalInrate = inrateToSettlement(rate, true);\n    uint256 interests = mocLibConfig.getInterestCost(reserveTokenAmount, finalInrate);\n\n    return interests;\n  }\n\n  /**\n    @dev This function calculates the interest to return to the user\n    in a RiskProx redemption. It uses a mechanism to counteract the effect\n    of free stableTokens redemption. It will be replaced with FreeStableToken redemption\n    interests in the future\n    @param bucket Bucket to use to calculate interest\n    @param reserveTokenToRedeem Total value from which calculate interest [using reservePrecision]\n    @return Reserves to recover in concept of interests [using reservePrecision]\n  */\n  function calcFinalRedeemInterestValue(bytes32 bucket, uint256 reserveTokenToRedeem) public view returns (uint256) {\n    // Get interests to return for redemption\n    uint256 redeemInterest = calcRedeemInterestValue(bucket, reserveTokenToRedeem); // Redeem\n    uint256 proportionalInterest = calcProportionalInterestValue(bucket, redeemInterest);\n\n    return Math.min(proportionalInterest, redeemInterest);\n  }\n\n  /************************************/\n  /***** UPGRADE v0110      ***********/\n  /************************************/\n\n  /** START UPDATE V0110: 24/09/2020  **/\n  /** Upgrade to support multiple commission rates **/\n  /** Public functions **/\n\n  /**\n    @dev calculates the Commission rate from the passed ReserveTokens amount for mint/redeem operations\n    @param reserveTokenAmount Total value from which apply the Commission rate [using reservePrecision]\n    @param txType Transaction type according to constant values defined in this contract\n    @return finalCommissionAmount [using reservePrecision]\n  */\n  function calcCommissionValue(uint256 reserveTokenAmount, uint8 txType)\n  public view returns(uint256) {\n    // Validate txType\n    require (txType > 0, \"Invalid transaction type 'txType'\");\n\n    uint256 finalCommissionAmount = reserveTokenAmount.mul(commissionRatesByTxType[txType]).div(mocLibConfig.mocPrecision);\n    return finalCommissionAmount;\n  }\n\n  /**\n    @dev calculates the vendor markup rate from the passed vendor account and amount\n    @param vendorAccount Vendor address\n    @param amount Total value from which apply the vendor markup rate [using reservePrecision]\n    @return finalCommissionAmount [using reservePrecision]\n  */\n  function calculateVendorMarkup(address vendorAccount, uint256 amount) public view\n    returns (uint256 markup) {\n    // Calculate according to vendor markup\n    if (vendorAccount != address(0)) {\n      IMoCVendors mocVendors = IMoCVendors(mocState.getMoCVendors());\n\n      markup = amount.mul(mocVendors.getMarkup(vendorAccount)).div(mocLibConfig.mocPrecision);\n    }\n\n    return markup;\n  }\n\n  /** END UPDATE V0110: 24/09/2020 **/\n\n  /**\n    @dev Calculates ReserveTokens value to return to the user in concept of interests\n    @param bucket Bucket to use to calculate interest\n    @param reserveTokenToRedeem Total value from which calculate interest [using reservePrecision]\n    @return Reserves to recover in concept of interests [using reservePrecision]\n  */\n  function calcRedeemInterestValue(bytes32 bucket, uint256 reserveTokenToRedeem) public view returns (uint256) {\n    // Calculate Reserves to move in the operation\n    uint256 reservesToMove = mocLibConfig.bucketTransferAmount(reserveTokenToRedeem, mocState.leverage(bucket));\n    // Get interests to return for redemption\n    uint256 inrate = riskProxInrateAvg(bucket, reserveTokenToRedeem, false); // Redeem\n    uint256 finalInrate = inrateToSettlement(inrate, false); // Redeem\n\n    // Calculate interest for the redemption\n    return mocLibConfig.getInterestCost(reservesToMove, finalInrate);\n  }\n\n  /**\n    @dev Moves the daily amount of interest rate to C0 bucket\n  */\n  function dailyInratePayment() public\n  onlyWhitelisted(msg.sender) onlyOnceADay() returns(uint256) {\n    uint256 toPay = dailyInrate();\n    lastDailyPayBlock = block.number;\n\n    if (toPay != 0) {\n      riskProxManager.deliverInrate(BUCKET_C0, toPay);\n    }\n\n    emit InrateDailyPay(toPay, mocState.daysToSettlement(), mocState.getBucketNReserve(BUCKET_C0));\n  }\n\n  function isDailyEnabled() public view returns (bool) {\n    return lastDailyPayBlock == 0 || block.number > lastDailyPayBlock + mocState.dayBlockSpan();\n  }\n\n  function isRiskProInterestEnabled() public view returns (bool) {\n    return lastRiskProInterestBlock == 0 || block.number > (lastRiskProInterestBlock + riskProInterestBlockSpan);\n  }\n\n  /**\n   * @dev Calculates RiskPro Holders interest rates\n   * @return toPay interest in ReserveTokens [using reservePrecsion]\n   * @return bucketBtnc0 RTBC on bucket0 used to calculate de interest [using reservePrecsion]\n   */\n  function calculateRiskProHoldersInterest() public view returns (uint256, uint256) {\n    uint256 bucketBtnc0 = riskProxManager.getBucketNReserve(BUCKET_C0);\n    uint256 toPay = (bucketBtnc0.mul(riskProRate).div(mocLibConfig.mocPrecision));\n    return (toPay, bucketBtnc0);\n  }\n\n  /**\n   * @dev Pays the RiskPro Holders interest rates\n   * @return interest payed in ReserveTokens [using reservePrecsion]\n   */\n  function payRiskProHoldersInterestPayment() public\n  onlyWhitelisted(msg.sender)\n  onlyWhenRiskProInterestsIsEnabled() returns(uint256) {\n    (uint256 riskProInterest, uint256 bucketBtnc0) = calculateRiskProHoldersInterest();\n    lastRiskProInterestBlock = block.number;\n    emit RiskProHoldersInterestPay(riskProInterest, bucketBtnc0);\n    return riskProInterest;\n  }\n\n  /************************************/\n  /***** UPGRADE v0110      ***********/\n  /************************************/\n\n  /** START UPDATE V0110: 24/09/2020  **/\n  /** Upgrade to support multiple commission rates **/\n  /** Public functions **/\n  /**\n    @dev Sets the commission rate to a particular transaction type\n    @param txType Transaction type according to constant values defined in this contract\n    @param value Commission rate\n  */\n  function setCommissionRateByTxType(uint8 txType, uint256 value) public onlyAuthorizedChanger() {\n    commissionRatesByTxType[txType] = value;\n  }\n\n  /** END UPDATE V0110: 24/09/2020 **/\n\n  /**\n    @dev Calculates the interest rate to pay until the settlement day\n    @param inrate Spot interest rate\n    @param countAllDays Value that represents if the calculation will use all days or one day less\n    @return Interest rate value [using mocPrecision]\n   */\n  function inrateToSettlement(uint256 inrate, bool countAllDays) internal view returns (uint256) {\n    uint256 dayCount = inrateDayCount(countAllDays);\n\n    return inrate.mul(dayCount).div(mocLibConfig.dayPrecision);\n  }\n\n  /**\n    @dev This function calculates the interest to return to a user redeeming\n    RiskProx as a proportion of the amount in the interestBag.\n    @param bucket Bucket to use to calculate interest\n    @param redeemInterest Total value from which calculate interest [using reservePrecision]\n    @return InterestsInBag * (RedeemInterests / FullRedeemInterest) [using reservePrecision]\n  */\n  function calcProportionalInterestValue(bytes32 bucket, uint256 redeemInterest) internal view returns (uint256) {\n    uint256 fullRedeemInterest = calcFullRedeemInterestValue(bucket);\n    uint256 interestsInBag = riskProxManager.getInrateBag(BUCKET_C0);\n\n    if (fullRedeemInterest == 0) {\n      return 0;\n    }\n\n    // Proportional interests amount\n    return redeemInterest.mul(interestsInBag).div(fullRedeemInterest); // [RES] * [RES] / [RES]\n  }\n\n  /**\n    @dev This function calculates the interest to return if a user redeem all RiskProx in existance\n    @param bucket Bucket to use to calculate interest\n    @return Interests [using reservePrecision]\n  */\n  function calcFullRedeemInterestValue(bytes32 bucket) internal view returns (uint256) {\n    // Value in ReserveTokens of all RiskProxs in the bucket\n    uint256 fullRiskProxReserveTokenValue = mocConverter.riskProxToResToken(riskProxManager.getBucketNRiskPro(bucket), bucket);\n    // Interests to return if a redemption of all RiskProx is done\n    return calcRedeemInterestValue(bucket, fullRiskProxReserveTokenValue); // Redeem\n  }\n\n  /**\n    @dev Calculates the final amount of Bucket 0 StableTokens on RiskProx mint/redeem\n    @param bucket Name of the bucket involved in the operation\n    @param resTokensAmount Value of the operation from which calculates the inrate [using reservePrecision]\n    @return Final bucket 0 StableToken amount\n   */\n  function simulateStableTokenMovement(bytes32 bucket, uint256 resTokensAmount, bool onMinting) internal view returns (uint256) {\n    // Calculates stableTokens to move\n    uint256 reserveTokenToMove = mocLibConfig.bucketTransferAmount(resTokensAmount, mocState.leverage(bucket));\n    uint256 stableTokensToMove = mocConverter.resTokenToStableToken(reserveTokenToMove);\n\n    if (onMinting) {\n      /* Should not happen when minting riskPro because it's\n      not possible to mint more than max riskProx but is\n      useful when trying to calculate inrate before minting */\n      return riskProxManager.getBucketNStableToken(BUCKET_C0) > stableTokensToMove\n        ? riskProxManager.getBucketNStableToken(BUCKET_C0).sub(stableTokensToMove)\n        : 0;\n    } else {\n      return riskProxManager.getBucketNStableToken(BUCKET_C0).add(Math.min(stableTokensToMove, riskProxManager.getBucketNStableToken(bucket)));\n    }\n  }\n\n  /**\n    @dev Returns the days to use for interests calculation\n    @param countAllDays Value that represents if the calculation is based on mint or on redeem\n    @return days [using dayPrecision]\n   */\n  function inrateDayCount(bool countAllDays) internal view returns(uint256) {\n    uint256 daysToSettl = mocState.daysToSettlement();\n\n    if (daysToSettl < mocLibConfig.dayPrecision) {\n      return 0;\n    }\n\n    if (countAllDays) {\n      return daysToSettl;\n    }\n\n    return daysToSettl.sub(mocLibConfig.dayPrecision);\n  }\n\n  modifier onlyOnceADay() {\n    require(isDailyEnabled(), \"Interest rate already payed today\");\n    _;\n  }\n\n  modifier onlyWhenRiskProInterestsIsEnabled() {\n    require(isRiskProInterestEnabled(), \"Interest rate of RiskPro holders already payed this week\");\n    _;\n  }\n\n  /**\n   * @dev Initialize the contracts with which it interacts\n   */\n  function initializeContracts() internal {\n    riskProxManager = MoCRiskProxManager(connector.riskProxManager());\n    mocState = IMoCState(connector.mocState());\n    mocConverter = MoCConverter(connector.mocConverter());\n  }\n\n  /**\n   * @dev Initialize the parameters of the contract\n   * @param _governor the address of the IGovernor contract\n   * @param riskProxMin Minimum interest rate [using mocPrecision]\n   * @param riskProxPower Power is a parameter for interest rate calculation [using noPrecision]\n   * @param riskProxMax Maximun interest rate [using mocPrecision]\n   * @param _riskProRate RiskPro holder interest rate [using mocPrecision]\n   * @param blockSpanRiskPro RiskPro blockspan to configure payments periods[using mocPrecision]\n   * @param riskProInterestsTarget Target address to transfer the weekly RiskPro holders interest\n   * @param _stableTmin Upgrade to support red stable inrate parameter\n   * @param _stablePower Upgrade to support red stable inrate parameter\n   * @param _stableTmax Upgrade to support red stable inrate parameter\n   */\n  function initializeValues(\n    address _governor,\n    uint256 riskProxMin,\n    uint256 riskProxPower,\n    uint256 riskProxMax,\n    uint256 _riskProRate,\n    address payable commissionsAddressTarget,\n    //uint256 commissionRateParam,\n    uint256 blockSpanRiskPro,\n    address payable riskProInterestsTarget,\n    uint256 _stableTmin,\n    uint256 _stablePower,\n    uint256 _stableTmax\n  ) internal {\n    governor = IGovernor(_governor);\n    riskProxParams.tMin = riskProxMin;\n    riskProxParams.power = riskProxPower;\n    riskProxParams.tMax = riskProxMax;\n    riskProRate = _riskProRate;\n    riskProInterestAddress = riskProInterestsTarget;\n    riskProInterestBlockSpan = blockSpanRiskPro;\n    //commissionRate = commissionRateParam;\n    commissionsAddress = commissionsAddressTarget;\n    stableTmin = _stableTmin;\n    stablePower = _stablePower;\n    stableTmax = _stableTmax;\n  }\n\n  /************************************/\n  /***** UPGRADE v0110      ***********/\n  /************************************/\n\n  /** START UPDATE V0110: 24/09/2020  **/\n  /** Upgrade to support multiple commission rates **/\n\n  // Transaction types\n  uint8 public constant MINT_RISKPRO_FEES_RESERVE = 1;\n  uint8 public constant REDEEM_RISKPRO_FEES_RESERVE = 2;\n  uint8 public constant MINT_STABLETOKEN_FEES_RESERVE = 3;\n  uint8 public constant REDEEM_STABLETOKEN_FEES_RESERVE = 4;\n  uint8 public constant MINT_RISKPROX_FEES_RESERVE = 5;\n  uint8 public constant REDEEM_RISKPROX_FEES_RESERVE = 6;\n  uint8 public constant MINT_RISKPRO_FEES_MOC = 7;\n  uint8 public constant REDEEM_RISKPRO_FEES_MOC = 8;\n  uint8 public constant MINT_STABLETOKEN_FEES_MOC = 9;\n  uint8 public constant REDEEM_STABLETOKEN_FEES_MOC = 10;\n  uint8 public constant MINT_RISKPROX_FEES_MOC = 11;\n  uint8 public constant REDEEM_RISKPROX_FEES_MOC = 12;\n\n  mapping(uint8 => uint256) public commissionRatesByTxType;\n\n  /** END UPDATE V0110: 24/09/2020 **/\n\n  // Leave a gap betweeen inherited contracts variables in order to be\n  // able to add more variables in them later\n  uint256[50] private upgradeGap;\n}\n",
            "file": "MoCInrate.sol"
        }
    ],
    "libraries": {
        "MoCHelperLib": "0x280a61eFa0bAaE2eD0F91e403376953640c28C8e"
    },
    "creationData": {
        "blockHash": "0x16f96bccefa00e13993c767afce289968089894cb6062813222f99ca5c2600ef",
        "blockNumber": 1840972,
        "transactionHash": "0x7796a7322180cf3a4a87886e59c7d46b71616cccf1bc625dd40263ad6bd56d7e",
        "timestamp": 1620933156
    }
}