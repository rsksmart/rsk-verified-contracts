{
  "address": "0x794f99f1a9382ba88b453ddb4bfa00acae8d50e8",
  "net": {
    "id": "31",
    "name": "RSK Testnet"
  },
  "name": "NamePrice",
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    }
  },
  "version": "0.5.12+commit.7709ece9",
  "source": "pragma solidity ^0.5.3;\n\nimport \"./AbstractNamePrice.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/// @title NamePrice contract\n/// @author Javier Esses\n/// @notice Used to calculate the price in RIF token for a given name and duration\n/// @dev Implements AbstractNamePrice interface\ncontract NamePrice is AbstractNamePrice {\n    using SafeMath for uint256;\n\n    /// @author Javi Esses\n    /// @notice Calculate name price in RIF token for a given duration\n    /// @dev Is a pure function, but converted to view due the AbstractNamePrice spec\n    /// @param duration Duration of the name to register in years\n    /// @return price Price in RIF tokens\n    function price (string calldata /*name*/, uint /*expires*/, uint duration) external view returns(uint) {\n        require(duration >= 1, \"NamePrice: no zero duration\");\n\n        if (duration == 1) return 2 * (10**18);\n        if (duration == 2) return 4 * (10**18);\n\n        return duration.add(2).mul(10**18);\n    }\n}\n",
  "imports": [
    {
      "name": "NamePrice.sol",
      "contents": "pragma solidity ^0.5.3;\n\nimport \"./AbstractNamePrice.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/// @title NamePrice contract\n/// @author Javier Esses\n/// @notice Used to calculate the price in RIF token for a given name and duration\n/// @dev Implements AbstractNamePrice interface\ncontract NamePrice is AbstractNamePrice {\n    using SafeMath for uint256;\n\n    /// @author Javi Esses\n    /// @notice Calculate name price in RIF token for a given duration\n    /// @dev Is a pure function, but converted to view due the AbstractNamePrice spec\n    /// @param duration Duration of the name to register in years\n    /// @return price Price in RIF tokens\n    function price (string calldata /*name*/, uint /*expires*/, uint duration) external view returns(uint) {\n        require(duration >= 1, \"NamePrice: no zero duration\");\n\n        if (duration == 1) return 2 * (10**18);\n        if (duration == 2) return 4 * (10**18);\n\n        return duration.add(2).mul(10**18);\n    }\n}\n",
      "file": "NamePrice.sol"
    },
    {
      "name": "SafeMath.sol",
      "contents": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    {
      "name": "AbstractNamePrice.sol",
      "contents": "pragma solidity ^0.5.3;\n\n/// @title NamePrice interface\n/// @author Javier Esses\n/// @notice Defines an interface for name price calculations\ncontract AbstractNamePrice {\n    function price (string calldata name, uint expires, uint duration) external view returns(uint);\n}\n"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x0173dac0e280ac375dc211a533c1098544dd896d11f53f54e92f6a50aebb0650",
    "blockNumber": 385435,
    "transactionHash": "0x2fdfd23178152472bfb6d7a702e1bb20ba4c95b4525114a97f2836ea308c2a94",
    "timestamp": 1574279668
  }
}