{
    "address": "0x1a5b98670dcafe0ca211367fede54cc79013771a",
    "net": {
        "id": "31",
        "name": "RSK Testnet"
    },
    "name": "Supporters",
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        }
    },
    "version": "0.6.12+commit.27d51765",
    "source": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\n/*\n    Basic public interface for the supporters smart contract.\n    The facade for this contract is the StakingMachine, this interface is specifically for the scheduler\n    that needs to call distribute() to distribute the rewards.\n*/\ninterface ISupporters {\n    /**\n      @notice Deposit earnings that will be credited to supporters.\n      @dev Earnings will be credited periodically through several blocks.\n    */\n    function distribute() external;\n\n    /**\n      @notice Return true if is ready to do a distribute call\n\n      @return true if ready\n    */\n    function isReadyToDistribute() external view returns (bool);\n\n    /// @notice The moc token address\n    function mocToken() external view returns (IERC20);\n\n    /**\n     @notice Return the round length in blocks .\n     @dev During each round rewards are collected and distributed during next round.\n\n     @return Number of blocks to distribute earnings\n    */\n    function period() external view returns (uint256);\n\n    // @notice total amount of mocs inside the supporters contract\n    function totalMoc() external view returns (uint256);\n\n    // @notice total amount of tokens inside the supporters contect.\n    function totalToken() external view returns (uint256);\n}\n\n\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n    /**\n      @notice Override this function with a recipe of the changes to be done when this ChangeContract\n      is executed\n     */\n    function execute() external;\n}\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor {\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @dev This function should be protected somehow to only execute changes that\n      benefit the system. This decision process is independent of this architechture\n      therefore is independent of this interface too\n      @param changeContract Address of the contract that will execute the changes\n     */\n    function executeChange(ChangeContract changeContract) external;\n\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @param _changer Address of the contract that will execute the changes\n     */\n    function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed {\n    /**\n      @notice The address of the contract which governs this one\n     */\n    IGovernor public governor;\n\n    string private constant NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n    /**\n      @notice Modifier that protects the function\n      @dev You should use this modifier in any function that should be called through\n      the governance system\n     */\n    modifier onlyAuthorizedChanger() {\n        require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n        _;\n    }\n\n    /**\n      @notice Initialize the contract with the basic settings\n      @dev This initialize replaces the constructor but it is not called automatically.\n      It is necessary because of the upgradeability of the contracts\n      @param _governor Governor address\n     */\n    function _initialize(IGovernor _governor) internal {\n        governor = _governor;\n    }\n\n    /**\n      @notice Change the contract's governor. Should be called through the old governance system\n      @param newIGovernor New governor address\n     */\n    function changeIGovernor(IGovernor newIGovernor) external onlyAuthorizedChanger {\n        governor = newIGovernor;\n    }\n\n    /**\n      @notice This method is used by a change contract to access the storage freely even without a setter.\n      @param data the serialized function arguments\n     */\n    function delegateCallToChanger(bytes calldata data)\n        external\n        onlyAuthorizedChanger\n        returns (bytes memory)\n    {\n        address changerContrat = msg.sender;\n        (bool success, bytes memory result) = changerContrat.delegatecall(\n            abi.encodeWithSignature(\"impersonate(bytes)\", data)\n        );\n        require(success, \"Error in delegate call\");\n        return result;\n    }\n\n    // Leave a gap betweeen inherited contracts variables in order to be\n    // able to add more variables in them later\n    uint256[50] private upgradeGap;\n}\n\n\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n\n\n\n/**\n  @notice Based on heavily on EnumberableSet, but with the ability to clear all the contents.\n */\nlibrary AddressSetLib {\n    using SafeMath for uint256;\n\n    struct AddressSet {\n        // Storage of set values\n        address[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(address => uint256) _indexes;\n    }\n\n    function init() internal pure returns (AddressSet memory) {\n        return AddressSet({_values: new address[](0)});\n    }\n\n    /**\n     * @dev Removes all value from a set. O(N).\n     *\n     */\n    function clear(AddressSet storage set) internal {\n        for (uint256 i = 0; i < set._values.length; i++) {\n            delete set._indexes[set._values[i]];\n        }\n        delete set._values;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        if (!contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            address lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1;\n            // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        require(set._values.length > index, \"index out of bounds\");\n        return set._values[index];\n    }\n\n    /**\n     * @dev Returns the set contents as an array\n     */\n    function asArray(AddressSet storage set)\n        internal\n        view\n        returns (address[] memory selectedOracles)\n    {\n        return set._values;\n    }\n}\n\n\n/**\n  @dev An iterable mapping of addresses to boolean, used to check if an address is whitelisted.\n */\ncontract IIterableWhitelist {\n    /**\n      @notice Modifier that protects the function\n      @dev You should use this modifier in any function that should be filtered by the whitelist\n     */\n    modifier whitelistedOrExternal(IterableWhitelistLib.IterableWhitelistData storage self) {\n        // We use address(1) to allow calls from outside the block chain to peek\n        // The call must use msg.sender == 1 (or { from: 1 }) something that only can be done from\n        // outside the blockchain.\n        require(\n            msg.sender == address(1) || IterableWhitelistLib._isWhitelisted(self, msg.sender),\n            \"Address is not whitelisted\"\n        );\n        _;\n    }\n\n    /**\n      @notice Modifier that protects the function\n      @dev You should use this modifier in any function that should be filtered by the whitelist\n     */\n    modifier onlyWhitelisted(IterableWhitelistLib.IterableWhitelistData storage self) {\n        require(\n            IterableWhitelistLib._isWhitelisted(self, msg.sender),\n            \"Address is not whitelisted\"\n        );\n        _;\n    }\n}\n\nlibrary IterableWhitelistLib {\n    using AddressSetLib for AddressSetLib.AddressSet;\n\n    struct IterableWhitelistData {\n        AddressSetLib.AddressSet _inner;\n    }\n\n    /**\n     * @dev Check if an account is whitelisted\n     * @return Bool\n     */\n    function _isWhitelisted(IterableWhitelistData storage self, address account)\n        internal\n        view\n        returns (bool)\n    {\n        require(account != address(0), \"Account must not be 0x0\");\n        return self._inner.contains(account);\n    }\n\n    /**\n     * @dev Add account to whitelist\n     */\n    function _addToWhitelist(IterableWhitelistData storage self, address account) internal {\n        require(account != address(0), \"Account must not be 0x0\");\n        bool added = self._inner.add(account);\n        require(added, \"Account already whitelisted\");\n    }\n\n    /**\n     * @dev Remove account to whitelist\n     */\n    function _removeFromWhitelist(IterableWhitelistData storage self, address account) internal {\n        require(account != address(0), \"Account must not be 0x0\");\n        bool removed = self._inner.remove(account);\n        require(removed, \"Missing account\");\n    }\n\n    /// @notice Returns the count of whitelisted addresses.\n    function _getWhiteListLen(IterableWhitelistData storage self) internal view returns (uint256) {\n        return self._inner.length();\n    }\n\n    /// @notice Returns the address at index.\n    /// @param idx index to query.\n    function _getWhiteListAtIndex(IterableWhitelistData storage self, uint256 idx)\n        internal\n        view\n        returns (address)\n    {\n        return self._inner.at(idx);\n    }\n}\n\n\n\n/*\n    Abstract contract meant to be reused.\n*/\nlibrary SupportersLib {\n    /// Global registration information for each oracle\n    struct SupportersData {\n        // Balance in tokens for each supporter\n        mapping(address => mapping(address => uint256)) tokenBalances;\n        // Total of tokens created\n        uint256 totalSupply;\n        // Total of MOC deposited in the contract\n        uint256 mocBalance;\n        // Initial block where earnings started to be paid\n        uint256 startEarnings;\n        // Final block where earnings will be paid\n        uint256 endEarnings;\n        // Amount of earning paid\n        uint256 earnings;\n        // Number of blocks to distribute earnings\n        uint256 period;\n        // MOC token address\n        IERC20 mocToken;\n    }\n\n    using SafeMath for uint256;\n\n    event PayEarnings(uint256 earnings, uint256 start, uint256 end);\n\n    event CancelEarnings(uint256 earnings, uint256 start, uint256 end);\n\n    event AddStake(\n        address indexed user,\n        address indexed subaccount,\n        address indexed sender,\n        uint256 amount,\n        uint256 mocs\n    );\n\n    event WithdrawStake(\n        address indexed user,\n        address indexed subaccount,\n        address indexed destination,\n        uint256 amount,\n        uint256 mocs\n    );\n\n    /**\n    Contract creation\n\n    @param _mocToken MOC token address\n    @param _period Number of blocks to distribute earnings, round length\n    */\n    function _initialize(\n        SupportersData storage self,\n        IERC20 _mocToken,\n        uint256 _period\n    ) internal {\n        self.mocToken = _mocToken;\n        self.period = _period;\n    }\n\n    /**\n     * @dev Sets the period,\n     * @param _period- the override minOracleOwnerStake\n     */\n    function _setPeriod(SupportersData storage self, uint256 _period) internal {\n        self.period = _period;\n    }\n\n    /**\n     * @dev Sets the moc token address,\n     * @param _mocToken- the override mocToken\n     */\n    function _setMocToken(SupportersData storage self, IERC20 _mocToken) internal {\n        self.mocToken = _mocToken;\n    }\n\n    /**\n      Deposit earnings that will be credited to supporters.\n      Earnings will be credited periodically through several blocks.\n    */\n    function _distribute(SupportersData storage self) internal {\n        require(_isReadyToDistribute(self), \"Not ready to distribute\");\n\n        // Calculate deposited earnings that are unaccounted for\n        uint256 balance = self.mocToken.balanceOf(address(this));\n        self.earnings = balance.sub(self.mocBalance);\n\n        // Start paying earning to the next round\n        self.startEarnings = block.number;\n        self.endEarnings = self.startEarnings.add(self.period);\n        self.mocBalance = balance;\n\n        emit PayEarnings(self.earnings, self.startEarnings, self.endEarnings);\n    }\n\n    /**\n      Return true if is ready to do a distribute call\n\n      @return true if ready\n    */\n    function _isReadyToDistribute(SupportersData storage self) internal view returns (bool) {\n        return (self.totalSupply > 0 && block.number > self.endEarnings);\n    }\n\n    /**\n      Stake MOC to receive earnings on a subaccount.\n\n      @param _mocs amount of MOC to stake\n      @param _subaccount sub-account used to identify the stake\n      @param _sender sender account that must approve and from which the funds are taken\n    */\n    function _stakeAtFrom(\n        SupportersData storage self,\n        uint256 _mocs,\n        address _subaccount,\n        address _sender\n    ) internal {\n        uint256 tokens = _mocToToken(self, _mocs);\n        _stakeAtFromInternal(self, tokens, _mocs, _subaccount, _sender);\n    }\n\n    /**\n      Stake MOC to receive earnings on a subaccount.\n\n      @param _tokens amount of tokens to stake\n      @param _mocs amount of MOC to stake\n      @param _subaccount sub-account used to identify the stake\n      @param _sender sender account that must approve and from which the funds are taken\n    */\n    function _stakeAtFromInternal(\n        SupportersData storage self,\n        uint256 _tokens,\n        uint256 _mocs,\n        address _subaccount,\n        address _sender\n    ) internal {\n        // Done outside this contract so we can get the value of\n        // uint256 tokens = _mocToToken(self, _mocs);\n        self.mocBalance = self.mocBalance.add(_mocs);\n        require(\n            self.mocToken.transferFrom(_sender, address(this), _mocs),\n            \"error in transfer from\"\n        );\n\n        __mintToken(self, msg.sender, _tokens, _subaccount);\n\n        emit AddStake(msg.sender, _subaccount, _sender, _tokens, _mocs);\n    }\n\n    /**\n      Withdraw MOC for tokens for a subaccount.\n\n      @param _tokens amount of tokens to convert to MOC\n      @param _subaccount subaccount used to withdraw MOC\n      @param _receiver destination address that gets the MOC\n      @return Amount of MOC transfered\n    */\n    function _withdrawFromTo(\n        SupportersData storage self,\n        uint256 _tokens,\n        address _subaccount,\n        address _receiver\n    ) internal returns (uint256) {\n        uint256 mocs = _tokenToMoc(self, _tokens);\n\n        _burnToken(self, msg.sender, _tokens, _subaccount);\n\n        self.mocBalance = self.mocBalance.sub(mocs);\n        require(self.mocToken.transfer(_receiver, mocs), \"error in transfer\");\n\n        // When last supporter exits move pending earnings to next round\n        if (self.totalSupply == 0) {\n            _resetEarnings(self);\n        }\n\n        emit WithdrawStake(msg.sender, _subaccount, _receiver, _tokens, mocs);\n        return mocs;\n    }\n\n    /**\n      Amount of tokens for _user in a _subaccount.\n\n      @param _user User address\n      @param _subaccount subaccount to get balance\n      @return tokens for _user at _subaccount\n    */\n    function _getBalanceAt(\n        SupportersData storage self,\n        address _user,\n        address _subaccount\n    ) internal view returns (uint256) {\n        return self.tokenBalances[_user][_subaccount];\n    }\n\n    /**\n      MOC available for withdrawal by _user.\n\n      @param _user User address\n      @param _subaccount subaccount to get MOC balance\n      @return MOC for _user\n    */\n    function _getMOCBalanceAt(\n        SupportersData storage self,\n        address _user,\n        address _subaccount\n    ) internal view returns (uint256) {\n        return _tokenToMoc(self, self.tokenBalances[_user][_subaccount]);\n    }\n\n    /**\n      Total tokens created.\n\n      @return total amount of tokens\n    */\n    function _getTokens(SupportersData storage self) internal view returns (uint256) {\n        return self.totalSupply;\n    }\n\n    /**\n      MOC available for withdrawal.\n\n      @return total amount of MOC\n    */\n    function _getAvailableMOC(SupportersData storage self) internal view returns (uint256) {\n        return self.mocBalance.sub(_getLockedAt(self, block.number));\n    }\n\n    /**\n      Convert amount MOC to equivalent in token\n\n      @param _mocs Amount of MOC\n      @return Equivalent amount of tokens\n    */\n    function _mocToToken(SupportersData storage self, uint256 _mocs)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 totalMocs = _getAvailableMOC(self);\n        uint256 totalTokens = _getTokens(self);\n        if (totalMocs == 0 && totalTokens == 0) {\n            return _mocs;\n        }\n        return _mocs.mul(totalTokens).div(totalMocs);\n    }\n\n    /**\n      Convert tokens to equivalente in MOC\n\n      @param _tokens Amount of tokens\n      @return Equivalent amount of MOC\n    */\n    function _tokenToMoc(SupportersData storage self, uint256 _tokens)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 totalTokens = _getTokens(self);\n        uint256 totalMocs = _getAvailableMOC(self);\n        if (totalMocs == 0) {\n            return 0;\n        }\n        return _tokens.mul(totalMocs).div(totalTokens);\n    }\n\n    /**\n      Convert tokens to equivalente in MOC ceiling up\n\n      @param _tokens Amount of tokens\n      @return Equivalent amount of MOC\n    */\n    function _tokenToMocUP(SupportersData storage self, uint256 _tokens)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 totalTokens = _getTokens(self);\n        uint256 totalMocs = _getAvailableMOC(self);\n        if (totalMocs == 0) {\n            return 0;\n        }\n        return _tokens.mul(totalMocs).add(totalTokens).sub(1).div(totalTokens);\n    }\n\n    /**\n      Calculate earnings to be paid at a block\n\n      @param _block Block used to calculate\n      @return Earnings to be paid\n    */\n    function _getEarningsAt(SupportersData storage self, uint256 _block)\n        internal\n        view\n        returns (uint256)\n    {\n        if (self.earnings == 0) return 0;\n        if (_block < self.startEarnings) return 0;\n        if (_block > self.endEarnings) return self.earnings;\n        return\n            self.earnings.mul(_block.sub(self.startEarnings)).div(\n                self.endEarnings.sub(self.startEarnings)\n            );\n    }\n\n    /**\n      Calculate locked earnings at a block\n\n      @param _block Block used for calculations\n      @return Locked amount of earnings in MOC\n    */\n    function _getLockedAt(SupportersData storage self, uint256 _block)\n        internal\n        view\n        returns (uint256)\n    {\n        return self.earnings.sub(_getEarningsAt(self, _block));\n    }\n\n    /**\n      @dev Create tokens and assign to a user\n\n      @param _user User address to be assigned tokens\n      @param _amount Amount of tokens to create\n      @param _subaccount Subaccount to store tokens\n    */\n    function __mintToken(\n        SupportersData storage self,\n        address _user,\n        uint256 _amount,\n        address _subaccount\n    ) internal {\n        self.tokenBalances[_user][_subaccount] = self.tokenBalances[_user][_subaccount].add(\n            _amount\n        );\n        self.totalSupply = self.totalSupply.add(_amount);\n    }\n\n    /**\n      @dev Return information about earnings\n\n      @return Information about earnings\n    */\n    function _getEarningsInfo(SupportersData storage self)\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 next = self.mocToken.balanceOf(address(this)).sub(self.mocBalance);\n        uint256 distributed = _getEarningsAt(self, block.number);\n        return (self.earnings, distributed, next);\n    }\n\n    /**\n      @dev Destroy tokens from a user\n\n      @param _user User address containing tokens\n      @param _amount Amount of tokens to destroy\n      @param _subaccount Subaccount with tokens\n    */\n    function _burnToken(\n        SupportersData storage self,\n        address _user,\n        uint256 _amount,\n        address _subaccount\n    ) internal {\n        self.tokenBalances[_user][_subaccount] = self.tokenBalances[_user][_subaccount].sub(\n            _amount\n        );\n        self.totalSupply = self.totalSupply.sub(_amount);\n    }\n\n    /**\n      @dev Reset earnings\n\n      Move pending earnings on the current round to the next one\n    */\n    function _resetEarnings(SupportersData storage self) internal {\n        uint256 pending = self.mocBalance;\n        self.mocBalance = 0;\n        self.earnings = 0;\n        emit CancelEarnings(pending, self.startEarnings, self.endEarnings);\n    }\n}\n\n\n/*\n    Right now we have two things implemented in the same smart-contract:\n        - Only the smart-contracts in the whitelist can access this one.\n        - Some vesting rules implemented in SupportersVestedAbstract\n    This can be split in the future in two smart-contracts if we want to add a specific set\n    of vesting rules (that doesn't do what SupportersVestedAbstract does).\n*/\ncontract SupportersStorage is Initializable, Governed, IIterableWhitelist {\n    using SafeMath for uint256;\n    using SupportersLib for SupportersLib.SupportersData;\n    using IterableWhitelistLib for IterableWhitelistLib.IterableWhitelistData;\n\n    struct LockingInfo {\n        uint256 untilTimestamp;\n        uint256 amount;\n    }\n\n    mapping(address => LockingInfo) public lockedMocs;\n\n    // Whitelisted contracts that can add/remove stake in this one.\n    IterableWhitelistLib.IterableWhitelistData internal iterableWhitelistData;\n\n    SupportersLib.SupportersData internal supportersData;\n\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    // solhint-disable-next-line no-empty-blocks\n    constructor() internal {}\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n\n\n/*\n    Right now we have two things implemented in the same smart-contract:\n        - Only the smart-contracts in the whitelist can access this one.\n        - Some vesting rules implemented in SupportersVestedAbstract\n    This can be split in the future in two smart-contracts if we want to add a specific set\n    of vesting rules (that doesn't do what SupportersVestedAbstract does).\n*/\ncontract Supporters is SupportersStorage, ISupporters {\n    using SafeMath for uint256;\n\n    // Emitted by SupportersLib\n    event PayEarnings(uint256 earnings, uint256 start, uint256 end);\n    event CancelEarnings(uint256 earnings, uint256 start, uint256 end);\n    event AddStake(\n        address indexed user,\n        address indexed subaccount,\n        address indexed sender,\n        uint256 amount,\n        uint256 mocs\n    );\n    event WithdrawStake(\n        address indexed user,\n        address indexed subaccount,\n        address indexed destination,\n        uint256 amount,\n        uint256 mocs\n    );\n\n    event Withdraw(\n        address indexed msgSender,\n        address indexed subacount,\n        address indexed receiver,\n        uint256 mocs,\n        uint256 blockNum\n    );\n\n    /**\n     @notice Contract creation\n\n     @param _governor The address of the contract which governs this one\n     @param _wlist Initial whitelist addresses\n     @param _mocToken The address of the contract which governs this one\n     @param _period The address of the contract which governs this one\n    */\n    function initialize(\n        IGovernor _governor,\n        address[] calldata _wlist,\n        IERC20 _mocToken,\n        uint256 _period\n    ) external initializer {\n        Governed._initialize(_governor);\n        supportersData._initialize(_mocToken, _period);\n        for (uint256 i = 0; i < _wlist.length; i++) {\n            iterableWhitelistData._addToWhitelist(_wlist[i]);\n        }\n    }\n\n    /// @notice Used by the voting machine to lock an amount of MOCs.\n    /// @param mocHolder the moc holder whose mocs will be locked.\n    /// @param untilTimestamp timestamp until which the mocs will be locked.\n    function lockMocs(address mocHolder, uint256 untilTimestamp)\n        external\n        onlyWhitelisted(iterableWhitelistData)\n    {\n        LockingInfo storage lockedMocsInfo = lockedMocs[mocHolder];\n        lockedMocsInfo.untilTimestamp = untilTimestamp;\n        uint256 mocBalance = supportersData._getMOCBalanceAt(msg.sender, mocHolder);\n        lockedMocsInfo.amount = mocBalance;\n    }\n\n    /// @notice Reports the balance of locked MOCs for a specific user.\n    /// Delegates to the Supporters smart contract.\n    /// @param user user address\n    function getLockedBalance(address user) external view returns (uint256) {\n        LockingInfo storage lockedMocsInfo = lockedMocs[user];\n        return lockedMocsInfo.amount;\n    }\n\n    /// @notice Reports the balance of locked MOCs for a specific user.\n    /// Delegates to the Supporters smart contract.\n    /// @param user user address\n    /// @return amount the amount of mocs locked\n    /// @return untilTimestamp the timestamp that corresponds to the locking date.\n    function getLockingInfo(address user)\n        external\n        view\n        returns (uint256 amount, uint256 untilTimestamp)\n    {\n        LockingInfo storage lockedMocsInfo = lockedMocs[user];\n        return (lockedMocsInfo.amount, lockedMocsInfo.untilTimestamp);\n    }\n\n    /**\n     @notice Add to the list of contracts that can stake in this contract\n\n     @param  _whitelisted - the override coinPair\n    */\n    function addToWhitelist(address _whitelisted) external onlyAuthorizedChanger() {\n        iterableWhitelistData._addToWhitelist(_whitelisted);\n    }\n\n    /**\n     @notice Remove from the list of contracts that can stake in this contract\n\n     @param _whitelisted - the override coinPair\n    */\n    function removeFromWhitelist(address _whitelisted) external onlyAuthorizedChanger() {\n        iterableWhitelistData._removeFromWhitelist(_whitelisted);\n    }\n\n    /**\n      @notice Deposit earnings that will be credited to supporters.\n      @dev Earnings will be credited periodically through several blocks.\n    */\n    function distribute() external override {\n        supportersData._distribute();\n    }\n\n    /**\n      @notice Return true if is ready to do a distribute call\n\n      @return true if ready\n    */\n    function isReadyToDistribute() external override view returns (bool) {\n        return supportersData._isReadyToDistribute();\n    }\n\n    /**\n     Stake MOC to receive earnings on a subaccount.\n\n     @param _mocs amount of MOC to stake\n     @param _subaccount sub-account used to identify the stake\n    */\n    function stakeAt(uint256 _mocs, address _subaccount)\n        external\n        onlyWhitelisted(iterableWhitelistData)\n    {\n        supportersData._stakeAtFrom(_mocs, _subaccount, msg.sender);\n    }\n\n    /**\n     Stake MOC to receive earnings on a subaccount.\n\n     @param _mocs amount of MOC to stake\n     @param _subaccount sub-account used to identify the stake\n     @param _sender sender account that must approve and from which the funds are taken\n    */\n    function stakeAtFrom(\n        uint256 _mocs,\n        address _subaccount,\n        address _sender\n    ) external onlyWhitelisted(iterableWhitelistData) {\n        supportersData._stakeAtFrom(_mocs, _subaccount, _sender);\n    }\n\n    /**\n     This function is for internal use, it doesn't force a price for the internal token.\n     The idea is to let the code in the staking machine calculate the price relationship and take only the\n     needed amount of mocs from the user.\n\n     @param _tokens amount of tokens to stake\n     @param _mocs amount of MOC to stake\n     @param _subaccount sub-account used to identify the stake\n     @param _sender sender account that must approve and from which the funds are taken\n    */\n    function stakeAtFromInternal(\n        uint256 _tokens,\n        uint256 _mocs,\n        address _subaccount,\n        address _sender\n    ) external onlyWhitelisted(iterableWhitelistData) {\n        supportersData._stakeAtFromInternal(_tokens, _mocs, _subaccount, _sender);\n    }\n\n    /**\n      Withdraw MOC for tokens for a subaccount.\n\n      @param _tokens amount of tokens to convert to MOC\n      @param _subaccount subaccount used to withdraw MOC\n      @return Amount of MOC transfered\n    */\n    function withdrawFrom(uint256 _tokens, address _subaccount)\n        external\n        onlyWhitelisted(iterableWhitelistData)\n        stakeAvailable(msg.sender, _subaccount, _tokens)\n        returns (uint256)\n    {\n        return supportersData._withdrawFromTo(_tokens, _subaccount, msg.sender);\n    }\n\n    /**\n      Withdraw MOC for tokens for a subaccount.\n\n      @param _tokens amount of tokens to convert to MOC\n      @param _subaccount subaccount used to withdraw MOC\n      @param _receiver destination address that gets the MOC\n      @return Amount of MOC transfered\n    */\n    function withdrawFromTo(\n        uint256 _tokens,\n        address _subaccount,\n        address _receiver\n    )\n        external\n        onlyWhitelisted(iterableWhitelistData)\n        stakeAvailable(msg.sender, _subaccount, _tokens)\n        returns (uint256)\n    {\n        return supportersData._withdrawFromTo(_tokens, _subaccount, _receiver);\n    }\n\n    /**\n      @notice Amount of tokens for _user in a _subaccount.\n\n      @param _user User address\n      @param _subaccount subaccount to get balance\n      @return tokens for _user at _subaccount\n    */\n    function getBalanceAt(address _user, address _subaccount) external view returns (uint256) {\n        return supportersData._getBalanceAt(_user, _subaccount);\n    }\n\n    /**\n      @notice MOC available for withdrawal by _user.\n\n      @param _user User address\n      @param _subaccount subaccount to get MOC balance\n      @return MOC for _user\n    */\n    function getMOCBalanceAt(address _user, address _subaccount) external view returns (uint256) {\n        return supportersData._getMOCBalanceAt(_user, _subaccount);\n    }\n\n    /**\n      @notice Calculate earnings to be paid at a block\n\n      @param _block Block used to calculate\n      @return Earnings to be paid\n    */\n    function getEarningsAt(uint256 _block) external view returns (uint256) {\n        return supportersData._getEarningsAt(_block);\n    }\n\n    /**\n      @notice Calculate locked earnings at a block\n\n      @param _block Block used for calculations\n      @return Locked amount of earnings in MOC\n    */\n    function getLockedAt(uint256 _block) external view returns (uint256) {\n        return supportersData._getLockedAt(_block);\n    }\n\n    /**\n      @notice Return information about earnings\n\n      @return Information about earnings\n    */\n    function getEarningsInfo()\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return supportersData._getEarningsInfo();\n    }\n\n    /// @notice The moc token address\n    function mocToken() external override view returns (IERC20) {\n        return supportersData.mocToken;\n    }\n\n    /**\n     @notice Return the round length in blocks .\n     @dev During each round rewards are collected and distributed during next round.\n\n     @return Number of blocks to distribute earnings\n    */\n    function period() external override view returns (uint256) {\n        return supportersData.period;\n    }\n\n    /// @notice Returns the count of whitelisted addresses.\n    function getWhiteListLen() external view returns (uint256) {\n        return iterableWhitelistData._getWhiteListLen();\n    }\n\n    /**\n     @notice Returns the address at index.\n\n     @param _idx index to query.\n    */\n    function getWhiteListAtIndex(uint256 _idx) external view returns (address) {\n        return iterableWhitelistData._getWhiteListAtIndex(_idx);\n    }\n\n    /**\n     @notice Check if an account is whitelisted\n\n     @param _account The account to check\n    */\n    function isWhitelisted(address _account) external view returns (bool) {\n        return iterableWhitelistData._isWhitelisted(_account);\n    }\n\n    /**\n      Convert amount MOC to equivalent in token\n\n      @param _mocs Amount of MOC\n      @return Equivalent amount of tokens\n    */\n    function mocToToken(uint256 _mocs) external view returns (uint256) {\n        return supportersData._mocToToken(_mocs);\n    }\n\n    /**\n      Convert amount tokens to equivalent in MOCS\n\n      @param _token Amount of tokens\n      @return Equivalent amount of tokens\n    */\n    function tokenToMoc(uint256 _token) external view returns (uint256) {\n        return supportersData._tokenToMoc(_token);\n    }\n\n    /**\n       Convert amount tokens to equivalent in MOCS ceiling up\n\n       @param _token Amount of tokens\n       @return Equivalent amount of tokens\n     */\n    function tokenToMocUP(uint256 _token) external view returns (uint256) {\n        return supportersData._tokenToMocUP(_token);\n    }\n\n    // @notice total amount of mocs inside the supporters contract\n    function totalMoc() external override view returns (uint256) {\n        return supportersData._getAvailableMOC();\n    }\n\n    // @notice total amount of tokens inside the supporters contect.\n    function totalToken() external override view returns (uint256) {\n        return supportersData._getTokens();\n    }\n\n    function getMaxMOCBalance(address owner, address[] calldata addresses)\n        external\n        view\n        returns (address selected, uint256 maxBalance)\n    {\n        if (addresses.length == 0) {\n            return (selected, maxBalance);\n        }\n\n        selected = addresses[0];\n        maxBalance = supportersData._getMOCBalanceAt(owner, addresses[0]);\n        for (uint256 i = 1; i < addresses.length; i += 1) {\n            if (addresses[i] == address(0)) {\n                continue;\n            }\n            uint256 balance = supportersData._getMOCBalanceAt(owner, addresses[i]);\n            if (balance > maxBalance) {\n                maxBalance = balance;\n                selected = addresses[i];\n            }\n        }\n\n        return (selected, maxBalance);\n    }\n\n    /**\n      @notice Modifier that checks locked stake for withdrawal availability\n      @dev You should use this modifier in any function that withdraws a user's stake.\n     */\n    modifier stakeAvailable(\n        address user,\n        address subaccount,\n        uint256 tokens\n    ) {\n        uint256 lockedAmount = 0;\n        uint256 mocs = supportersData._tokenToMoc(tokens);\n        LockingInfo storage lockedMocsInfo = lockedMocs[subaccount];\n        uint256 mocBalance = supportersData._getMOCBalanceAt(user, subaccount);\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp < lockedMocsInfo.untilTimestamp) {\n            lockedAmount = lockedMocsInfo.amount;\n        }\n        uint256 surplus = mocBalance.sub(lockedAmount);\n        require(mocs <= surplus, \"Stake not available for withdrawal.\");\n        _;\n    }\n}\n\n",
    "imports": [
        {
            "name": "Supporters.sol",
            "contents": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\n/*\n    Basic public interface for the supporters smart contract.\n    The facade for this contract is the StakingMachine, this interface is specifically for the scheduler\n    that needs to call distribute() to distribute the rewards.\n*/\ninterface ISupporters {\n    /**\n      @notice Deposit earnings that will be credited to supporters.\n      @dev Earnings will be credited periodically through several blocks.\n    */\n    function distribute() external;\n\n    /**\n      @notice Return true if is ready to do a distribute call\n\n      @return true if ready\n    */\n    function isReadyToDistribute() external view returns (bool);\n\n    /// @notice The moc token address\n    function mocToken() external view returns (IERC20);\n\n    /**\n     @notice Return the round length in blocks .\n     @dev During each round rewards are collected and distributed during next round.\n\n     @return Number of blocks to distribute earnings\n    */\n    function period() external view returns (uint256);\n\n    // @notice total amount of mocs inside the supporters contract\n    function totalMoc() external view returns (uint256);\n\n    // @notice total amount of tokens inside the supporters contect.\n    function totalToken() external view returns (uint256);\n}\n\n\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n    /**\n      @notice Override this function with a recipe of the changes to be done when this ChangeContract\n      is executed\n     */\n    function execute() external;\n}\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor {\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @dev This function should be protected somehow to only execute changes that\n      benefit the system. This decision process is independent of this architechture\n      therefore is independent of this interface too\n      @param changeContract Address of the contract that will execute the changes\n     */\n    function executeChange(ChangeContract changeContract) external;\n\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @param _changer Address of the contract that will execute the changes\n     */\n    function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed {\n    /**\n      @notice The address of the contract which governs this one\n     */\n    IGovernor public governor;\n\n    string private constant NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n    /**\n      @notice Modifier that protects the function\n      @dev You should use this modifier in any function that should be called through\n      the governance system\n     */\n    modifier onlyAuthorizedChanger() {\n        require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n        _;\n    }\n\n    /**\n      @notice Initialize the contract with the basic settings\n      @dev This initialize replaces the constructor but it is not called automatically.\n      It is necessary because of the upgradeability of the contracts\n      @param _governor Governor address\n     */\n    function _initialize(IGovernor _governor) internal {\n        governor = _governor;\n    }\n\n    /**\n      @notice Change the contract's governor. Should be called through the old governance system\n      @param newIGovernor New governor address\n     */\n    function changeIGovernor(IGovernor newIGovernor) external onlyAuthorizedChanger {\n        governor = newIGovernor;\n    }\n\n    /**\n      @notice This method is used by a change contract to access the storage freely even without a setter.\n      @param data the serialized function arguments\n     */\n    function delegateCallToChanger(bytes calldata data)\n        external\n        onlyAuthorizedChanger\n        returns (bytes memory)\n    {\n        address changerContrat = msg.sender;\n        (bool success, bytes memory result) = changerContrat.delegatecall(\n            abi.encodeWithSignature(\"impersonate(bytes)\", data)\n        );\n        require(success, \"Error in delegate call\");\n        return result;\n    }\n\n    // Leave a gap betweeen inherited contracts variables in order to be\n    // able to add more variables in them later\n    uint256[50] private upgradeGap;\n}\n\n\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n\n\n\n/**\n  @notice Based on heavily on EnumberableSet, but with the ability to clear all the contents.\n */\nlibrary AddressSetLib {\n    using SafeMath for uint256;\n\n    struct AddressSet {\n        // Storage of set values\n        address[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(address => uint256) _indexes;\n    }\n\n    function init() internal pure returns (AddressSet memory) {\n        return AddressSet({_values: new address[](0)});\n    }\n\n    /**\n     * @dev Removes all value from a set. O(N).\n     *\n     */\n    function clear(AddressSet storage set) internal {\n        for (uint256 i = 0; i < set._values.length; i++) {\n            delete set._indexes[set._values[i]];\n        }\n        delete set._values;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        if (!contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            address lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1;\n            // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        require(set._values.length > index, \"index out of bounds\");\n        return set._values[index];\n    }\n\n    /**\n     * @dev Returns the set contents as an array\n     */\n    function asArray(AddressSet storage set)\n        internal\n        view\n        returns (address[] memory selectedOracles)\n    {\n        return set._values;\n    }\n}\n\n\n/**\n  @dev An iterable mapping of addresses to boolean, used to check if an address is whitelisted.\n */\ncontract IIterableWhitelist {\n    /**\n      @notice Modifier that protects the function\n      @dev You should use this modifier in any function that should be filtered by the whitelist\n     */\n    modifier whitelistedOrExternal(IterableWhitelistLib.IterableWhitelistData storage self) {\n        // We use address(1) to allow calls from outside the block chain to peek\n        // The call must use msg.sender == 1 (or { from: 1 }) something that only can be done from\n        // outside the blockchain.\n        require(\n            msg.sender == address(1) || IterableWhitelistLib._isWhitelisted(self, msg.sender),\n            \"Address is not whitelisted\"\n        );\n        _;\n    }\n\n    /**\n      @notice Modifier that protects the function\n      @dev You should use this modifier in any function that should be filtered by the whitelist\n     */\n    modifier onlyWhitelisted(IterableWhitelistLib.IterableWhitelistData storage self) {\n        require(\n            IterableWhitelistLib._isWhitelisted(self, msg.sender),\n            \"Address is not whitelisted\"\n        );\n        _;\n    }\n}\n\nlibrary IterableWhitelistLib {\n    using AddressSetLib for AddressSetLib.AddressSet;\n\n    struct IterableWhitelistData {\n        AddressSetLib.AddressSet _inner;\n    }\n\n    /**\n     * @dev Check if an account is whitelisted\n     * @return Bool\n     */\n    function _isWhitelisted(IterableWhitelistData storage self, address account)\n        internal\n        view\n        returns (bool)\n    {\n        require(account != address(0), \"Account must not be 0x0\");\n        return self._inner.contains(account);\n    }\n\n    /**\n     * @dev Add account to whitelist\n     */\n    function _addToWhitelist(IterableWhitelistData storage self, address account) internal {\n        require(account != address(0), \"Account must not be 0x0\");\n        bool added = self._inner.add(account);\n        require(added, \"Account already whitelisted\");\n    }\n\n    /**\n     * @dev Remove account to whitelist\n     */\n    function _removeFromWhitelist(IterableWhitelistData storage self, address account) internal {\n        require(account != address(0), \"Account must not be 0x0\");\n        bool removed = self._inner.remove(account);\n        require(removed, \"Missing account\");\n    }\n\n    /// @notice Returns the count of whitelisted addresses.\n    function _getWhiteListLen(IterableWhitelistData storage self) internal view returns (uint256) {\n        return self._inner.length();\n    }\n\n    /// @notice Returns the address at index.\n    /// @param idx index to query.\n    function _getWhiteListAtIndex(IterableWhitelistData storage self, uint256 idx)\n        internal\n        view\n        returns (address)\n    {\n        return self._inner.at(idx);\n    }\n}\n\n\n\n/*\n    Abstract contract meant to be reused.\n*/\nlibrary SupportersLib {\n    /// Global registration information for each oracle\n    struct SupportersData {\n        // Balance in tokens for each supporter\n        mapping(address => mapping(address => uint256)) tokenBalances;\n        // Total of tokens created\n        uint256 totalSupply;\n        // Total of MOC deposited in the contract\n        uint256 mocBalance;\n        // Initial block where earnings started to be paid\n        uint256 startEarnings;\n        // Final block where earnings will be paid\n        uint256 endEarnings;\n        // Amount of earning paid\n        uint256 earnings;\n        // Number of blocks to distribute earnings\n        uint256 period;\n        // MOC token address\n        IERC20 mocToken;\n    }\n\n    using SafeMath for uint256;\n\n    event PayEarnings(uint256 earnings, uint256 start, uint256 end);\n\n    event CancelEarnings(uint256 earnings, uint256 start, uint256 end);\n\n    event AddStake(\n        address indexed user,\n        address indexed subaccount,\n        address indexed sender,\n        uint256 amount,\n        uint256 mocs\n    );\n\n    event WithdrawStake(\n        address indexed user,\n        address indexed subaccount,\n        address indexed destination,\n        uint256 amount,\n        uint256 mocs\n    );\n\n    /**\n    Contract creation\n\n    @param _mocToken MOC token address\n    @param _period Number of blocks to distribute earnings, round length\n    */\n    function _initialize(\n        SupportersData storage self,\n        IERC20 _mocToken,\n        uint256 _period\n    ) internal {\n        self.mocToken = _mocToken;\n        self.period = _period;\n    }\n\n    /**\n     * @dev Sets the period,\n     * @param _period- the override minOracleOwnerStake\n     */\n    function _setPeriod(SupportersData storage self, uint256 _period) internal {\n        self.period = _period;\n    }\n\n    /**\n     * @dev Sets the moc token address,\n     * @param _mocToken- the override mocToken\n     */\n    function _setMocToken(SupportersData storage self, IERC20 _mocToken) internal {\n        self.mocToken = _mocToken;\n    }\n\n    /**\n      Deposit earnings that will be credited to supporters.\n      Earnings will be credited periodically through several blocks.\n    */\n    function _distribute(SupportersData storage self) internal {\n        require(_isReadyToDistribute(self), \"Not ready to distribute\");\n\n        // Calculate deposited earnings that are unaccounted for\n        uint256 balance = self.mocToken.balanceOf(address(this));\n        self.earnings = balance.sub(self.mocBalance);\n\n        // Start paying earning to the next round\n        self.startEarnings = block.number;\n        self.endEarnings = self.startEarnings.add(self.period);\n        self.mocBalance = balance;\n\n        emit PayEarnings(self.earnings, self.startEarnings, self.endEarnings);\n    }\n\n    /**\n      Return true if is ready to do a distribute call\n\n      @return true if ready\n    */\n    function _isReadyToDistribute(SupportersData storage self) internal view returns (bool) {\n        return (self.totalSupply > 0 && block.number > self.endEarnings);\n    }\n\n    /**\n      Stake MOC to receive earnings on a subaccount.\n\n      @param _mocs amount of MOC to stake\n      @param _subaccount sub-account used to identify the stake\n      @param _sender sender account that must approve and from which the funds are taken\n    */\n    function _stakeAtFrom(\n        SupportersData storage self,\n        uint256 _mocs,\n        address _subaccount,\n        address _sender\n    ) internal {\n        uint256 tokens = _mocToToken(self, _mocs);\n        _stakeAtFromInternal(self, tokens, _mocs, _subaccount, _sender);\n    }\n\n    /**\n      Stake MOC to receive earnings on a subaccount.\n\n      @param _tokens amount of tokens to stake\n      @param _mocs amount of MOC to stake\n      @param _subaccount sub-account used to identify the stake\n      @param _sender sender account that must approve and from which the funds are taken\n    */\n    function _stakeAtFromInternal(\n        SupportersData storage self,\n        uint256 _tokens,\n        uint256 _mocs,\n        address _subaccount,\n        address _sender\n    ) internal {\n        // Done outside this contract so we can get the value of\n        // uint256 tokens = _mocToToken(self, _mocs);\n        self.mocBalance = self.mocBalance.add(_mocs);\n        require(\n            self.mocToken.transferFrom(_sender, address(this), _mocs),\n            \"error in transfer from\"\n        );\n\n        __mintToken(self, msg.sender, _tokens, _subaccount);\n\n        emit AddStake(msg.sender, _subaccount, _sender, _tokens, _mocs);\n    }\n\n    /**\n      Withdraw MOC for tokens for a subaccount.\n\n      @param _tokens amount of tokens to convert to MOC\n      @param _subaccount subaccount used to withdraw MOC\n      @param _receiver destination address that gets the MOC\n      @return Amount of MOC transfered\n    */\n    function _withdrawFromTo(\n        SupportersData storage self,\n        uint256 _tokens,\n        address _subaccount,\n        address _receiver\n    ) internal returns (uint256) {\n        uint256 mocs = _tokenToMoc(self, _tokens);\n\n        _burnToken(self, msg.sender, _tokens, _subaccount);\n\n        self.mocBalance = self.mocBalance.sub(mocs);\n        require(self.mocToken.transfer(_receiver, mocs), \"error in transfer\");\n\n        // When last supporter exits move pending earnings to next round\n        if (self.totalSupply == 0) {\n            _resetEarnings(self);\n        }\n\n        emit WithdrawStake(msg.sender, _subaccount, _receiver, _tokens, mocs);\n        return mocs;\n    }\n\n    /**\n      Amount of tokens for _user in a _subaccount.\n\n      @param _user User address\n      @param _subaccount subaccount to get balance\n      @return tokens for _user at _subaccount\n    */\n    function _getBalanceAt(\n        SupportersData storage self,\n        address _user,\n        address _subaccount\n    ) internal view returns (uint256) {\n        return self.tokenBalances[_user][_subaccount];\n    }\n\n    /**\n      MOC available for withdrawal by _user.\n\n      @param _user User address\n      @param _subaccount subaccount to get MOC balance\n      @return MOC for _user\n    */\n    function _getMOCBalanceAt(\n        SupportersData storage self,\n        address _user,\n        address _subaccount\n    ) internal view returns (uint256) {\n        return _tokenToMoc(self, self.tokenBalances[_user][_subaccount]);\n    }\n\n    /**\n      Total tokens created.\n\n      @return total amount of tokens\n    */\n    function _getTokens(SupportersData storage self) internal view returns (uint256) {\n        return self.totalSupply;\n    }\n\n    /**\n      MOC available for withdrawal.\n\n      @return total amount of MOC\n    */\n    function _getAvailableMOC(SupportersData storage self) internal view returns (uint256) {\n        return self.mocBalance.sub(_getLockedAt(self, block.number));\n    }\n\n    /**\n      Convert amount MOC to equivalent in token\n\n      @param _mocs Amount of MOC\n      @return Equivalent amount of tokens\n    */\n    function _mocToToken(SupportersData storage self, uint256 _mocs)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 totalMocs = _getAvailableMOC(self);\n        uint256 totalTokens = _getTokens(self);\n        if (totalMocs == 0 && totalTokens == 0) {\n            return _mocs;\n        }\n        return _mocs.mul(totalTokens).div(totalMocs);\n    }\n\n    /**\n      Convert tokens to equivalente in MOC\n\n      @param _tokens Amount of tokens\n      @return Equivalent amount of MOC\n    */\n    function _tokenToMoc(SupportersData storage self, uint256 _tokens)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 totalTokens = _getTokens(self);\n        uint256 totalMocs = _getAvailableMOC(self);\n        if (totalMocs == 0) {\n            return 0;\n        }\n        return _tokens.mul(totalMocs).div(totalTokens);\n    }\n\n    /**\n      Convert tokens to equivalente in MOC ceiling up\n\n      @param _tokens Amount of tokens\n      @return Equivalent amount of MOC\n    */\n    function _tokenToMocUP(SupportersData storage self, uint256 _tokens)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 totalTokens = _getTokens(self);\n        uint256 totalMocs = _getAvailableMOC(self);\n        if (totalMocs == 0) {\n            return 0;\n        }\n        return _tokens.mul(totalMocs).add(totalTokens).sub(1).div(totalTokens);\n    }\n\n    /**\n      Calculate earnings to be paid at a block\n\n      @param _block Block used to calculate\n      @return Earnings to be paid\n    */\n    function _getEarningsAt(SupportersData storage self, uint256 _block)\n        internal\n        view\n        returns (uint256)\n    {\n        if (self.earnings == 0) return 0;\n        if (_block < self.startEarnings) return 0;\n        if (_block > self.endEarnings) return self.earnings;\n        return\n            self.earnings.mul(_block.sub(self.startEarnings)).div(\n                self.endEarnings.sub(self.startEarnings)\n            );\n    }\n\n    /**\n      Calculate locked earnings at a block\n\n      @param _block Block used for calculations\n      @return Locked amount of earnings in MOC\n    */\n    function _getLockedAt(SupportersData storage self, uint256 _block)\n        internal\n        view\n        returns (uint256)\n    {\n        return self.earnings.sub(_getEarningsAt(self, _block));\n    }\n\n    /**\n      @dev Create tokens and assign to a user\n\n      @param _user User address to be assigned tokens\n      @param _amount Amount of tokens to create\n      @param _subaccount Subaccount to store tokens\n    */\n    function __mintToken(\n        SupportersData storage self,\n        address _user,\n        uint256 _amount,\n        address _subaccount\n    ) internal {\n        self.tokenBalances[_user][_subaccount] = self.tokenBalances[_user][_subaccount].add(\n            _amount\n        );\n        self.totalSupply = self.totalSupply.add(_amount);\n    }\n\n    /**\n      @dev Return information about earnings\n\n      @return Information about earnings\n    */\n    function _getEarningsInfo(SupportersData storage self)\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 next = self.mocToken.balanceOf(address(this)).sub(self.mocBalance);\n        uint256 distributed = _getEarningsAt(self, block.number);\n        return (self.earnings, distributed, next);\n    }\n\n    /**\n      @dev Destroy tokens from a user\n\n      @param _user User address containing tokens\n      @param _amount Amount of tokens to destroy\n      @param _subaccount Subaccount with tokens\n    */\n    function _burnToken(\n        SupportersData storage self,\n        address _user,\n        uint256 _amount,\n        address _subaccount\n    ) internal {\n        self.tokenBalances[_user][_subaccount] = self.tokenBalances[_user][_subaccount].sub(\n            _amount\n        );\n        self.totalSupply = self.totalSupply.sub(_amount);\n    }\n\n    /**\n      @dev Reset earnings\n\n      Move pending earnings on the current round to the next one\n    */\n    function _resetEarnings(SupportersData storage self) internal {\n        uint256 pending = self.mocBalance;\n        self.mocBalance = 0;\n        self.earnings = 0;\n        emit CancelEarnings(pending, self.startEarnings, self.endEarnings);\n    }\n}\n\n\n/*\n    Right now we have two things implemented in the same smart-contract:\n        - Only the smart-contracts in the whitelist can access this one.\n        - Some vesting rules implemented in SupportersVestedAbstract\n    This can be split in the future in two smart-contracts if we want to add a specific set\n    of vesting rules (that doesn't do what SupportersVestedAbstract does).\n*/\ncontract SupportersStorage is Initializable, Governed, IIterableWhitelist {\n    using SafeMath for uint256;\n    using SupportersLib for SupportersLib.SupportersData;\n    using IterableWhitelistLib for IterableWhitelistLib.IterableWhitelistData;\n\n    struct LockingInfo {\n        uint256 untilTimestamp;\n        uint256 amount;\n    }\n\n    mapping(address => LockingInfo) public lockedMocs;\n\n    // Whitelisted contracts that can add/remove stake in this one.\n    IterableWhitelistLib.IterableWhitelistData internal iterableWhitelistData;\n\n    SupportersLib.SupportersData internal supportersData;\n\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    // solhint-disable-next-line no-empty-blocks\n    constructor() internal {}\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n\n\n/*\n    Right now we have two things implemented in the same smart-contract:\n        - Only the smart-contracts in the whitelist can access this one.\n        - Some vesting rules implemented in SupportersVestedAbstract\n    This can be split in the future in two smart-contracts if we want to add a specific set\n    of vesting rules (that doesn't do what SupportersVestedAbstract does).\n*/\ncontract Supporters is SupportersStorage, ISupporters {\n    using SafeMath for uint256;\n\n    // Emitted by SupportersLib\n    event PayEarnings(uint256 earnings, uint256 start, uint256 end);\n    event CancelEarnings(uint256 earnings, uint256 start, uint256 end);\n    event AddStake(\n        address indexed user,\n        address indexed subaccount,\n        address indexed sender,\n        uint256 amount,\n        uint256 mocs\n    );\n    event WithdrawStake(\n        address indexed user,\n        address indexed subaccount,\n        address indexed destination,\n        uint256 amount,\n        uint256 mocs\n    );\n\n    event Withdraw(\n        address indexed msgSender,\n        address indexed subacount,\n        address indexed receiver,\n        uint256 mocs,\n        uint256 blockNum\n    );\n\n    /**\n     @notice Contract creation\n\n     @param _governor The address of the contract which governs this one\n     @param _wlist Initial whitelist addresses\n     @param _mocToken The address of the contract which governs this one\n     @param _period The address of the contract which governs this one\n    */\n    function initialize(\n        IGovernor _governor,\n        address[] calldata _wlist,\n        IERC20 _mocToken,\n        uint256 _period\n    ) external initializer {\n        Governed._initialize(_governor);\n        supportersData._initialize(_mocToken, _period);\n        for (uint256 i = 0; i < _wlist.length; i++) {\n            iterableWhitelistData._addToWhitelist(_wlist[i]);\n        }\n    }\n\n    /// @notice Used by the voting machine to lock an amount of MOCs.\n    /// @param mocHolder the moc holder whose mocs will be locked.\n    /// @param untilTimestamp timestamp until which the mocs will be locked.\n    function lockMocs(address mocHolder, uint256 untilTimestamp)\n        external\n        onlyWhitelisted(iterableWhitelistData)\n    {\n        LockingInfo storage lockedMocsInfo = lockedMocs[mocHolder];\n        lockedMocsInfo.untilTimestamp = untilTimestamp;\n        uint256 mocBalance = supportersData._getMOCBalanceAt(msg.sender, mocHolder);\n        lockedMocsInfo.amount = mocBalance;\n    }\n\n    /// @notice Reports the balance of locked MOCs for a specific user.\n    /// Delegates to the Supporters smart contract.\n    /// @param user user address\n    function getLockedBalance(address user) external view returns (uint256) {\n        LockingInfo storage lockedMocsInfo = lockedMocs[user];\n        return lockedMocsInfo.amount;\n    }\n\n    /// @notice Reports the balance of locked MOCs for a specific user.\n    /// Delegates to the Supporters smart contract.\n    /// @param user user address\n    /// @return amount the amount of mocs locked\n    /// @return untilTimestamp the timestamp that corresponds to the locking date.\n    function getLockingInfo(address user)\n        external\n        view\n        returns (uint256 amount, uint256 untilTimestamp)\n    {\n        LockingInfo storage lockedMocsInfo = lockedMocs[user];\n        return (lockedMocsInfo.amount, lockedMocsInfo.untilTimestamp);\n    }\n\n    /**\n     @notice Add to the list of contracts that can stake in this contract\n\n     @param  _whitelisted - the override coinPair\n    */\n    function addToWhitelist(address _whitelisted) external onlyAuthorizedChanger() {\n        iterableWhitelistData._addToWhitelist(_whitelisted);\n    }\n\n    /**\n     @notice Remove from the list of contracts that can stake in this contract\n\n     @param _whitelisted - the override coinPair\n    */\n    function removeFromWhitelist(address _whitelisted) external onlyAuthorizedChanger() {\n        iterableWhitelistData._removeFromWhitelist(_whitelisted);\n    }\n\n    /**\n      @notice Deposit earnings that will be credited to supporters.\n      @dev Earnings will be credited periodically through several blocks.\n    */\n    function distribute() external override {\n        supportersData._distribute();\n    }\n\n    /**\n      @notice Return true if is ready to do a distribute call\n\n      @return true if ready\n    */\n    function isReadyToDistribute() external override view returns (bool) {\n        return supportersData._isReadyToDistribute();\n    }\n\n    /**\n     Stake MOC to receive earnings on a subaccount.\n\n     @param _mocs amount of MOC to stake\n     @param _subaccount sub-account used to identify the stake\n    */\n    function stakeAt(uint256 _mocs, address _subaccount)\n        external\n        onlyWhitelisted(iterableWhitelistData)\n    {\n        supportersData._stakeAtFrom(_mocs, _subaccount, msg.sender);\n    }\n\n    /**\n     Stake MOC to receive earnings on a subaccount.\n\n     @param _mocs amount of MOC to stake\n     @param _subaccount sub-account used to identify the stake\n     @param _sender sender account that must approve and from which the funds are taken\n    */\n    function stakeAtFrom(\n        uint256 _mocs,\n        address _subaccount,\n        address _sender\n    ) external onlyWhitelisted(iterableWhitelistData) {\n        supportersData._stakeAtFrom(_mocs, _subaccount, _sender);\n    }\n\n    /**\n     This function is for internal use, it doesn't force a price for the internal token.\n     The idea is to let the code in the staking machine calculate the price relationship and take only the\n     needed amount of mocs from the user.\n\n     @param _tokens amount of tokens to stake\n     @param _mocs amount of MOC to stake\n     @param _subaccount sub-account used to identify the stake\n     @param _sender sender account that must approve and from which the funds are taken\n    */\n    function stakeAtFromInternal(\n        uint256 _tokens,\n        uint256 _mocs,\n        address _subaccount,\n        address _sender\n    ) external onlyWhitelisted(iterableWhitelistData) {\n        supportersData._stakeAtFromInternal(_tokens, _mocs, _subaccount, _sender);\n    }\n\n    /**\n      Withdraw MOC for tokens for a subaccount.\n\n      @param _tokens amount of tokens to convert to MOC\n      @param _subaccount subaccount used to withdraw MOC\n      @return Amount of MOC transfered\n    */\n    function withdrawFrom(uint256 _tokens, address _subaccount)\n        external\n        onlyWhitelisted(iterableWhitelistData)\n        stakeAvailable(msg.sender, _subaccount, _tokens)\n        returns (uint256)\n    {\n        return supportersData._withdrawFromTo(_tokens, _subaccount, msg.sender);\n    }\n\n    /**\n      Withdraw MOC for tokens for a subaccount.\n\n      @param _tokens amount of tokens to convert to MOC\n      @param _subaccount subaccount used to withdraw MOC\n      @param _receiver destination address that gets the MOC\n      @return Amount of MOC transfered\n    */\n    function withdrawFromTo(\n        uint256 _tokens,\n        address _subaccount,\n        address _receiver\n    )\n        external\n        onlyWhitelisted(iterableWhitelistData)\n        stakeAvailable(msg.sender, _subaccount, _tokens)\n        returns (uint256)\n    {\n        return supportersData._withdrawFromTo(_tokens, _subaccount, _receiver);\n    }\n\n    /**\n      @notice Amount of tokens for _user in a _subaccount.\n\n      @param _user User address\n      @param _subaccount subaccount to get balance\n      @return tokens for _user at _subaccount\n    */\n    function getBalanceAt(address _user, address _subaccount) external view returns (uint256) {\n        return supportersData._getBalanceAt(_user, _subaccount);\n    }\n\n    /**\n      @notice MOC available for withdrawal by _user.\n\n      @param _user User address\n      @param _subaccount subaccount to get MOC balance\n      @return MOC for _user\n    */\n    function getMOCBalanceAt(address _user, address _subaccount) external view returns (uint256) {\n        return supportersData._getMOCBalanceAt(_user, _subaccount);\n    }\n\n    /**\n      @notice Calculate earnings to be paid at a block\n\n      @param _block Block used to calculate\n      @return Earnings to be paid\n    */\n    function getEarningsAt(uint256 _block) external view returns (uint256) {\n        return supportersData._getEarningsAt(_block);\n    }\n\n    /**\n      @notice Calculate locked earnings at a block\n\n      @param _block Block used for calculations\n      @return Locked amount of earnings in MOC\n    */\n    function getLockedAt(uint256 _block) external view returns (uint256) {\n        return supportersData._getLockedAt(_block);\n    }\n\n    /**\n      @notice Return information about earnings\n\n      @return Information about earnings\n    */\n    function getEarningsInfo()\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return supportersData._getEarningsInfo();\n    }\n\n    /// @notice The moc token address\n    function mocToken() external override view returns (IERC20) {\n        return supportersData.mocToken;\n    }\n\n    /**\n     @notice Return the round length in blocks .\n     @dev During each round rewards are collected and distributed during next round.\n\n     @return Number of blocks to distribute earnings\n    */\n    function period() external override view returns (uint256) {\n        return supportersData.period;\n    }\n\n    /// @notice Returns the count of whitelisted addresses.\n    function getWhiteListLen() external view returns (uint256) {\n        return iterableWhitelistData._getWhiteListLen();\n    }\n\n    /**\n     @notice Returns the address at index.\n\n     @param _idx index to query.\n    */\n    function getWhiteListAtIndex(uint256 _idx) external view returns (address) {\n        return iterableWhitelistData._getWhiteListAtIndex(_idx);\n    }\n\n    /**\n     @notice Check if an account is whitelisted\n\n     @param _account The account to check\n    */\n    function isWhitelisted(address _account) external view returns (bool) {\n        return iterableWhitelistData._isWhitelisted(_account);\n    }\n\n    /**\n      Convert amount MOC to equivalent in token\n\n      @param _mocs Amount of MOC\n      @return Equivalent amount of tokens\n    */\n    function mocToToken(uint256 _mocs) external view returns (uint256) {\n        return supportersData._mocToToken(_mocs);\n    }\n\n    /**\n      Convert amount tokens to equivalent in MOCS\n\n      @param _token Amount of tokens\n      @return Equivalent amount of tokens\n    */\n    function tokenToMoc(uint256 _token) external view returns (uint256) {\n        return supportersData._tokenToMoc(_token);\n    }\n\n    /**\n       Convert amount tokens to equivalent in MOCS ceiling up\n\n       @param _token Amount of tokens\n       @return Equivalent amount of tokens\n     */\n    function tokenToMocUP(uint256 _token) external view returns (uint256) {\n        return supportersData._tokenToMocUP(_token);\n    }\n\n    // @notice total amount of mocs inside the supporters contract\n    function totalMoc() external override view returns (uint256) {\n        return supportersData._getAvailableMOC();\n    }\n\n    // @notice total amount of tokens inside the supporters contect.\n    function totalToken() external override view returns (uint256) {\n        return supportersData._getTokens();\n    }\n\n    function getMaxMOCBalance(address owner, address[] calldata addresses)\n        external\n        view\n        returns (address selected, uint256 maxBalance)\n    {\n        if (addresses.length == 0) {\n            return (selected, maxBalance);\n        }\n\n        selected = addresses[0];\n        maxBalance = supportersData._getMOCBalanceAt(owner, addresses[0]);\n        for (uint256 i = 1; i < addresses.length; i += 1) {\n            if (addresses[i] == address(0)) {\n                continue;\n            }\n            uint256 balance = supportersData._getMOCBalanceAt(owner, addresses[i]);\n            if (balance > maxBalance) {\n                maxBalance = balance;\n                selected = addresses[i];\n            }\n        }\n\n        return (selected, maxBalance);\n    }\n\n    /**\n      @notice Modifier that checks locked stake for withdrawal availability\n      @dev You should use this modifier in any function that withdraws a user's stake.\n     */\n    modifier stakeAvailable(\n        address user,\n        address subaccount,\n        uint256 tokens\n    ) {\n        uint256 lockedAmount = 0;\n        uint256 mocs = supportersData._tokenToMoc(tokens);\n        LockingInfo storage lockedMocsInfo = lockedMocs[subaccount];\n        uint256 mocBalance = supportersData._getMOCBalanceAt(user, subaccount);\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp < lockedMocsInfo.untilTimestamp) {\n            lockedAmount = lockedMocsInfo.amount;\n        }\n        uint256 surplus = mocBalance.sub(lockedAmount);\n        require(mocs <= surplus, \"Stake not available for withdrawal.\");\n        _;\n    }\n}\n\n",
            "file": "Supporters.sol"
        }
    ],
    "libraries": {},
    "creationData": {
        "blockHash": "0xdf24b5345549a61dc431b6e10f56bb7ee45a39b8e70e86237a714014254985a3",
        "blockNumber": 1319742,
        "transactionHash": "0x3c13728a9b753ceeb6c474cbabf2ef93574e787c30c95bf8fa369dd9563a67c1",
        "timestamp": 1604602259
    }
}