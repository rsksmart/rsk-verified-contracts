{
  "address": "0x380a47e2a1cec8a21cf00374ea5d092166a702fc",
  "net": {
    "id": "31",
    "name": "RSK Testnet"
  },
  "name": "RSKDomainsBatch",
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "metadata",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ]
      }
    }
  },
  "version": "0.5.11+commit.c082d0b4",
  "source": "\n// File: @openzeppelin/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: @ensdomains/ethregistrar/contracts/StringUtils.sol\n\npragma solidity >=0.4.24;\n\nlibrary StringUtils {\n    /**\n     * @dev Returns the length of a given string\n     *\n     * @param s The string to measure the length of\n     * @return The length of the input string\n     */\n    function strlen(string memory s) internal pure returns (uint) {\n        uint len;\n        uint i = 0;\n        uint bytelength = bytes(s).length;\n        for(len = 0; i < bytelength; len++) {\n            byte b = bytes(s)[i];\n            if(b < 0x80) {\n                i += 1;\n            } else if (b < 0xE0) {\n                i += 2;\n            } else if (b < 0xF0) {\n                i += 3;\n            } else if (b < 0xF8) {\n                i += 4;\n            } else if (b < 0xFC) {\n                i += 5;\n            } else {\n                i += 6;\n            }\n        }\n        return len;\n    }\n}\n\n// File: @openzeppelin/contracts/GSN/Context.sol\n\npragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\n\npragma solidity ^0.5.0;\n\n\n\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\n// File: @rsksmart/erc677/contracts/ERC677TransferReceiver.sol\n\npragma solidity ^0.5.0;\n\n /*\n * Contract interface for receivers of tokens that\n * comply with ERC-677.\n * See https://github.com/ethereum/EIPs/issues/677 for details.\n */\ncontract ERC677TransferReceiver {\n    function tokenFallback(address from, uint256 amount, bytes calldata data) external returns (bool);\n}\n\n// File: @rsksmart/erc677/contracts/IERC677.sol\n\npragma solidity ^0.5.0;\n\n\ncontract IERC677 is IERC20 {\n    function transferAndCall(address to, uint256 value, bytes memory data) public returns (bool ok);\n\n    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);\n}\n\n// File: @rsksmart/erc677/contracts/ERC677.sol\n\npragma solidity ^0.5.0;\n\n// Use only for testing reasons\n\n\n\n\n\ncontract ERC677 is IERC677, ERC20, ERC20Detailed {\n    constructor(\n        address initialAccount,\n        uint256 initialBalance,\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) ERC20Detailed(name, symbol, decimals) public {\n        _mint(initialAccount, initialBalance);\n    }\n\n    /**\n     * ERC-677's only method implementation\n     * See https://github.com/ethereum/EIPs/issues/677 for details\n     */\n    function transferAndCall(address _to, uint _value, bytes memory _data) public returns (bool) {\n        bool result = super.transfer(_to, _value);\n        if (!result) return false;\n\n        emit Transfer(msg.sender, _to, _value, _data);\n\n        ERC677TransferReceiver receiver = ERC677TransferReceiver(_to);\n        receiver.tokenFallback(msg.sender, _value, _data);\n\n        // IMPORTANT: the ERC-677 specification does not say\n        // anything about the use of the receiver contract's\n        // tokenFallback method return value. Given\n        // its return type matches with this method's return\n        // type, returning it could be a possibility.\n        // We here take the more conservative approach and\n        // ignore the return value, returning true\n        // to signal a succesful transfer despite tokenFallback's\n        // return value -- fact being tokens are transferred\n        // in any case.\n        return true;\n    }\n}\n\n// File: @openzeppelin/contracts/introspection/IERC165.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address owner) public view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     *\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract IERC721Receiver {\n    /**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\n     * otherwise the caller will revert the transaction. The selector to be\n     * returned can be obtained as `this.onERC721Received.selector`. This\n     * function MAY throw to revert and reject the transfer.\n     * Note: the ERC721 contract address is always the message sender.\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n    public returns (bytes4);\n}\n\n// File: @openzeppelin/contracts/utils/Address.sol\n\npragma solidity ^0.5.5;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following \n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\n// File: @openzeppelin/contracts/drafts/Counters.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n\n// File: @openzeppelin/contracts/introspection/ERC165.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\ncontract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/ERC721.sol\n\npragma solidity ^0.5.0;\n\n\n\n\n\n\n\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is Context, ERC165, IERC721 {\n    using SafeMath for uint256;\n    using Address for address;\n    using Counters for Counters.Counter;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from token ID to owner\n    mapping (uint256 => address) private _tokenOwner;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping (address => Counters.Counter) private _ownedTokensCount;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    constructor () public {\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner address to query the balance of\n     * @return uint256 representing the amount owned by the passed address\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n\n        return _ownedTokensCount[owner].current();\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _tokenOwner[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n\n        return owner;\n    }\n\n    /**\n     * @dev Approves another address to transfer the given token ID\n     * The zero address indicates there is no approved address.\n     * There can only be one approved address per token at a given time.\n     * Can only be called by the token owner or an approved operator.\n     * @param to address to be approved for the given token ID\n     * @param tokenId uint256 ID of the token to be approved\n     */\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Gets the approved address for a token ID, or zero if no address set\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to query the approval of\n     * @return address currently approved for the given token ID\n     */\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Sets or unsets the approval of a given operator\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\n     * @param to operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     */\n    function setApprovalForAll(address to, bool approved) public {\n        require(to != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][to] = approved;\n        emit ApprovalForAll(_msgSender(), to, approved);\n    }\n\n    /**\n     * @dev Tells whether an operator is approved by a given owner.\n     * @param owner owner address which you want to query the approval of\n     * @param operator operator address which you want to query the approval of\n     * @return bool whether the given operator is approved by the given owner\n     */\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Transfers the ownership of a given token ID to another address.\n     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     * Requires the msg.sender to be the owner, approved, or operator.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the _msgSender() to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransferFrom(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function _safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) internal {\n        _transferFrom(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether the specified token exists.\n     * @param tokenId uint256 ID of the token to query the existence of\n     * @return bool whether the token exists\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner = _tokenOwner[tokenId];\n        return owner != address(0);\n    }\n\n    /**\n     * @dev Returns whether the given spender can transfer a given token ID.\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     * is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Internal function to safely mint a new token.\n     * Reverts if the given token ID already exists.\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Internal function to safely mint a new token.\n     * Reverts if the given token ID already exists.\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Internal function to mint a new token.\n     * Reverts if the given token ID already exists.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _tokenOwner[tokenId] = to;\n        _ownedTokensCount[to].increment();\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use {_burn} instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == owner, \"ERC721: burn of token that is not own\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[owner].decrement();\n        _tokenOwner[tokenId] = address(0);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(uint256 tokenId) internal {\n        _burn(ownerOf(tokenId), tokenId);\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[from].decrement();\n        _ownedTokensCount[to].increment();\n\n        _tokenOwner[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * This is an internal detail of the `ERC721` contract and its use is deprecated.\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        internal returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = to.call(abi.encodeWithSelector(\n            IERC721Receiver(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ));\n        if (!success) {\n            if (returndata.length > 0) {\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n            }\n        } else {\n            bytes4 retval = abi.decode(returndata, (bytes4));\n            return (retval == _ERC721_RECEIVED);\n        }\n    }\n\n    /**\n     * @dev Private function to clear current approval of a given token ID.\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _clearApproval(uint256 tokenId) private {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n        }\n    }\n}\n\n// File: @openzeppelin/contracts/ownership/Ownable.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: @openzeppelin/contracts/access/Roles.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\n// File: @rsksmart/rns-registry/contracts/AbstractRNS.sol\n\npragma solidity ^0.5.0;\n\ncontract AbstractRNS {\n    function owner(bytes32 node) public view returns(address);\n    function resolver(bytes32 node) public view returns(address);\n    function ttl(bytes32 node) public view returns(uint64);\n    function setOwner(bytes32 node, address ownerAddress) public;\n    function setSubnodeOwner(bytes32 node, bytes32 label, address ownerAddress) public;\n    function setResolver(bytes32 node, address resolverAddress) public;\n    function setTTL(bytes32 node, uint64 ttlValue) public;\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address ownerAddress);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address ownerAddress);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolverAddress);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttlValue);\n}\n\n// File: @rsksmart/rns-rskregistrar/contracts/NodeOwner.sol\n\npragma solidity ^0.5.3;\n\n\n\n\n\ncontract NodeOwner is ERC721, Ownable {\n    using Roles for Roles.Role;\n\n    AbstractRNS private rns;\n    bytes32 private rootNode;\n\n    mapping (uint256 => uint) public expirationTime;\n\n    event ExpirationChanged(uint256 tokenId, uint expirationTime);\n\n    modifier onlyRegistrar {\n        require(registrars.has(msg.sender), \"Only registrar.\");\n        _;\n    }\n\n    modifier onlyRenewer {\n        require(renewers.has(msg.sender), \"Only renewer.\");\n        _;\n    }\n\n    constructor (\n        AbstractRNS _rns,\n        bytes32 _rootNode\n    ) public {\n        rns = _rns;\n        rootNode = _rootNode;\n    }\n\n    /// @notice Gets the owner of the specified domain.\n    /// @param tokenId keccak256 of the domain label.\n    /// @return domain owner.\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        require(expirationTime[tokenId] > now, \"ERC721: owner query for nonexistent token\");\n        return super.ownerOf(tokenId);\n    }\n\n    /// @notice Check if a domain is available to be registered.\n    /// @dev The name must be registered via account with registrar role.\n    /// @param tokenId keccak256 of the domain label.\n    /// @return true if the specified domain can be registered.\n    function available(uint256 tokenId) public view returns(bool) {\n        return expirationTime[tokenId] < now;\n    }\n\n    ///////////////////\n    // RSK TLD ADMIN //\n    ///////////////////\n\n    /*\n        This contract owns a node in RNS, so it is capable to\n        change it's resolution and ttl.\n    */\n\n    /// @notice set root node resolver in RNS.\n    /// @param resolver to be set.\n    function setRootResolver (address resolver) external onlyOwner {\n        rns.setResolver(rootNode, resolver);\n    }\n\n    /// @notice set root node ttl in RNS.\n    /// @param ttl to be set.\n    function setRootTTL (uint64 ttl) external onlyOwner {\n        rns.setTTL(rootNode, ttl);\n    }\n\n    //////////////////\n    // REGISTRATION //\n    //////////////////\n\n    /*\n        Only available domains can be registered. Once a domain is\n        registered, it cannot be revoked until expiration.\n    */\n\n    // An account with registrar role can register domains.\n    Roles.Role registrars;\n\n    /// @notice Give an account access to registrar role.\n    /// @dev Only owner.\n    /// @param registrar new registrar.\n    function addRegistrar(address registrar) external onlyOwner {\n        registrars.add(registrar);\n    }\n\n    /// @notice Check if an account has registrar role.\n    /// @param registrar to query if has registrar role.\n    /// @return true if it has registrar role.\n    function isRegistrar(address registrar) external view returns (bool) {\n        return registrars.has(registrar);\n    }\n\n    /// @notice Remove an account's access to registrar role.\n    /// @dev Only owner\n    /// @param registrar registrar to remove from registrar role.\n    function removeRegistrar(address registrar) external onlyOwner {\n        registrars.remove(registrar);\n    }\n\n    /// @notice Registers a domain in RNS for a given duration.\n    /// @dev Only accounts with registrar role.\n    /// @param label keccak256 of the domain label to register.\n    /// @param tokenOwner account that will own the registered domain.\n    /// @param duration time to register the domain for.\n    function register(bytes32 label, address tokenOwner, uint duration) external onlyRegistrar {\n        uint256 tokenId = uint256(label);\n\n        require(available(tokenId), \"Not available\");\n\n        uint newExpirationTime = now.add(duration);\n        expirationTime[tokenId] = newExpirationTime;\n        emit ExpirationChanged(tokenId, newExpirationTime);\n\n        if (_exists(tokenId))\n            _burn(tokenId);\n\n        _mint(tokenOwner, tokenId);\n\n        rns.setSubnodeOwner(rootNode, label, tokenOwner);\n    }\n\n    ////////////////\n    // RECLAIMING //\n    ////////////////\n\n    /*\n        Names might be lost by transferring to contracts, or by\n        error. This allows any owner (or approved) to reclaim the\n        domain ownership in RNS.\n    */\n\n    /// @notice Reclaim ownership of a domain in RNS.\n    /// @dev Only owner or approved for the domain.\n    /// @param tokenId keccak256 of the domain\n    /// @param newOwner the owner to set in RNS.\n    function reclaim(uint256 tokenId, address newOwner) external {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"Not approved or owner\");\n        rns.setSubnodeOwner(rootNode, bytes32(tokenId), newOwner);\n    }\n\n    ////////////////\n    // RENOVATION //\n    ////////////////\n\n    /*\n        Only owned domains can be renewed. A renovation extends\n        domain ownership.\n    */\n\n    // An account with renewer role can extend domain expirations.\n    Roles.Role renewers;\n\n    /// @notice Give an account access to renewer role.\n    /// @dev Only owner\n    /// @param renewer new renewer.\n    function addRenewer(address renewer) external onlyOwner {\n        renewers.add(renewer);\n    }\n\n    /// @notice Check if an account has renewer role.\n    /// @param renewer to query if has renewer role.\n    /// @return true if it has renewer role.\n    function isRenewer(address renewer) external view returns (bool) {\n        return renewers.has(renewer);\n    }\n\n    /// @notice Remove an account's access to renewer role.\n    /// @dev Only owner\n    /// @param renewer renewer to remove from renewer role.\n    function removeRenewer(address renewer) external onlyOwner {\n        renewers.remove(renewer);\n    }\n\n    /// @notice Renew a domain for a given duraiton.\n    /// @dev Only accounts with renewer role.\n    /// @param label keccak256 of the domain label to renew.\n    /// @param time to extend the duration for.\n    function renew (bytes32 label, uint time) external onlyRenewer {\n        uint256 tokenId = uint256(label);\n        require(expirationTime[tokenId] > now, \"Name already expired\");\n        uint newExpirationTime = expirationTime[tokenId].add(time);\n        expirationTime[tokenId] = newExpirationTime;\n        emit ExpirationChanged(tokenId, newExpirationTime);\n    }\n\n    //////////////////////\n    // AFTER EXPIRATION //\n    //////////////////////\n\n    /// @notice This method removes expired domains.\n    /// @dev Use this to set 0 address in RNS ownership\n    /// and burn the domains to keep balance up to date.\n    /// @param tokenIds keccak256s of the domain labels to remove.\n    function removeExpired(uint256[] calldata tokenIds) external {\n        uint256 tokenId;\n        bytes32 label;\n\n        for (uint i = 0; i < tokenIds.length; i++) {\n            tokenId = tokenIds[i];\n\n            if (_exists(tokenId) && available(tokenId)) {\n                expirationTime[tokenId] = ~uint(0);\n                _burn(tokenId);\n                expirationTime[tokenId] = 0;\n\n                label = bytes32(tokenId);\n                rns.setSubnodeOwner(rootNode, label, address(0));\n            }\n        }\n    }\n}\n\n// File: @rsksmart/rns-rskregistrar/contracts/AbstractNamePrice.sol\n\npragma solidity ^0.5.3;\n\n/// @title NamePrice interface\n/// @author Javier Esses\n/// @notice Defines an interface for name price calculations\ncontract AbstractNamePrice {\n    function price (string calldata name, uint expires, uint duration) external view returns(uint);\n}\n\n// File: @rsksmart/rns-rskregistrar/contracts/BytesUtils.sol\n\npragma solidity ^0.5.3;\n\n\nlibrary BytesUtils {\n    using SafeMath for uint256;\n\n    modifier minLength (uint size, uint offset, uint length) {\n        require(size >= offset.add(length), \"Short input\");\n        _;\n    }\n\n    function toBytes32 (bytes memory input, uint offset) public view minLength(input.length, offset, 32) returns (bytes32) {\n        bytes32 output;\n\n        assembly {\n            output := mload(add(add(input, 0x20), offset))\n        }\n\n        return output;\n    }\n\n    function toBytes4 (bytes memory input, uint offset) public view minLength(input.length, offset, 4) returns (bytes4) {\n        bytes4 output;\n\n        assembly {\n            output := mload(add(add(input, 0x20), offset))\n        }\n\n        return output;\n    }\n\n    function toUint (bytes memory input, uint offset) public view returns (uint) {\n        return uint(toBytes32(input, offset));\n    }\n\n    // source: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n    function toString (bytes memory input, uint offset, uint strLength) public view minLength(input.length, offset, strLength) returns (string memory) {\n        bytes memory output;\n\n        assembly {\n            switch iszero(strLength)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                output := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(strLength, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(output, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, strLength)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(input, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(output, strLength)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                output := mload(0x40)\n\n                mstore(0x40, add(output, 0x20))\n            }\n        }\n\n        return string(output);\n    }\n\n    function toAddress (bytes memory input, uint offset) public view minLength(input.length, offset, 20) returns (address) {\n        bytes20 output;\n\n        assembly {\n            output := mload(add(add(input, 0x20), offset))\n        }\n\n        return address(output);\n    }\n}\n\n// File: @rsksmart/rns-rskregistrar/contracts/FIFSRegistrarBase.sol\n\npragma solidity ^0.5.3;\n\n\n\n\n\n\n\n\n\n/// @title First-in first-served registrar base.\n/// @notice This is an abstract contract. A Registrar can inherit from\n/// this contract to implement basic commit-reveal and admin functionality.\n/// @dev Inherited contract should have registrar permission in Node Owner.\ncontract FIFSRegistrarBase is ERC677TransferReceiver, Ownable {\n    using SafeMath for uint256;\n    using StringUtils for string;\n    using BytesUtils for bytes;\n\n    mapping (bytes32 => uint) internal commitmentRevealTime;\n    uint public minCommitmentAge = 1 minutes;\n\n    uint public minLength = 5;\n\n    ERC677 rif;\n    NodeOwner nodeOwner;\n\n    constructor (\n        ERC677 _rif,\n        NodeOwner _nodeOwner\n    ) public {\n        rif = _rif;\n        nodeOwner = _nodeOwner;\n    }\n\n    ///////////////////\n    // COMMIT-REVEAL //\n    ///////////////////\n\n    /*\n        0. Caclulate makeCommitment hash of the domain to be registered (off-chain)\n        1. Commit the calculated hash\n        2. Wait minCommitmentAge\n        3. Execute registration via inheriting contract.\n    */\n\n    // 0.\n    /// @notice Create a commitment for register action.\n    /// @dev Don't use this method on-chain when commiting.\n    /// @param label keccak256 of the name to be registered.\n    /// @param nameOwner Owner of the name to be registered.\n    /// @param secret Secret to protect the name to be registered.\n    /// @return The commitment hash.\n    function makeCommitment (bytes32 label, address nameOwner, bytes32 secret) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(label, nameOwner, secret));\n    }\n\n    // 1.\n    /// @notice Commit before registring a name.\n    /// @dev A valid commitment can be calculated using makeCommitment off-chain.\n    /// @param commitment A valid commitment hash.\n    function commit(bytes32 commitment) external {\n        require(commitmentRevealTime[commitment] < 1, \"Existent commitment\");\n        commitmentRevealTime[commitment] = now.add(minCommitmentAge);\n    }\n\n    // 2.\n    /// @notice Ensure the commitment is ready to be revealed.\n    /// @dev This method can be polled to ensure registration.\n    /// @param commitment Commitment to be queried.\n    /// @return Wether the commitment can be revealed or not.\n    function canReveal(bytes32 commitment) public view returns (bool) {\n        uint revealTime = commitmentRevealTime[commitment];\n        return 0 < revealTime && revealTime <= now;\n    }\n\n    /////////////////////\n    // REGISTRAR ADMIN //\n    /////////////////////\n\n    /// @notice Change required commitment maturity.\n    /// @dev Only owner.\n    /// @param newMinCommitmentAge The new maturity required.\n    function setMinCommitmentAge (uint newMinCommitmentAge) external onlyOwner {\n        minCommitmentAge = newMinCommitmentAge;\n    }\n\n    /// @notice Change disbaled names.\n    /// @dev Only owner.\n    /// @param newMinLength The new minimum length enabled.\n    function setMinLength (uint newMinLength) external onlyOwner {\n        minLength = newMinLength;\n    }\n}\n\n// File: @rsksmart/rns-rskregistrar/contracts/PricedContract.sol\n\npragma solidity ^0.5.3;\n\n\n\ncontract PricedContract is Ownable {\n    AbstractNamePrice public namePrice;\n\n    event NamePriceChanged(AbstractNamePrice contractAddress);\n\n    constructor(AbstractNamePrice _namePrice) public Ownable() {\n        namePrice = _namePrice;\n    }\n\n    /// @notice Change price contract\n    /// @dev Only owner\n    /// @param newNamePrice The new maturity required\n    function setNamePrice(AbstractNamePrice newNamePrice) external onlyOwner {\n        namePrice = newNamePrice;\n        emit NamePriceChanged(newNamePrice);\n    }\n\n    /// @notice Price of a name in RIF\n    /// @param duration Time to register the name\n    /// @return cost in RIF\n    function price (string memory name, uint expires, uint duration) public view returns(uint) {\n        return namePrice.price(name, expires, duration);\n    }\n}\n\n// File: @rsksmart/rns-rskregistrar/contracts/FIFSRegistrar.sol\n\npragma solidity ^0.5.3;\n\n\n\n/// @title First-in first-served registrar.\n/// @notice You can use this contract to register .rsk names in RNS.\n/// @dev This contract has permission to register in RSK Owner.\ncontract FIFSRegistrar is FIFSRegistrarBase, PricedContract {\n    address pool;\n\n    // sha3('register(string,address,bytes32,uint)')\n    bytes4 constant REGISTER_SIGNATURE = 0xc2c414c8;\n\n    constructor (\n        ERC677 _rif,\n        NodeOwner _nodeOwner,\n        address _pool,\n        AbstractNamePrice _namePrice\n    ) public FIFSRegistrarBase(_rif, _nodeOwner) PricedContract(_namePrice) {\n        pool = _pool;\n    }\n\n    /*\n        3. Execute registration via:\n            - ERC-20 with approve() + register()\n            - ERC-677 with transferAndCall()\n        The price of a domain is given by name price contract.\n    */\n\n    // - Via ERC-20\n    /// @notice Registers a .rsk name in RNS.\n    /// @dev This method must be called after commiting.\n    /// @param name The name to register.\n    /// @param nameOwner The owner of the name to regiter.\n    /// @param secret The secret used to make the commitment.\n    /// @param duration Time to register in years.\n    function register(string calldata name, address nameOwner, bytes32 secret, uint duration) external {\n        uint cost = executeRegistration(name, nameOwner, secret, duration);\n        require(rif.transferFrom(msg.sender, pool, cost), \"Token transfer failed\");\n    }\n\n    // - Via ERC-677\n    /* Encoding:\n        | signature  |  4 bytes      - offset  0\n        | owner      | 20 bytes      - offset  4\n        | secret     | 32 bytes      - offest 24\n        | duration   | 32 bytes      - offset 56\n        | name       | variable size - offset 88\n    */\n\n    /// @notice ERC-677 token fallback function.\n    /// @dev Follow 'Register encoding' to execute a one-transaction regitration.\n    /// @param from token sender.\n    /// @param value amount of tokens sent.\n    /// @param data data associated with transaction.\n    /// @return true if successfull.\n    function tokenFallback(address from, uint value, bytes calldata data) external returns (bool) {\n        require(msg.sender == address(rif), \"Only RIF token\");\n        require(data.length > 88, \"Invalid data\");\n\n        bytes4 signature = data.toBytes4(0);\n\n        require(signature == REGISTER_SIGNATURE, \"Invalid signature\");\n\n        address nameOwner = data.toAddress(4);\n        bytes32 secret = data.toBytes32(24);\n        uint duration = data.toUint(56);\n        string memory name = data.toString(88, data.length.sub(88));\n\n        registerWithToken(name, nameOwner, secret, duration, from, value);\n\n        return true;\n    }\n\n    function registerWithToken(string memory name, address nameOwner, bytes32 secret, uint duration, address from, uint amount) private {\n        uint cost = executeRegistration(name, nameOwner, secret, duration);\n        require(amount >= cost, \"Not enough tokens\");\n        require(rif.transfer(pool, cost), \"Token transfer failed\");\n        if (amount.sub(cost) > 0)\n            require(rif.transfer(from, amount.sub(cost)), \"Token transfer failed\");\n    }\n\n    /// @notice Executes registration abstracted from payment method.\n    /// @param name The name to register.\n    /// @param nameOwner The owner of the name to regiter.\n    /// @param secret The secret used to make the commitment.\n    /// @param duration Time to register in years.\n    /// @return price Price of the name to register.\n    function executeRegistration (string memory name, address nameOwner, bytes32 secret, uint duration) private returns (uint) {\n        bytes32 label = keccak256(abi.encodePacked(name));\n\n        require(name.strlen() >= minLength, \"Short names not available\");\n\n        bytes32 commitment = makeCommitment(label, nameOwner, secret);\n        require(canReveal(commitment), \"No commitment found\");\n        commitmentRevealTime[commitment] = 0;\n\n        nodeOwner.register(label, nameOwner, duration.mul(365 days));\n\n        return price(name, nodeOwner.expirationTime(uint(label)), duration);\n    }\n}\n\n// File: solidity-rlp/contracts/RLPReader.sol\n\n/*\n* @author Hamdi Allam hamdi.allam97@gmail.com\n* Please reach out with any questions or concerns\n*/\npragma solidity ^0.5.0;\n\nlibrary RLPReader {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START  = 0xb8;\n    uint8 constant LIST_SHORT_START   = 0xc0;\n    uint8 constant LIST_LONG_START    = 0xf8;\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint len;\n        uint memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item;   // Item that's being iterated over.\n        uint nextPtr;   // Position of the next item in the list.\n    }\n\n    /*\n    * @dev Returns the next element in the iteration. Reverts if it has not next element.\n    * @param self The iterator.\n    * @return The next element in the iteration.\n    */\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self), \"Overflow\");\n\n        uint ptr = self.nextPtr;\n        uint itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    /*\n    * @dev Returns true if the iteration has more elements.\n    * @param self The iterator.\n    * @return true if the iteration has more elements.\n    */\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    /*\n    * @param item RLP encoded bytes\n    */\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n        uint memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /*\n    * @dev Create an iterator. Reverts if item is not a list.\n    * @param self The RLP item.\n    * @return An 'Iterator' over the item.\n    */\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    /*\n    * @param item RLP encoded bytes\n    */\n    function rlpLen(RLPItem memory item) internal pure returns (uint) {\n        return item.len;\n    }\n\n    /*\n    * @param item RLP encoded bytes\n    */\n    function payloadLen(RLPItem memory item) internal pure returns (uint) {\n        return item.len - _payloadOffset(item.memPtr);\n    }\n\n    /*\n    * @param item RLP encoded list in bytes\n    */\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item));\n\n        uint items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint dataLen;\n        for (uint i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr); \n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START)\n            return false;\n        return true;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n        \n        uint ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint result;\n        uint memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        return result == 0 ? false : true;\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(toUint(item));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint) {\n        require(item.len > 0 && item.len <= 33);\n\n        uint offset = _payloadOffset(item.memPtr);\n        uint len = item.len - offset;\n\n        uint result;\n        uint memPtr = item.memPtr + offset;\n        assembly {\n            result := mload(memPtr)\n\n            // shfit to the correct location if neccesary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint result;\n        uint memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0);\n\n        uint offset = _payloadOffset(item.memPtr);\n        uint len = item.len - offset; // data length\n        bytes memory result = new bytes(len);\n\n        uint destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(item.memPtr + offset, destPtr, len);\n        return result;\n    }\n\n    /*\n    * Private Helpers\n    */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) private pure returns (uint) {\n        if (item.len == 0) return 0;\n\n        uint count = 0;\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n           currPtr = currPtr + _itemLength(currPtr); // skip over an item\n           count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint memPtr) private pure returns (uint) {\n        uint itemLen;\n        uint byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START)\n            itemLen = 1;\n        \n        else if (byte0 < STRING_LONG_START)\n            itemLen = byte0 - STRING_SHORT_START + 1;\n\n        else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n                \n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } \n\n        else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint memPtr) private pure returns (uint) {\n        uint byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) \n            return 0;\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))\n            return 1;\n        else if (byte0 < LIST_SHORT_START)  // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        else\n            return byte0 - (LIST_LONG_START - 1) + 1;\n    }\n\n    /*\n    * @param src Pointer to source\n    * @param dest Pointer to destination\n    * @param len Amount of memory to copy from the source\n    */\n    function copy(uint src, uint dest, uint len) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask)) // zero out src\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n\n// File: contracts/batch/RSKDomainsBatch.sol\n\npragma solidity ^0.5.11;\n\n\n\n\n\ncontract RSKDomainsBatch is ERC677TransferReceiver {\n    FIFSRegistrar fifs;\n    IERC677 rif;\n\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for RLPReader.Iterator;\n    using RLPReader for bytes;\n\n    constructor(FIFSRegistrar _fifs, IERC677 _rif) public {\n        fifs = _fifs;\n        rif = _rif;\n    }\n\n    function batchCommit(bytes32[] calldata commitments) external {\n        for (uint i = 0; i < commitments.length; i++) {\n            fifs.commit(commitments[i]);\n        }\n    }\n\n    function tokenFallback(address from, uint value, bytes calldata data) external returns(bool) {\n        RLPReader.RLPItem[] memory ls = data.toRlpItem().toList();\n\n        uint price = ls[0].toUint();\n        RLPReader.Iterator memory iter = ls[1].iterator();\n\n        while(iter.hasNext()) {\n            require(\n                rif.transferAndCall(address(fifs), price, iter.next().toBytes()),\n                \"Register error\"\n            );\n        }\n\n        return true;\n    }\n}\n",
  "imports": [
    {
      "name": "RSKDomainsBatch.sol",
      "contents": "\n// File: @openzeppelin/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: @ensdomains/ethregistrar/contracts/StringUtils.sol\n\npragma solidity >=0.4.24;\n\nlibrary StringUtils {\n    /**\n     * @dev Returns the length of a given string\n     *\n     * @param s The string to measure the length of\n     * @return The length of the input string\n     */\n    function strlen(string memory s) internal pure returns (uint) {\n        uint len;\n        uint i = 0;\n        uint bytelength = bytes(s).length;\n        for(len = 0; i < bytelength; len++) {\n            byte b = bytes(s)[i];\n            if(b < 0x80) {\n                i += 1;\n            } else if (b < 0xE0) {\n                i += 2;\n            } else if (b < 0xF0) {\n                i += 3;\n            } else if (b < 0xF8) {\n                i += 4;\n            } else if (b < 0xFC) {\n                i += 5;\n            } else {\n                i += 6;\n            }\n        }\n        return len;\n    }\n}\n\n// File: @openzeppelin/contracts/GSN/Context.sol\n\npragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\n\npragma solidity ^0.5.0;\n\n\n\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\n// File: @rsksmart/erc677/contracts/ERC677TransferReceiver.sol\n\npragma solidity ^0.5.0;\n\n /*\n * Contract interface for receivers of tokens that\n * comply with ERC-677.\n * See https://github.com/ethereum/EIPs/issues/677 for details.\n */\ncontract ERC677TransferReceiver {\n    function tokenFallback(address from, uint256 amount, bytes calldata data) external returns (bool);\n}\n\n// File: @rsksmart/erc677/contracts/IERC677.sol\n\npragma solidity ^0.5.0;\n\n\ncontract IERC677 is IERC20 {\n    function transferAndCall(address to, uint256 value, bytes memory data) public returns (bool ok);\n\n    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);\n}\n\n// File: @rsksmart/erc677/contracts/ERC677.sol\n\npragma solidity ^0.5.0;\n\n// Use only for testing reasons\n\n\n\n\n\ncontract ERC677 is IERC677, ERC20, ERC20Detailed {\n    constructor(\n        address initialAccount,\n        uint256 initialBalance,\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) ERC20Detailed(name, symbol, decimals) public {\n        _mint(initialAccount, initialBalance);\n    }\n\n    /**\n     * ERC-677's only method implementation\n     * See https://github.com/ethereum/EIPs/issues/677 for details\n     */\n    function transferAndCall(address _to, uint _value, bytes memory _data) public returns (bool) {\n        bool result = super.transfer(_to, _value);\n        if (!result) return false;\n\n        emit Transfer(msg.sender, _to, _value, _data);\n\n        ERC677TransferReceiver receiver = ERC677TransferReceiver(_to);\n        receiver.tokenFallback(msg.sender, _value, _data);\n\n        // IMPORTANT: the ERC-677 specification does not say\n        // anything about the use of the receiver contract's\n        // tokenFallback method return value. Given\n        // its return type matches with this method's return\n        // type, returning it could be a possibility.\n        // We here take the more conservative approach and\n        // ignore the return value, returning true\n        // to signal a succesful transfer despite tokenFallback's\n        // return value -- fact being tokens are transferred\n        // in any case.\n        return true;\n    }\n}\n\n// File: @openzeppelin/contracts/introspection/IERC165.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address owner) public view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     *\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract IERC721Receiver {\n    /**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\n     * otherwise the caller will revert the transaction. The selector to be\n     * returned can be obtained as `this.onERC721Received.selector`. This\n     * function MAY throw to revert and reject the transfer.\n     * Note: the ERC721 contract address is always the message sender.\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n    public returns (bytes4);\n}\n\n// File: @openzeppelin/contracts/utils/Address.sol\n\npragma solidity ^0.5.5;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following \n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\n// File: @openzeppelin/contracts/drafts/Counters.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n\n// File: @openzeppelin/contracts/introspection/ERC165.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\ncontract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/ERC721.sol\n\npragma solidity ^0.5.0;\n\n\n\n\n\n\n\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is Context, ERC165, IERC721 {\n    using SafeMath for uint256;\n    using Address for address;\n    using Counters for Counters.Counter;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from token ID to owner\n    mapping (uint256 => address) private _tokenOwner;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping (address => Counters.Counter) private _ownedTokensCount;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    constructor () public {\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner address to query the balance of\n     * @return uint256 representing the amount owned by the passed address\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n\n        return _ownedTokensCount[owner].current();\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _tokenOwner[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n\n        return owner;\n    }\n\n    /**\n     * @dev Approves another address to transfer the given token ID\n     * The zero address indicates there is no approved address.\n     * There can only be one approved address per token at a given time.\n     * Can only be called by the token owner or an approved operator.\n     * @param to address to be approved for the given token ID\n     * @param tokenId uint256 ID of the token to be approved\n     */\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Gets the approved address for a token ID, or zero if no address set\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to query the approval of\n     * @return address currently approved for the given token ID\n     */\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Sets or unsets the approval of a given operator\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\n     * @param to operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     */\n    function setApprovalForAll(address to, bool approved) public {\n        require(to != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][to] = approved;\n        emit ApprovalForAll(_msgSender(), to, approved);\n    }\n\n    /**\n     * @dev Tells whether an operator is approved by a given owner.\n     * @param owner owner address which you want to query the approval of\n     * @param operator operator address which you want to query the approval of\n     * @return bool whether the given operator is approved by the given owner\n     */\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Transfers the ownership of a given token ID to another address.\n     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     * Requires the msg.sender to be the owner, approved, or operator.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the _msgSender() to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransferFrom(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function _safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) internal {\n        _transferFrom(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether the specified token exists.\n     * @param tokenId uint256 ID of the token to query the existence of\n     * @return bool whether the token exists\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner = _tokenOwner[tokenId];\n        return owner != address(0);\n    }\n\n    /**\n     * @dev Returns whether the given spender can transfer a given token ID.\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     * is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Internal function to safely mint a new token.\n     * Reverts if the given token ID already exists.\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Internal function to safely mint a new token.\n     * Reverts if the given token ID already exists.\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Internal function to mint a new token.\n     * Reverts if the given token ID already exists.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _tokenOwner[tokenId] = to;\n        _ownedTokensCount[to].increment();\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use {_burn} instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == owner, \"ERC721: burn of token that is not own\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[owner].decrement();\n        _tokenOwner[tokenId] = address(0);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(uint256 tokenId) internal {\n        _burn(ownerOf(tokenId), tokenId);\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[from].decrement();\n        _ownedTokensCount[to].increment();\n\n        _tokenOwner[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * This is an internal detail of the `ERC721` contract and its use is deprecated.\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        internal returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = to.call(abi.encodeWithSelector(\n            IERC721Receiver(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ));\n        if (!success) {\n            if (returndata.length > 0) {\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n            }\n        } else {\n            bytes4 retval = abi.decode(returndata, (bytes4));\n            return (retval == _ERC721_RECEIVED);\n        }\n    }\n\n    /**\n     * @dev Private function to clear current approval of a given token ID.\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _clearApproval(uint256 tokenId) private {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n        }\n    }\n}\n\n// File: @openzeppelin/contracts/ownership/Ownable.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: @openzeppelin/contracts/access/Roles.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\n// File: @rsksmart/rns-registry/contracts/AbstractRNS.sol\n\npragma solidity ^0.5.0;\n\ncontract AbstractRNS {\n    function owner(bytes32 node) public view returns(address);\n    function resolver(bytes32 node) public view returns(address);\n    function ttl(bytes32 node) public view returns(uint64);\n    function setOwner(bytes32 node, address ownerAddress) public;\n    function setSubnodeOwner(bytes32 node, bytes32 label, address ownerAddress) public;\n    function setResolver(bytes32 node, address resolverAddress) public;\n    function setTTL(bytes32 node, uint64 ttlValue) public;\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address ownerAddress);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address ownerAddress);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolverAddress);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttlValue);\n}\n\n// File: @rsksmart/rns-rskregistrar/contracts/NodeOwner.sol\n\npragma solidity ^0.5.3;\n\n\n\n\n\ncontract NodeOwner is ERC721, Ownable {\n    using Roles for Roles.Role;\n\n    AbstractRNS private rns;\n    bytes32 private rootNode;\n\n    mapping (uint256 => uint) public expirationTime;\n\n    event ExpirationChanged(uint256 tokenId, uint expirationTime);\n\n    modifier onlyRegistrar {\n        require(registrars.has(msg.sender), \"Only registrar.\");\n        _;\n    }\n\n    modifier onlyRenewer {\n        require(renewers.has(msg.sender), \"Only renewer.\");\n        _;\n    }\n\n    constructor (\n        AbstractRNS _rns,\n        bytes32 _rootNode\n    ) public {\n        rns = _rns;\n        rootNode = _rootNode;\n    }\n\n    /// @notice Gets the owner of the specified domain.\n    /// @param tokenId keccak256 of the domain label.\n    /// @return domain owner.\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        require(expirationTime[tokenId] > now, \"ERC721: owner query for nonexistent token\");\n        return super.ownerOf(tokenId);\n    }\n\n    /// @notice Check if a domain is available to be registered.\n    /// @dev The name must be registered via account with registrar role.\n    /// @param tokenId keccak256 of the domain label.\n    /// @return true if the specified domain can be registered.\n    function available(uint256 tokenId) public view returns(bool) {\n        return expirationTime[tokenId] < now;\n    }\n\n    ///////////////////\n    // RSK TLD ADMIN //\n    ///////////////////\n\n    /*\n        This contract owns a node in RNS, so it is capable to\n        change it's resolution and ttl.\n    */\n\n    /// @notice set root node resolver in RNS.\n    /// @param resolver to be set.\n    function setRootResolver (address resolver) external onlyOwner {\n        rns.setResolver(rootNode, resolver);\n    }\n\n    /// @notice set root node ttl in RNS.\n    /// @param ttl to be set.\n    function setRootTTL (uint64 ttl) external onlyOwner {\n        rns.setTTL(rootNode, ttl);\n    }\n\n    //////////////////\n    // REGISTRATION //\n    //////////////////\n\n    /*\n        Only available domains can be registered. Once a domain is\n        registered, it cannot be revoked until expiration.\n    */\n\n    // An account with registrar role can register domains.\n    Roles.Role registrars;\n\n    /// @notice Give an account access to registrar role.\n    /// @dev Only owner.\n    /// @param registrar new registrar.\n    function addRegistrar(address registrar) external onlyOwner {\n        registrars.add(registrar);\n    }\n\n    /// @notice Check if an account has registrar role.\n    /// @param registrar to query if has registrar role.\n    /// @return true if it has registrar role.\n    function isRegistrar(address registrar) external view returns (bool) {\n        return registrars.has(registrar);\n    }\n\n    /// @notice Remove an account's access to registrar role.\n    /// @dev Only owner\n    /// @param registrar registrar to remove from registrar role.\n    function removeRegistrar(address registrar) external onlyOwner {\n        registrars.remove(registrar);\n    }\n\n    /// @notice Registers a domain in RNS for a given duration.\n    /// @dev Only accounts with registrar role.\n    /// @param label keccak256 of the domain label to register.\n    /// @param tokenOwner account that will own the registered domain.\n    /// @param duration time to register the domain for.\n    function register(bytes32 label, address tokenOwner, uint duration) external onlyRegistrar {\n        uint256 tokenId = uint256(label);\n\n        require(available(tokenId), \"Not available\");\n\n        uint newExpirationTime = now.add(duration);\n        expirationTime[tokenId] = newExpirationTime;\n        emit ExpirationChanged(tokenId, newExpirationTime);\n\n        if (_exists(tokenId))\n            _burn(tokenId);\n\n        _mint(tokenOwner, tokenId);\n\n        rns.setSubnodeOwner(rootNode, label, tokenOwner);\n    }\n\n    ////////////////\n    // RECLAIMING //\n    ////////////////\n\n    /*\n        Names might be lost by transferring to contracts, or by\n        error. This allows any owner (or approved) to reclaim the\n        domain ownership in RNS.\n    */\n\n    /// @notice Reclaim ownership of a domain in RNS.\n    /// @dev Only owner or approved for the domain.\n    /// @param tokenId keccak256 of the domain\n    /// @param newOwner the owner to set in RNS.\n    function reclaim(uint256 tokenId, address newOwner) external {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"Not approved or owner\");\n        rns.setSubnodeOwner(rootNode, bytes32(tokenId), newOwner);\n    }\n\n    ////////////////\n    // RENOVATION //\n    ////////////////\n\n    /*\n        Only owned domains can be renewed. A renovation extends\n        domain ownership.\n    */\n\n    // An account with renewer role can extend domain expirations.\n    Roles.Role renewers;\n\n    /// @notice Give an account access to renewer role.\n    /// @dev Only owner\n    /// @param renewer new renewer.\n    function addRenewer(address renewer) external onlyOwner {\n        renewers.add(renewer);\n    }\n\n    /// @notice Check if an account has renewer role.\n    /// @param renewer to query if has renewer role.\n    /// @return true if it has renewer role.\n    function isRenewer(address renewer) external view returns (bool) {\n        return renewers.has(renewer);\n    }\n\n    /// @notice Remove an account's access to renewer role.\n    /// @dev Only owner\n    /// @param renewer renewer to remove from renewer role.\n    function removeRenewer(address renewer) external onlyOwner {\n        renewers.remove(renewer);\n    }\n\n    /// @notice Renew a domain for a given duraiton.\n    /// @dev Only accounts with renewer role.\n    /// @param label keccak256 of the domain label to renew.\n    /// @param time to extend the duration for.\n    function renew (bytes32 label, uint time) external onlyRenewer {\n        uint256 tokenId = uint256(label);\n        require(expirationTime[tokenId] > now, \"Name already expired\");\n        uint newExpirationTime = expirationTime[tokenId].add(time);\n        expirationTime[tokenId] = newExpirationTime;\n        emit ExpirationChanged(tokenId, newExpirationTime);\n    }\n\n    //////////////////////\n    // AFTER EXPIRATION //\n    //////////////////////\n\n    /// @notice This method removes expired domains.\n    /// @dev Use this to set 0 address in RNS ownership\n    /// and burn the domains to keep balance up to date.\n    /// @param tokenIds keccak256s of the domain labels to remove.\n    function removeExpired(uint256[] calldata tokenIds) external {\n        uint256 tokenId;\n        bytes32 label;\n\n        for (uint i = 0; i < tokenIds.length; i++) {\n            tokenId = tokenIds[i];\n\n            if (_exists(tokenId) && available(tokenId)) {\n                expirationTime[tokenId] = ~uint(0);\n                _burn(tokenId);\n                expirationTime[tokenId] = 0;\n\n                label = bytes32(tokenId);\n                rns.setSubnodeOwner(rootNode, label, address(0));\n            }\n        }\n    }\n}\n\n// File: @rsksmart/rns-rskregistrar/contracts/AbstractNamePrice.sol\n\npragma solidity ^0.5.3;\n\n/// @title NamePrice interface\n/// @author Javier Esses\n/// @notice Defines an interface for name price calculations\ncontract AbstractNamePrice {\n    function price (string calldata name, uint expires, uint duration) external view returns(uint);\n}\n\n// File: @rsksmart/rns-rskregistrar/contracts/BytesUtils.sol\n\npragma solidity ^0.5.3;\n\n\nlibrary BytesUtils {\n    using SafeMath for uint256;\n\n    modifier minLength (uint size, uint offset, uint length) {\n        require(size >= offset.add(length), \"Short input\");\n        _;\n    }\n\n    function toBytes32 (bytes memory input, uint offset) public view minLength(input.length, offset, 32) returns (bytes32) {\n        bytes32 output;\n\n        assembly {\n            output := mload(add(add(input, 0x20), offset))\n        }\n\n        return output;\n    }\n\n    function toBytes4 (bytes memory input, uint offset) public view minLength(input.length, offset, 4) returns (bytes4) {\n        bytes4 output;\n\n        assembly {\n            output := mload(add(add(input, 0x20), offset))\n        }\n\n        return output;\n    }\n\n    function toUint (bytes memory input, uint offset) public view returns (uint) {\n        return uint(toBytes32(input, offset));\n    }\n\n    // source: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n    function toString (bytes memory input, uint offset, uint strLength) public view minLength(input.length, offset, strLength) returns (string memory) {\n        bytes memory output;\n\n        assembly {\n            switch iszero(strLength)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                output := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(strLength, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(output, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, strLength)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(input, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(output, strLength)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                output := mload(0x40)\n\n                mstore(0x40, add(output, 0x20))\n            }\n        }\n\n        return string(output);\n    }\n\n    function toAddress (bytes memory input, uint offset) public view minLength(input.length, offset, 20) returns (address) {\n        bytes20 output;\n\n        assembly {\n            output := mload(add(add(input, 0x20), offset))\n        }\n\n        return address(output);\n    }\n}\n\n// File: @rsksmart/rns-rskregistrar/contracts/FIFSRegistrarBase.sol\n\npragma solidity ^0.5.3;\n\n\n\n\n\n\n\n\n\n/// @title First-in first-served registrar base.\n/// @notice This is an abstract contract. A Registrar can inherit from\n/// this contract to implement basic commit-reveal and admin functionality.\n/// @dev Inherited contract should have registrar permission in Node Owner.\ncontract FIFSRegistrarBase is ERC677TransferReceiver, Ownable {\n    using SafeMath for uint256;\n    using StringUtils for string;\n    using BytesUtils for bytes;\n\n    mapping (bytes32 => uint) internal commitmentRevealTime;\n    uint public minCommitmentAge = 1 minutes;\n\n    uint public minLength = 5;\n\n    ERC677 rif;\n    NodeOwner nodeOwner;\n\n    constructor (\n        ERC677 _rif,\n        NodeOwner _nodeOwner\n    ) public {\n        rif = _rif;\n        nodeOwner = _nodeOwner;\n    }\n\n    ///////////////////\n    // COMMIT-REVEAL //\n    ///////////////////\n\n    /*\n        0. Caclulate makeCommitment hash of the domain to be registered (off-chain)\n        1. Commit the calculated hash\n        2. Wait minCommitmentAge\n        3. Execute registration via inheriting contract.\n    */\n\n    // 0.\n    /// @notice Create a commitment for register action.\n    /// @dev Don't use this method on-chain when commiting.\n    /// @param label keccak256 of the name to be registered.\n    /// @param nameOwner Owner of the name to be registered.\n    /// @param secret Secret to protect the name to be registered.\n    /// @return The commitment hash.\n    function makeCommitment (bytes32 label, address nameOwner, bytes32 secret) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(label, nameOwner, secret));\n    }\n\n    // 1.\n    /// @notice Commit before registring a name.\n    /// @dev A valid commitment can be calculated using makeCommitment off-chain.\n    /// @param commitment A valid commitment hash.\n    function commit(bytes32 commitment) external {\n        require(commitmentRevealTime[commitment] < 1, \"Existent commitment\");\n        commitmentRevealTime[commitment] = now.add(minCommitmentAge);\n    }\n\n    // 2.\n    /// @notice Ensure the commitment is ready to be revealed.\n    /// @dev This method can be polled to ensure registration.\n    /// @param commitment Commitment to be queried.\n    /// @return Wether the commitment can be revealed or not.\n    function canReveal(bytes32 commitment) public view returns (bool) {\n        uint revealTime = commitmentRevealTime[commitment];\n        return 0 < revealTime && revealTime <= now;\n    }\n\n    /////////////////////\n    // REGISTRAR ADMIN //\n    /////////////////////\n\n    /// @notice Change required commitment maturity.\n    /// @dev Only owner.\n    /// @param newMinCommitmentAge The new maturity required.\n    function setMinCommitmentAge (uint newMinCommitmentAge) external onlyOwner {\n        minCommitmentAge = newMinCommitmentAge;\n    }\n\n    /// @notice Change disbaled names.\n    /// @dev Only owner.\n    /// @param newMinLength The new minimum length enabled.\n    function setMinLength (uint newMinLength) external onlyOwner {\n        minLength = newMinLength;\n    }\n}\n\n// File: @rsksmart/rns-rskregistrar/contracts/PricedContract.sol\n\npragma solidity ^0.5.3;\n\n\n\ncontract PricedContract is Ownable {\n    AbstractNamePrice public namePrice;\n\n    event NamePriceChanged(AbstractNamePrice contractAddress);\n\n    constructor(AbstractNamePrice _namePrice) public Ownable() {\n        namePrice = _namePrice;\n    }\n\n    /// @notice Change price contract\n    /// @dev Only owner\n    /// @param newNamePrice The new maturity required\n    function setNamePrice(AbstractNamePrice newNamePrice) external onlyOwner {\n        namePrice = newNamePrice;\n        emit NamePriceChanged(newNamePrice);\n    }\n\n    /// @notice Price of a name in RIF\n    /// @param duration Time to register the name\n    /// @return cost in RIF\n    function price (string memory name, uint expires, uint duration) public view returns(uint) {\n        return namePrice.price(name, expires, duration);\n    }\n}\n\n// File: @rsksmart/rns-rskregistrar/contracts/FIFSRegistrar.sol\n\npragma solidity ^0.5.3;\n\n\n\n/// @title First-in first-served registrar.\n/// @notice You can use this contract to register .rsk names in RNS.\n/// @dev This contract has permission to register in RSK Owner.\ncontract FIFSRegistrar is FIFSRegistrarBase, PricedContract {\n    address pool;\n\n    // sha3('register(string,address,bytes32,uint)')\n    bytes4 constant REGISTER_SIGNATURE = 0xc2c414c8;\n\n    constructor (\n        ERC677 _rif,\n        NodeOwner _nodeOwner,\n        address _pool,\n        AbstractNamePrice _namePrice\n    ) public FIFSRegistrarBase(_rif, _nodeOwner) PricedContract(_namePrice) {\n        pool = _pool;\n    }\n\n    /*\n        3. Execute registration via:\n            - ERC-20 with approve() + register()\n            - ERC-677 with transferAndCall()\n        The price of a domain is given by name price contract.\n    */\n\n    // - Via ERC-20\n    /// @notice Registers a .rsk name in RNS.\n    /// @dev This method must be called after commiting.\n    /// @param name The name to register.\n    /// @param nameOwner The owner of the name to regiter.\n    /// @param secret The secret used to make the commitment.\n    /// @param duration Time to register in years.\n    function register(string calldata name, address nameOwner, bytes32 secret, uint duration) external {\n        uint cost = executeRegistration(name, nameOwner, secret, duration);\n        require(rif.transferFrom(msg.sender, pool, cost), \"Token transfer failed\");\n    }\n\n    // - Via ERC-677\n    /* Encoding:\n        | signature  |  4 bytes      - offset  0\n        | owner      | 20 bytes      - offset  4\n        | secret     | 32 bytes      - offest 24\n        | duration   | 32 bytes      - offset 56\n        | name       | variable size - offset 88\n    */\n\n    /// @notice ERC-677 token fallback function.\n    /// @dev Follow 'Register encoding' to execute a one-transaction regitration.\n    /// @param from token sender.\n    /// @param value amount of tokens sent.\n    /// @param data data associated with transaction.\n    /// @return true if successfull.\n    function tokenFallback(address from, uint value, bytes calldata data) external returns (bool) {\n        require(msg.sender == address(rif), \"Only RIF token\");\n        require(data.length > 88, \"Invalid data\");\n\n        bytes4 signature = data.toBytes4(0);\n\n        require(signature == REGISTER_SIGNATURE, \"Invalid signature\");\n\n        address nameOwner = data.toAddress(4);\n        bytes32 secret = data.toBytes32(24);\n        uint duration = data.toUint(56);\n        string memory name = data.toString(88, data.length.sub(88));\n\n        registerWithToken(name, nameOwner, secret, duration, from, value);\n\n        return true;\n    }\n\n    function registerWithToken(string memory name, address nameOwner, bytes32 secret, uint duration, address from, uint amount) private {\n        uint cost = executeRegistration(name, nameOwner, secret, duration);\n        require(amount >= cost, \"Not enough tokens\");\n        require(rif.transfer(pool, cost), \"Token transfer failed\");\n        if (amount.sub(cost) > 0)\n            require(rif.transfer(from, amount.sub(cost)), \"Token transfer failed\");\n    }\n\n    /// @notice Executes registration abstracted from payment method.\n    /// @param name The name to register.\n    /// @param nameOwner The owner of the name to regiter.\n    /// @param secret The secret used to make the commitment.\n    /// @param duration Time to register in years.\n    /// @return price Price of the name to register.\n    function executeRegistration (string memory name, address nameOwner, bytes32 secret, uint duration) private returns (uint) {\n        bytes32 label = keccak256(abi.encodePacked(name));\n\n        require(name.strlen() >= minLength, \"Short names not available\");\n\n        bytes32 commitment = makeCommitment(label, nameOwner, secret);\n        require(canReveal(commitment), \"No commitment found\");\n        commitmentRevealTime[commitment] = 0;\n\n        nodeOwner.register(label, nameOwner, duration.mul(365 days));\n\n        return price(name, nodeOwner.expirationTime(uint(label)), duration);\n    }\n}\n\n// File: solidity-rlp/contracts/RLPReader.sol\n\n/*\n* @author Hamdi Allam hamdi.allam97@gmail.com\n* Please reach out with any questions or concerns\n*/\npragma solidity ^0.5.0;\n\nlibrary RLPReader {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START  = 0xb8;\n    uint8 constant LIST_SHORT_START   = 0xc0;\n    uint8 constant LIST_LONG_START    = 0xf8;\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint len;\n        uint memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item;   // Item that's being iterated over.\n        uint nextPtr;   // Position of the next item in the list.\n    }\n\n    /*\n    * @dev Returns the next element in the iteration. Reverts if it has not next element.\n    * @param self The iterator.\n    * @return The next element in the iteration.\n    */\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self), \"Overflow\");\n\n        uint ptr = self.nextPtr;\n        uint itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    /*\n    * @dev Returns true if the iteration has more elements.\n    * @param self The iterator.\n    * @return true if the iteration has more elements.\n    */\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    /*\n    * @param item RLP encoded bytes\n    */\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n        uint memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /*\n    * @dev Create an iterator. Reverts if item is not a list.\n    * @param self The RLP item.\n    * @return An 'Iterator' over the item.\n    */\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    /*\n    * @param item RLP encoded bytes\n    */\n    function rlpLen(RLPItem memory item) internal pure returns (uint) {\n        return item.len;\n    }\n\n    /*\n    * @param item RLP encoded bytes\n    */\n    function payloadLen(RLPItem memory item) internal pure returns (uint) {\n        return item.len - _payloadOffset(item.memPtr);\n    }\n\n    /*\n    * @param item RLP encoded list in bytes\n    */\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item));\n\n        uint items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint dataLen;\n        for (uint i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr); \n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START)\n            return false;\n        return true;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n        \n        uint ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint result;\n        uint memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        return result == 0 ? false : true;\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(toUint(item));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint) {\n        require(item.len > 0 && item.len <= 33);\n\n        uint offset = _payloadOffset(item.memPtr);\n        uint len = item.len - offset;\n\n        uint result;\n        uint memPtr = item.memPtr + offset;\n        assembly {\n            result := mload(memPtr)\n\n            // shfit to the correct location if neccesary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint result;\n        uint memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0);\n\n        uint offset = _payloadOffset(item.memPtr);\n        uint len = item.len - offset; // data length\n        bytes memory result = new bytes(len);\n\n        uint destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(item.memPtr + offset, destPtr, len);\n        return result;\n    }\n\n    /*\n    * Private Helpers\n    */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) private pure returns (uint) {\n        if (item.len == 0) return 0;\n\n        uint count = 0;\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n           currPtr = currPtr + _itemLength(currPtr); // skip over an item\n           count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint memPtr) private pure returns (uint) {\n        uint itemLen;\n        uint byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START)\n            itemLen = 1;\n        \n        else if (byte0 < STRING_LONG_START)\n            itemLen = byte0 - STRING_SHORT_START + 1;\n\n        else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n                \n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } \n\n        else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint memPtr) private pure returns (uint) {\n        uint byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) \n            return 0;\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))\n            return 1;\n        else if (byte0 < LIST_SHORT_START)  // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        else\n            return byte0 - (LIST_LONG_START - 1) + 1;\n    }\n\n    /*\n    * @param src Pointer to source\n    * @param dest Pointer to destination\n    * @param len Amount of memory to copy from the source\n    */\n    function copy(uint src, uint dest, uint len) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask)) // zero out src\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n\n// File: contracts/batch/RSKDomainsBatch.sol\n\npragma solidity ^0.5.11;\n\n\n\n\n\ncontract RSKDomainsBatch is ERC677TransferReceiver {\n    FIFSRegistrar fifs;\n    IERC677 rif;\n\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for RLPReader.Iterator;\n    using RLPReader for bytes;\n\n    constructor(FIFSRegistrar _fifs, IERC677 _rif) public {\n        fifs = _fifs;\n        rif = _rif;\n    }\n\n    function batchCommit(bytes32[] calldata commitments) external {\n        for (uint i = 0; i < commitments.length; i++) {\n            fifs.commit(commitments[i]);\n        }\n    }\n\n    function tokenFallback(address from, uint value, bytes calldata data) external returns(bool) {\n        RLPReader.RLPItem[] memory ls = data.toRlpItem().toList();\n\n        uint price = ls[0].toUint();\n        RLPReader.Iterator memory iter = ls[1].iterator();\n\n        while(iter.hasNext()) {\n            require(\n                rif.transferAndCall(address(fifs), price, iter.next().toBytes()),\n                \"Register error\"\n            );\n        }\n\n        return true;\n    }\n}\n",
      "file": "RSKDomainsBatch.sol"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x562d588d436554c899bf406bebdc29ed3b309ecbf50d71219e3b2d5ac70a4b26",
    "blockNumber": 675524,
    "transactionHash": "0xcff430237922c0e1012a028cccf26d3a1864fa9b56113e98180e5fef8b08784b",
    "timestamp": 1583793165
  },
  "constructorArguments": [
    "0x36ffda909f941950a552011f2c50569fda14a169",
    "0x19f64674d8a5b4e652319f5e239efd3bc969a1fe"
  ]
}