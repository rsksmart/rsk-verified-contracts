{
    "address": "0x369706822facb3441853c9c405eab1a2d5c76664",
    "net": {
        "id": "31",
        "name": "RSK Testnet"
    },
    "name": "MultiSigWallet",
    "settings": {
        "optimizer": {
            "enabled": false,
            "runs": 200
        }
    },
    "version": "0.5.17+commit.d19bba13",
    "source": "pragma solidity ^0.5.17;\n\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\n/// @author Stefan George - <stefan.george@consensys.net>\ncontract MultiSigWallet {\n\t/*\n\t *  Events\n\t */\n\tevent Confirmation(address indexed sender, uint256 indexed transactionId);\n\tevent Revocation(address indexed sender, uint256 indexed transactionId);\n\tevent Submission(uint256 indexed transactionId);\n\tevent Execution(uint256 indexed transactionId);\n\tevent ExecutionFailure(uint256 indexed transactionId);\n\tevent Deposit(address indexed sender, uint256 value);\n\tevent OwnerAddition(address indexed owner);\n\tevent OwnerRemoval(address indexed owner);\n\tevent RequirementChange(uint256 required);\n\n\t/*\n\t *  Constants\n\t */\n\tuint256 public constant MAX_OWNER_COUNT = 50;\n\n\t/*\n\t *  Storage\n\t */\n\tmapping(uint256 => Transaction) public transactions;\n\tmapping(uint256 => mapping(address => bool)) public confirmations;\n\tmapping(address => bool) public isOwner;\n\taddress[] public owners;\n\tuint256 public required;\n\tuint256 public transactionCount;\n\n\tstruct Transaction {\n\t\taddress destination;\n\t\tuint256 value;\n\t\tbytes data;\n\t\tbool executed;\n\t}\n\n\t/*\n\t *  Modifiers\n\t */\n\tmodifier onlyWallet() {\n\t\trequire(msg.sender == address(this));\n\t\t_;\n\t}\n\n\tmodifier ownerDoesNotExist(address owner) {\n\t\trequire(!isOwner[owner]);\n\t\t_;\n\t}\n\n\tmodifier ownerExists(address owner) {\n\t\trequire(isOwner[owner]);\n\t\t_;\n\t}\n\n\tmodifier transactionExists(uint256 transactionId) {\n\t\trequire(transactions[transactionId].destination != address(0));\n\t\t_;\n\t}\n\n\tmodifier confirmed(uint256 transactionId, address owner) {\n\t\trequire(confirmations[transactionId][owner]);\n\t\t_;\n\t}\n\n\tmodifier notConfirmed(uint256 transactionId, address owner) {\n\t\trequire(!confirmations[transactionId][owner]);\n\t\t_;\n\t}\n\n\tmodifier notExecuted(uint256 transactionId) {\n\t\trequire(!transactions[transactionId].executed);\n\t\t_;\n\t}\n\n\tmodifier notNull(address _address) {\n\t\trequire(_address != address(0));\n\t\t_;\n\t}\n\n\tmodifier validRequirement(uint256 ownerCount, uint256 _required) {\n\t\trequire(ownerCount <= MAX_OWNER_COUNT && _required <= ownerCount && _required != 0 && ownerCount != 0);\n\t\t_;\n\t}\n\n\t/// @dev Fallback function allows to deposit ether.\n\tfunction() external payable {\n\t\tif (msg.value > 0) emit Deposit(msg.sender, msg.value);\n\t}\n\n\t/*\n\t * Public functions\n\t */\n\t/// @dev Contract constructor sets initial owners and required number of confirmations.\n\t/// @param _owners List of initial owners.\n\t/// @param _required Number of required confirmations.\n\tconstructor(address[] memory _owners, uint256 _required) public validRequirement(_owners.length, _required) {\n\t\tfor (uint256 i = 0; i < _owners.length; i++) {\n\t\t\trequire(!isOwner[_owners[i]] && _owners[i] != address(0));\n\t\t\tisOwner[_owners[i]] = true;\n\t\t}\n\t\towners = _owners;\n\t\trequired = _required;\n\t}\n\n\t/// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n\t/// @param owner Address of new owner.\n\tfunction addOwner(address owner)\n\t\tpublic\n\t\tonlyWallet\n\t\townerDoesNotExist(owner)\n\t\tnotNull(owner)\n\t\tvalidRequirement(owners.length + 1, required)\n\t{\n\t\tisOwner[owner] = true;\n\t\towners.push(owner);\n\t\temit OwnerAddition(owner);\n\t}\n\n\t/// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n\t/// @param owner Address of owner.\n\tfunction removeOwner(address owner) public onlyWallet ownerExists(owner) {\n\t\tisOwner[owner] = false;\n\t\tfor (uint256 i = 0; i < owners.length - 1; i++)\n\t\t\tif (owners[i] == owner) {\n\t\t\t\towners[i] = owners[owners.length - 1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\towners.length -= 1;\n\t\tif (required > owners.length) changeRequirement(owners.length);\n\t\temit OwnerRemoval(owner);\n\t}\n\n\t/// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n\t/// @param owner Address of owner to be replaced.\n\t/// @param newOwner Address of new owner.\n\tfunction replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) {\n\t\tfor (uint256 i = 0; i < owners.length; i++)\n\t\t\tif (owners[i] == owner) {\n\t\t\t\towners[i] = newOwner;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tisOwner[owner] = false;\n\t\tisOwner[newOwner] = true;\n\t\temit OwnerRemoval(owner);\n\t\temit OwnerAddition(newOwner);\n\t}\n\n\t/// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\n\t/// @param _required Number of required confirmations.\n\tfunction changeRequirement(uint256 _required) public onlyWallet validRequirement(owners.length, _required) {\n\t\trequired = _required;\n\t\temit RequirementChange(_required);\n\t}\n\n\t/// @dev Allows an owner to submit and confirm a transaction.\n\t/// @param destination Transaction target address.\n\t/// @param value Transaction ether value.\n\t/// @param data Transaction data payload.\n\t/// @return Returns transaction ID.\n\tfunction submitTransaction(\n\t\taddress destination,\n\t\tuint256 value,\n\t\tbytes memory data\n\t) public returns (uint256 transactionId) {\n\t\ttransactionId = addTransaction(destination, value, data);\n\t\tconfirmTransaction(transactionId);\n\t}\n\n\t/// @dev Allows an owner to confirm a transaction.\n\t/// @param transactionId Transaction ID.\n\tfunction confirmTransaction(uint256 transactionId)\n\t\tpublic\n\t\townerExists(msg.sender)\n\t\ttransactionExists(transactionId)\n\t\tnotConfirmed(transactionId, msg.sender)\n\t{\n\t\tconfirmations[transactionId][msg.sender] = true;\n\t\temit Confirmation(msg.sender, transactionId);\n\t\texecuteTransaction(transactionId);\n\t}\n\n\t/// @dev Allows an owner to revoke a confirmation for a transaction.\n\t/// @param transactionId Transaction ID.\n\tfunction revokeConfirmation(uint256 transactionId)\n\t\tpublic\n\t\townerExists(msg.sender)\n\t\tconfirmed(transactionId, msg.sender)\n\t\tnotExecuted(transactionId)\n\t{\n\t\tconfirmations[transactionId][msg.sender] = false;\n\t\temit Revocation(msg.sender, transactionId);\n\t}\n\n\t/// @dev Allows anyone to execute a confirmed transaction.\n\t/// @param transactionId Transaction ID.\n\tfunction executeTransaction(uint256 transactionId)\n\t\tpublic\n\t\townerExists(msg.sender)\n\t\tconfirmed(transactionId, msg.sender)\n\t\tnotExecuted(transactionId)\n\t{\n\t\tif (isConfirmed(transactionId)) {\n\t\t\tTransaction storage txn = transactions[transactionId];\n\t\t\ttxn.executed = true;\n\t\t\tif (external_call(txn.destination, txn.value, txn.data.length, txn.data)) emit Execution(transactionId);\n\t\t\telse {\n\t\t\t\temit ExecutionFailure(transactionId);\n\t\t\t\ttxn.executed = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t// call has been separated into its own function in order to take advantage\n\t// of the Solidity's code generator to produce a loop that copies tx.data into memory.\n\tfunction external_call(\n\t\taddress destination,\n\t\tuint256 value,\n\t\tuint256 dataLength,\n\t\tbytes memory data\n\t) internal returns (bool) {\n\t\tbool result;\n\t\tassembly {\n\t\t\tlet x := mload(0x40) // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n\t\t\tlet d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n\t\t\tresult := call(\n\t\t\t\tsub(gas, 34710), // 34710 is the value that solidity is currently emitting\n\t\t\t\t// It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n\t\t\t\t// callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n\t\t\t\tdestination,\n\t\t\t\tvalue,\n\t\t\t\td,\n\t\t\t\tdataLength, // Size of the input (in bytes) - this is what fixes the padding problem\n\t\t\t\tx,\n\t\t\t\t0 // Output is ignored, therefore the output size is zero\n\t\t\t)\n\t\t}\n\t\treturn result;\n\t}\n\n\t/// @dev Returns the confirmation status of a transaction.\n\t/// @param transactionId Transaction ID.\n\t/// @return Confirmation status.\n\tfunction isConfirmed(uint256 transactionId) public view returns (bool) {\n\t\tuint256 count = 0;\n\t\tfor (uint256 i = 0; i < owners.length; i++) {\n\t\t\tif (confirmations[transactionId][owners[i]]) count += 1;\n\t\t\tif (count == required) return true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * Internal functions\n\t */\n\t/// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\n\t/// @param destination Transaction target address.\n\t/// @param value Transaction ether value.\n\t/// @param data Transaction data payload.\n\t/// @return Returns transaction ID.\n\tfunction addTransaction(\n\t\taddress destination,\n\t\tuint256 value,\n\t\tbytes memory data\n\t) internal notNull(destination) returns (uint256 transactionId) {\n\t\ttransactionId = transactionCount;\n\t\ttransactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false });\n\t\ttransactionCount += 1;\n\t\temit Submission(transactionId);\n\t}\n\n\t/*\n\t * Web3 call functions\n\t */\n\t/// @dev Returns number of confirmations of a transaction.\n\t/// @param transactionId Transaction ID.\n\t/// @return Number of confirmations.\n\tfunction getConfirmationCount(uint256 transactionId) public view returns (uint256 count) {\n\t\tfor (uint256 i = 0; i < owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1;\n\t}\n\n\t/// @dev Returns total number of transactions after filers are applied.\n\t/// @param pending Include pending transactions.\n\t/// @param executed Include executed transactions.\n\t/// @return Total number of transactions after filters are applied.\n\tfunction getTransactionCount(bool pending, bool executed) public view returns (uint256 count) {\n\t\tfor (uint256 i = 0; i < transactionCount; i++)\n\t\t\tif ((pending && !transactions[i].executed) || (executed && transactions[i].executed)) count += 1;\n\t}\n\n\t/// @dev Returns list of owners.\n\t/// @return List of owner addresses.\n\tfunction getOwners() public view returns (address[] memory) {\n\t\treturn owners;\n\t}\n\n\t/// @dev Returns array with owner addresses, which confirmed transaction.\n\t/// @param transactionId Transaction ID.\n\t/// @return Returns array of owner addresses.\n\tfunction getConfirmations(uint256 transactionId) public view returns (address[] memory _confirmations) {\n\t\taddress[] memory confirmationsTemp = new address[](owners.length);\n\t\tuint256 count = 0;\n\t\tuint256 i;\n\t\tfor (i = 0; i < owners.length; i++)\n\t\t\tif (confirmations[transactionId][owners[i]]) {\n\t\t\t\tconfirmationsTemp[count] = owners[i];\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t_confirmations = new address[](count);\n\t\tfor (i = 0; i < count; i++) _confirmations[i] = confirmationsTemp[i];\n\t}\n\n\t/// @dev Returns list of transaction IDs in defined range.\n\t/// @param from Index start position of transaction array.\n\t/// @param to Index end position of transaction array.\n\t/// @param pending Include pending transactions.\n\t/// @param executed Include executed transactions.\n\t/// @return Returns array of transaction IDs.\n\tfunction getTransactionIds(\n\t\tuint256 from,\n\t\tuint256 to,\n\t\tbool pending,\n\t\tbool executed\n\t) public view returns (uint256[] memory _transactionIds) {\n\t\tuint256[] memory transactionIdsTemp = new uint256[](transactionCount);\n\t\tuint256 count = 0;\n\t\tuint256 i;\n\t\tfor (i = 0; i < transactionCount; i++)\n\t\t\tif ((pending && !transactions[i].executed) || (executed && transactions[i].executed)) {\n\t\t\t\ttransactionIdsTemp[count] = i;\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t_transactionIds = new uint256[](to - from);\n\t\tfor (i = from; i < to; i++) _transactionIds[i - from] = transactionIdsTemp[i];\n\t}\n}\n",
    "imports": [
        {
            "name": "MultiSigWallet.sol",
            "contents": "pragma solidity ^0.5.17;\n\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\n/// @author Stefan George - <stefan.george@consensys.net>\ncontract MultiSigWallet {\n\t/*\n\t *  Events\n\t */\n\tevent Confirmation(address indexed sender, uint256 indexed transactionId);\n\tevent Revocation(address indexed sender, uint256 indexed transactionId);\n\tevent Submission(uint256 indexed transactionId);\n\tevent Execution(uint256 indexed transactionId);\n\tevent ExecutionFailure(uint256 indexed transactionId);\n\tevent Deposit(address indexed sender, uint256 value);\n\tevent OwnerAddition(address indexed owner);\n\tevent OwnerRemoval(address indexed owner);\n\tevent RequirementChange(uint256 required);\n\n\t/*\n\t *  Constants\n\t */\n\tuint256 public constant MAX_OWNER_COUNT = 50;\n\n\t/*\n\t *  Storage\n\t */\n\tmapping(uint256 => Transaction) public transactions;\n\tmapping(uint256 => mapping(address => bool)) public confirmations;\n\tmapping(address => bool) public isOwner;\n\taddress[] public owners;\n\tuint256 public required;\n\tuint256 public transactionCount;\n\n\tstruct Transaction {\n\t\taddress destination;\n\t\tuint256 value;\n\t\tbytes data;\n\t\tbool executed;\n\t}\n\n\t/*\n\t *  Modifiers\n\t */\n\tmodifier onlyWallet() {\n\t\trequire(msg.sender == address(this));\n\t\t_;\n\t}\n\n\tmodifier ownerDoesNotExist(address owner) {\n\t\trequire(!isOwner[owner]);\n\t\t_;\n\t}\n\n\tmodifier ownerExists(address owner) {\n\t\trequire(isOwner[owner]);\n\t\t_;\n\t}\n\n\tmodifier transactionExists(uint256 transactionId) {\n\t\trequire(transactions[transactionId].destination != address(0));\n\t\t_;\n\t}\n\n\tmodifier confirmed(uint256 transactionId, address owner) {\n\t\trequire(confirmations[transactionId][owner]);\n\t\t_;\n\t}\n\n\tmodifier notConfirmed(uint256 transactionId, address owner) {\n\t\trequire(!confirmations[transactionId][owner]);\n\t\t_;\n\t}\n\n\tmodifier notExecuted(uint256 transactionId) {\n\t\trequire(!transactions[transactionId].executed);\n\t\t_;\n\t}\n\n\tmodifier notNull(address _address) {\n\t\trequire(_address != address(0));\n\t\t_;\n\t}\n\n\tmodifier validRequirement(uint256 ownerCount, uint256 _required) {\n\t\trequire(ownerCount <= MAX_OWNER_COUNT && _required <= ownerCount && _required != 0 && ownerCount != 0);\n\t\t_;\n\t}\n\n\t/// @dev Fallback function allows to deposit ether.\n\tfunction() external payable {\n\t\tif (msg.value > 0) emit Deposit(msg.sender, msg.value);\n\t}\n\n\t/*\n\t * Public functions\n\t */\n\t/// @dev Contract constructor sets initial owners and required number of confirmations.\n\t/// @param _owners List of initial owners.\n\t/// @param _required Number of required confirmations.\n\tconstructor(address[] memory _owners, uint256 _required) public validRequirement(_owners.length, _required) {\n\t\tfor (uint256 i = 0; i < _owners.length; i++) {\n\t\t\trequire(!isOwner[_owners[i]] && _owners[i] != address(0));\n\t\t\tisOwner[_owners[i]] = true;\n\t\t}\n\t\towners = _owners;\n\t\trequired = _required;\n\t}\n\n\t/// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n\t/// @param owner Address of new owner.\n\tfunction addOwner(address owner)\n\t\tpublic\n\t\tonlyWallet\n\t\townerDoesNotExist(owner)\n\t\tnotNull(owner)\n\t\tvalidRequirement(owners.length + 1, required)\n\t{\n\t\tisOwner[owner] = true;\n\t\towners.push(owner);\n\t\temit OwnerAddition(owner);\n\t}\n\n\t/// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n\t/// @param owner Address of owner.\n\tfunction removeOwner(address owner) public onlyWallet ownerExists(owner) {\n\t\tisOwner[owner] = false;\n\t\tfor (uint256 i = 0; i < owners.length - 1; i++)\n\t\t\tif (owners[i] == owner) {\n\t\t\t\towners[i] = owners[owners.length - 1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\towners.length -= 1;\n\t\tif (required > owners.length) changeRequirement(owners.length);\n\t\temit OwnerRemoval(owner);\n\t}\n\n\t/// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n\t/// @param owner Address of owner to be replaced.\n\t/// @param newOwner Address of new owner.\n\tfunction replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) {\n\t\tfor (uint256 i = 0; i < owners.length; i++)\n\t\t\tif (owners[i] == owner) {\n\t\t\t\towners[i] = newOwner;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tisOwner[owner] = false;\n\t\tisOwner[newOwner] = true;\n\t\temit OwnerRemoval(owner);\n\t\temit OwnerAddition(newOwner);\n\t}\n\n\t/// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\n\t/// @param _required Number of required confirmations.\n\tfunction changeRequirement(uint256 _required) public onlyWallet validRequirement(owners.length, _required) {\n\t\trequired = _required;\n\t\temit RequirementChange(_required);\n\t}\n\n\t/// @dev Allows an owner to submit and confirm a transaction.\n\t/// @param destination Transaction target address.\n\t/// @param value Transaction ether value.\n\t/// @param data Transaction data payload.\n\t/// @return Returns transaction ID.\n\tfunction submitTransaction(\n\t\taddress destination,\n\t\tuint256 value,\n\t\tbytes memory data\n\t) public returns (uint256 transactionId) {\n\t\ttransactionId = addTransaction(destination, value, data);\n\t\tconfirmTransaction(transactionId);\n\t}\n\n\t/// @dev Allows an owner to confirm a transaction.\n\t/// @param transactionId Transaction ID.\n\tfunction confirmTransaction(uint256 transactionId)\n\t\tpublic\n\t\townerExists(msg.sender)\n\t\ttransactionExists(transactionId)\n\t\tnotConfirmed(transactionId, msg.sender)\n\t{\n\t\tconfirmations[transactionId][msg.sender] = true;\n\t\temit Confirmation(msg.sender, transactionId);\n\t\texecuteTransaction(transactionId);\n\t}\n\n\t/// @dev Allows an owner to revoke a confirmation for a transaction.\n\t/// @param transactionId Transaction ID.\n\tfunction revokeConfirmation(uint256 transactionId)\n\t\tpublic\n\t\townerExists(msg.sender)\n\t\tconfirmed(transactionId, msg.sender)\n\t\tnotExecuted(transactionId)\n\t{\n\t\tconfirmations[transactionId][msg.sender] = false;\n\t\temit Revocation(msg.sender, transactionId);\n\t}\n\n\t/// @dev Allows anyone to execute a confirmed transaction.\n\t/// @param transactionId Transaction ID.\n\tfunction executeTransaction(uint256 transactionId)\n\t\tpublic\n\t\townerExists(msg.sender)\n\t\tconfirmed(transactionId, msg.sender)\n\t\tnotExecuted(transactionId)\n\t{\n\t\tif (isConfirmed(transactionId)) {\n\t\t\tTransaction storage txn = transactions[transactionId];\n\t\t\ttxn.executed = true;\n\t\t\tif (external_call(txn.destination, txn.value, txn.data.length, txn.data)) emit Execution(transactionId);\n\t\t\telse {\n\t\t\t\temit ExecutionFailure(transactionId);\n\t\t\t\ttxn.executed = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t// call has been separated into its own function in order to take advantage\n\t// of the Solidity's code generator to produce a loop that copies tx.data into memory.\n\tfunction external_call(\n\t\taddress destination,\n\t\tuint256 value,\n\t\tuint256 dataLength,\n\t\tbytes memory data\n\t) internal returns (bool) {\n\t\tbool result;\n\t\tassembly {\n\t\t\tlet x := mload(0x40) // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n\t\t\tlet d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n\t\t\tresult := call(\n\t\t\t\tsub(gas, 34710), // 34710 is the value that solidity is currently emitting\n\t\t\t\t// It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n\t\t\t\t// callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n\t\t\t\tdestination,\n\t\t\t\tvalue,\n\t\t\t\td,\n\t\t\t\tdataLength, // Size of the input (in bytes) - this is what fixes the padding problem\n\t\t\t\tx,\n\t\t\t\t0 // Output is ignored, therefore the output size is zero\n\t\t\t)\n\t\t}\n\t\treturn result;\n\t}\n\n\t/// @dev Returns the confirmation status of a transaction.\n\t/// @param transactionId Transaction ID.\n\t/// @return Confirmation status.\n\tfunction isConfirmed(uint256 transactionId) public view returns (bool) {\n\t\tuint256 count = 0;\n\t\tfor (uint256 i = 0; i < owners.length; i++) {\n\t\t\tif (confirmations[transactionId][owners[i]]) count += 1;\n\t\t\tif (count == required) return true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * Internal functions\n\t */\n\t/// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\n\t/// @param destination Transaction target address.\n\t/// @param value Transaction ether value.\n\t/// @param data Transaction data payload.\n\t/// @return Returns transaction ID.\n\tfunction addTransaction(\n\t\taddress destination,\n\t\tuint256 value,\n\t\tbytes memory data\n\t) internal notNull(destination) returns (uint256 transactionId) {\n\t\ttransactionId = transactionCount;\n\t\ttransactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false });\n\t\ttransactionCount += 1;\n\t\temit Submission(transactionId);\n\t}\n\n\t/*\n\t * Web3 call functions\n\t */\n\t/// @dev Returns number of confirmations of a transaction.\n\t/// @param transactionId Transaction ID.\n\t/// @return Number of confirmations.\n\tfunction getConfirmationCount(uint256 transactionId) public view returns (uint256 count) {\n\t\tfor (uint256 i = 0; i < owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1;\n\t}\n\n\t/// @dev Returns total number of transactions after filers are applied.\n\t/// @param pending Include pending transactions.\n\t/// @param executed Include executed transactions.\n\t/// @return Total number of transactions after filters are applied.\n\tfunction getTransactionCount(bool pending, bool executed) public view returns (uint256 count) {\n\t\tfor (uint256 i = 0; i < transactionCount; i++)\n\t\t\tif ((pending && !transactions[i].executed) || (executed && transactions[i].executed)) count += 1;\n\t}\n\n\t/// @dev Returns list of owners.\n\t/// @return List of owner addresses.\n\tfunction getOwners() public view returns (address[] memory) {\n\t\treturn owners;\n\t}\n\n\t/// @dev Returns array with owner addresses, which confirmed transaction.\n\t/// @param transactionId Transaction ID.\n\t/// @return Returns array of owner addresses.\n\tfunction getConfirmations(uint256 transactionId) public view returns (address[] memory _confirmations) {\n\t\taddress[] memory confirmationsTemp = new address[](owners.length);\n\t\tuint256 count = 0;\n\t\tuint256 i;\n\t\tfor (i = 0; i < owners.length; i++)\n\t\t\tif (confirmations[transactionId][owners[i]]) {\n\t\t\t\tconfirmationsTemp[count] = owners[i];\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t_confirmations = new address[](count);\n\t\tfor (i = 0; i < count; i++) _confirmations[i] = confirmationsTemp[i];\n\t}\n\n\t/// @dev Returns list of transaction IDs in defined range.\n\t/// @param from Index start position of transaction array.\n\t/// @param to Index end position of transaction array.\n\t/// @param pending Include pending transactions.\n\t/// @param executed Include executed transactions.\n\t/// @return Returns array of transaction IDs.\n\tfunction getTransactionIds(\n\t\tuint256 from,\n\t\tuint256 to,\n\t\tbool pending,\n\t\tbool executed\n\t) public view returns (uint256[] memory _transactionIds) {\n\t\tuint256[] memory transactionIdsTemp = new uint256[](transactionCount);\n\t\tuint256 count = 0;\n\t\tuint256 i;\n\t\tfor (i = 0; i < transactionCount; i++)\n\t\t\tif ((pending && !transactions[i].executed) || (executed && transactions[i].executed)) {\n\t\t\t\ttransactionIdsTemp[count] = i;\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t_transactionIds = new uint256[](to - from);\n\t\tfor (i = from; i < to; i++) _transactionIds[i - from] = transactionIdsTemp[i];\n\t}\n}\n",
            "file": "MultiSigWallet.sol"
        }
    ],
    "libraries": {},
    "encodedConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000300000000000000000000000010217ef7b21c3b6da24e9f0b4fd2eedccd7a0fcf00000000000000000000000061fd331f75801225316ca208f66d5b7e908557590000000000000000000000004cb2ec28deca346901df07319c7e798612edc695",
    "creationData": {
        "blockHash": "0x0dd670d3a1637f9430cbd1f89f906b54585c226816d94c6ff47b72fdd9e83d68",
        "blockNumber": 1713158,
        "transactionHash": "0x6ab7e71739a7410cb03a025ae6a0cbec67d99eca2030066dc66486db2401e670",
        "timestamp": 1616707017
    }
}