{
    "address": "0xc357e663bcaddd07dd2d7e764f1ea81fa69b058a",
    "net": {
        "id": "31",
        "name": "RSK Testnet"
    },
    "name": "BufferToken",
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        }
    },
    "version": "0.6.12+commit.27d51765",
    "source": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n    /**\n      @notice Override this function with a recipe of the changes to be done when this ChangeContract\n      is executed\n     */\n    function execute() external;\n}\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor {\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @dev This function should be protected somehow to only execute changes that\n      benefit the system. This decision process is independent of this architechture\n      therefore is independent of this interface too\n      @param changeContract Address of the contract that will execute the changes\n     */\n    function executeChange(ChangeContract changeContract) external;\n\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @param _changer Address of the contract that will execute the changes\n     */\n    function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed {\n    /**\n      @notice The address of the contract which governs this one\n     */\n    IGovernor public governor;\n\n    string private constant NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n    /**\n      @notice Modifier that protects the function\n      @dev You should use this modifier in any function that should be called through\n      the governance system\n     */\n    modifier onlyAuthorizedChanger() {\n        require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n        _;\n    }\n\n    /**\n      @notice Initialize the contract with the basic settings\n      @dev This initialize replaces the constructor but it is not called automatically.\n      It is necessary because of the upgradeability of the contracts\n      @param _governor Governor address\n     */\n    function _initialize(IGovernor _governor) internal {\n        governor = _governor;\n    }\n\n    /**\n      @notice Change the contract's governor. Should be called through the old governance system\n      @param newIGovernor New governor address\n     */\n    function changeIGovernor(IGovernor newIGovernor) external onlyAuthorizedChanger {\n        governor = newIGovernor;\n    }\n\n    /**\n      @notice This method is used by a change contract to access the storage freely even without a setter.\n      @param data the serialized function arguments\n     */\n    function delegateCallToChanger(bytes calldata data)\n        external\n        onlyAuthorizedChanger\n        returns (bytes memory)\n    {\n        address changerContrat = msg.sender;\n        (bool success, bytes memory result) = changerContrat.delegatecall(\n            abi.encodeWithSignature(\"impersonate(bytes)\", data)\n        );\n        require(success, \"Error in delegate call\");\n        return result;\n    }\n\n    // Leave a gap betweeen inherited contracts variables in order to be\n    // able to add more variables in them later\n    uint256[50] private upgradeGap;\n}\n\n\nabstract contract BufferBase is Initializable, Governed {\n    using SafeMath for uint256;\n\n    event PaymentReceive(address payable indexed output, uint256 amount);\n    event PaymentSent(address payable indexed output, uint256 amount);\n\n    // @dev Single output\n    struct Output {\n        address payable output;\n        uint256 split;\n        uint256 threshold;\n        uint256 balance;\n    }\n\n    // @dev Outputs\n    Output[] internal _outputs;\n    // @dev Sum of individual splits\n    uint256 internal _splitTotal;\n    uint256 internal _liquidated;\n    uint256 internal _threshold;\n    uint256 public constant PRECISION = 10**18;\n\n    // @dev minimum threshold to send\n    function _initialize(\n        IGovernor _governor,\n        uint256 threshold,\n        address payable[] memory outputs,\n        uint256[] memory splits,\n        uint256[] memory thresholds\n    ) internal {\n        Governed._initialize(_governor);\n        require(outputs.length == splits.length, \"Lengths should match\");\n        _threshold = threshold;\n        for (uint256 i = 0; i < outputs.length; i += 1) {\n            _addOutput(outputs[i], splits[i], thresholds[i]);\n        }\n    }\n\n    function getBalance() public view virtual returns (uint256);\n\n    function transfer(address destination, uint256 balance) internal virtual returns (bool);\n\n    function liquidate() public {\n        uint256 balance = getBalance();\n        uint256 toLiquidate = getLiquidated();\n        uint256 amount = balance.sub(toLiquidate);\n        require(isLiquidable(), \"Buffer unliquidated ammount is not above buffer threshold\");\n        for (uint256 i = 0; i < _outputs.length; i += 1) {\n            _outputs[i].balance = _outputs[i].balance.add(\n                amount.mul(_outputs[i].split).div(_splitTotal)\n            );\n        }\n        _liquidated = balance;\n    }\n\n    function flush(uint256 i) public {\n        uint256 balance = _outputs[i].balance;\n        require(isFlushable(i), \"Output ammount is not above output threshold\");\n        _outputs[i].balance = 0;\n        bool success = transfer(_outputs[i].output, balance);\n        require(success, \"Failed to transfer the funds, aborting.\");\n        _liquidated = _liquidated.sub(balance);\n        emit PaymentSent(_outputs[i].output, balance);\n    }\n\n    function addOutput(\n        address payable output,\n        uint256 split,\n        uint256 threshold\n    ) public onlyAuthorizedChanger() {\n        _addOutput(output, split, threshold);\n    }\n\n    function _addOutput(\n        address payable output,\n        uint256 split,\n        uint256 threshold\n    ) internal {\n        _outputs.push(Output({output: output, split: split, threshold: threshold, balance: 0}));\n        _splitTotal = _splitTotal.add(split);\n    }\n\n    function removeOutput(uint256 idx) public onlyAuthorizedChanger() {\n        require(idx < _outputs.length, \"Invalid index\");\n        uint256 balance = _outputs[idx].balance;\n        if (balance > 0) {\n            _outputs[idx].balance = 0;\n            bool success = transfer(_outputs[idx].output, balance);\n            require(success, \"Failed to transfer the funds, aborting.\");\n            _liquidated = _liquidated.sub(balance);\n        }\n        _splitTotal = _splitTotal.sub(_outputs[idx].split);\n        _outputs[idx] = _outputs[_outputs.length - 1];\n        _outputs.pop();\n    }\n\n    function setThreshold(uint256 threshold) public onlyAuthorizedChanger() {\n        _threshold = threshold;\n    }\n\n    function getThreshold() public view returns (uint256) {\n        return _threshold;\n    }\n\n    function getSplit() public view returns (uint256) {\n        return _splitTotal;\n    }\n\n    function getLiquidated() public view returns (uint256) {\n        return _liquidated;\n    }\n\n    function getNumOutputs() public view returns (uint256) {\n        return _outputs.length;\n    }\n\n    function isFlushable(uint256 i) public view returns (bool) {\n        return _outputs[i].balance > _outputs[i].threshold;\n    }\n\n    function isLiquidable() public view returns (bool) {\n        uint256 balance = getBalance();\n        uint256 toLiquidate = getLiquidated();\n        uint256 amount = balance.sub(toLiquidate);\n        return amount > _threshold;\n    }\n\n    function getOutput(uint256 idx)\n        public\n        view\n        returns (\n            address,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (\n            _outputs[idx].output,\n            _outputs[idx].split,\n            _outputs[idx].balance,\n            _outputs[idx].threshold\n        );\n    }\n\n    function getToken() public view virtual returns (address);\n\n    function getAll()\n        public\n        view\n        virtual\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            address,\n            uint256\n        );\n\n    receive() external payable {}\n}\n\n\ncontract BufferToken is BufferBase {\n    using SafeMath for uint256;\n\n    IERC20 internal _token;\n\n    // @dev minimum threshold to send\n    function initialize(\n        IGovernor _governor,\n        IERC20 token,\n        uint256 threshold,\n        address payable[] memory outputs,\n        uint256[] memory splits,\n        uint256[] memory thresholds\n    ) public initializer {\n        require(token != IERC20(0), \"Wrong token address\");\n        _token = token;\n        BufferBase._initialize(_governor, threshold, outputs, splits, thresholds);\n    }\n\n    function getBalance() public view override returns (uint256) {\n        return _token.balanceOf(address(this));\n    }\n\n    function transfer(address destination, uint256 balance) internal override returns (bool) {\n        return _token.transfer(destination, balance);\n    }\n\n    function dispose(address payable beneficiary) external onlyAuthorizedChanger {\n        uint256 balance = getBalance();\n        bool success = _token.transfer(beneficiary, balance);\n        require(success, \"Failed to transfer the funds, aborting.\");\n        selfdestruct(beneficiary);\n    }\n\n    function getToken() public view override returns (address) {\n        return address(_token);\n    }\n\n    function getAll()\n        public\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            address,\n            uint256\n        )\n    {\n        return (\n            getBalance(),\n            _threshold,\n            _splitTotal,\n            _liquidated,\n            address(_token),\n            _outputs.length\n        );\n    }\n\n    function setToken(IERC20 token) public onlyAuthorizedChanger {\n        require(getBalance() == 0, \"Failed to set new token. Balance is not zero.\");\n        _token = token;\n    }\n}\n\n",
    "imports": [
        {
            "name": "BufferToken.sol",
            "contents": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n    /**\n      @notice Override this function with a recipe of the changes to be done when this ChangeContract\n      is executed\n     */\n    function execute() external;\n}\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor {\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @dev This function should be protected somehow to only execute changes that\n      benefit the system. This decision process is independent of this architechture\n      therefore is independent of this interface too\n      @param changeContract Address of the contract that will execute the changes\n     */\n    function executeChange(ChangeContract changeContract) external;\n\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @param _changer Address of the contract that will execute the changes\n     */\n    function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed {\n    /**\n      @notice The address of the contract which governs this one\n     */\n    IGovernor public governor;\n\n    string private constant NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n    /**\n      @notice Modifier that protects the function\n      @dev You should use this modifier in any function that should be called through\n      the governance system\n     */\n    modifier onlyAuthorizedChanger() {\n        require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n        _;\n    }\n\n    /**\n      @notice Initialize the contract with the basic settings\n      @dev This initialize replaces the constructor but it is not called automatically.\n      It is necessary because of the upgradeability of the contracts\n      @param _governor Governor address\n     */\n    function _initialize(IGovernor _governor) internal {\n        governor = _governor;\n    }\n\n    /**\n      @notice Change the contract's governor. Should be called through the old governance system\n      @param newIGovernor New governor address\n     */\n    function changeIGovernor(IGovernor newIGovernor) external onlyAuthorizedChanger {\n        governor = newIGovernor;\n    }\n\n    /**\n      @notice This method is used by a change contract to access the storage freely even without a setter.\n      @param data the serialized function arguments\n     */\n    function delegateCallToChanger(bytes calldata data)\n        external\n        onlyAuthorizedChanger\n        returns (bytes memory)\n    {\n        address changerContrat = msg.sender;\n        (bool success, bytes memory result) = changerContrat.delegatecall(\n            abi.encodeWithSignature(\"impersonate(bytes)\", data)\n        );\n        require(success, \"Error in delegate call\");\n        return result;\n    }\n\n    // Leave a gap betweeen inherited contracts variables in order to be\n    // able to add more variables in them later\n    uint256[50] private upgradeGap;\n}\n\n\nabstract contract BufferBase is Initializable, Governed {\n    using SafeMath for uint256;\n\n    event PaymentReceive(address payable indexed output, uint256 amount);\n    event PaymentSent(address payable indexed output, uint256 amount);\n\n    // @dev Single output\n    struct Output {\n        address payable output;\n        uint256 split;\n        uint256 threshold;\n        uint256 balance;\n    }\n\n    // @dev Outputs\n    Output[] internal _outputs;\n    // @dev Sum of individual splits\n    uint256 internal _splitTotal;\n    uint256 internal _liquidated;\n    uint256 internal _threshold;\n    uint256 public constant PRECISION = 10**18;\n\n    // @dev minimum threshold to send\n    function _initialize(\n        IGovernor _governor,\n        uint256 threshold,\n        address payable[] memory outputs,\n        uint256[] memory splits,\n        uint256[] memory thresholds\n    ) internal {\n        Governed._initialize(_governor);\n        require(outputs.length == splits.length, \"Lengths should match\");\n        _threshold = threshold;\n        for (uint256 i = 0; i < outputs.length; i += 1) {\n            _addOutput(outputs[i], splits[i], thresholds[i]);\n        }\n    }\n\n    function getBalance() public view virtual returns (uint256);\n\n    function transfer(address destination, uint256 balance) internal virtual returns (bool);\n\n    function liquidate() public {\n        uint256 balance = getBalance();\n        uint256 toLiquidate = getLiquidated();\n        uint256 amount = balance.sub(toLiquidate);\n        require(isLiquidable(), \"Buffer unliquidated ammount is not above buffer threshold\");\n        for (uint256 i = 0; i < _outputs.length; i += 1) {\n            _outputs[i].balance = _outputs[i].balance.add(\n                amount.mul(_outputs[i].split).div(_splitTotal)\n            );\n        }\n        _liquidated = balance;\n    }\n\n    function flush(uint256 i) public {\n        uint256 balance = _outputs[i].balance;\n        require(isFlushable(i), \"Output ammount is not above output threshold\");\n        _outputs[i].balance = 0;\n        bool success = transfer(_outputs[i].output, balance);\n        require(success, \"Failed to transfer the funds, aborting.\");\n        _liquidated = _liquidated.sub(balance);\n        emit PaymentSent(_outputs[i].output, balance);\n    }\n\n    function addOutput(\n        address payable output,\n        uint256 split,\n        uint256 threshold\n    ) public onlyAuthorizedChanger() {\n        _addOutput(output, split, threshold);\n    }\n\n    function _addOutput(\n        address payable output,\n        uint256 split,\n        uint256 threshold\n    ) internal {\n        _outputs.push(Output({output: output, split: split, threshold: threshold, balance: 0}));\n        _splitTotal = _splitTotal.add(split);\n    }\n\n    function removeOutput(uint256 idx) public onlyAuthorizedChanger() {\n        require(idx < _outputs.length, \"Invalid index\");\n        uint256 balance = _outputs[idx].balance;\n        if (balance > 0) {\n            _outputs[idx].balance = 0;\n            bool success = transfer(_outputs[idx].output, balance);\n            require(success, \"Failed to transfer the funds, aborting.\");\n            _liquidated = _liquidated.sub(balance);\n        }\n        _splitTotal = _splitTotal.sub(_outputs[idx].split);\n        _outputs[idx] = _outputs[_outputs.length - 1];\n        _outputs.pop();\n    }\n\n    function setThreshold(uint256 threshold) public onlyAuthorizedChanger() {\n        _threshold = threshold;\n    }\n\n    function getThreshold() public view returns (uint256) {\n        return _threshold;\n    }\n\n    function getSplit() public view returns (uint256) {\n        return _splitTotal;\n    }\n\n    function getLiquidated() public view returns (uint256) {\n        return _liquidated;\n    }\n\n    function getNumOutputs() public view returns (uint256) {\n        return _outputs.length;\n    }\n\n    function isFlushable(uint256 i) public view returns (bool) {\n        return _outputs[i].balance > _outputs[i].threshold;\n    }\n\n    function isLiquidable() public view returns (bool) {\n        uint256 balance = getBalance();\n        uint256 toLiquidate = getLiquidated();\n        uint256 amount = balance.sub(toLiquidate);\n        return amount > _threshold;\n    }\n\n    function getOutput(uint256 idx)\n        public\n        view\n        returns (\n            address,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (\n            _outputs[idx].output,\n            _outputs[idx].split,\n            _outputs[idx].balance,\n            _outputs[idx].threshold\n        );\n    }\n\n    function getToken() public view virtual returns (address);\n\n    function getAll()\n        public\n        view\n        virtual\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            address,\n            uint256\n        );\n\n    receive() external payable {}\n}\n\n\ncontract BufferToken is BufferBase {\n    using SafeMath for uint256;\n\n    IERC20 internal _token;\n\n    // @dev minimum threshold to send\n    function initialize(\n        IGovernor _governor,\n        IERC20 token,\n        uint256 threshold,\n        address payable[] memory outputs,\n        uint256[] memory splits,\n        uint256[] memory thresholds\n    ) public initializer {\n        require(token != IERC20(0), \"Wrong token address\");\n        _token = token;\n        BufferBase._initialize(_governor, threshold, outputs, splits, thresholds);\n    }\n\n    function getBalance() public view override returns (uint256) {\n        return _token.balanceOf(address(this));\n    }\n\n    function transfer(address destination, uint256 balance) internal override returns (bool) {\n        return _token.transfer(destination, balance);\n    }\n\n    function dispose(address payable beneficiary) external onlyAuthorizedChanger {\n        uint256 balance = getBalance();\n        bool success = _token.transfer(beneficiary, balance);\n        require(success, \"Failed to transfer the funds, aborting.\");\n        selfdestruct(beneficiary);\n    }\n\n    function getToken() public view override returns (address) {\n        return address(_token);\n    }\n\n    function getAll()\n        public\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            address,\n            uint256\n        )\n    {\n        return (\n            getBalance(),\n            _threshold,\n            _splitTotal,\n            _liquidated,\n            address(_token),\n            _outputs.length\n        );\n    }\n\n    function setToken(IERC20 token) public onlyAuthorizedChanger {\n        require(getBalance() == 0, \"Failed to set new token. Balance is not zero.\");\n        _token = token;\n    }\n}\n\n",
            "file": "BufferToken.sol"
        }
    ],
    "libraries": {},
    "creationData": {
        "blockHash": "0x6e84e8e2df1f3b9305706eac3fa11ae5099a72cca12c9c5d692ab7ec5623efad",
        "blockNumber": 1697032,
        "transactionHash": "0xf426933a967052c68caaf40020fa0095246357b247907d9f060ae22d21887d39",
        "timestamp": 1616184723
    }
}