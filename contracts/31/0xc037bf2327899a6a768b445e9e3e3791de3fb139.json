{
  "address": "0xc037bf2327899a6a768b445e9e3e3791de3fb139",
  "net": {
    "id": "31",
    "name": "RSK Testnet"
  },
  "name": "VotingMachine",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    }
  },
  "version": "0.6.12+commit.27d51765",
  "source": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n\n\n\n/*\n    Abstract contract meant to be reused.\n    An iterable unique map of address -> proposals.\n*/\nlibrary ProposalInfoLib {\n    using SafeMath for uint256;\n\n    struct ProposalData {\n        // The round in which this proposal was proposed\n        uint256 votingRound;\n        // Accumulated votes in MOCs\n        uint256 votes;\n        // Expiration time\n        uint256 expirationTimestamp;\n    }\n\n    struct ProposalInfoData {\n        address[] proposalList;\n        mapping(address => ProposalData) proposals;\n    }\n\n    /**\n      ProposalInfoData data initializations\n    */\n    function _init() internal pure returns (ProposalInfoData memory) {\n        address[] memory emptyList;\n        return ProposalInfoData(emptyList);\n    }\n\n    /**\n    Add to the set, increasing its size\n\n    @param _key the key of the mapping\n    @param _data the value to assign\n    */\n    function _push(\n        ProposalInfoData storage self,\n        address _key,\n        ProposalData memory _data\n    ) internal {\n        require(!_contains(self, _key), \"Duplicated key\");\n        require(_data.votingRound != 0, \"Invalid votingRound value\");\n        self.proposals[_key] = _data;\n        self.proposalList.push(_key);\n    }\n\n    /**\n    Replace an element by index. After an iteration the resulting index can be use to replace an element\n\n    @param _idx the index in the list for the old element\n    @param _newKey the new key of the mapping\n    @param _data the new value to assign\n    */\n    function _replace(\n        ProposalInfoData storage self,\n        uint256 _idx,\n        address _newKey,\n        ProposalData memory _data\n    ) internal {\n        require(_idx < _length(self), \"Index out of range_replace\");\n        require(_data.votingRound != 0, \"Invalid votingRound value\");\n        delete self.proposals[self.proposalList[_idx]];\n        require(!_contains(self, _newKey), \"Duplicated key\");\n        self.proposalList[_idx] = _newKey;\n        self.proposals[_newKey] = _data;\n    }\n\n    /**\n    Replace an element by index address\n\n    @param _oldKey the kef of the old element\n    @param _newKey the new key of the mapping\n    @param _data the new value to assign\n    */\n    function _replace(\n        ProposalInfoData storage self,\n        address _oldKey,\n        address _newKey,\n        ProposalData memory _data\n    ) internal {\n        _replace(self, _find(self, _oldKey), _newKey, _data);\n    }\n\n    /**\n    Gets an element by index (used during iteration).\n\n    @param _idx the index used to get the element\n    */\n    function _get(ProposalInfoData storage self, uint256 _idx)\n        internal\n        view\n        returns (address, ProposalData memory)\n    {\n        require(_idx < _length(self), \"Index out of range_get\");\n        return (self.proposalList[_idx], self.proposals[self.proposalList[_idx]]);\n    }\n\n    /**\n    Gets an element by address.\n\n    @param _key the key used to get the element\n    */\n    function _get(ProposalInfoData storage self, address _key)\n        internal\n        view\n        returns (ProposalData memory)\n    {\n        require(_contains(self, _key), \"Key not found\");\n        return self.proposals[_key];\n    }\n\n    /**\n    Set a value by address.\n\n    @param _key the key used to set the element value\n    @param _data the new value to set\n    */\n    function _set(\n        ProposalInfoData storage self,\n        address _key,\n        ProposalData memory _data\n    ) internal {\n        require(_contains(self, _key), \"Invalid key\");\n        require(_data.votingRound != 0, \"Invalid votingRound value\");\n        self.proposals[_key] = _data;\n    }\n\n    /**\n    Set a value by index.\n\n    @param _idx the index of element to change\n    @param _data the new value to set\n    */\n    function _set(\n        ProposalInfoData storage self,\n        uint256 _idx,\n        ProposalData memory _data\n    ) internal {\n        require(_idx < _length(self), \"Index out of range_set\");\n        _set(self, self.proposalList[_idx], _data);\n    }\n\n    /**\n    Get the quantity of elements\n\n    */\n    function _length(ProposalInfoData storage self) internal view returns (uint256) {\n        return self.proposalList.length;\n    }\n\n    /**\n    Check if the map contains a specific address.\n\n    @param _key the address to check\n    */\n    function _contains(ProposalInfoData storage self, address _key) internal view returns (bool) {\n        return _key != address(0) && self.proposals[_key].votingRound != 0;\n    }\n\n    /**\n    Remove from the list by index (reducing its size)\n\n    @param _idx the index of the element to remove\n    */\n    function _remove(ProposalInfoData storage self, uint256 _idx) internal {\n        require(_idx < _length(self), \"Index out of range _remove\");\n        delete self.proposals[self.proposalList[_idx]];\n        self.proposalList[_idx] = self.proposalList[self.proposalList.length - 1];\n        self.proposalList.pop();\n    }\n\n    /**\n      Remove from the list by address (reducing its size).\n      This method does a linear search of the element, use with care\n\n      @param _key the key used to search the element to remove\n    */\n    function _remove(ProposalInfoData storage self, address _key) internal {\n        _remove(self, _find(self, _key));\n    }\n\n    /**\n      This method does a linear search of some key, use with care\n\n      @param _key the key to that is searched\n    */\n    function _find(ProposalInfoData storage self, address _key) internal view returns (uint256) {\n        require(_contains(self, _key), \"Key not found\");\n        for (uint256 i = 0; i < _length(self); i++) {\n            if (self.proposalList[i] == _key) {\n                return i;\n            }\n        }\n        require(false, \"Missing key?\");\n        return 0;\n    }\n}\n\n\n/*\n    Abstract contract meant to be reused.\n*/\nlibrary PreVotingDataLib {\n    using SafeMath for uint256;\n    using ProposalInfoLib for ProposalInfoLib.ProposalInfoData;\n\n    struct PreVotingData {\n        // Proposal Information\n        ProposalInfoLib.ProposalInfoData proposalInfo;\n    }\n\n    /**\n    PreVotingList data initializations\n    */\n    function _init(PreVotingData storage self) internal {\n        self.proposalInfo = ProposalInfoLib._init();\n    }\n\n    /**\n    The proposal was never voted or is new in this round\n\n    @param _proposalAddr Address of the change contract that will be executed if this vote is successful\n    */\n    function _isEmptyProposal(\n        PreVotingData storage self,\n        uint256 _votingRound,\n        address _proposalAddr\n    ) internal view returns (bool) {\n        if (!self.proposalInfo._contains(_proposalAddr)) {\n            return true;\n        }\n        ProposalInfoLib.ProposalData memory proposal = self.proposalInfo._get(_proposalAddr);\n        return __isReusableProposal(_votingRound, proposal);\n    }\n\n    /**\n    Insert or update a proposal. If the list is full then replace the one with less stake.\n\n    @param _proposalAddr address of the change contract\n    @param _stake stake used\n    */\n    function _upsert(\n        PreVotingData storage self,\n        uint256 _votingRound,\n        uint256 _maxPreProposals,\n        uint256 _preVoteExpirationTimeDelta,\n        address _proposalAddr,\n        uint256 _stake\n    ) internal returns (bool) {\n        // Reuse a proposal.\n        if (self.proposalInfo._contains(_proposalAddr)) {\n            ProposalInfoLib.ProposalData memory proposal = self.proposalInfo._get(_proposalAddr);\n            if (!__isReusableProposal(_votingRound, proposal)) {\n                // Can't reuse an active proposal\n                return false;\n            }\n\n            self.proposalInfo._set(\n                _proposalAddr,\n                __newProposal(_votingRound, _preVoteExpirationTimeDelta, _stake)\n            );\n            return true;\n        }\n\n        // Completely new proposal, there is a place in the list\n        if (self.proposalInfo._length() < _maxPreProposals) {\n            self.proposalInfo._push(\n                _proposalAddr,\n                __newProposal(_votingRound, _preVoteExpirationTimeDelta, _stake)\n            );\n            return true;\n        }\n\n        // Completely new proposal but there is no place in the list, must check if there are proposals to remove.\n        (uint256 minIdx, uint256 minVal) = __findAPlace(self, _votingRound);\n        if (_stake > minVal) {\n            self.proposalInfo._replace(\n                minIdx,\n                _proposalAddr,\n                __newProposal(_votingRound, _preVoteExpirationTimeDelta, _stake)\n            );\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     Add votes to a proposal\n\n     @param _proposalAddr address of the change contract\n     @param _stake stake used\n     */\n    function _addVotes(\n        PreVotingData storage self,\n        uint256 _votingRound,\n        address _proposalAddr,\n        uint256 _stake\n    ) internal returns (bool) {\n        if (!self.proposalInfo._contains(_proposalAddr)) {\n            return false;\n        }\n        ProposalInfoLib.ProposalData memory proposal = self.proposalInfo._get(_proposalAddr);\n        if (__isReusableProposal(_votingRound, proposal)) {\n            return false;\n        }\n        // We don't let them vote an expired proposal\n        if (__isExpired(proposal)) {\n            return false;\n        }\n        proposal.votes = _stake.add(proposal.votes);\n        self.proposalInfo._set(_proposalAddr, proposal);\n        return true;\n    }\n\n    /**\n      Remove from the pre-voting list an expired proposal\n\n      @param _proposalAddr address of the change contract\n    */\n    function _remove(\n        PreVotingData storage self,\n        uint256 _votingRound,\n        address _proposalAddr\n    ) internal returns (bool) {\n        if (!self.proposalInfo._contains(_proposalAddr)) {\n            return false;\n        }\n        ProposalInfoLib.ProposalData memory proposal = self.proposalInfo._get(_proposalAddr);\n        if (!__isReusableProposal(_votingRound, proposal)) {\n            return false;\n        }\n        self.proposalInfo._remove(_proposalAddr);\n        return true;\n    }\n\n    /**\n    Get a winner proposal.\n    Search the proposal with max pre-votes if it is expired then that proposal is the winner.\n    If two proposals has the same quantity of votes take the with older expiration time.\n    @param _preVoteMinPCToWin minimum percentage of vote needed to participate (moc votes/total moc in circulation).\n    @param _pctPrecision percentage precision.\n    @param _totalMOCSupply total supply of moc to calculate percentages.\n    */\n    function _getWinnerProposal(\n        PreVotingData storage self,\n        uint256 _votingRound,\n        uint256 _preVoteMinPCToWin,\n        uint256 _pctPrecision,\n        uint256 _totalMOCSupply\n    ) internal view returns (address candidateAddress, uint256 maxVal) {\n        address currentAddress;\n        ProposalInfoLib.ProposalData memory candidateProposal;\n        ProposalInfoLib.ProposalData memory currentProposal;\n        uint256 maxVotes = 0;\n\n        // Search the proposal (expired or not) with the max quantity of votes.\n        for (uint256 i = 0; i < self.proposalInfo._length(); i++) {\n            (currentAddress, currentProposal) = self.proposalInfo._get(i);\n\n            if (__isReusableProposal(_votingRound, currentProposal)) {\n                continue;\n            }\n\n            // Not enough votes to participate.\n            if (\n                currentProposal.votes.mul(_pctPrecision) < _totalMOCSupply.mul(_preVoteMinPCToWin)\n            ) {\n                continue;\n            }\n\n            if (\n                currentProposal.votes > maxVotes ||\n                (currentProposal.votes == maxVotes &&\n                    currentProposal.expirationTimestamp < candidateProposal.expirationTimestamp)\n            ) {\n                maxVotes = currentProposal.votes;\n                candidateAddress = currentAddress;\n                candidateProposal = currentProposal;\n            }\n        }\n\n        // if the candidate is expired we have a winner.\n        if (__isExpired(candidateProposal)) {\n            return (candidateAddress, candidateProposal.votes);\n        }\n        return (address(0), 0);\n    }\n\n    /**\n    Get the proposal count\n    */\n    function _getProposalCount(PreVotingData storage self) internal view returns (uint256) {\n        return self.proposalInfo._length();\n    }\n\n    /**\n    Get proposal address and information by index\n\n    @param _index Index of proposal to query. \n    */\n    function _getProposalByIndex(PreVotingData storage self, uint256 _index)\n        internal\n        view\n        returns (\n            address proposalAddress,\n            uint256 votingRound,\n            uint256 votes,\n            uint256 expirationTimeStamp\n        )\n    {\n        (address addr, ProposalInfoLib.ProposalData memory data) = self.proposalInfo._get(_index);\n        return (addr, data.votingRound, data.votes, data.expirationTimestamp);\n    }\n\n    /**\n    Check if a is valid.\n\n    @param _votes stake used\n    */\n    function __newProposal(\n        uint256 _votingRound,\n        uint256 _preVoteExpirationTimeDelta,\n        uint256 _votes\n    ) internal view returns (ProposalInfoLib.ProposalData memory) {\n        return\n            ProposalInfoLib.ProposalData({\n                votingRound: _votingRound,\n                votes: _votes, // solhint-disable-next-line not-rely-on-time\n                expirationTimestamp: block.timestamp + _preVoteExpirationTimeDelta\n            });\n    }\n\n    /**\n    Find a place in the list, at this point I'm sure that there is no winner proposal and that the list is\n    full (length > 1). We use the first  expired or reusable slot. If all the proposals are active then we\n    search for the one that has minimum votes.\n    */\n    function __findAPlace(PreVotingData storage self, uint256 _votingRound)\n        internal\n        view\n        returns (uint256 minIdx, uint256 minVal)\n    {\n        ProposalInfoLib.ProposalData memory proposal;\n        (, proposal) = self.proposalInfo._get(0);\n        if (__isReusableProposal(_votingRound, proposal) || __isExpired(proposal)) {\n            return (0, 0);\n        }\n\n        // The proposal in idx == 0 is not expired => is active.\n        (minIdx, minVal) = (0, proposal.votes);\n        for (uint256 i = 1; i < self.proposalInfo._length(); i++) {\n            (, proposal) = self.proposalInfo._get(i);\n            if (__isReusableProposal(_votingRound, proposal) || __isExpired(proposal)) {\n                return (i, 0);\n            }\n            // Not expired proposals, calculate the min and max\n            if (proposal.votes < minVal) {\n                (minIdx, minVal) = (i, proposal.votes);\n            }\n        }\n\n        // We only use an active proposal if there are no expired proposals or free slots.\n        return (minIdx, minVal);\n    }\n\n    function _isExpired(\n        PreVotingData storage self,\n        uint256 _votingRound,\n        address _proposalAddr\n    ) internal view returns (bool) {\n        if (!self.proposalInfo._contains(_proposalAddr)) {\n            return false;\n        }\n        ProposalInfoLib.ProposalData memory proposal = self.proposalInfo._get(_proposalAddr);\n        if (__isReusableProposal(_votingRound, proposal)) {\n            return false;\n        }\n        return __isExpired(proposal);\n    }\n\n    /**\n    The proposal was never voted or is new in this round\n\n    @param _proposal proposal data\n    */\n    function __isReusableProposal(\n        uint256 _votingRound,\n        ProposalInfoLib.ProposalData memory _proposal\n    ) internal pure returns (bool) {\n        return (_proposal.votingRound != _votingRound);\n    }\n\n    function __isExpired(ProposalInfoLib.ProposalData memory _proposal)\n        internal\n        view\n        returns (bool)\n    {\n        // solhint-disable-next-line not-rely-on-time\n        return (_proposal.expirationTimestamp < block.timestamp);\n    }\n}\n\n\n\n/*\n    Abstract contract meant to be reused.\n*/\nlibrary VotingDataLib {\n    using SafeMath for uint256;\n    using ProposalInfoLib for ProposalInfoLib.ProposalInfoData;\n\n    struct VotingData {\n        // Pre-voting winner proposal\n        address winnerProposal;\n        // Accumulated votes in MOCs\n        uint256 inFavorVotes;\n        // Accumulated votes in MOCs\n        uint256 againstVotes;\n        // voting process expiration time.\n        uint256 votingExpirationTime;\n    }\n\n    /**\n    Voting data initializations\n    */\n    function _init(VotingData storage self) internal {\n        self.winnerProposal = address(0);\n        self.inFavorVotes = 0;\n        self.againstVotes = 0;\n    }\n\n    /**\n     */\n    function _startVoting(\n        VotingData storage self,\n        uint256 _votingTimeDelta,\n        address _winnerProposal,\n        uint256 _inFavorVotes,\n        uint256 _againstVotes\n    ) internal {\n        self.winnerProposal = _winnerProposal;\n        self.inFavorVotes = _inFavorVotes;\n        self.againstVotes = _againstVotes;\n        // solhint-disable-next-line not-rely-on-time\n        self.votingExpirationTime = _votingTimeDelta + block.timestamp;\n    }\n\n    /**\n     */\n    function _addVotes(\n        VotingData storage self,\n        uint256 _stake,\n        bool _inFavorAgainst\n    ) internal {\n        if (_inFavorAgainst) {\n            self.inFavorVotes = self.inFavorVotes.add(_stake);\n        } else {\n            self.againstVotes = self.againstVotes.add(_stake);\n        }\n    }\n\n    /**\n     */\n    function _isVeto(\n        VotingData storage self,\n        uint256 _PCTPrecision,\n        uint256 _voteMinPctToVeto,\n        uint256 _totalMOC\n    ) internal view returns (bool) {\n        return (self.againstVotes.mul(_PCTPrecision) > _totalMOC.mul(_voteMinPctToVeto));\n    }\n\n    /**\n     */\n    function _isAccepted(\n        VotingData storage self,\n        uint256 _PCTPrecision,\n        uint256 _voteMinPctToVeto,\n        uint256 _voteMinPctForQuorum,\n        uint256 _voteMinPctToAccept,\n        uint256 _totalMOC\n    ) internal view returns (bool) {\n        uint256 inFavor = self.inFavorVotes.mul(_PCTPrecision);\n        // If the proposal is more than 70% of total mocs in circulation is accepted (can not be vetted anyway)\n        if ((inFavor >= _totalMOC.mul(_PCTPrecision.sub(_voteMinPctToVeto)))) {\n            return true;\n        }\n        // Still don't expired.\n        if (!_isExpired(self)) {\n            return false;\n        }\n        // Less than 20% of total mocs in circulation\n        if (inFavor < _totalMOC.mul(_voteMinPctForQuorum)) {\n            return false;\n        }\n        // After expiration in favor < 50% * (in favor + against)\n        if (inFavor < _voteMinPctToAccept.mul(self.againstVotes.add(self.inFavorVotes))) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     */\n    function _isExpired(VotingData storage self) internal view returns (bool) {\n        // solhint-disable-next-line not-rely-on-time\n        return (self.votingExpirationTime < block.timestamp);\n    }\n}\n\n\n\ninterface IRegistry {\n    // *** Getter Methods ***\n    function getDecimal(bytes32 _key) external view returns (int232 base, int16 exp);\n\n    function getUint(bytes32 _key) external view returns (uint248);\n\n    function getString(bytes32 _key) external view returns (string memory);\n\n    function getAddress(bytes32 _key) external view returns (address);\n\n    function getBytes(bytes32 _key) external view returns (bytes memory);\n\n    function getBool(bytes32 _key) external view returns (bool);\n\n    function getInt(bytes32 _key) external view returns (int248);\n\n    // *** Setter Methods ***\n    function setDecimal(\n        bytes32 _key,\n        int232 _base,\n        int16 _exp\n    ) external;\n\n    function setUint(bytes32 _key, uint248 _value) external;\n\n    function setString(bytes32 _key, string calldata _value) external;\n\n    function setAddress(bytes32 _key, address _value) external;\n\n    function setBytes(bytes32 _key, bytes calldata _value) external;\n\n    function setBool(bytes32 _key, bool _value) external;\n\n    function setInt(bytes32 _key, int248 _value) external;\n\n    // *** Delete Methods ***\n    function deleteDecimal(bytes32 _key) external;\n\n    function deleteUint(bytes32 _key) external;\n\n    function deleteString(bytes32 _key) external;\n\n    function deleteAddress(bytes32 _key) external;\n\n    function deleteBytes(bytes32 _key) external;\n\n    function deleteBool(bytes32 _key) external;\n\n    function deleteInt(bytes32 _key) external;\n}\n\n// Autogenerated by registryConstants.js\n\ncontract RegistryConstants {\n    // MOC_TOKEN = keccak256(moc.token)\n    bytes32\n        public constant MOC_TOKEN = 0x4bd5e7ff929fdd1ba62a33f76e0f40e97bb35e8bf126c0d9d91ce5c69a4bc521;\n\n    // MOC_DELAY_MACHINE = keccak256(moc.delay-machine)\n    bytes32\n        public constant MOC_DELAY_MACHINE = 0x66b60892ff6e7f0da16db27046f5960fdfd6bce5c3c8c21d56ccca3236a6281b;\n\n    // MOC_STAKING_MACHINE = keccak256(moc.staking-machine)\n    bytes32\n        public constant MOC_STAKING_MACHINE = 0x3c557531fea67120f21bc7711270a96f1b8cff3dfe3dd798a8a9f09ce9b77972;\n\n    // MOC_VESTING_MACHINE = keccak256(moc.vesting-machine)\n    bytes32\n        public constant MOC_VESTING_MACHINE = 0x7dfea4fb968e2599cdb7b3028c07d0188d0f92d1d00bd95c2805523c224649dd;\n\n    // MOC_VOTING_MACHINE = keccak256(moc.voting-machine)\n    bytes32\n        public constant MOC_VOTING_MACHINE = 0xc0ded27704f62d8726fdbd83648113d9fd8cf32c09f80523d2ba523e0bbd5ba4;\n\n    // MOC_UPGRADE_DELEGATOR = keccak256(moc.upgrade-delegator)\n    bytes32\n        public constant MOC_UPGRADE_DELEGATOR = 0x631bcbb9b033f9c8d13c32cf6e60827348d77b91b58c295e87745219242cca22;\n\n    // MOC_VOTING_MACHINE_MIN_STAKE = keccak256(moc.voting-machine.minStake)\n    bytes32\n        public constant MOC_VOTING_MACHINE_MIN_STAKE = 0x580be8e098dd1016787d59c2a534bf9df9ec679a29de4c8f92dc3807f7d7d54d;\n\n    // MOC_VOTING_MACHINE_PRE_VOTE_EXPIRATION_TIME_DELTA = keccak256(moc.voting-machine.preVoteExpirationTimeDelta)\n    bytes32\n        public constant MOC_VOTING_MACHINE_PRE_VOTE_EXPIRATION_TIME_DELTA = 0x62f5dbf0c17b0df83487409f747ad2eeca5fd54c140ca59b32cf39d6f6eaf916;\n\n    // MOC_VOTING_MACHINE_MAX_PRE_PROPOSALS = keccak256(moc.voting-machine.maxPreProposals)\n    bytes32\n        public constant MOC_VOTING_MACHINE_MAX_PRE_PROPOSALS = 0xc32b9cbc59039d297e670e7c196424308c90ba4a437fa7ccd008498c934e7dbf;\n\n    // MOC_VOTING_MACHINE_PRE_VOTE_MIN_PCT_TO_WIN = keccak256(moc.voting-machine.preVoteMinPCToWin)\n    bytes32\n        public constant MOC_VOTING_MACHINE_PRE_VOTE_MIN_PCT_TO_WIN = 0x0a1b21dfd7e4f3741529cf579e2731e847d81bbf13a82d0eba6910d7ac4c1c0a;\n\n    // MOC_VOTING_MACHINE_VOTE_MIN_PCT_TO_VETO = keccak256(moc.voting-machine.voteMinPctToVeto)\n    bytes32\n        public constant MOC_VOTING_MACHINE_VOTE_MIN_PCT_TO_VETO = 0xfb2d33acd65c36f68a15f8fe41cb8c0dd1eda164ffa87c6882e685ccb1c1adfb;\n\n    // MOC_VOTING_MACHINE_VOTE_MIN_PCT_FOR_QUORUM = keccak256(moc.voting-machine.voteMinPctForQuorum)\n    bytes32\n        public constant MOC_VOTING_MACHINE_VOTE_MIN_PCT_FOR_QUORUM = 0xde1ede48948567c43c504b761af8cd6af5363fafeceb1239b3083955d809714f;\n\n    // MOC_VOTING_MACHINE_VOTE_MIN_PCT_TO_ACCEPT = keccak256(moc.voting-machine.voteMinPctToAccept)\n    bytes32\n        public constant MOC_VOTING_MACHINE_VOTE_MIN_PCT_TO_ACCEPT = 0x99f83ee0c57b325f3deafb536d55596743ff112c6ac0d853d5f4f89b75dec045;\n\n    // MOC_VOTING_MACHINE_PCT_PRECISION = keccak256(moc.voting-machine.PCTPrecision)\n    bytes32\n        public constant MOC_VOTING_MACHINE_PCT_PRECISION = 0x73ee596441ef88c207a7a9147d62f59186b4991555e37b7ce9c801f9539d1050;\n\n    // MOC_VOTING_MACHINE_VOTING_TIME_DELTA = keccak256(moc.voting-machine.votingTimeDelta)\n    bytes32\n        public constant MOC_VOTING_MACHINE_VOTING_TIME_DELTA = 0xb43ee0a5ee6dcc7115ce824e4e353526ad6e479afa4daeb78451070de942de36;\n\n    // ORACLE_MANAGER_ADDR = keccak256(MOC_ORACLE\\1\\ORACLE_MANAGER_ADDR)\n    bytes32\n        public constant ORACLE_MANAGER_ADDR = 0x16986f74674f2ed21d50b6e74e6b12bb323ff4f72364542fd5de5104f3cc3ca9;\n\n    // SUPPORTERS_ADDR = keccak256(MOC_ORACLE\\1\\SUPPORTERS_ADDR)\n    bytes32\n        public constant SUPPORTERS_ADDR = 0xe4f979504d2a7a24557a15195eb83131e7c4a66d33900454705435aa5a6ee086;\n\n    // INFO_ADDR = keccak256(MOC_ORACLE\\1\\INFO_ADDR)\n    bytes32\n        public constant INFO_ADDR = 0xda9f12e01fc92de345bb741448d36ecb967052dd7aa1670439af833c9a3d78f1;\n\n    // ORACLE_PRICE_FETCH_RATE = keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_FETCH_RATE)\n    bytes32\n        public constant ORACLE_PRICE_FETCH_RATE = 0x945f72e5d44fb0ce3b1de393d19415723b79f97ad801089d8470d1c20e15ffef;\n\n    // ORACLE_BLOCKCHAIN_INFO_INTERVAL = keccak256(MOC_ORACLE\\1\\ORACLE_BLOCKCHAIN_INFO_INTERVAL)\n    bytes32\n        public constant ORACLE_BLOCKCHAIN_INFO_INTERVAL = 0x11cfbdf601b80a575e4366f0234cc06de0c9f401fe250dd9dccfccefeedb6fc2;\n\n    // ORACLE_COIN_PAIR_LOOP_TASK_INTERVAL = keccak256(MOC_ORACLE\\1\\ORACLE_COIN_PAIR_LOOP_TASK_INTERVAL)\n    bytes32\n        public constant ORACLE_COIN_PAIR_LOOP_TASK_INTERVAL = 0x2f271dc1fa81985bda14a2d6d0d60b45191d2a2d97e636b192696a8796d654a7;\n\n    // ORACLE_MAIN_LOOP_TASK_INTERVAL = keccak256(MOC_ORACLE\\1\\ORACLE_MAIN_LOOP_TASK_INTERVAL)\n    bytes32\n        public constant ORACLE_MAIN_LOOP_TASK_INTERVAL = 0x275d8a46b817572476d2d55b41c7709dee307740bad676a9693805003a48d231;\n\n    // ORACLE_PRICE_REJECT_DELTA_PCT = keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_REJECT_DELTA_PCT)\n    bytes32\n        public constant ORACLE_PRICE_REJECT_DELTA_PCT = 0x7a3ee46ca1bd3e19089870d8d6530b083a86da93aab52efccb32d5950e2709cf;\n\n    // ORACLE_CONFIGURATION_TASK_INTERVAL = keccak256(MOC_ORACLE\\1\\ORACLE_CONFIGURATION_TASK_INTERVAL)\n    bytes32\n        public constant ORACLE_CONFIGURATION_TASK_INTERVAL = 0xb027f2006a45346de89db4c5efc53f4e05e96532d27366aff00367a394d0abc4;\n\n    // ORACLE_GATHER_SIGNATURE_TIMEOUT = keccak256(MOC_ORACLE\\1\\ORACLE_GATHER_SIGNATURE_TIMEOUT)\n    bytes32\n        public constant ORACLE_GATHER_SIGNATURE_TIMEOUT = 0xf75b08b2b912abdbb87cc459ca0b4fdc019329386ec84ab68399b0c86fed5a95;\n\n    // ORACLE_MAIN_EXECUTOR_TASK_INTERVAL = keccak256(MOC_ORACLE\\1\\ORACLE_MAIN_EXECUTOR_TASK_INTERVAL)\n    bytes32\n        public constant ORACLE_MAIN_EXECUTOR_TASK_INTERVAL = 0xb324a91be1ac0d0c4888c835aee124ca1a7caf4b73ce10aa3504e2683865d7e5;\n\n    // SCHEDULER_POOL_DELAY = keccak256(MOC_ORACLE\\1\\SCHEDULER_POOL_DELAY)\n    bytes32\n        public constant SCHEDULER_POOL_DELAY = 0x6c2abc911c0fa4c73b90c7143a9f4429749be45ebfe7b81e69b86e7ca440d811;\n\n    // SCHEDULER_ROUND_DELAY = keccak256(MOC_ORACLE\\1\\SCHEDULER_ROUND_DELAY)\n    bytes32\n        public constant SCHEDULER_ROUND_DELAY = 0xa82bea7140872d1398fa0ab5075330ab0228f4c7e381b4b6502379ffc7cdcd9f;\n\n    // ORACLE_PRICE_DIGITS = keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_DIGITS)\n    bytes32\n        public constant ORACLE_PRICE_DIGITS = 0x4cd7e3f12ee4a2db0a6ba16e03fbc31bba1048c149bbf4fc9f3c02021ec550b8;\n\n    // ORACLE_QUEUE_LEN = keccak256(MOC_ORACLE\\1\\ORACLE_QUEUE_LEN)\n    bytes32\n        public constant ORACLE_QUEUE_LEN = 0x7d32d87d65898c3cbc7e72c59d223bf61c7811e99dafafd24fb08e0a38f10914;\n\n    // MESSAGE_VERSION = keccak256(MOC_ORACLE\\1\\MESSAGE_VERSION)\n    bytes32\n        public constant MESSAGE_VERSION = 0xeafac1a2b4d4fdcc942cbdce334a88ec83387087978d039f1320d3639a0b59df;\n\n    // ORACLE_STAKE_LIMIT_MULTIPLICATOR = keccak256(MOC_ORACLE\\1\\ORACLE_STAKE_LIMIT_MULTIPLICATOR)\n    bytes32\n        public constant ORACLE_STAKE_LIMIT_MULTIPLICATOR = 0xa1e0b5b458fe661fe687da135d3340a172e262c3cb31d646a4cb5cea9b6f1790;\n\n    // ORACLE_WITHDRAW_LOCK_TIME = keccak256(MOC_ORACLE\\1\\ORACLE_WITHDRAW_LOCK_TIME)\n    bytes32\n        public constant ORACLE_WITHDRAW_LOCK_TIME = 0x5e92c359b77ace8f4933558289f577781c0713b4ff91b2d2f76c8e523e560070;\n\n    // ORACLE_PRICE_DELTA_PCT = keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_DELTA_PCT)\n    bytes32\n        public constant ORACLE_PRICE_DELTA_PCT = 0x41a2ac05b365409628009a8091d8dda06fe52fe2f1c792e651e5df7599a7a7de;\n\n    // ORACLE_PRICE_PUBLISH_BLOCKS = keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_PUBLISH_BLOCKS)\n    bytes32\n        public constant ORACLE_PRICE_PUBLISH_BLOCKS = 0x51a2be29a473202678b6cf57b717ba5d7ff671f01fdbdbfcad4e1882601b8896;\n\n    // ORACLE_ENTERING_FALLBACKS_AMOUNTS = keccak256(MOC_ORACLE\\1\\ORACLE_ENTERING_FALLBACKS_AMOUNTS)\n    bytes32\n        public constant ORACLE_ENTERING_FALLBACKS_AMOUNTS = 0xf646c455329c7af0436f9e95c59c90ce0e11bb4e3a1deff805807798696adf88;\n\n    // ORACLE_TRIGGER_VALID_PUBLICATION_BLOCKS = keccak256(MOC_ORACLE\\1\\ORACLE_TRIGGER_VALID_PUBLICATION_BLOCKS)\n    bytes32\n        public constant ORACLE_TRIGGER_VALID_PUBLICATION_BLOCKS = 0xef9006fe6663199909dfaa4ab45e3f86d6454adb7773682f356824b6b3bc6b0e;\n}\n\n\n\n\n\n/// @title This contract provides an interface for feeding prices from oracles, and\n///        get the current price. One contract must be instanced per supported coin pair,\n///        and registered through OracleManager global contract.\n/// This contract has two lists:\n/// 1) A subscribed list (EnumerableSet.AddressSet) oracles owner addresses, this list has a max size (30).\n/// 2) A selected list, EnumerableSet.AddressSet of oracles owner addresses that are selected to participate in\n/// current publication round (10 entries max size).\n///\n/// Oracles are subscribed by adding them to the subscribed oracle list. When the list is full\n/// the oracle with less stake can be removed by a new oracle that is trying to\n/// subscribe (if its stake is greater than his).\n/// On each round switch the list of selected oracles is populated with the 10 Oracles with more stake. An oracle\n/// can unsubscribe itself from the subscribed list in the middle of the round, in this case, the oracle is still\n/// listed in the selected list until the round ends.\n/// If an oracle withdraw some stake then his participation in the round is put into consideration: If the\n/// oracle ends up having less stake than the next oracle in the subscribed list (but not in the selected list) then\n/// it is removed from the selected list and the point he accumulated during the round are lost (set to zero).\n\ninterface ICoinPairPrice {\n    // getOracleOwnerAddress: Given an Oracle address return the Oracle Owner address.\n    // Used during publication, the servers sign with the oracle address, but the list of selected oracles\n    // is by oracle owner address.\n    // getOracleOwnerStake: Get the stake stored in the supporters smart-contract\n    // prettier-ignore\n    struct CoinPairPriceCallbacks {\n        function (address) external view returns (address) getOracleOwnerAddress;\n        function (address) external view returns (uint256) getOracleOwnerStake;\n    }\n\n    /// @notice subscribe an oracle to this coin pair, allowing it to be selected in the next round.\n    /// If the subscribed list is full and the current oracle has more stake than one with minimum stake in the\n    /// subscribed list, then the one with minimum stake is replaced.\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\n    /// @dev This is designed to be called from OracleManager.\n    function subscribe(address oracleOwnerAddr) external;\n\n    /// @notice Unsubscribe an oracle from this coin pair. The oracle won't be selected in the next round.\n    /// After the round end, the oracle can withdraw stake without having the risk of loosing won points.\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\n    /// @dev This is designed to be called from OracleManager.\n    function unsubscribe(address oracleOwnerAddr) external;\n\n    /// @notice Returns true if an oracle is subscribed to this contract' coin pair\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\n    /// @dev This is designed to be called from OracleManager.\n    function isSubscribed(address oracleOwnerAddr) external view returns (bool);\n\n    /// @notice Publish a price. (The message contain oracleAddresses that must be converted to owner addresses).\n    /// @param _version Version number of message format (3)\n    /// @param _coinpair The coin pair to report (must match this contract)\n    /// @param _price Price to report.\n    /// @param _votedOracle The address of the oracle voted as a publisher by the network.\n    /// @param _blockNumber The blocknumber acting as nonce to prevent replay attacks.\n    /// @param _sigV The array of V-component of Oracle signatures.\n    /// @param _sigR The array of R-component of Oracle signatures.\n    /// @param _sigS The array of S-component of Oracle signatures.\n    function publishPrice(\n        uint256 _version,\n        bytes32 _coinpair,\n        uint256 _price,\n        address _votedOracle,\n        uint256 _blockNumber,\n        uint8[] calldata _sigV,\n        bytes32[] calldata _sigR,\n        bytes32[] calldata _sigS\n    ) external;\n\n    /// @notice Publish a price without signature validation (when there is an emergecy!!!).\n    /// @param _price Price to report.\n    function emergencyPublish(uint256 _price) external;\n\n    /// @notice The oracle owner has withdrawn some stake.\n    /// Must check if the oracle is part of current round and if he lost his place with the\n    /// new stake value (the stake is global and is saved in the supporters contract).\n    /// @param oracleOwnerAddr the oracle owner that is trying to withdraw\n    function onWithdraw(address oracleOwnerAddr) external returns (uint256);\n\n    /// @notice Switch contract context to a new round. With the objective of\n    /// being a decentralized solution, this can be called by *anyone* if current\n    /// round lock period is expired.\n    /// This method search the subscribed list and choose the 10 with more stake.\n    function switchRound() external;\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS\n\n    /// @notice Return the available reward fees\n    ///\n    function getAvailableRewardFees() external view returns (uint256);\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS TO GET CURRENT PRICE\n    // MUST BE WHITELISTED\n    /// @notice Return the current price, compatible with old MOC Oracle\n    function peek() external view returns (bytes32, bool);\n\n    /// @notice Return the current price\n    function getPrice() external view returns (uint256);\n\n    ///////////////////////////////////////////////////////////////////////////////// GETTERS TO GET CURRENT PRICE END\n\n    /// @notice Return current round information\n    function getRoundInfo()\n        external\n        view\n        returns (\n            uint256 round,\n            uint256 startBlock,\n            uint256 lockPeriodTimestamp,\n            uint256 totalPoints,\n            address[] memory selectedOwners,\n            address[] memory selectedOracles\n        );\n\n    /// @notice Return round information for specific oracle\n    function getOracleRoundInfo(address addr)\n        external\n        view\n        returns (uint256 points, bool selectedInCurrentRound);\n\n    // The maximum count of oracles selected to participate each round\n    function maxOraclesPerRound() external view returns (uint256);\n\n    // The round lock period in secs\n    function roundLockPeriodSecs() external view returns (uint256);\n\n    function isOracleInCurrentRound(address oracleAddr) external view returns (bool);\n\n    /// @notice Returns the amount of oracles subscribed to this coin pair.\n    function getSubscribedOraclesLen() external view returns (uint256);\n\n    /// @notice Returns the oracle owner address that is subscribed to this coin pair\n    /// @param idx index to query.\n    function getSubscribedOracleAtIndex(uint256 idx) external view returns (address ownerAddr);\n\n    // Public variable\n    function getMaxSubscribedOraclesPerRound() external view returns (uint256);\n\n    // Public variable\n    function getCoinPair() external view returns (bytes32);\n\n    // Public variable\n    function getLastPublicationBlock() external view returns (uint256);\n\n    // Public variable\n    function getValidPricePeriodInBlocks() external view returns (uint256);\n\n    // Public variable\n    function getEmergencyPublishingPeriodInBlocks() external view returns (uint256);\n\n    // Public variable\n    function getOracleManager() external view returns (IOracleManager);\n\n    // Public variable\n    function getToken() external view returns (IERC20);\n}\n\n\n/// This contract manages the Oracle and CoinPair registration info.\n/// The Oracle python server interacts with this contract:\n/// - Coin pair registration\n/// - Oracle registration to coin pairs\n/// - Access Oracle info (oracle address + url) indexed by oracle owner address\n/// - Get the oracle information (url + the specifics of some coin pair rounds) from an oracle address\n/// - Get the oracle address from the owner address.\ninterface IOracleManager {\n    // getOracleOwnerStake: Get the stake stored in the supporters smart-contract\n    // prettier-ignore\n    struct OracleManagerCallbacks {\n        function (address) external view returns (uint256) getOracleOwnerStake;\n    }\n\n    /// @notice Register a new coin pair contract (the contract must be created separately).\n    /// Once created the coin pairs cannot be removed.\n    /// @param coinPair The bytes32-encoded coinpair string (e.g. BTCUSD)\n    /// @param addr The contract address associated to the coin pair.\n    function registerCoinPair(bytes32 coinPair, address addr) external;\n\n    /// Register an oracle in the system must be called by the oracle owner.\n    /// @notice Registers the oracle and transfer the specified caller's MOC token stake.\n    /// @param oracleOwnerAddr The address of the owner of the oracle.\n    /// @param oracleAddr Address of the Oracle to register.\n    /// @param internetName Public Internet name of this Oracle.\n    function registerOracle(\n        address oracleOwnerAddr,\n        address oracleAddr,\n        string calldata internetName\n    ) external;\n\n    /// @notice Change the oracle \"internet\" name (URI), called by the owner.\n    /// @param oracleOwnerAddr The address of the owner of the oracle.\n    /// @param name The new name to set.\n    function setOracleName(address oracleOwnerAddr, string calldata name) external;\n\n    /// @notice Change the oracle address, called by the owner.\n    /// @param oracleOwnerAddr The address of the owner of the oracle.\n    /// @param oracleAddr new value for the address of the oracle\n    function setOracleAddress(address oracleOwnerAddr, address oracleAddr) external;\n\n    /// @notice Removes the oracle registration info. Must be called by the owner\n    /// The oracle must be previously unregistered from all coin pairs.\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\n    function removeOracle(address oracleOwnerAddr) external;\n\n    /// @notice Subscribe a registered oracle to participate in the next round of a registered coin-pair.\n    /// @param oracleOwnerAddr Address of oracle owner\n    function subscribeToCoinPair(address oracleOwnerAddr, bytes32 coinPair) external;\n\n    /// @notice Unsubscribe a registered oracle from participating in rounds of a registered coin-pair.\n    /// The oracle is flagged so it is not selected in the next round.\n    /// @param oracleOwnerAddr Address of oracle owner\n    function unSubscribeFromCoinPair(address oracleOwnerAddr, bytes32 coinPair) external;\n\n    /// @notice The oracle owner did a partial withdrawal of funds\n    /// 1. The oracle address is searched by the owner address.\n    /// 2. Each coin pair to which the oracle is subscribed is consulted to:\n    ///   - Check if the new amount is enough to stay in the current round.\n    ///       If not the oracle is replaced and lost his points.\n    ///   - Get the timestamp for the round end.\n    /// The return value is the maximum timestamp from all the coin pairs.\n    /// @param oracleOwnerAddr Address of oracle owner\n    /// @return the timestamp until which the funds must be locked.\n    function onWithdraw(address oracleOwnerAddr) external returns (uint256);\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS USED BY COINPAIR\n    /// @notice Used by the coin pair to get the oracle address from the oracleOwnerAddress.\n    /// @param  oracleOwnerAddr the address of the owner of the oracle.\n    /// @return oracleAddr Address of oracle\n    function getOracleAddress(address oracleOwnerAddr) external view returns (address oracleAddr);\n\n    /// @notice Returns true if oracle is registered.\n    /// @param ownerAddr The address of the oracle's owner.\n    function isRegistered(address ownerAddr) external view returns (bool);\n\n    /// @notice Used by CoinPair\n    /// @param oracleAddr The oracle address not the owner address.\n    function getOracleOwner(address oracleAddr) external view returns (address);\n\n    /// @notice Returns the amount of owners registered.\n    function getRegisteredOraclesLen() external view returns (uint256);\n\n    /// @notice Returns the oracle name and address at index.\n    /// @param idx index to query.\n    function getRegisteredOracleAtIndex(uint256 idx)\n        external\n        view\n        returns (\n            address ownerAddr,\n            address oracleAddr,\n            string memory url\n        );\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS USED BY COINPAIR END\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS\n\n    // TODO: Check what is the minimum amount of getters the python server needs.\n\n    /// @notice Returns true if an oracle is subscribed to a coin pair\n    function isSubscribed(address oracleAddr, bytes32 coinPair) external view returns (bool);\n\n    /// @notice Return true if the oracle is registered on this coin-pair\n    /// @param oracleAddr addr The address of the Oracle check for.\n    function isOracleRegistered(address oracleAddr) external view returns (bool);\n\n    /// @notice Returns registration information for a registered Oracle.\n    /// @param oracleAddr addr The address of the Oracle to query for.\n    function getOracleRegistrationInfo(address oracleAddr)\n        external\n        view\n        returns (\n            string memory internetName,\n            uint256 stake,\n            address _owner\n        );\n\n    /// @notice Returns round information for a registered oracle in a specific coin-pair.\n    /// @param oracleAddr address of the oracle to query for.\n    /// @param coinpair The coin pair to lookup.\n    function getOracleRoundInfo(address oracleAddr, bytes32 coinpair)\n        external\n        view\n        returns (uint256 points, bool selectedInCurrentRound);\n\n    /// @notice Returns true if an oracle satisfies conditions to be removed from system.\n    /// @param oracleAddr the oracle address to lookup.\n    function canRemoveOracle(address oracleAddr) external view returns (bool);\n\n    /// @notice Get the stake in MOCs that an oracle has.\n    /// @param oracleAddr The address of the oracle.\n    function getStake(address oracleAddr) external view returns (uint256 balance);\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTER TO LIST COIN PAIRS\n\n    /// @notice Returns the count of registered coin pairs.\n    /// Keep in mind that Deleted coin-pairs will contain zeroed addresses.\n    function getCoinPairCount() external view returns (uint256);\n\n    /// @notice Returns the coin pair at index.\n    /// @param i index to query.\n    function getCoinPairAtIndex(uint256 i) external view returns (bytes32);\n\n    /// @notice Return the contract address for a specified registered coin pair.\n    /// @param coinpair Coin-pair string to lookup (e.g: BTCUSD)\n    /// @return address Address of contract or zero if does not exist or was deleted.\n    function getContractAddress(bytes32 coinpair) external view returns (address);\n\n    /// @notice Searches a coinpair in coinPairList\n    /// @param coinPair The bytes32-encoded coinpair string (e.g. BTCUSD)\n    /// @param hint Optional hint to start traversing the coinPairList array, zero is to search all the array.\n    function getCoinPairIndex(bytes32 coinPair, uint256 hint) external view returns (uint256);\n\n    function getMaxStake(address[] calldata addresses) external view returns (address, uint256);\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTER TO LIST COIN PAIRS END\n\n    // Public variable\n    function getStakingContract() external view returns (IStakingMachine);\n\n    // Public variable\n    function getMinCPSubscriptionStake() external view returns (uint256);\n}\n\n\n\ninterface IDelayMachine {\n    /// @notice Accept a deposit from an account.\n    /// @param mocs token quantity\n    /// @param expiration the expiration date for this deposit\n    /// @return id the transaction id\n    function deposit(\n        uint256 mocs,\n        address destination,\n        uint256 expiration\n    ) external returns (uint256 id);\n\n    /// @notice Cancel a transaction returning the funds to the source\n    /// @param id transaction id\n    function cancel(uint256 id) external;\n\n    /// @notice Withdraw stake, send it to the delay machine.\n    /// @param id transaction id\n    function withdraw(uint256 id) external;\n\n    /// @notice Returns the list of transaction for some account\n    /// @return ids transaction ids\n    /// @return amounts token quantity\n    /// @return expirations expiration dates\n    function getTransactions(address account)\n        external\n        view\n        returns (\n            uint256[] memory ids,\n            uint256[] memory amounts,\n            uint256[] memory expirations\n        );\n\n    /// @notice Returns the total balance in MOCs for an account\n    function getBalance(address account) external view returns (uint256);\n\n    // Public variable\n    function getToken() external view returns (IERC20);\n\n    // Public variable\n    function getLastId() external view returns (uint256);\n\n    // Public variable\n    function getSource() external view returns (address);\n}\n\n\ninterface IStakingMachine {\n    /// @notice Used by the voting machine to lock the current balance of MOCs.\n    /// @param mocHolder the moc holder whose mocs will be locked.\n    /// @param untilTimestamp timestamp until which the mocs will be locked.\n    function lockMocs(address mocHolder, uint256 untilTimestamp) external;\n\n    /// @notice Accept a deposit from an account.\n    /// Delegate to the Supporters smart contract.\n    /// @param mocs token quantity\n    /// @param destination the destination account of this deposit.\n    function deposit(uint256 mocs, address destination) external;\n\n    /// @notice Accept a deposit from an account.\n    /// @param mocs token quantity\n    /// @param destination the destination account of this deposit.\n    /// @param source the address that approved the transfer\n    function depositFrom(\n        uint256 mocs,\n        address destination,\n        address source\n    ) external;\n\n    /// @notice Withdraw stake, send it to the delay machine.\n    /// @param mocs token quantity\n    function withdraw(uint256 mocs) external;\n\n    /// @notice Reports the balance of MOCs for a specific user.\n    /// @param user user address\n    function getBalance(address user) external view returns (uint256);\n\n    /// @notice Reports the locked balance of MOCs for a specific user.\n    /// @param user user address\n    function getLockedBalance(address user) external view returns (uint256);\n\n    /// @notice Reports the balance of locked MOCs for a specific user.\n    /// Delegates to the Supporters smart contract.\n    /// @param user user address\n    /// @return amount the amount of mocs locked\n    /// @return untilTimestamp the timestamp that corresponds to the locking date.\n    function getLockingInfo(address user)\n        external\n        view\n        returns (uint256 amount, uint256 untilTimestamp);\n\n    // Public variable\n    function getSupporters() external view returns (address);\n\n    // Public variable\n    function getOracleManager() external view returns (IOracleManager);\n\n    // Public variable\n    function getMocToken() external view returns (IERC20);\n\n    // Public variable\n    function getDelayMachine() external view returns (IDelayMachine);\n\n    // Public variable\n    function getWithdrawLockTime() external view returns (uint256);\n}\n\ninterface IStakingMachineOracles {\n    /// @notice Register an oracle\n    /// @param oracleAddr address of the oracle (from which we publish prices)\n    /// @param url url used by the oracle server\n    function registerOracle(address oracleAddr, string calldata url) external;\n\n    /// @notice Change the oracle \"internet\" name (URI)\n    /// @param url The new url to set.\n    function setOracleName(string calldata url) external;\n\n    /// @notice Change the oracle address\n    /// @param oracleAddr The new oracle address\n    function setOracleAddress(address oracleAddr) external;\n\n    /// @notice Return true if the oracle is registered.\n    /// @param oracleAddr addr The address of the Oracle check for.\n    function isOracleRegistered(address oracleAddr) external view returns (bool);\n\n    /// @notice Returns true if an oracle satisfies conditions to be removed from system.\n    /// @param oracleAddr the oracle address to lookup.\n    function canRemoveOracle(address oracleAddr) external view returns (bool);\n\n    /// @notice Remove an oracle.\n    function removeOracle() external;\n\n    /// @notice Returns the count of registered coin pairs.\n    /// Keep in mind that Deleted coin-pairs will contain zeroed addresses.\n    function getCoinPairCount() external view returns (uint256);\n\n    /// @notice Returns the coin pair at index.\n    /// @param i index to query.\n    function getCoinPairAtIndex(uint256 i) external view returns (bytes32);\n\n    /// @notice Return the contract address for a specified registered coin pair.\n    /// @param coinpair Coin-pair string to lookup (e.g: BTCUSD)\n    /// @return address Address of contract or zero if does not exist or was deleted.\n    function getContractAddress(bytes32 coinpair) external view returns (address);\n\n    /// @notice Searches a coinpair in coinPairList\n    /// @param coinPair The bytes32-encoded coinpair string (e.g. BTCUSD)\n    /// @param hint Optional hint to start traversing the coinPairList array, zero is to search all the array.\n    function getCoinPairIndex(bytes32 coinPair, uint256 hint) external view returns (uint256);\n\n    /// @notice Subscribe an oracle to a coin pair.\n    /// @param coinPair coin pair to subscribe, for example BTCUSD\n    function subscribeToCoinPair(bytes32 coinPair) external;\n\n    /// @notice Unsubscribe an oracle from a coin pair.\n    /// @param coinPair coin pair to unsubscribe, for example BTCUSD\n    function unSubscribeFromCoinPair(bytes32 coinPair) external;\n\n    /// @notice Returns true if an oracle is subscribed to a coin pair\n    /// @param oracleAddr address of the oracle\n    /// @param coinPair coin pair to unsubscribe, for example BTCUSD\n    function isSubscribed(address oracleAddr, bytes32 coinPair) external view returns (bool);\n\n    /// @notice Returns the amount of owners registered.\n    /// Delegates to the Oracle Manager smart contract.\n    function getRegisteredOraclesLen() external view returns (uint256);\n\n    /// @notice Returns the oracle name and address at index.\n    /// Delegates to the Oracle Manager smart contract.\n    /// @param idx index to query.\n    function getRegisteredOracleAtIndex(uint256 idx)\n        external\n        view\n        returns (\n            address ownerAddr,\n            address oracleAddr,\n            string memory url\n        );\n}\n\n\ncontract RegistryValues is RegistryConstants {\n    function _totalSupply(IRegistry registry) internal view returns (uint256) {\n        return _getToken(registry).totalSupply();\n    }\n\n    function _lockStake(\n        IRegistry registry,\n        address mocHolder,\n        uint256 untilTimestamp\n    ) internal {\n        _getStakingMachine(registry).lockMocs(mocHolder, untilTimestamp);\n    }\n\n    function _getLockedStake(IRegistry registry, address user) internal view returns (uint256) {\n        return _getStakingMachine(registry).getLockedBalance(user);\n    }\n\n    function _getStake(IRegistry registry, address user) internal view returns (uint256) {\n        return _getStakingMachine(registry).getBalance(user);\n    }\n\n    function _getToken(IRegistry registry) internal view returns (IERC20) {\n        return IERC20(registry.getAddress(MOC_TOKEN));\n    }\n\n    function _getStakingMachine(IRegistry registry) internal view returns (IStakingMachine) {\n        return IStakingMachine(registry.getAddress(MOC_STAKING_MACHINE));\n    }\n\n    function _getMinStake(IRegistry registry) internal view returns (uint256) {\n        return registry.getUint(MOC_VOTING_MACHINE_MIN_STAKE);\n    }\n\n    function _getPreVoteExpirationTimeDelta(IRegistry registry) internal view returns (uint256) {\n        uint256 ret = registry.getUint(MOC_VOTING_MACHINE_PRE_VOTE_EXPIRATION_TIME_DELTA);\n        require(ret > 0, \"Invalid preVoteExpirationTimeDelta\");\n        return ret;\n    }\n\n    function _getMaxPreProposals(IRegistry registry) internal view returns (uint256) {\n        uint256 ret = registry.getUint(MOC_VOTING_MACHINE_MAX_PRE_PROPOSALS);\n        require(ret > 0, \"Invalid maxPreProposals\");\n        return ret;\n    }\n\n    function _getPreVoteMinPCToWin(IRegistry registry) internal view returns (uint256) {\n        uint256 ret = registry.getUint(MOC_VOTING_MACHINE_PRE_VOTE_MIN_PCT_TO_WIN);\n        require(ret > 0, \"Invalid preVoteMinPCToWin\");\n        return ret;\n    }\n\n    function _getVoteMinPctToVeto(IRegistry registry) internal view returns (uint256) {\n        uint256 ret = registry.getUint(MOC_VOTING_MACHINE_VOTE_MIN_PCT_TO_VETO);\n        require(ret > 0, \"Invalid voteMinPctToVeto\");\n        return ret;\n    }\n\n    function _getVoteMinPctForQuorum(IRegistry registry) internal view returns (uint256) {\n        uint256 ret = registry.getUint(MOC_VOTING_MACHINE_VOTE_MIN_PCT_FOR_QUORUM);\n        require(ret > 0, \"Invalid voteMinPctForQuorum\");\n        return ret;\n    }\n\n    function _getVoteMinPctToAccept(IRegistry registry) internal view returns (uint256) {\n        uint256 ret = registry.getUint(MOC_VOTING_MACHINE_VOTE_MIN_PCT_TO_ACCEPT);\n        require(ret > 0, \"Invalid voteMinPctToAccept\");\n        return ret;\n    }\n\n    function _getPCTPrecision(IRegistry registry) internal view returns (uint256) {\n        uint256 ret = registry.getUint(MOC_VOTING_MACHINE_PCT_PRECISION);\n        require(ret >= 100, \"Invalid pctPrecision\");\n        return ret;\n    }\n\n    function _getVotingTimeDelta(IRegistry registry) internal view returns (uint256) {\n        uint256 ret = registry.getUint(MOC_VOTING_MACHINE_VOTING_TIME_DELTA);\n        require(ret > 0, \"Invalid votingTimeDelta\");\n        return ret;\n    }\n}\n\n\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n    /**\n      @notice Override this function with a recipe of the changes to be done when this ChangeContract\n      is executed\n     */\n    function execute() external;\n}\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor {\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @dev This function should be protected somehow to only execute changes that\n      benefit the system. This decision process is independent of this architechture\n      therefore is independent of this interface too\n      @param changeContract Address of the contract that will execute the changes\n     */\n    function executeChange(ChangeContract changeContract) external;\n\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @param _changer Address of the contract that will execute the changes\n     */\n    function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed {\n    /**\n      @notice The address of the contract which governs this one\n     */\n    IGovernor public governor;\n\n    string private constant NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n    /**\n      @notice Modifier that protects the function\n      @dev You should use this modifier in any function that should be called through\n      the governance system\n     */\n    modifier onlyAuthorizedChanger() {\n        require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n        _;\n    }\n\n    /**\n      @notice Initialize the contract with the basic settings\n      @dev This initialize replaces the constructor but it is not called automatically.\n      It is necessary because of the upgradeability of the contracts\n      @param _governor Governor address\n     */\n    function _initialize(IGovernor _governor) internal {\n        governor = _governor;\n    }\n\n    /**\n      @notice Change the contract's governor. Should be called through the old governance system\n      @param newIGovernor New governor address\n     */\n    function changeIGovernor(IGovernor newIGovernor) external onlyAuthorizedChanger {\n        governor = newIGovernor;\n    }\n\n    /**\n      @notice This method is used by a change contract to access the storage freely even without a setter.\n      @param data the serialized function arguments\n     */\n    function delegateCallToChanger(bytes calldata data)\n        external\n        onlyAuthorizedChanger\n        returns (bytes memory)\n    {\n        address changerContrat = msg.sender;\n        (bool success, bytes memory result) = changerContrat.delegatecall(\n            abi.encodeWithSignature(\"impersonate(bytes)\", data)\n        );\n        require(success, \"Error in delegate call\");\n        return result;\n    }\n\n    // Leave a gap betweeen inherited contracts variables in order to be\n    // able to add more variables in them later\n    uint256[50] private upgradeGap;\n}\n\n\ncontract VotingMachineStorage is Initializable, Governed, RegistryValues {\n    using SafeMath for uint256;\n    using PreVotingDataLib for PreVotingDataLib.PreVotingData;\n    using VotingDataLib for VotingDataLib.VotingData;\n\n    // Iterable list of proposals used during preVoting\n    enum VotingState {PreVoting, Voting, Accepted}\n\n    // Governor used to execute change contracts\n    IGovernor public controlledGovernor;\n\n    // Library configuration.\n    IRegistry public registry;\n\n    // Current voting round\n    // TODO: With uint8 is enough, can be packed with something else?\n    uint256 internal votingRound;\n\n    struct Vote {\n        address addr;\n        uint8 round;\n    }\n\n    // Votes\n    mapping(address => Vote) public votes;\n\n    // The contract state\n    VotingState internal votingState;\n    PreVotingDataLib.PreVotingData internal preVotingData;\n    VotingDataLib.VotingData internal votingData;\n\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    // solhint-disable-next-line no-empty-blocks\n    constructor() internal {}\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n\n\ninterface IVotingMachine {\n    /**\n        get current contract state\n        */\n    function getState() external view returns (uint256);\n\n    /**\n        return the current voting round\n        */\n    function getVotingRound() external view returns (uint256);\n\n    /**\n    Pre Vote a proposal\n\n    @param _proposal Address of the change contract that will be executed if this vote is successful\n    */\n    function preVote(address _proposal) external;\n\n    /**\n    Vote a proposal\n\n    @param _inFavorAgainst Type of vote\n    */\n    function vote(bool _inFavorAgainst) external;\n\n    /**\n    There is a veto Condition\n\n    */\n    function vetoCondition() external;\n\n    /**\n    Veto\n    */\n    function veto() external;\n\n    function readyToPreVoteStep() external view returns (bool);\n\n    /**\n    preVoteStep\n    */\n    function preVoteStep() external;\n\n    function readyToVoteStep() external view returns (bool);\n\n    /**\n    voteStep\n    */\n    function voteStep() external;\n\n    /**\n    vetoStep\n    */\n    function vetoStep() external;\n\n    /**\n    acceptedStep\n    */\n    function acceptedStep() external;\n\n    /**\n    Get the pre-voting registered proposal count.\n    */\n    function getProposalCount() external view returns (uint256);\n\n    /**\n    Get pre-voting proposal address and information by index\n\n    @param _index Index of proposal to query.\n    */\n    function getProposalByIndex(uint256 _index)\n        external\n        view\n        returns (\n            address proposalAddress,\n            uint256 proposalVotingRound,\n            uint256 proposalVotes,\n            uint256 proposalExpirationTimeStamp\n        );\n\n    /**\n    Get voting data\n    */\n    function getVotingData()\n        external\n        view\n        returns (\n            address winnerProposal,\n            uint256 inFavorVotes,\n            uint256 againstVotes,\n            uint256 votingExpirationTime\n        );\n\n    /**\n        Get user vote\n    */\n    function getUserVote(address user)\n        external\n        view\n        returns (address voteAddress, uint256 voteRound);\n\n    /**\n    will the call to unregister be successfull?\n\n    @param _proposal Address of the change contract that will be executed if this vote is successful\n    */\n    function canUnregister(address _proposal) external view returns (bool);\n\n    /**\n    Unregister a proposal, free the assets it uses.\n\n    @param _proposal Address of the change contract that will be executed if this vote is successful\n    */\n    function unregister(address _proposal) external;\n}\n\n\ncontract VotingMachine is VotingMachineStorage, IVotingMachine {\n    using SafeMath for uint256;\n\n    // Emitted by VotingLib\n    // event Vote(uint256 earnings, uint256 start, uint256 end);\n    event VoteEvent(\n        address indexed user,\n        address indexed subaccount,\n        address indexed destination,\n        uint256 amount,\n        uint256 mocs\n    );\n\n    modifier atState(VotingState _state) {\n        require(votingState == _state, \"Invalid state\");\n        _;\n    }\n\n    /**\n     @notice Contract creation\n\n     @param _governor The address of the contract which governs this one\n     @param _controlledGovernor The address of the governor that executes the change contracts\n    */\n    function initialize(\n        IGovernor _governor,\n        IGovernor _controlledGovernor,\n        IRegistry _registry\n    ) external initializer {\n        Governed._initialize(_governor);\n        votingState = VotingState.PreVoting;\n        registry = _registry;\n\n        votingRound = 1;\n        controlledGovernor = _controlledGovernor;\n        preVotingData._init();\n        votingData._init();\n    }\n\n    /**\n    get current contract state\n\n    */\n    function getState() external override view returns (uint256) {\n        return uint256(votingState);\n    }\n\n    /**\n        return the current voting round\n        */\n    function getVotingRound() external override view returns (uint256) {\n        return votingRound;\n    }\n\n    /**\n    Pre Vote\n\n    @param _changeContractAddress Address of the change contract that will be executed if this vote is successful\n    */\n    function preVote(address _changeContractAddress)\n        external\n        override\n        atState(VotingState.PreVoting)\n    {\n        require(_changeContractAddress != address(0), \"address must be != 0\");\n        (address winnerProposal, ) = _getWinnerProposal();\n        require(winnerProposal == address(0), \"There is a winner proposal\");\n\n        require(!preVotingData._isExpired(votingRound, _changeContractAddress), \"Proposal expired\");\n\n        uint256 stake = _getStake(registry, msg.sender);\n        Vote memory _vote = votes[msg.sender];\n        if (_alreadyVoted(_vote) && !preVotingData._isExpired(votingRound, _vote.addr)) {\n            // This is necessary to avoid storing the voting history.\n            require(_vote.addr == _changeContractAddress, \"Must vote the same proposal\");\n            uint256 locked = _getLockedStake(registry, msg.sender);\n            require(stake > locked, \"Not enough stake\");\n            stake = stake - locked;\n        }\n        // solhint-disable-next-line not-rely-on-time\n        _lockStake(registry, msg.sender, block.timestamp + _getVotingTimeDelta(registry));\n        votes[msg.sender] = Vote(_changeContractAddress, uint8(votingRound));\n\n        if (preVotingData._isEmptyProposal(votingRound, _changeContractAddress)) {\n            require(stake > _getMinStake(registry), \"Not enough stake\");\n            require(\n                preVotingData._upsert(\n                    votingRound,\n                    _getMaxPreProposals(registry),\n                    _getPreVoteExpirationTimeDelta(registry),\n                    _changeContractAddress,\n                    stake\n                ),\n                \"Not enough to add a proposal\"\n            );\n        } else {\n            require(\n                preVotingData._addVotes(votingRound, _changeContractAddress, stake),\n                \"Proposal expired\"\n            );\n        }\n    }\n\n    /**\n    Vote a proposal\n\n    @param _inFavorAgainst Type of vote\n    */\n    function vote(bool _inFavorAgainst) external override atState(VotingState.Voting) {\n        uint256 stake = _getStake(registry, msg.sender);\n        Vote memory _vote = votes[msg.sender];\n\n        // Those that voted something different than the winner proposal can use they whole stake\n        if (_alreadyVoted(_vote) && _vote.addr == votingData.winnerProposal) {\n            uint256 locked = _getLockedStake(registry, msg.sender);\n            require(stake > locked, \"Not enough stake\");\n            stake = stake - locked;\n        }\n        votes[msg.sender] = Vote(votingData.winnerProposal, uint8(votingRound));\n        votingData._addVotes(stake, _inFavorAgainst);\n    }\n\n    /**\n        Return vote info.\n    */\n    function getVoteInfo()\n        external\n        view\n        returns (\n            address winnerProposal,\n            uint256 inFavorVotes,\n            uint256 againstVotes\n        )\n    {\n        if (votingState != VotingState.Voting) {\n            return (address(0), 0, 0);\n        }\n        return (votingData.winnerProposal, votingData.inFavorVotes, votingData.againstVotes);\n    }\n\n    /**\n    Vote Condition\n    */\n    function vetoCondition() external override {}\n\n    /**\n    Veto\n    */\n    function veto() external override {}\n\n    function readyToPreVoteStep() external override view returns (bool) {\n        (address winnerProposal, ) = _getWinnerProposal();\n        return (winnerProposal != address(0));\n    }\n\n    /**\n    preVoteStep\n    */\n    function preVoteStep() external override atState(VotingState.PreVoting) {\n        (address winnerProposal, uint256 votesInFavor) = _getWinnerProposal();\n        require(winnerProposal != address(0), \"No winner proposal\");\n\n        votingState = VotingState.Voting;\n        // Expires all the pre-voting proposals.\n        votingData._startVoting(_getVotingTimeDelta(registry), winnerProposal, votesInFavor, 0);\n    }\n\n    function readyToVoteStep() external override view returns (bool) {\n        return (_isVeto() || _isAccepted() || votingData._isExpired());\n    }\n\n    /**\n    voteStep\n    */\n    function voteStep() external override atState(VotingState.Voting) {\n        if (_isVeto()) {\n            votingState = VotingState.PreVoting;\n            votingRound = votingRound + 1;\n        } else if (_isAccepted()) {\n            votingState = VotingState.Accepted;\n            votingRound = votingRound + 1;\n        } else if (votingData._isExpired()) {\n            votingState = VotingState.PreVoting;\n            votingRound = votingRound + 1;\n        }\n    }\n\n    /**\n    vetoStep\n    */\n    function vetoStep() external override {}\n\n    /**\n    acceptedStep\n    */\n    function acceptedStep() external override atState(VotingState.Accepted) {\n        {\n            // Try-catch and in any case change state to PreVoting.\n            try controlledGovernor.executeChange(ChangeContract(votingData.winnerProposal))  {\n                votingState = VotingState.PreVoting;\n            } catch Error(string memory) {\n                votingState = VotingState.PreVoting;\n            } catch (bytes memory) {\n                votingState = VotingState.PreVoting;\n            }\n        }\n    }\n\n    /**\n    will the call to unregister be successfull?\n\n    @param _changeContractAddress Address of the change contract that will be executed if this vote is successful\n    */\n    function canUnregister(address _changeContractAddress) external override view returns (bool) {\n        return (_changeContractAddress != address(0) &&\n            preVotingData._isEmptyProposal(votingRound, _changeContractAddress));\n    }\n\n    /**\n    Unregister a proposal, free the assets it uses.\n\n    @param _changeContractAddress Address of the change contract that will be executed if this vote is successful\n    */\n    function unregister(address _changeContractAddress) external override {\n        require(_changeContractAddress != address(0), \"address must be != 0\");\n        require(preVotingData._remove(votingRound, _changeContractAddress), \"Can't remove\");\n    }\n\n    /**\n    get the maximum total expiration time of a voting process.\n    */\n    function __totalExpirationTime() internal view returns (uint256) {\n        return _getPreVoteExpirationTimeDelta(registry) + _getVotingTimeDelta(registry);\n    }\n\n    /**\n    The used still didn't vote in this round\n    */\n    function _alreadyVoted(Vote memory _vote) internal view returns (bool) {\n        return (_vote.round == votingRound);\n    }\n\n    function _isAccepted() internal view returns (bool) {\n        return\n            votingData._isAccepted(\n                _getPCTPrecision(registry),\n                _getVoteMinPctToVeto(registry),\n                _getVoteMinPctForQuorum(registry),\n                _getVoteMinPctToAccept(registry),\n                _totalSupply(registry)\n            );\n    }\n\n    function _isVeto() internal view returns (bool) {\n        return\n            votingData._isVeto(\n                _getPCTPrecision(registry),\n                _getVoteMinPctToVeto(registry),\n                _totalSupply(registry)\n            );\n    }\n\n    function _getWinnerProposal() internal view returns (address candidate, uint256 maxVal) {\n        return\n            preVotingData._getWinnerProposal(\n                votingRound,\n                _getPreVoteMinPCToWin(registry),\n                _getPCTPrecision(registry),\n                _totalSupply(registry)\n            );\n    }\n\n    /**\n    Get the pre-voting registered proposal count.\n    */\n    function getProposalCount() external override view returns (uint256) {\n        return preVotingData._getProposalCount();\n    }\n\n    /**\n    Get pre-voting proposal address and information by index\n\n    @param _index Index of proposal to query. \n    */\n    function getProposalByIndex(uint256 _index)\n        external\n        override\n        view\n        returns (\n            address proposalAddress,\n            uint256 votingRound,\n            uint256 votes,\n            uint256 expirationTimeStamp\n        )\n    {\n        return preVotingData._getProposalByIndex(_index);\n    }\n\n    /**\n    Get voting data\n    */\n    function getVotingData()\n        external\n        override\n        view\n        returns (\n            address winnerProposal,\n            uint256 inFavorVotes,\n            uint256 againstVotes,\n            uint256 votingExpirationTime\n        )\n    {\n        return (\n            votingData.winnerProposal,\n            votingData.inFavorVotes,\n            votingData.againstVotes,\n            votingData.votingExpirationTime\n        );\n    }\n\n    /**\n        Get user vote\n    */\n    function getUserVote(address user)\n        external\n        override\n        view\n        returns (address voteAddress, uint256 voteRound)\n    {\n        Vote memory _vote = votes[user];\n        return (_vote.addr, _vote.round);\n    }\n}\n\n",
  "imports": [
    {
      "name": "VotingFlat.sol",
      "contents": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n\n\n\n/*\n    Abstract contract meant to be reused.\n    An iterable unique map of address -> proposals.\n*/\nlibrary ProposalInfoLib {\n    using SafeMath for uint256;\n\n    struct ProposalData {\n        // The round in which this proposal was proposed\n        uint256 votingRound;\n        // Accumulated votes in MOCs\n        uint256 votes;\n        // Expiration time\n        uint256 expirationTimestamp;\n    }\n\n    struct ProposalInfoData {\n        address[] proposalList;\n        mapping(address => ProposalData) proposals;\n    }\n\n    /**\n      ProposalInfoData data initializations\n    */\n    function _init() internal pure returns (ProposalInfoData memory) {\n        address[] memory emptyList;\n        return ProposalInfoData(emptyList);\n    }\n\n    /**\n    Add to the set, increasing its size\n\n    @param _key the key of the mapping\n    @param _data the value to assign\n    */\n    function _push(\n        ProposalInfoData storage self,\n        address _key,\n        ProposalData memory _data\n    ) internal {\n        require(!_contains(self, _key), \"Duplicated key\");\n        require(_data.votingRound != 0, \"Invalid votingRound value\");\n        self.proposals[_key] = _data;\n        self.proposalList.push(_key);\n    }\n\n    /**\n    Replace an element by index. After an iteration the resulting index can be use to replace an element\n\n    @param _idx the index in the list for the old element\n    @param _newKey the new key of the mapping\n    @param _data the new value to assign\n    */\n    function _replace(\n        ProposalInfoData storage self,\n        uint256 _idx,\n        address _newKey,\n        ProposalData memory _data\n    ) internal {\n        require(_idx < _length(self), \"Index out of range_replace\");\n        require(_data.votingRound != 0, \"Invalid votingRound value\");\n        delete self.proposals[self.proposalList[_idx]];\n        require(!_contains(self, _newKey), \"Duplicated key\");\n        self.proposalList[_idx] = _newKey;\n        self.proposals[_newKey] = _data;\n    }\n\n    /**\n    Replace an element by index address\n\n    @param _oldKey the kef of the old element\n    @param _newKey the new key of the mapping\n    @param _data the new value to assign\n    */\n    function _replace(\n        ProposalInfoData storage self,\n        address _oldKey,\n        address _newKey,\n        ProposalData memory _data\n    ) internal {\n        _replace(self, _find(self, _oldKey), _newKey, _data);\n    }\n\n    /**\n    Gets an element by index (used during iteration).\n\n    @param _idx the index used to get the element\n    */\n    function _get(ProposalInfoData storage self, uint256 _idx)\n        internal\n        view\n        returns (address, ProposalData memory)\n    {\n        require(_idx < _length(self), \"Index out of range_get\");\n        return (self.proposalList[_idx], self.proposals[self.proposalList[_idx]]);\n    }\n\n    /**\n    Gets an element by address.\n\n    @param _key the key used to get the element\n    */\n    function _get(ProposalInfoData storage self, address _key)\n        internal\n        view\n        returns (ProposalData memory)\n    {\n        require(_contains(self, _key), \"Key not found\");\n        return self.proposals[_key];\n    }\n\n    /**\n    Set a value by address.\n\n    @param _key the key used to set the element value\n    @param _data the new value to set\n    */\n    function _set(\n        ProposalInfoData storage self,\n        address _key,\n        ProposalData memory _data\n    ) internal {\n        require(_contains(self, _key), \"Invalid key\");\n        require(_data.votingRound != 0, \"Invalid votingRound value\");\n        self.proposals[_key] = _data;\n    }\n\n    /**\n    Set a value by index.\n\n    @param _idx the index of element to change\n    @param _data the new value to set\n    */\n    function _set(\n        ProposalInfoData storage self,\n        uint256 _idx,\n        ProposalData memory _data\n    ) internal {\n        require(_idx < _length(self), \"Index out of range_set\");\n        _set(self, self.proposalList[_idx], _data);\n    }\n\n    /**\n    Get the quantity of elements\n\n    */\n    function _length(ProposalInfoData storage self) internal view returns (uint256) {\n        return self.proposalList.length;\n    }\n\n    /**\n    Check if the map contains a specific address.\n\n    @param _key the address to check\n    */\n    function _contains(ProposalInfoData storage self, address _key) internal view returns (bool) {\n        return _key != address(0) && self.proposals[_key].votingRound != 0;\n    }\n\n    /**\n    Remove from the list by index (reducing its size)\n\n    @param _idx the index of the element to remove\n    */\n    function _remove(ProposalInfoData storage self, uint256 _idx) internal {\n        require(_idx < _length(self), \"Index out of range _remove\");\n        delete self.proposals[self.proposalList[_idx]];\n        self.proposalList[_idx] = self.proposalList[self.proposalList.length - 1];\n        self.proposalList.pop();\n    }\n\n    /**\n      Remove from the list by address (reducing its size).\n      This method does a linear search of the element, use with care\n\n      @param _key the key used to search the element to remove\n    */\n    function _remove(ProposalInfoData storage self, address _key) internal {\n        _remove(self, _find(self, _key));\n    }\n\n    /**\n      This method does a linear search of some key, use with care\n\n      @param _key the key to that is searched\n    */\n    function _find(ProposalInfoData storage self, address _key) internal view returns (uint256) {\n        require(_contains(self, _key), \"Key not found\");\n        for (uint256 i = 0; i < _length(self); i++) {\n            if (self.proposalList[i] == _key) {\n                return i;\n            }\n        }\n        require(false, \"Missing key?\");\n        return 0;\n    }\n}\n\n\n/*\n    Abstract contract meant to be reused.\n*/\nlibrary PreVotingDataLib {\n    using SafeMath for uint256;\n    using ProposalInfoLib for ProposalInfoLib.ProposalInfoData;\n\n    struct PreVotingData {\n        // Proposal Information\n        ProposalInfoLib.ProposalInfoData proposalInfo;\n    }\n\n    /**\n    PreVotingList data initializations\n    */\n    function _init(PreVotingData storage self) internal {\n        self.proposalInfo = ProposalInfoLib._init();\n    }\n\n    /**\n    The proposal was never voted or is new in this round\n\n    @param _proposalAddr Address of the change contract that will be executed if this vote is successful\n    */\n    function _isEmptyProposal(\n        PreVotingData storage self,\n        uint256 _votingRound,\n        address _proposalAddr\n    ) internal view returns (bool) {\n        if (!self.proposalInfo._contains(_proposalAddr)) {\n            return true;\n        }\n        ProposalInfoLib.ProposalData memory proposal = self.proposalInfo._get(_proposalAddr);\n        return __isReusableProposal(_votingRound, proposal);\n    }\n\n    /**\n    Insert or update a proposal. If the list is full then replace the one with less stake.\n\n    @param _proposalAddr address of the change contract\n    @param _stake stake used\n    */\n    function _upsert(\n        PreVotingData storage self,\n        uint256 _votingRound,\n        uint256 _maxPreProposals,\n        uint256 _preVoteExpirationTimeDelta,\n        address _proposalAddr,\n        uint256 _stake\n    ) internal returns (bool) {\n        // Reuse a proposal.\n        if (self.proposalInfo._contains(_proposalAddr)) {\n            ProposalInfoLib.ProposalData memory proposal = self.proposalInfo._get(_proposalAddr);\n            if (!__isReusableProposal(_votingRound, proposal)) {\n                // Can't reuse an active proposal\n                return false;\n            }\n\n            self.proposalInfo._set(\n                _proposalAddr,\n                __newProposal(_votingRound, _preVoteExpirationTimeDelta, _stake)\n            );\n            return true;\n        }\n\n        // Completely new proposal, there is a place in the list\n        if (self.proposalInfo._length() < _maxPreProposals) {\n            self.proposalInfo._push(\n                _proposalAddr,\n                __newProposal(_votingRound, _preVoteExpirationTimeDelta, _stake)\n            );\n            return true;\n        }\n\n        // Completely new proposal but there is no place in the list, must check if there are proposals to remove.\n        (uint256 minIdx, uint256 minVal) = __findAPlace(self, _votingRound);\n        if (_stake > minVal) {\n            self.proposalInfo._replace(\n                minIdx,\n                _proposalAddr,\n                __newProposal(_votingRound, _preVoteExpirationTimeDelta, _stake)\n            );\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     Add votes to a proposal\n\n     @param _proposalAddr address of the change contract\n     @param _stake stake used\n     */\n    function _addVotes(\n        PreVotingData storage self,\n        uint256 _votingRound,\n        address _proposalAddr,\n        uint256 _stake\n    ) internal returns (bool) {\n        if (!self.proposalInfo._contains(_proposalAddr)) {\n            return false;\n        }\n        ProposalInfoLib.ProposalData memory proposal = self.proposalInfo._get(_proposalAddr);\n        if (__isReusableProposal(_votingRound, proposal)) {\n            return false;\n        }\n        // We don't let them vote an expired proposal\n        if (__isExpired(proposal)) {\n            return false;\n        }\n        proposal.votes = _stake.add(proposal.votes);\n        self.proposalInfo._set(_proposalAddr, proposal);\n        return true;\n    }\n\n    /**\n      Remove from the pre-voting list an expired proposal\n\n      @param _proposalAddr address of the change contract\n    */\n    function _remove(\n        PreVotingData storage self,\n        uint256 _votingRound,\n        address _proposalAddr\n    ) internal returns (bool) {\n        if (!self.proposalInfo._contains(_proposalAddr)) {\n            return false;\n        }\n        ProposalInfoLib.ProposalData memory proposal = self.proposalInfo._get(_proposalAddr);\n        if (!__isReusableProposal(_votingRound, proposal)) {\n            return false;\n        }\n        self.proposalInfo._remove(_proposalAddr);\n        return true;\n    }\n\n    /**\n    Get a winner proposal.\n    Search the proposal with max pre-votes if it is expired then that proposal is the winner.\n    If two proposals has the same quantity of votes take the with older expiration time.\n    @param _preVoteMinPCToWin minimum percentage of vote needed to participate (moc votes/total moc in circulation).\n    @param _pctPrecision percentage precision.\n    @param _totalMOCSupply total supply of moc to calculate percentages.\n    */\n    function _getWinnerProposal(\n        PreVotingData storage self,\n        uint256 _votingRound,\n        uint256 _preVoteMinPCToWin,\n        uint256 _pctPrecision,\n        uint256 _totalMOCSupply\n    ) internal view returns (address candidateAddress, uint256 maxVal) {\n        address currentAddress;\n        ProposalInfoLib.ProposalData memory candidateProposal;\n        ProposalInfoLib.ProposalData memory currentProposal;\n        uint256 maxVotes = 0;\n\n        // Search the proposal (expired or not) with the max quantity of votes.\n        for (uint256 i = 0; i < self.proposalInfo._length(); i++) {\n            (currentAddress, currentProposal) = self.proposalInfo._get(i);\n\n            if (__isReusableProposal(_votingRound, currentProposal)) {\n                continue;\n            }\n\n            // Not enough votes to participate.\n            if (\n                currentProposal.votes.mul(_pctPrecision) < _totalMOCSupply.mul(_preVoteMinPCToWin)\n            ) {\n                continue;\n            }\n\n            if (\n                currentProposal.votes > maxVotes ||\n                (currentProposal.votes == maxVotes &&\n                    currentProposal.expirationTimestamp < candidateProposal.expirationTimestamp)\n            ) {\n                maxVotes = currentProposal.votes;\n                candidateAddress = currentAddress;\n                candidateProposal = currentProposal;\n            }\n        }\n\n        // if the candidate is expired we have a winner.\n        if (__isExpired(candidateProposal)) {\n            return (candidateAddress, candidateProposal.votes);\n        }\n        return (address(0), 0);\n    }\n\n    /**\n    Get the proposal count\n    */\n    function _getProposalCount(PreVotingData storage self) internal view returns (uint256) {\n        return self.proposalInfo._length();\n    }\n\n    /**\n    Get proposal address and information by index\n\n    @param _index Index of proposal to query. \n    */\n    function _getProposalByIndex(PreVotingData storage self, uint256 _index)\n        internal\n        view\n        returns (\n            address proposalAddress,\n            uint256 votingRound,\n            uint256 votes,\n            uint256 expirationTimeStamp\n        )\n    {\n        (address addr, ProposalInfoLib.ProposalData memory data) = self.proposalInfo._get(_index);\n        return (addr, data.votingRound, data.votes, data.expirationTimestamp);\n    }\n\n    /**\n    Check if a is valid.\n\n    @param _votes stake used\n    */\n    function __newProposal(\n        uint256 _votingRound,\n        uint256 _preVoteExpirationTimeDelta,\n        uint256 _votes\n    ) internal view returns (ProposalInfoLib.ProposalData memory) {\n        return\n            ProposalInfoLib.ProposalData({\n                votingRound: _votingRound,\n                votes: _votes, // solhint-disable-next-line not-rely-on-time\n                expirationTimestamp: block.timestamp + _preVoteExpirationTimeDelta\n            });\n    }\n\n    /**\n    Find a place in the list, at this point I'm sure that there is no winner proposal and that the list is\n    full (length > 1). We use the first  expired or reusable slot. If all the proposals are active then we\n    search for the one that has minimum votes.\n    */\n    function __findAPlace(PreVotingData storage self, uint256 _votingRound)\n        internal\n        view\n        returns (uint256 minIdx, uint256 minVal)\n    {\n        ProposalInfoLib.ProposalData memory proposal;\n        (, proposal) = self.proposalInfo._get(0);\n        if (__isReusableProposal(_votingRound, proposal) || __isExpired(proposal)) {\n            return (0, 0);\n        }\n\n        // The proposal in idx == 0 is not expired => is active.\n        (minIdx, minVal) = (0, proposal.votes);\n        for (uint256 i = 1; i < self.proposalInfo._length(); i++) {\n            (, proposal) = self.proposalInfo._get(i);\n            if (__isReusableProposal(_votingRound, proposal) || __isExpired(proposal)) {\n                return (i, 0);\n            }\n            // Not expired proposals, calculate the min and max\n            if (proposal.votes < minVal) {\n                (minIdx, minVal) = (i, proposal.votes);\n            }\n        }\n\n        // We only use an active proposal if there are no expired proposals or free slots.\n        return (minIdx, minVal);\n    }\n\n    function _isExpired(\n        PreVotingData storage self,\n        uint256 _votingRound,\n        address _proposalAddr\n    ) internal view returns (bool) {\n        if (!self.proposalInfo._contains(_proposalAddr)) {\n            return false;\n        }\n        ProposalInfoLib.ProposalData memory proposal = self.proposalInfo._get(_proposalAddr);\n        if (__isReusableProposal(_votingRound, proposal)) {\n            return false;\n        }\n        return __isExpired(proposal);\n    }\n\n    /**\n    The proposal was never voted or is new in this round\n\n    @param _proposal proposal data\n    */\n    function __isReusableProposal(\n        uint256 _votingRound,\n        ProposalInfoLib.ProposalData memory _proposal\n    ) internal pure returns (bool) {\n        return (_proposal.votingRound != _votingRound);\n    }\n\n    function __isExpired(ProposalInfoLib.ProposalData memory _proposal)\n        internal\n        view\n        returns (bool)\n    {\n        // solhint-disable-next-line not-rely-on-time\n        return (_proposal.expirationTimestamp < block.timestamp);\n    }\n}\n\n\n\n/*\n    Abstract contract meant to be reused.\n*/\nlibrary VotingDataLib {\n    using SafeMath for uint256;\n    using ProposalInfoLib for ProposalInfoLib.ProposalInfoData;\n\n    struct VotingData {\n        // Pre-voting winner proposal\n        address winnerProposal;\n        // Accumulated votes in MOCs\n        uint256 inFavorVotes;\n        // Accumulated votes in MOCs\n        uint256 againstVotes;\n        // voting process expiration time.\n        uint256 votingExpirationTime;\n    }\n\n    /**\n    Voting data initializations\n    */\n    function _init(VotingData storage self) internal {\n        self.winnerProposal = address(0);\n        self.inFavorVotes = 0;\n        self.againstVotes = 0;\n    }\n\n    /**\n     */\n    function _startVoting(\n        VotingData storage self,\n        uint256 _votingTimeDelta,\n        address _winnerProposal,\n        uint256 _inFavorVotes,\n        uint256 _againstVotes\n    ) internal {\n        self.winnerProposal = _winnerProposal;\n        self.inFavorVotes = _inFavorVotes;\n        self.againstVotes = _againstVotes;\n        // solhint-disable-next-line not-rely-on-time\n        self.votingExpirationTime = _votingTimeDelta + block.timestamp;\n    }\n\n    /**\n     */\n    function _addVotes(\n        VotingData storage self,\n        uint256 _stake,\n        bool _inFavorAgainst\n    ) internal {\n        if (_inFavorAgainst) {\n            self.inFavorVotes = self.inFavorVotes.add(_stake);\n        } else {\n            self.againstVotes = self.againstVotes.add(_stake);\n        }\n    }\n\n    /**\n     */\n    function _isVeto(\n        VotingData storage self,\n        uint256 _PCTPrecision,\n        uint256 _voteMinPctToVeto,\n        uint256 _totalMOC\n    ) internal view returns (bool) {\n        return (self.againstVotes.mul(_PCTPrecision) > _totalMOC.mul(_voteMinPctToVeto));\n    }\n\n    /**\n     */\n    function _isAccepted(\n        VotingData storage self,\n        uint256 _PCTPrecision,\n        uint256 _voteMinPctToVeto,\n        uint256 _voteMinPctForQuorum,\n        uint256 _voteMinPctToAccept,\n        uint256 _totalMOC\n    ) internal view returns (bool) {\n        uint256 inFavor = self.inFavorVotes.mul(_PCTPrecision);\n        // If the proposal is more than 70% of total mocs in circulation is accepted (can not be vetted anyway)\n        if ((inFavor >= _totalMOC.mul(_PCTPrecision.sub(_voteMinPctToVeto)))) {\n            return true;\n        }\n        // Still don't expired.\n        if (!_isExpired(self)) {\n            return false;\n        }\n        // Less than 20% of total mocs in circulation\n        if (inFavor < _totalMOC.mul(_voteMinPctForQuorum)) {\n            return false;\n        }\n        // After expiration in favor < 50% * (in favor + against)\n        if (inFavor < _voteMinPctToAccept.mul(self.againstVotes.add(self.inFavorVotes))) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     */\n    function _isExpired(VotingData storage self) internal view returns (bool) {\n        // solhint-disable-next-line not-rely-on-time\n        return (self.votingExpirationTime < block.timestamp);\n    }\n}\n\n\n\ninterface IRegistry {\n    // *** Getter Methods ***\n    function getDecimal(bytes32 _key) external view returns (int232 base, int16 exp);\n\n    function getUint(bytes32 _key) external view returns (uint248);\n\n    function getString(bytes32 _key) external view returns (string memory);\n\n    function getAddress(bytes32 _key) external view returns (address);\n\n    function getBytes(bytes32 _key) external view returns (bytes memory);\n\n    function getBool(bytes32 _key) external view returns (bool);\n\n    function getInt(bytes32 _key) external view returns (int248);\n\n    // *** Setter Methods ***\n    function setDecimal(\n        bytes32 _key,\n        int232 _base,\n        int16 _exp\n    ) external;\n\n    function setUint(bytes32 _key, uint248 _value) external;\n\n    function setString(bytes32 _key, string calldata _value) external;\n\n    function setAddress(bytes32 _key, address _value) external;\n\n    function setBytes(bytes32 _key, bytes calldata _value) external;\n\n    function setBool(bytes32 _key, bool _value) external;\n\n    function setInt(bytes32 _key, int248 _value) external;\n\n    // *** Delete Methods ***\n    function deleteDecimal(bytes32 _key) external;\n\n    function deleteUint(bytes32 _key) external;\n\n    function deleteString(bytes32 _key) external;\n\n    function deleteAddress(bytes32 _key) external;\n\n    function deleteBytes(bytes32 _key) external;\n\n    function deleteBool(bytes32 _key) external;\n\n    function deleteInt(bytes32 _key) external;\n}\n\n// Autogenerated by registryConstants.js\n\ncontract RegistryConstants {\n    // MOC_TOKEN = keccak256(moc.token)\n    bytes32\n        public constant MOC_TOKEN = 0x4bd5e7ff929fdd1ba62a33f76e0f40e97bb35e8bf126c0d9d91ce5c69a4bc521;\n\n    // MOC_DELAY_MACHINE = keccak256(moc.delay-machine)\n    bytes32\n        public constant MOC_DELAY_MACHINE = 0x66b60892ff6e7f0da16db27046f5960fdfd6bce5c3c8c21d56ccca3236a6281b;\n\n    // MOC_STAKING_MACHINE = keccak256(moc.staking-machine)\n    bytes32\n        public constant MOC_STAKING_MACHINE = 0x3c557531fea67120f21bc7711270a96f1b8cff3dfe3dd798a8a9f09ce9b77972;\n\n    // MOC_VESTING_MACHINE = keccak256(moc.vesting-machine)\n    bytes32\n        public constant MOC_VESTING_MACHINE = 0x7dfea4fb968e2599cdb7b3028c07d0188d0f92d1d00bd95c2805523c224649dd;\n\n    // MOC_VOTING_MACHINE = keccak256(moc.voting-machine)\n    bytes32\n        public constant MOC_VOTING_MACHINE = 0xc0ded27704f62d8726fdbd83648113d9fd8cf32c09f80523d2ba523e0bbd5ba4;\n\n    // MOC_UPGRADE_DELEGATOR = keccak256(moc.upgrade-delegator)\n    bytes32\n        public constant MOC_UPGRADE_DELEGATOR = 0x631bcbb9b033f9c8d13c32cf6e60827348d77b91b58c295e87745219242cca22;\n\n    // MOC_VOTING_MACHINE_MIN_STAKE = keccak256(moc.voting-machine.minStake)\n    bytes32\n        public constant MOC_VOTING_MACHINE_MIN_STAKE = 0x580be8e098dd1016787d59c2a534bf9df9ec679a29de4c8f92dc3807f7d7d54d;\n\n    // MOC_VOTING_MACHINE_PRE_VOTE_EXPIRATION_TIME_DELTA = keccak256(moc.voting-machine.preVoteExpirationTimeDelta)\n    bytes32\n        public constant MOC_VOTING_MACHINE_PRE_VOTE_EXPIRATION_TIME_DELTA = 0x62f5dbf0c17b0df83487409f747ad2eeca5fd54c140ca59b32cf39d6f6eaf916;\n\n    // MOC_VOTING_MACHINE_MAX_PRE_PROPOSALS = keccak256(moc.voting-machine.maxPreProposals)\n    bytes32\n        public constant MOC_VOTING_MACHINE_MAX_PRE_PROPOSALS = 0xc32b9cbc59039d297e670e7c196424308c90ba4a437fa7ccd008498c934e7dbf;\n\n    // MOC_VOTING_MACHINE_PRE_VOTE_MIN_PCT_TO_WIN = keccak256(moc.voting-machine.preVoteMinPCToWin)\n    bytes32\n        public constant MOC_VOTING_MACHINE_PRE_VOTE_MIN_PCT_TO_WIN = 0x0a1b21dfd7e4f3741529cf579e2731e847d81bbf13a82d0eba6910d7ac4c1c0a;\n\n    // MOC_VOTING_MACHINE_VOTE_MIN_PCT_TO_VETO = keccak256(moc.voting-machine.voteMinPctToVeto)\n    bytes32\n        public constant MOC_VOTING_MACHINE_VOTE_MIN_PCT_TO_VETO = 0xfb2d33acd65c36f68a15f8fe41cb8c0dd1eda164ffa87c6882e685ccb1c1adfb;\n\n    // MOC_VOTING_MACHINE_VOTE_MIN_PCT_FOR_QUORUM = keccak256(moc.voting-machine.voteMinPctForQuorum)\n    bytes32\n        public constant MOC_VOTING_MACHINE_VOTE_MIN_PCT_FOR_QUORUM = 0xde1ede48948567c43c504b761af8cd6af5363fafeceb1239b3083955d809714f;\n\n    // MOC_VOTING_MACHINE_VOTE_MIN_PCT_TO_ACCEPT = keccak256(moc.voting-machine.voteMinPctToAccept)\n    bytes32\n        public constant MOC_VOTING_MACHINE_VOTE_MIN_PCT_TO_ACCEPT = 0x99f83ee0c57b325f3deafb536d55596743ff112c6ac0d853d5f4f89b75dec045;\n\n    // MOC_VOTING_MACHINE_PCT_PRECISION = keccak256(moc.voting-machine.PCTPrecision)\n    bytes32\n        public constant MOC_VOTING_MACHINE_PCT_PRECISION = 0x73ee596441ef88c207a7a9147d62f59186b4991555e37b7ce9c801f9539d1050;\n\n    // MOC_VOTING_MACHINE_VOTING_TIME_DELTA = keccak256(moc.voting-machine.votingTimeDelta)\n    bytes32\n        public constant MOC_VOTING_MACHINE_VOTING_TIME_DELTA = 0xb43ee0a5ee6dcc7115ce824e4e353526ad6e479afa4daeb78451070de942de36;\n\n    // ORACLE_MANAGER_ADDR = keccak256(MOC_ORACLE\\1\\ORACLE_MANAGER_ADDR)\n    bytes32\n        public constant ORACLE_MANAGER_ADDR = 0x16986f74674f2ed21d50b6e74e6b12bb323ff4f72364542fd5de5104f3cc3ca9;\n\n    // SUPPORTERS_ADDR = keccak256(MOC_ORACLE\\1\\SUPPORTERS_ADDR)\n    bytes32\n        public constant SUPPORTERS_ADDR = 0xe4f979504d2a7a24557a15195eb83131e7c4a66d33900454705435aa5a6ee086;\n\n    // INFO_ADDR = keccak256(MOC_ORACLE\\1\\INFO_ADDR)\n    bytes32\n        public constant INFO_ADDR = 0xda9f12e01fc92de345bb741448d36ecb967052dd7aa1670439af833c9a3d78f1;\n\n    // ORACLE_PRICE_FETCH_RATE = keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_FETCH_RATE)\n    bytes32\n        public constant ORACLE_PRICE_FETCH_RATE = 0x945f72e5d44fb0ce3b1de393d19415723b79f97ad801089d8470d1c20e15ffef;\n\n    // ORACLE_BLOCKCHAIN_INFO_INTERVAL = keccak256(MOC_ORACLE\\1\\ORACLE_BLOCKCHAIN_INFO_INTERVAL)\n    bytes32\n        public constant ORACLE_BLOCKCHAIN_INFO_INTERVAL = 0x11cfbdf601b80a575e4366f0234cc06de0c9f401fe250dd9dccfccefeedb6fc2;\n\n    // ORACLE_COIN_PAIR_LOOP_TASK_INTERVAL = keccak256(MOC_ORACLE\\1\\ORACLE_COIN_PAIR_LOOP_TASK_INTERVAL)\n    bytes32\n        public constant ORACLE_COIN_PAIR_LOOP_TASK_INTERVAL = 0x2f271dc1fa81985bda14a2d6d0d60b45191d2a2d97e636b192696a8796d654a7;\n\n    // ORACLE_MAIN_LOOP_TASK_INTERVAL = keccak256(MOC_ORACLE\\1\\ORACLE_MAIN_LOOP_TASK_INTERVAL)\n    bytes32\n        public constant ORACLE_MAIN_LOOP_TASK_INTERVAL = 0x275d8a46b817572476d2d55b41c7709dee307740bad676a9693805003a48d231;\n\n    // ORACLE_PRICE_REJECT_DELTA_PCT = keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_REJECT_DELTA_PCT)\n    bytes32\n        public constant ORACLE_PRICE_REJECT_DELTA_PCT = 0x7a3ee46ca1bd3e19089870d8d6530b083a86da93aab52efccb32d5950e2709cf;\n\n    // ORACLE_CONFIGURATION_TASK_INTERVAL = keccak256(MOC_ORACLE\\1\\ORACLE_CONFIGURATION_TASK_INTERVAL)\n    bytes32\n        public constant ORACLE_CONFIGURATION_TASK_INTERVAL = 0xb027f2006a45346de89db4c5efc53f4e05e96532d27366aff00367a394d0abc4;\n\n    // ORACLE_GATHER_SIGNATURE_TIMEOUT = keccak256(MOC_ORACLE\\1\\ORACLE_GATHER_SIGNATURE_TIMEOUT)\n    bytes32\n        public constant ORACLE_GATHER_SIGNATURE_TIMEOUT = 0xf75b08b2b912abdbb87cc459ca0b4fdc019329386ec84ab68399b0c86fed5a95;\n\n    // ORACLE_MAIN_EXECUTOR_TASK_INTERVAL = keccak256(MOC_ORACLE\\1\\ORACLE_MAIN_EXECUTOR_TASK_INTERVAL)\n    bytes32\n        public constant ORACLE_MAIN_EXECUTOR_TASK_INTERVAL = 0xb324a91be1ac0d0c4888c835aee124ca1a7caf4b73ce10aa3504e2683865d7e5;\n\n    // SCHEDULER_POOL_DELAY = keccak256(MOC_ORACLE\\1\\SCHEDULER_POOL_DELAY)\n    bytes32\n        public constant SCHEDULER_POOL_DELAY = 0x6c2abc911c0fa4c73b90c7143a9f4429749be45ebfe7b81e69b86e7ca440d811;\n\n    // SCHEDULER_ROUND_DELAY = keccak256(MOC_ORACLE\\1\\SCHEDULER_ROUND_DELAY)\n    bytes32\n        public constant SCHEDULER_ROUND_DELAY = 0xa82bea7140872d1398fa0ab5075330ab0228f4c7e381b4b6502379ffc7cdcd9f;\n\n    // ORACLE_PRICE_DIGITS = keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_DIGITS)\n    bytes32\n        public constant ORACLE_PRICE_DIGITS = 0x4cd7e3f12ee4a2db0a6ba16e03fbc31bba1048c149bbf4fc9f3c02021ec550b8;\n\n    // ORACLE_QUEUE_LEN = keccak256(MOC_ORACLE\\1\\ORACLE_QUEUE_LEN)\n    bytes32\n        public constant ORACLE_QUEUE_LEN = 0x7d32d87d65898c3cbc7e72c59d223bf61c7811e99dafafd24fb08e0a38f10914;\n\n    // MESSAGE_VERSION = keccak256(MOC_ORACLE\\1\\MESSAGE_VERSION)\n    bytes32\n        public constant MESSAGE_VERSION = 0xeafac1a2b4d4fdcc942cbdce334a88ec83387087978d039f1320d3639a0b59df;\n\n    // ORACLE_STAKE_LIMIT_MULTIPLICATOR = keccak256(MOC_ORACLE\\1\\ORACLE_STAKE_LIMIT_MULTIPLICATOR)\n    bytes32\n        public constant ORACLE_STAKE_LIMIT_MULTIPLICATOR = 0xa1e0b5b458fe661fe687da135d3340a172e262c3cb31d646a4cb5cea9b6f1790;\n\n    // ORACLE_WITHDRAW_LOCK_TIME = keccak256(MOC_ORACLE\\1\\ORACLE_WITHDRAW_LOCK_TIME)\n    bytes32\n        public constant ORACLE_WITHDRAW_LOCK_TIME = 0x5e92c359b77ace8f4933558289f577781c0713b4ff91b2d2f76c8e523e560070;\n\n    // ORACLE_PRICE_DELTA_PCT = keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_DELTA_PCT)\n    bytes32\n        public constant ORACLE_PRICE_DELTA_PCT = 0x41a2ac05b365409628009a8091d8dda06fe52fe2f1c792e651e5df7599a7a7de;\n\n    // ORACLE_PRICE_PUBLISH_BLOCKS = keccak256(MOC_ORACLE\\1\\ORACLE_PRICE_PUBLISH_BLOCKS)\n    bytes32\n        public constant ORACLE_PRICE_PUBLISH_BLOCKS = 0x51a2be29a473202678b6cf57b717ba5d7ff671f01fdbdbfcad4e1882601b8896;\n\n    // ORACLE_ENTERING_FALLBACKS_AMOUNTS = keccak256(MOC_ORACLE\\1\\ORACLE_ENTERING_FALLBACKS_AMOUNTS)\n    bytes32\n        public constant ORACLE_ENTERING_FALLBACKS_AMOUNTS = 0xf646c455329c7af0436f9e95c59c90ce0e11bb4e3a1deff805807798696adf88;\n\n    // ORACLE_TRIGGER_VALID_PUBLICATION_BLOCKS = keccak256(MOC_ORACLE\\1\\ORACLE_TRIGGER_VALID_PUBLICATION_BLOCKS)\n    bytes32\n        public constant ORACLE_TRIGGER_VALID_PUBLICATION_BLOCKS = 0xef9006fe6663199909dfaa4ab45e3f86d6454adb7773682f356824b6b3bc6b0e;\n}\n\n\n\n\n\n/// @title This contract provides an interface for feeding prices from oracles, and\n///        get the current price. One contract must be instanced per supported coin pair,\n///        and registered through OracleManager global contract.\n/// This contract has two lists:\n/// 1) A subscribed list (EnumerableSet.AddressSet) oracles owner addresses, this list has a max size (30).\n/// 2) A selected list, EnumerableSet.AddressSet of oracles owner addresses that are selected to participate in\n/// current publication round (10 entries max size).\n///\n/// Oracles are subscribed by adding them to the subscribed oracle list. When the list is full\n/// the oracle with less stake can be removed by a new oracle that is trying to\n/// subscribe (if its stake is greater than his).\n/// On each round switch the list of selected oracles is populated with the 10 Oracles with more stake. An oracle\n/// can unsubscribe itself from the subscribed list in the middle of the round, in this case, the oracle is still\n/// listed in the selected list until the round ends.\n/// If an oracle withdraw some stake then his participation in the round is put into consideration: If the\n/// oracle ends up having less stake than the next oracle in the subscribed list (but not in the selected list) then\n/// it is removed from the selected list and the point he accumulated during the round are lost (set to zero).\n\ninterface ICoinPairPrice {\n    // getOracleOwnerAddress: Given an Oracle address return the Oracle Owner address.\n    // Used during publication, the servers sign with the oracle address, but the list of selected oracles\n    // is by oracle owner address.\n    // getOracleOwnerStake: Get the stake stored in the supporters smart-contract\n    // prettier-ignore\n    struct CoinPairPriceCallbacks {\n        function (address) external view returns (address) getOracleOwnerAddress;\n        function (address) external view returns (uint256) getOracleOwnerStake;\n    }\n\n    /// @notice subscribe an oracle to this coin pair, allowing it to be selected in the next round.\n    /// If the subscribed list is full and the current oracle has more stake than one with minimum stake in the\n    /// subscribed list, then the one with minimum stake is replaced.\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\n    /// @dev This is designed to be called from OracleManager.\n    function subscribe(address oracleOwnerAddr) external;\n\n    /// @notice Unsubscribe an oracle from this coin pair. The oracle won't be selected in the next round.\n    /// After the round end, the oracle can withdraw stake without having the risk of loosing won points.\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\n    /// @dev This is designed to be called from OracleManager.\n    function unsubscribe(address oracleOwnerAddr) external;\n\n    /// @notice Returns true if an oracle is subscribed to this contract' coin pair\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\n    /// @dev This is designed to be called from OracleManager.\n    function isSubscribed(address oracleOwnerAddr) external view returns (bool);\n\n    /// @notice Publish a price. (The message contain oracleAddresses that must be converted to owner addresses).\n    /// @param _version Version number of message format (3)\n    /// @param _coinpair The coin pair to report (must match this contract)\n    /// @param _price Price to report.\n    /// @param _votedOracle The address of the oracle voted as a publisher by the network.\n    /// @param _blockNumber The blocknumber acting as nonce to prevent replay attacks.\n    /// @param _sigV The array of V-component of Oracle signatures.\n    /// @param _sigR The array of R-component of Oracle signatures.\n    /// @param _sigS The array of S-component of Oracle signatures.\n    function publishPrice(\n        uint256 _version,\n        bytes32 _coinpair,\n        uint256 _price,\n        address _votedOracle,\n        uint256 _blockNumber,\n        uint8[] calldata _sigV,\n        bytes32[] calldata _sigR,\n        bytes32[] calldata _sigS\n    ) external;\n\n    /// @notice Publish a price without signature validation (when there is an emergecy!!!).\n    /// @param _price Price to report.\n    function emergencyPublish(uint256 _price) external;\n\n    /// @notice The oracle owner has withdrawn some stake.\n    /// Must check if the oracle is part of current round and if he lost his place with the\n    /// new stake value (the stake is global and is saved in the supporters contract).\n    /// @param oracleOwnerAddr the oracle owner that is trying to withdraw\n    function onWithdraw(address oracleOwnerAddr) external returns (uint256);\n\n    /// @notice Switch contract context to a new round. With the objective of\n    /// being a decentralized solution, this can be called by *anyone* if current\n    /// round lock period is expired.\n    /// This method search the subscribed list and choose the 10 with more stake.\n    function switchRound() external;\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS\n\n    /// @notice Return the available reward fees\n    ///\n    function getAvailableRewardFees() external view returns (uint256);\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS TO GET CURRENT PRICE\n    // MUST BE WHITELISTED\n    /// @notice Return the current price, compatible with old MOC Oracle\n    function peek() external view returns (bytes32, bool);\n\n    /// @notice Return the current price\n    function getPrice() external view returns (uint256);\n\n    ///////////////////////////////////////////////////////////////////////////////// GETTERS TO GET CURRENT PRICE END\n\n    /// @notice Return current round information\n    function getRoundInfo()\n        external\n        view\n        returns (\n            uint256 round,\n            uint256 startBlock,\n            uint256 lockPeriodTimestamp,\n            uint256 totalPoints,\n            address[] memory selectedOwners,\n            address[] memory selectedOracles\n        );\n\n    /// @notice Return round information for specific oracle\n    function getOracleRoundInfo(address addr)\n        external\n        view\n        returns (uint256 points, bool selectedInCurrentRound);\n\n    // The maximum count of oracles selected to participate each round\n    function maxOraclesPerRound() external view returns (uint256);\n\n    // The round lock period in secs\n    function roundLockPeriodSecs() external view returns (uint256);\n\n    function isOracleInCurrentRound(address oracleAddr) external view returns (bool);\n\n    /// @notice Returns the amount of oracles subscribed to this coin pair.\n    function getSubscribedOraclesLen() external view returns (uint256);\n\n    /// @notice Returns the oracle owner address that is subscribed to this coin pair\n    /// @param idx index to query.\n    function getSubscribedOracleAtIndex(uint256 idx) external view returns (address ownerAddr);\n\n    // Public variable\n    function getMaxSubscribedOraclesPerRound() external view returns (uint256);\n\n    // Public variable\n    function getCoinPair() external view returns (bytes32);\n\n    // Public variable\n    function getLastPublicationBlock() external view returns (uint256);\n\n    // Public variable\n    function getValidPricePeriodInBlocks() external view returns (uint256);\n\n    // Public variable\n    function getEmergencyPublishingPeriodInBlocks() external view returns (uint256);\n\n    // Public variable\n    function getOracleManager() external view returns (IOracleManager);\n\n    // Public variable\n    function getToken() external view returns (IERC20);\n}\n\n\n/// This contract manages the Oracle and CoinPair registration info.\n/// The Oracle python server interacts with this contract:\n/// - Coin pair registration\n/// - Oracle registration to coin pairs\n/// - Access Oracle info (oracle address + url) indexed by oracle owner address\n/// - Get the oracle information (url + the specifics of some coin pair rounds) from an oracle address\n/// - Get the oracle address from the owner address.\ninterface IOracleManager {\n    // getOracleOwnerStake: Get the stake stored in the supporters smart-contract\n    // prettier-ignore\n    struct OracleManagerCallbacks {\n        function (address) external view returns (uint256) getOracleOwnerStake;\n    }\n\n    /// @notice Register a new coin pair contract (the contract must be created separately).\n    /// Once created the coin pairs cannot be removed.\n    /// @param coinPair The bytes32-encoded coinpair string (e.g. BTCUSD)\n    /// @param addr The contract address associated to the coin pair.\n    function registerCoinPair(bytes32 coinPair, address addr) external;\n\n    /// Register an oracle in the system must be called by the oracle owner.\n    /// @notice Registers the oracle and transfer the specified caller's MOC token stake.\n    /// @param oracleOwnerAddr The address of the owner of the oracle.\n    /// @param oracleAddr Address of the Oracle to register.\n    /// @param internetName Public Internet name of this Oracle.\n    function registerOracle(\n        address oracleOwnerAddr,\n        address oracleAddr,\n        string calldata internetName\n    ) external;\n\n    /// @notice Change the oracle \"internet\" name (URI), called by the owner.\n    /// @param oracleOwnerAddr The address of the owner of the oracle.\n    /// @param name The new name to set.\n    function setOracleName(address oracleOwnerAddr, string calldata name) external;\n\n    /// @notice Change the oracle address, called by the owner.\n    /// @param oracleOwnerAddr The address of the owner of the oracle.\n    /// @param oracleAddr new value for the address of the oracle\n    function setOracleAddress(address oracleOwnerAddr, address oracleAddr) external;\n\n    /// @notice Removes the oracle registration info. Must be called by the owner\n    /// The oracle must be previously unregistered from all coin pairs.\n    /// @param oracleOwnerAddr The address of the owner of the oracle to remove from system.\n    function removeOracle(address oracleOwnerAddr) external;\n\n    /// @notice Subscribe a registered oracle to participate in the next round of a registered coin-pair.\n    /// @param oracleOwnerAddr Address of oracle owner\n    function subscribeToCoinPair(address oracleOwnerAddr, bytes32 coinPair) external;\n\n    /// @notice Unsubscribe a registered oracle from participating in rounds of a registered coin-pair.\n    /// The oracle is flagged so it is not selected in the next round.\n    /// @param oracleOwnerAddr Address of oracle owner\n    function unSubscribeFromCoinPair(address oracleOwnerAddr, bytes32 coinPair) external;\n\n    /// @notice The oracle owner did a partial withdrawal of funds\n    /// 1. The oracle address is searched by the owner address.\n    /// 2. Each coin pair to which the oracle is subscribed is consulted to:\n    ///   - Check if the new amount is enough to stay in the current round.\n    ///       If not the oracle is replaced and lost his points.\n    ///   - Get the timestamp for the round end.\n    /// The return value is the maximum timestamp from all the coin pairs.\n    /// @param oracleOwnerAddr Address of oracle owner\n    /// @return the timestamp until which the funds must be locked.\n    function onWithdraw(address oracleOwnerAddr) external returns (uint256);\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS USED BY COINPAIR\n    /// @notice Used by the coin pair to get the oracle address from the oracleOwnerAddress.\n    /// @param  oracleOwnerAddr the address of the owner of the oracle.\n    /// @return oracleAddr Address of oracle\n    function getOracleAddress(address oracleOwnerAddr) external view returns (address oracleAddr);\n\n    /// @notice Returns true if oracle is registered.\n    /// @param ownerAddr The address of the oracle's owner.\n    function isRegistered(address ownerAddr) external view returns (bool);\n\n    /// @notice Used by CoinPair\n    /// @param oracleAddr The oracle address not the owner address.\n    function getOracleOwner(address oracleAddr) external view returns (address);\n\n    /// @notice Returns the amount of owners registered.\n    function getRegisteredOraclesLen() external view returns (uint256);\n\n    /// @notice Returns the oracle name and address at index.\n    /// @param idx index to query.\n    function getRegisteredOracleAtIndex(uint256 idx)\n        external\n        view\n        returns (\n            address ownerAddr,\n            address oracleAddr,\n            string memory url\n        );\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS USED BY COINPAIR END\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTERS\n\n    // TODO: Check what is the minimum amount of getters the python server needs.\n\n    /// @notice Returns true if an oracle is subscribed to a coin pair\n    function isSubscribed(address oracleAddr, bytes32 coinPair) external view returns (bool);\n\n    /// @notice Return true if the oracle is registered on this coin-pair\n    /// @param oracleAddr addr The address of the Oracle check for.\n    function isOracleRegistered(address oracleAddr) external view returns (bool);\n\n    /// @notice Returns registration information for a registered Oracle.\n    /// @param oracleAddr addr The address of the Oracle to query for.\n    function getOracleRegistrationInfo(address oracleAddr)\n        external\n        view\n        returns (\n            string memory internetName,\n            uint256 stake,\n            address _owner\n        );\n\n    /// @notice Returns round information for a registered oracle in a specific coin-pair.\n    /// @param oracleAddr address of the oracle to query for.\n    /// @param coinpair The coin pair to lookup.\n    function getOracleRoundInfo(address oracleAddr, bytes32 coinpair)\n        external\n        view\n        returns (uint256 points, bool selectedInCurrentRound);\n\n    /// @notice Returns true if an oracle satisfies conditions to be removed from system.\n    /// @param oracleAddr the oracle address to lookup.\n    function canRemoveOracle(address oracleAddr) external view returns (bool);\n\n    /// @notice Get the stake in MOCs that an oracle has.\n    /// @param oracleAddr The address of the oracle.\n    function getStake(address oracleAddr) external view returns (uint256 balance);\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTER TO LIST COIN PAIRS\n\n    /// @notice Returns the count of registered coin pairs.\n    /// Keep in mind that Deleted coin-pairs will contain zeroed addresses.\n    function getCoinPairCount() external view returns (uint256);\n\n    /// @notice Returns the coin pair at index.\n    /// @param i index to query.\n    function getCoinPairAtIndex(uint256 i) external view returns (bytes32);\n\n    /// @notice Return the contract address for a specified registered coin pair.\n    /// @param coinpair Coin-pair string to lookup (e.g: BTCUSD)\n    /// @return address Address of contract or zero if does not exist or was deleted.\n    function getContractAddress(bytes32 coinpair) external view returns (address);\n\n    /// @notice Searches a coinpair in coinPairList\n    /// @param coinPair The bytes32-encoded coinpair string (e.g. BTCUSD)\n    /// @param hint Optional hint to start traversing the coinPairList array, zero is to search all the array.\n    function getCoinPairIndex(bytes32 coinPair, uint256 hint) external view returns (uint256);\n\n    function getMaxStake(address[] calldata addresses) external view returns (address, uint256);\n\n    //////////////////////////////////////////////////////////////////////////////////// GETTER TO LIST COIN PAIRS END\n\n    // Public variable\n    function getStakingContract() external view returns (IStakingMachine);\n\n    // Public variable\n    function getMinCPSubscriptionStake() external view returns (uint256);\n}\n\n\n\ninterface IDelayMachine {\n    /// @notice Accept a deposit from an account.\n    /// @param mocs token quantity\n    /// @param expiration the expiration date for this deposit\n    /// @return id the transaction id\n    function deposit(\n        uint256 mocs,\n        address destination,\n        uint256 expiration\n    ) external returns (uint256 id);\n\n    /// @notice Cancel a transaction returning the funds to the source\n    /// @param id transaction id\n    function cancel(uint256 id) external;\n\n    /// @notice Withdraw stake, send it to the delay machine.\n    /// @param id transaction id\n    function withdraw(uint256 id) external;\n\n    /// @notice Returns the list of transaction for some account\n    /// @return ids transaction ids\n    /// @return amounts token quantity\n    /// @return expirations expiration dates\n    function getTransactions(address account)\n        external\n        view\n        returns (\n            uint256[] memory ids,\n            uint256[] memory amounts,\n            uint256[] memory expirations\n        );\n\n    /// @notice Returns the total balance in MOCs for an account\n    function getBalance(address account) external view returns (uint256);\n\n    // Public variable\n    function getToken() external view returns (IERC20);\n\n    // Public variable\n    function getLastId() external view returns (uint256);\n\n    // Public variable\n    function getSource() external view returns (address);\n}\n\n\ninterface IStakingMachine {\n    /// @notice Used by the voting machine to lock the current balance of MOCs.\n    /// @param mocHolder the moc holder whose mocs will be locked.\n    /// @param untilTimestamp timestamp until which the mocs will be locked.\n    function lockMocs(address mocHolder, uint256 untilTimestamp) external;\n\n    /// @notice Accept a deposit from an account.\n    /// Delegate to the Supporters smart contract.\n    /// @param mocs token quantity\n    /// @param destination the destination account of this deposit.\n    function deposit(uint256 mocs, address destination) external;\n\n    /// @notice Accept a deposit from an account.\n    /// @param mocs token quantity\n    /// @param destination the destination account of this deposit.\n    /// @param source the address that approved the transfer\n    function depositFrom(\n        uint256 mocs,\n        address destination,\n        address source\n    ) external;\n\n    /// @notice Withdraw stake, send it to the delay machine.\n    /// @param mocs token quantity\n    function withdraw(uint256 mocs) external;\n\n    /// @notice Reports the balance of MOCs for a specific user.\n    /// @param user user address\n    function getBalance(address user) external view returns (uint256);\n\n    /// @notice Reports the locked balance of MOCs for a specific user.\n    /// @param user user address\n    function getLockedBalance(address user) external view returns (uint256);\n\n    /// @notice Reports the balance of locked MOCs for a specific user.\n    /// Delegates to the Supporters smart contract.\n    /// @param user user address\n    /// @return amount the amount of mocs locked\n    /// @return untilTimestamp the timestamp that corresponds to the locking date.\n    function getLockingInfo(address user)\n        external\n        view\n        returns (uint256 amount, uint256 untilTimestamp);\n\n    // Public variable\n    function getSupporters() external view returns (address);\n\n    // Public variable\n    function getOracleManager() external view returns (IOracleManager);\n\n    // Public variable\n    function getMocToken() external view returns (IERC20);\n\n    // Public variable\n    function getDelayMachine() external view returns (IDelayMachine);\n\n    // Public variable\n    function getWithdrawLockTime() external view returns (uint256);\n}\n\ninterface IStakingMachineOracles {\n    /// @notice Register an oracle\n    /// @param oracleAddr address of the oracle (from which we publish prices)\n    /// @param url url used by the oracle server\n    function registerOracle(address oracleAddr, string calldata url) external;\n\n    /// @notice Change the oracle \"internet\" name (URI)\n    /// @param url The new url to set.\n    function setOracleName(string calldata url) external;\n\n    /// @notice Change the oracle address\n    /// @param oracleAddr The new oracle address\n    function setOracleAddress(address oracleAddr) external;\n\n    /// @notice Return true if the oracle is registered.\n    /// @param oracleAddr addr The address of the Oracle check for.\n    function isOracleRegistered(address oracleAddr) external view returns (bool);\n\n    /// @notice Returns true if an oracle satisfies conditions to be removed from system.\n    /// @param oracleAddr the oracle address to lookup.\n    function canRemoveOracle(address oracleAddr) external view returns (bool);\n\n    /// @notice Remove an oracle.\n    function removeOracle() external;\n\n    /// @notice Returns the count of registered coin pairs.\n    /// Keep in mind that Deleted coin-pairs will contain zeroed addresses.\n    function getCoinPairCount() external view returns (uint256);\n\n    /// @notice Returns the coin pair at index.\n    /// @param i index to query.\n    function getCoinPairAtIndex(uint256 i) external view returns (bytes32);\n\n    /// @notice Return the contract address for a specified registered coin pair.\n    /// @param coinpair Coin-pair string to lookup (e.g: BTCUSD)\n    /// @return address Address of contract or zero if does not exist or was deleted.\n    function getContractAddress(bytes32 coinpair) external view returns (address);\n\n    /// @notice Searches a coinpair in coinPairList\n    /// @param coinPair The bytes32-encoded coinpair string (e.g. BTCUSD)\n    /// @param hint Optional hint to start traversing the coinPairList array, zero is to search all the array.\n    function getCoinPairIndex(bytes32 coinPair, uint256 hint) external view returns (uint256);\n\n    /// @notice Subscribe an oracle to a coin pair.\n    /// @param coinPair coin pair to subscribe, for example BTCUSD\n    function subscribeToCoinPair(bytes32 coinPair) external;\n\n    /// @notice Unsubscribe an oracle from a coin pair.\n    /// @param coinPair coin pair to unsubscribe, for example BTCUSD\n    function unSubscribeFromCoinPair(bytes32 coinPair) external;\n\n    /// @notice Returns true if an oracle is subscribed to a coin pair\n    /// @param oracleAddr address of the oracle\n    /// @param coinPair coin pair to unsubscribe, for example BTCUSD\n    function isSubscribed(address oracleAddr, bytes32 coinPair) external view returns (bool);\n\n    /// @notice Returns the amount of owners registered.\n    /// Delegates to the Oracle Manager smart contract.\n    function getRegisteredOraclesLen() external view returns (uint256);\n\n    /// @notice Returns the oracle name and address at index.\n    /// Delegates to the Oracle Manager smart contract.\n    /// @param idx index to query.\n    function getRegisteredOracleAtIndex(uint256 idx)\n        external\n        view\n        returns (\n            address ownerAddr,\n            address oracleAddr,\n            string memory url\n        );\n}\n\n\ncontract RegistryValues is RegistryConstants {\n    function _totalSupply(IRegistry registry) internal view returns (uint256) {\n        return _getToken(registry).totalSupply();\n    }\n\n    function _lockStake(\n        IRegistry registry,\n        address mocHolder,\n        uint256 untilTimestamp\n    ) internal {\n        _getStakingMachine(registry).lockMocs(mocHolder, untilTimestamp);\n    }\n\n    function _getLockedStake(IRegistry registry, address user) internal view returns (uint256) {\n        return _getStakingMachine(registry).getLockedBalance(user);\n    }\n\n    function _getStake(IRegistry registry, address user) internal view returns (uint256) {\n        return _getStakingMachine(registry).getBalance(user);\n    }\n\n    function _getToken(IRegistry registry) internal view returns (IERC20) {\n        return IERC20(registry.getAddress(MOC_TOKEN));\n    }\n\n    function _getStakingMachine(IRegistry registry) internal view returns (IStakingMachine) {\n        return IStakingMachine(registry.getAddress(MOC_STAKING_MACHINE));\n    }\n\n    function _getMinStake(IRegistry registry) internal view returns (uint256) {\n        return registry.getUint(MOC_VOTING_MACHINE_MIN_STAKE);\n    }\n\n    function _getPreVoteExpirationTimeDelta(IRegistry registry) internal view returns (uint256) {\n        uint256 ret = registry.getUint(MOC_VOTING_MACHINE_PRE_VOTE_EXPIRATION_TIME_DELTA);\n        require(ret > 0, \"Invalid preVoteExpirationTimeDelta\");\n        return ret;\n    }\n\n    function _getMaxPreProposals(IRegistry registry) internal view returns (uint256) {\n        uint256 ret = registry.getUint(MOC_VOTING_MACHINE_MAX_PRE_PROPOSALS);\n        require(ret > 0, \"Invalid maxPreProposals\");\n        return ret;\n    }\n\n    function _getPreVoteMinPCToWin(IRegistry registry) internal view returns (uint256) {\n        uint256 ret = registry.getUint(MOC_VOTING_MACHINE_PRE_VOTE_MIN_PCT_TO_WIN);\n        require(ret > 0, \"Invalid preVoteMinPCToWin\");\n        return ret;\n    }\n\n    function _getVoteMinPctToVeto(IRegistry registry) internal view returns (uint256) {\n        uint256 ret = registry.getUint(MOC_VOTING_MACHINE_VOTE_MIN_PCT_TO_VETO);\n        require(ret > 0, \"Invalid voteMinPctToVeto\");\n        return ret;\n    }\n\n    function _getVoteMinPctForQuorum(IRegistry registry) internal view returns (uint256) {\n        uint256 ret = registry.getUint(MOC_VOTING_MACHINE_VOTE_MIN_PCT_FOR_QUORUM);\n        require(ret > 0, \"Invalid voteMinPctForQuorum\");\n        return ret;\n    }\n\n    function _getVoteMinPctToAccept(IRegistry registry) internal view returns (uint256) {\n        uint256 ret = registry.getUint(MOC_VOTING_MACHINE_VOTE_MIN_PCT_TO_ACCEPT);\n        require(ret > 0, \"Invalid voteMinPctToAccept\");\n        return ret;\n    }\n\n    function _getPCTPrecision(IRegistry registry) internal view returns (uint256) {\n        uint256 ret = registry.getUint(MOC_VOTING_MACHINE_PCT_PRECISION);\n        require(ret >= 100, \"Invalid pctPrecision\");\n        return ret;\n    }\n\n    function _getVotingTimeDelta(IRegistry registry) internal view returns (uint256) {\n        uint256 ret = registry.getUint(MOC_VOTING_MACHINE_VOTING_TIME_DELTA);\n        require(ret > 0, \"Invalid votingTimeDelta\");\n        return ret;\n    }\n}\n\n\n\n/**\n  @title ChangeContract\n  @notice This interface is the one used by the governance system.\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\n  system is fully in place.\n */\ninterface ChangeContract {\n    /**\n      @notice Override this function with a recipe of the changes to be done when this ChangeContract\n      is executed\n     */\n    function execute() external;\n}\n\n\n/**\n  @title Governor\n  @notice Governor interface. This functions should be overwritten to\n  enable the comunnication with the rest of the system\n  */\ninterface IGovernor {\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @dev This function should be protected somehow to only execute changes that\n      benefit the system. This decision process is independent of this architechture\n      therefore is independent of this interface too\n      @param changeContract Address of the contract that will execute the changes\n     */\n    function executeChange(ChangeContract changeContract) external;\n\n    /**\n      @notice Function to be called to make the changes in changeContract\n      @param _changer Address of the contract that will execute the changes\n     */\n    function isAuthorizedChanger(address _changer) external view returns (bool);\n}\n\n\n\n/**\n  @title Governed\n  @notice Base contract to be inherited by governed contracts\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behaviour\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\n  governance aspect of the child contract\n  */\ncontract Governed {\n    /**\n      @notice The address of the contract which governs this one\n     */\n    IGovernor public governor;\n\n    string private constant NOT_AUTHORIZED_CHANGER = \"not_authorized_changer\";\n\n    /**\n      @notice Modifier that protects the function\n      @dev You should use this modifier in any function that should be called through\n      the governance system\n     */\n    modifier onlyAuthorizedChanger() {\n        require(governor.isAuthorizedChanger(msg.sender), NOT_AUTHORIZED_CHANGER);\n        _;\n    }\n\n    /**\n      @notice Initialize the contract with the basic settings\n      @dev This initialize replaces the constructor but it is not called automatically.\n      It is necessary because of the upgradeability of the contracts\n      @param _governor Governor address\n     */\n    function _initialize(IGovernor _governor) internal {\n        governor = _governor;\n    }\n\n    /**\n      @notice Change the contract's governor. Should be called through the old governance system\n      @param newIGovernor New governor address\n     */\n    function changeIGovernor(IGovernor newIGovernor) external onlyAuthorizedChanger {\n        governor = newIGovernor;\n    }\n\n    /**\n      @notice This method is used by a change contract to access the storage freely even without a setter.\n      @param data the serialized function arguments\n     */\n    function delegateCallToChanger(bytes calldata data)\n        external\n        onlyAuthorizedChanger\n        returns (bytes memory)\n    {\n        address changerContrat = msg.sender;\n        (bool success, bytes memory result) = changerContrat.delegatecall(\n            abi.encodeWithSignature(\"impersonate(bytes)\", data)\n        );\n        require(success, \"Error in delegate call\");\n        return result;\n    }\n\n    // Leave a gap betweeen inherited contracts variables in order to be\n    // able to add more variables in them later\n    uint256[50] private upgradeGap;\n}\n\n\ncontract VotingMachineStorage is Initializable, Governed, RegistryValues {\n    using SafeMath for uint256;\n    using PreVotingDataLib for PreVotingDataLib.PreVotingData;\n    using VotingDataLib for VotingDataLib.VotingData;\n\n    // Iterable list of proposals used during preVoting\n    enum VotingState {PreVoting, Voting, Accepted}\n\n    // Governor used to execute change contracts\n    IGovernor public controlledGovernor;\n\n    // Library configuration.\n    IRegistry public registry;\n\n    // Current voting round\n    // TODO: With uint8 is enough, can be packed with something else?\n    uint256 internal votingRound;\n\n    struct Vote {\n        address addr;\n        uint8 round;\n    }\n\n    // Votes\n    mapping(address => Vote) public votes;\n\n    // The contract state\n    VotingState internal votingState;\n    PreVotingDataLib.PreVotingData internal preVotingData;\n    VotingDataLib.VotingData internal votingData;\n\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    // solhint-disable-next-line no-empty-blocks\n    constructor() internal {}\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n\n\ninterface IVotingMachine {\n    /**\n        get current contract state\n        */\n    function getState() external view returns (uint256);\n\n    /**\n        return the current voting round\n        */\n    function getVotingRound() external view returns (uint256);\n\n    /**\n    Pre Vote a proposal\n\n    @param _proposal Address of the change contract that will be executed if this vote is successful\n    */\n    function preVote(address _proposal) external;\n\n    /**\n    Vote a proposal\n\n    @param _inFavorAgainst Type of vote\n    */\n    function vote(bool _inFavorAgainst) external;\n\n    /**\n    There is a veto Condition\n\n    */\n    function vetoCondition() external;\n\n    /**\n    Veto\n    */\n    function veto() external;\n\n    function readyToPreVoteStep() external view returns (bool);\n\n    /**\n    preVoteStep\n    */\n    function preVoteStep() external;\n\n    function readyToVoteStep() external view returns (bool);\n\n    /**\n    voteStep\n    */\n    function voteStep() external;\n\n    /**\n    vetoStep\n    */\n    function vetoStep() external;\n\n    /**\n    acceptedStep\n    */\n    function acceptedStep() external;\n\n    /**\n    Get the pre-voting registered proposal count.\n    */\n    function getProposalCount() external view returns (uint256);\n\n    /**\n    Get pre-voting proposal address and information by index\n\n    @param _index Index of proposal to query.\n    */\n    function getProposalByIndex(uint256 _index)\n        external\n        view\n        returns (\n            address proposalAddress,\n            uint256 proposalVotingRound,\n            uint256 proposalVotes,\n            uint256 proposalExpirationTimeStamp\n        );\n\n    /**\n    Get voting data\n    */\n    function getVotingData()\n        external\n        view\n        returns (\n            address winnerProposal,\n            uint256 inFavorVotes,\n            uint256 againstVotes,\n            uint256 votingExpirationTime\n        );\n\n    /**\n        Get user vote\n    */\n    function getUserVote(address user)\n        external\n        view\n        returns (address voteAddress, uint256 voteRound);\n\n    /**\n    will the call to unregister be successfull?\n\n    @param _proposal Address of the change contract that will be executed if this vote is successful\n    */\n    function canUnregister(address _proposal) external view returns (bool);\n\n    /**\n    Unregister a proposal, free the assets it uses.\n\n    @param _proposal Address of the change contract that will be executed if this vote is successful\n    */\n    function unregister(address _proposal) external;\n}\n\n\ncontract VotingMachine is VotingMachineStorage, IVotingMachine {\n    using SafeMath for uint256;\n\n    // Emitted by VotingLib\n    // event Vote(uint256 earnings, uint256 start, uint256 end);\n    event VoteEvent(\n        address indexed user,\n        address indexed subaccount,\n        address indexed destination,\n        uint256 amount,\n        uint256 mocs\n    );\n\n    modifier atState(VotingState _state) {\n        require(votingState == _state, \"Invalid state\");\n        _;\n    }\n\n    /**\n     @notice Contract creation\n\n     @param _governor The address of the contract which governs this one\n     @param _controlledGovernor The address of the governor that executes the change contracts\n    */\n    function initialize(\n        IGovernor _governor,\n        IGovernor _controlledGovernor,\n        IRegistry _registry\n    ) external initializer {\n        Governed._initialize(_governor);\n        votingState = VotingState.PreVoting;\n        registry = _registry;\n\n        votingRound = 1;\n        controlledGovernor = _controlledGovernor;\n        preVotingData._init();\n        votingData._init();\n    }\n\n    /**\n    get current contract state\n\n    */\n    function getState() external override view returns (uint256) {\n        return uint256(votingState);\n    }\n\n    /**\n        return the current voting round\n        */\n    function getVotingRound() external override view returns (uint256) {\n        return votingRound;\n    }\n\n    /**\n    Pre Vote\n\n    @param _changeContractAddress Address of the change contract that will be executed if this vote is successful\n    */\n    function preVote(address _changeContractAddress)\n        external\n        override\n        atState(VotingState.PreVoting)\n    {\n        require(_changeContractAddress != address(0), \"address must be != 0\");\n        (address winnerProposal, ) = _getWinnerProposal();\n        require(winnerProposal == address(0), \"There is a winner proposal\");\n\n        require(!preVotingData._isExpired(votingRound, _changeContractAddress), \"Proposal expired\");\n\n        uint256 stake = _getStake(registry, msg.sender);\n        Vote memory _vote = votes[msg.sender];\n        if (_alreadyVoted(_vote) && !preVotingData._isExpired(votingRound, _vote.addr)) {\n            // This is necessary to avoid storing the voting history.\n            require(_vote.addr == _changeContractAddress, \"Must vote the same proposal\");\n            uint256 locked = _getLockedStake(registry, msg.sender);\n            require(stake > locked, \"Not enough stake\");\n            stake = stake - locked;\n        }\n        // solhint-disable-next-line not-rely-on-time\n        _lockStake(registry, msg.sender, block.timestamp + _getVotingTimeDelta(registry));\n        votes[msg.sender] = Vote(_changeContractAddress, uint8(votingRound));\n\n        if (preVotingData._isEmptyProposal(votingRound, _changeContractAddress)) {\n            require(stake > _getMinStake(registry), \"Not enough stake\");\n            require(\n                preVotingData._upsert(\n                    votingRound,\n                    _getMaxPreProposals(registry),\n                    _getPreVoteExpirationTimeDelta(registry),\n                    _changeContractAddress,\n                    stake\n                ),\n                \"Not enough to add a proposal\"\n            );\n        } else {\n            require(\n                preVotingData._addVotes(votingRound, _changeContractAddress, stake),\n                \"Proposal expired\"\n            );\n        }\n    }\n\n    /**\n    Vote a proposal\n\n    @param _inFavorAgainst Type of vote\n    */\n    function vote(bool _inFavorAgainst) external override atState(VotingState.Voting) {\n        uint256 stake = _getStake(registry, msg.sender);\n        Vote memory _vote = votes[msg.sender];\n\n        // Those that voted something different than the winner proposal can use they whole stake\n        if (_alreadyVoted(_vote) && _vote.addr == votingData.winnerProposal) {\n            uint256 locked = _getLockedStake(registry, msg.sender);\n            require(stake > locked, \"Not enough stake\");\n            stake = stake - locked;\n        }\n        votes[msg.sender] = Vote(votingData.winnerProposal, uint8(votingRound));\n        votingData._addVotes(stake, _inFavorAgainst);\n    }\n\n    /**\n        Return vote info.\n    */\n    function getVoteInfo()\n        external\n        view\n        returns (\n            address winnerProposal,\n            uint256 inFavorVotes,\n            uint256 againstVotes\n        )\n    {\n        if (votingState != VotingState.Voting) {\n            return (address(0), 0, 0);\n        }\n        return (votingData.winnerProposal, votingData.inFavorVotes, votingData.againstVotes);\n    }\n\n    /**\n    Vote Condition\n    */\n    function vetoCondition() external override {}\n\n    /**\n    Veto\n    */\n    function veto() external override {}\n\n    function readyToPreVoteStep() external override view returns (bool) {\n        (address winnerProposal, ) = _getWinnerProposal();\n        return (winnerProposal != address(0));\n    }\n\n    /**\n    preVoteStep\n    */\n    function preVoteStep() external override atState(VotingState.PreVoting) {\n        (address winnerProposal, uint256 votesInFavor) = _getWinnerProposal();\n        require(winnerProposal != address(0), \"No winner proposal\");\n\n        votingState = VotingState.Voting;\n        // Expires all the pre-voting proposals.\n        votingData._startVoting(_getVotingTimeDelta(registry), winnerProposal, votesInFavor, 0);\n    }\n\n    function readyToVoteStep() external override view returns (bool) {\n        return (_isVeto() || _isAccepted() || votingData._isExpired());\n    }\n\n    /**\n    voteStep\n    */\n    function voteStep() external override atState(VotingState.Voting) {\n        if (_isVeto()) {\n            votingState = VotingState.PreVoting;\n            votingRound = votingRound + 1;\n        } else if (_isAccepted()) {\n            votingState = VotingState.Accepted;\n            votingRound = votingRound + 1;\n        } else if (votingData._isExpired()) {\n            votingState = VotingState.PreVoting;\n            votingRound = votingRound + 1;\n        }\n    }\n\n    /**\n    vetoStep\n    */\n    function vetoStep() external override {}\n\n    /**\n    acceptedStep\n    */\n    function acceptedStep() external override atState(VotingState.Accepted) {\n        {\n            // Try-catch and in any case change state to PreVoting.\n            try controlledGovernor.executeChange(ChangeContract(votingData.winnerProposal))  {\n                votingState = VotingState.PreVoting;\n            } catch Error(string memory) {\n                votingState = VotingState.PreVoting;\n            } catch (bytes memory) {\n                votingState = VotingState.PreVoting;\n            }\n        }\n    }\n\n    /**\n    will the call to unregister be successfull?\n\n    @param _changeContractAddress Address of the change contract that will be executed if this vote is successful\n    */\n    function canUnregister(address _changeContractAddress) external override view returns (bool) {\n        return (_changeContractAddress != address(0) &&\n            preVotingData._isEmptyProposal(votingRound, _changeContractAddress));\n    }\n\n    /**\n    Unregister a proposal, free the assets it uses.\n\n    @param _changeContractAddress Address of the change contract that will be executed if this vote is successful\n    */\n    function unregister(address _changeContractAddress) external override {\n        require(_changeContractAddress != address(0), \"address must be != 0\");\n        require(preVotingData._remove(votingRound, _changeContractAddress), \"Can't remove\");\n    }\n\n    /**\n    get the maximum total expiration time of a voting process.\n    */\n    function __totalExpirationTime() internal view returns (uint256) {\n        return _getPreVoteExpirationTimeDelta(registry) + _getVotingTimeDelta(registry);\n    }\n\n    /**\n    The used still didn't vote in this round\n    */\n    function _alreadyVoted(Vote memory _vote) internal view returns (bool) {\n        return (_vote.round == votingRound);\n    }\n\n    function _isAccepted() internal view returns (bool) {\n        return\n            votingData._isAccepted(\n                _getPCTPrecision(registry),\n                _getVoteMinPctToVeto(registry),\n                _getVoteMinPctForQuorum(registry),\n                _getVoteMinPctToAccept(registry),\n                _totalSupply(registry)\n            );\n    }\n\n    function _isVeto() internal view returns (bool) {\n        return\n            votingData._isVeto(\n                _getPCTPrecision(registry),\n                _getVoteMinPctToVeto(registry),\n                _totalSupply(registry)\n            );\n    }\n\n    function _getWinnerProposal() internal view returns (address candidate, uint256 maxVal) {\n        return\n            preVotingData._getWinnerProposal(\n                votingRound,\n                _getPreVoteMinPCToWin(registry),\n                _getPCTPrecision(registry),\n                _totalSupply(registry)\n            );\n    }\n\n    /**\n    Get the pre-voting registered proposal count.\n    */\n    function getProposalCount() external override view returns (uint256) {\n        return preVotingData._getProposalCount();\n    }\n\n    /**\n    Get pre-voting proposal address and information by index\n\n    @param _index Index of proposal to query. \n    */\n    function getProposalByIndex(uint256 _index)\n        external\n        override\n        view\n        returns (\n            address proposalAddress,\n            uint256 votingRound,\n            uint256 votes,\n            uint256 expirationTimeStamp\n        )\n    {\n        return preVotingData._getProposalByIndex(_index);\n    }\n\n    /**\n    Get voting data\n    */\n    function getVotingData()\n        external\n        override\n        view\n        returns (\n            address winnerProposal,\n            uint256 inFavorVotes,\n            uint256 againstVotes,\n            uint256 votingExpirationTime\n        )\n    {\n        return (\n            votingData.winnerProposal,\n            votingData.inFavorVotes,\n            votingData.againstVotes,\n            votingData.votingExpirationTime\n        );\n    }\n\n    /**\n        Get user vote\n    */\n    function getUserVote(address user)\n        external\n        override\n        view\n        returns (address voteAddress, uint256 voteRound)\n    {\n        Vote memory _vote = votes[user];\n        return (_vote.addr, _vote.round);\n    }\n}\n\n",
      "file": "VotingFlat.sol"
    }
  ],
  "libraries": {},
  "creationData": {
    "blockHash": "0x47b62cb4566156f677b91654afc6517ebf6a268e1f05a117205753902a5abf91",
    "blockNumber": 1330867,
    "transactionHash": "0x1187766c399f3d7fe0cf19b601658dd9794c371d6457c246b089913047378fe3",
    "timestamp": 1604959954
  }
}