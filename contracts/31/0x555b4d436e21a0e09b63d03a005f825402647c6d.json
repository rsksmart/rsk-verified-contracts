{
    "address": "0x555b4d436e21a0e09b63d03a005f825402647c6d",
    "net": {
        "id": "31",
        "name": "RSK Testnet"
    },
    "name": "TexMocBtcPriceProviderFallback",
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": "100"
        },
        "evmVersion": "byzantium"
    },
    "version": "0.5.8+commit.23d335f2",
    "source": "// SPDX-License-Identifier: \n// File: openzeppelin-eth/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.2;\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n// File: openzeppelin-eth/contracts/math/Math.sol\n\npragma solidity ^0.5.2;\n\n/**\n * @title Math\n * @dev Assorted math operations\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Calculates the average of two numbers. Since these are integers,\n     * averages of an even and odd number cannot be represented, and will be\n     * rounded down.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n\n// File: contracts/interface/IPriceProvider.sol\n\npragma solidity 0.5.8;\n\n/**\n * @notice Get price of a Token. See https://github.com/money-on-chain/OMoC-Decentralized-Oracle\n * @dev Interface of OMoC-Decentralized-Oracle, compatible with MOC.\n */\ninterface IPriceProvider {\n  function peek() external view returns (bytes32, bool);\n}\n\n// File: contracts/interface/IMoCDecentralizedExchange.sol\n\npragma solidity 0.5.8;\n\n\ncontract IMoCDecentralizedExchange {\n\n  function getTokenPairStatus(address _baseToken, address _secondaryToken)\n    external\n    view\n    returns (\n      uint256 emergentPrice,\n      uint256 lastBuyMatchId,\n      uint256 lastBuyMatchAmount,\n      uint256 lastSellMatchId,\n      uint64 tickNumber,\n      uint256 nextTickBlock,\n      uint256 lastTickBlock,\n      uint256 lastClosingPrice,\n      bool disabled,\n      uint256 emaPrice,\n      uint256 smoothingFactor,\n      uint256 marketPrice\n    );\n\n  function getLastClosingPrice(address _baseToken, address _secondaryToken) external view returns (uint256 lastClosingPrice) ;\n\n  function getEmergentPrice(address _baseToken, address _secondaryToken)\n    public\n    view\n    returns (\n      uint256 emergentPrice,\n      uint256 lastBuyMatchId,\n      uint256 lastBuyMatchAmount,\n      uint256 lastSellMatchId\n    );\n\n  function getMarketPrice(address _baseToken, address _secondaryToken) public view returns (uint256);\n\n}\n\n// File: contracts/price-providers/PriceProviderFallback.sol\n\npragma solidity 0.5.8;\n\n\n\n/**\n  @notice if the main price source is not available, falls back to dex\n          getLastClosingPrice method for the given pair\n  @dev This is an abstract contract as failablePeek() should be overriten\n  FIXME: if bumping to solidity 0.6, add \"abstract\" and \"virtual\" reserved words for readability\n*/\ncontract PriceProviderFallback is IPriceProvider {\n  IMoCDecentralizedExchange public dex;\n  address public baseToken;\n  address public secondaryToken;\n\n  /**\n    @param _dex contract to query for getLastClosingPrice fo the given pair\n    @param _baseToken base token of the pair to get the price from\n    @param _secondaryToken secondary token of the pair to get the price from\n  */\n  constructor(\n    IMoCDecentralizedExchange _dex,\n    address _baseToken,\n    address _secondaryToken\n  ) public {\n    dex = _dex;\n    baseToken = _baseToken;\n    secondaryToken = _secondaryToken;\n  }\n\n  /**\n    @dev quesries for failablePeek, and if get's and not valid price\n         falls back to the getLastClosingPrice price\n    @return the price, always true.\n  */\n  function peek() external view returns (bytes32, bool) {\n    (bytes32 price, bool isValid) = failablePeek();\n    bytes32 finalPrice = isValid ? price : fallbackPrice();\n    return (finalPrice, finalPrice != 0);\n  }\n\n  /**\n    @notice main source of this pair price\n    @return the price and true/false whether it's valid or not\n  */\n  function failablePeek() internal view returns (bytes32, bool);\n\n  function fallbackPrice() internal view returns (bytes32) {\n    uint256 lastClosingPrice = dex.getLastClosingPrice(baseToken, secondaryToken);\n    return bytes32(lastClosingPrice);\n  }\n\n}\n\n// File: contracts/interface/IMocState.sol\n\npragma solidity 0.5.8;\n\n/**\n * @notice Interface for MocState price providers relevant methods\n */\ninterface IMocState {\n\n  /**\n  * @dev BPro USD PRICE\n  * @return the BPro USD Price [using mocPrecision]\n  */\n  function bproUsdPrice() external view returns(uint256);\n\n  /**\n  * @dev BTC price of BPro\n  * @return the BPro Tec Price [using reservePrecision]\n  */\n  function bproTecPrice() external view returns(uint256);\n\n  /**\n  * @dev Gets the BTCPriceProviderAddress\n  * @return btcPriceProvider blocks there are in a day\n  **/\n  function getBtcPriceProvider() external view returns(address);\n}\n\n// File: contracts/price-providers/TexMocBtcPriceProviderFallback.sol\n\npragma solidity 0.5.8;\n\n\n\n\n\n/**\n  @notice gets the Bitcoin Price from MocState contract\n*/\ncontract TexMocBtcPriceProviderFallback is PriceProviderFallback {\n  using SafeMath for uint256;\n  IMocState public mocState;\n  address public baseTokenDocMoc;\n  address public secondaryTokenDocMoc;\n  uint256 public constant RATE_PRECISION = uint256(10**18);\n\n  constructor(\n    IMocState _mocState,\n    IMoCDecentralizedExchange _dex,\n    address _baseToken,\n    address _secondaryToken,\n    address _baseTokenDocMoc,\n    address _secondaryTokenDocMoc\n  ) public PriceProviderFallback(_dex, _baseToken, _secondaryToken) {\n    mocState = _mocState;\n    baseTokenDocMoc = _baseTokenDocMoc;\n    secondaryTokenDocMoc = _secondaryTokenDocMoc;\n  }\n\n  function failablePeek() internal view returns (bytes32, bool) {\n    // MocState BtcPriceProvider is complient with IPriceProvider interface\n    IPriceProvider priceProvider = IPriceProvider(mocState.getBtcPriceProvider());\n    (bytes32 btcPrice, bool isValid) = priceProvider.peek();\n    // Only if MocState BtcPriceProvider has a valid price\n    if (isValid && btcPrice != bytes32(0)) {\n      uint256 lastClosingPriceDoCMoc = dex.getLastClosingPrice(baseTokenDocMoc, secondaryTokenDocMoc);\n      //uint256 mocPriceBtc = lastClosingPriceDoCMoc.div(uint256(btcPrice));\n      uint256 mocPriceBtc = lastClosingPriceDoCMoc.mul(RATE_PRECISION).div(uint256(btcPrice));\n      return (bytes32(mocPriceBtc), mocPriceBtc != 0);\n    }\n    return (0, false);\n  }\n}\n",
    "imports": [
        {
            "name": "TexMocBtcPriceProviderFallback.sol",
            "contents": "// SPDX-License-Identifier: \n// File: openzeppelin-eth/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.2;\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n// File: openzeppelin-eth/contracts/math/Math.sol\n\npragma solidity ^0.5.2;\n\n/**\n * @title Math\n * @dev Assorted math operations\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Calculates the average of two numbers. Since these are integers,\n     * averages of an even and odd number cannot be represented, and will be\n     * rounded down.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n\n// File: contracts/interface/IPriceProvider.sol\n\npragma solidity 0.5.8;\n\n/**\n * @notice Get price of a Token. See https://github.com/money-on-chain/OMoC-Decentralized-Oracle\n * @dev Interface of OMoC-Decentralized-Oracle, compatible with MOC.\n */\ninterface IPriceProvider {\n  function peek() external view returns (bytes32, bool);\n}\n\n// File: contracts/interface/IMoCDecentralizedExchange.sol\n\npragma solidity 0.5.8;\n\n\ncontract IMoCDecentralizedExchange {\n\n  function getTokenPairStatus(address _baseToken, address _secondaryToken)\n    external\n    view\n    returns (\n      uint256 emergentPrice,\n      uint256 lastBuyMatchId,\n      uint256 lastBuyMatchAmount,\n      uint256 lastSellMatchId,\n      uint64 tickNumber,\n      uint256 nextTickBlock,\n      uint256 lastTickBlock,\n      uint256 lastClosingPrice,\n      bool disabled,\n      uint256 emaPrice,\n      uint256 smoothingFactor,\n      uint256 marketPrice\n    );\n\n  function getLastClosingPrice(address _baseToken, address _secondaryToken) external view returns (uint256 lastClosingPrice) ;\n\n  function getEmergentPrice(address _baseToken, address _secondaryToken)\n    public\n    view\n    returns (\n      uint256 emergentPrice,\n      uint256 lastBuyMatchId,\n      uint256 lastBuyMatchAmount,\n      uint256 lastSellMatchId\n    );\n\n  function getMarketPrice(address _baseToken, address _secondaryToken) public view returns (uint256);\n\n}\n\n// File: contracts/price-providers/PriceProviderFallback.sol\n\npragma solidity 0.5.8;\n\n\n\n/**\n  @notice if the main price source is not available, falls back to dex\n          getLastClosingPrice method for the given pair\n  @dev This is an abstract contract as failablePeek() should be overriten\n  FIXME: if bumping to solidity 0.6, add \"abstract\" and \"virtual\" reserved words for readability\n*/\ncontract PriceProviderFallback is IPriceProvider {\n  IMoCDecentralizedExchange public dex;\n  address public baseToken;\n  address public secondaryToken;\n\n  /**\n    @param _dex contract to query for getLastClosingPrice fo the given pair\n    @param _baseToken base token of the pair to get the price from\n    @param _secondaryToken secondary token of the pair to get the price from\n  */\n  constructor(\n    IMoCDecentralizedExchange _dex,\n    address _baseToken,\n    address _secondaryToken\n  ) public {\n    dex = _dex;\n    baseToken = _baseToken;\n    secondaryToken = _secondaryToken;\n  }\n\n  /**\n    @dev quesries for failablePeek, and if get's and not valid price\n         falls back to the getLastClosingPrice price\n    @return the price, always true.\n  */\n  function peek() external view returns (bytes32, bool) {\n    (bytes32 price, bool isValid) = failablePeek();\n    bytes32 finalPrice = isValid ? price : fallbackPrice();\n    return (finalPrice, finalPrice != 0);\n  }\n\n  /**\n    @notice main source of this pair price\n    @return the price and true/false whether it's valid or not\n  */\n  function failablePeek() internal view returns (bytes32, bool);\n\n  function fallbackPrice() internal view returns (bytes32) {\n    uint256 lastClosingPrice = dex.getLastClosingPrice(baseToken, secondaryToken);\n    return bytes32(lastClosingPrice);\n  }\n\n}\n\n// File: contracts/interface/IMocState.sol\n\npragma solidity 0.5.8;\n\n/**\n * @notice Interface for MocState price providers relevant methods\n */\ninterface IMocState {\n\n  /**\n  * @dev BPro USD PRICE\n  * @return the BPro USD Price [using mocPrecision]\n  */\n  function bproUsdPrice() external view returns(uint256);\n\n  /**\n  * @dev BTC price of BPro\n  * @return the BPro Tec Price [using reservePrecision]\n  */\n  function bproTecPrice() external view returns(uint256);\n\n  /**\n  * @dev Gets the BTCPriceProviderAddress\n  * @return btcPriceProvider blocks there are in a day\n  **/\n  function getBtcPriceProvider() external view returns(address);\n}\n\n// File: contracts/price-providers/TexMocBtcPriceProviderFallback.sol\n\npragma solidity 0.5.8;\n\n\n\n\n\n/**\n  @notice gets the Bitcoin Price from MocState contract\n*/\ncontract TexMocBtcPriceProviderFallback is PriceProviderFallback {\n  using SafeMath for uint256;\n  IMocState public mocState;\n  address public baseTokenDocMoc;\n  address public secondaryTokenDocMoc;\n  uint256 public constant RATE_PRECISION = uint256(10**18);\n\n  constructor(\n    IMocState _mocState,\n    IMoCDecentralizedExchange _dex,\n    address _baseToken,\n    address _secondaryToken,\n    address _baseTokenDocMoc,\n    address _secondaryTokenDocMoc\n  ) public PriceProviderFallback(_dex, _baseToken, _secondaryToken) {\n    mocState = _mocState;\n    baseTokenDocMoc = _baseTokenDocMoc;\n    secondaryTokenDocMoc = _secondaryTokenDocMoc;\n  }\n\n  function failablePeek() internal view returns (bytes32, bool) {\n    // MocState BtcPriceProvider is complient with IPriceProvider interface\n    IPriceProvider priceProvider = IPriceProvider(mocState.getBtcPriceProvider());\n    (bytes32 btcPrice, bool isValid) = priceProvider.peek();\n    // Only if MocState BtcPriceProvider has a valid price\n    if (isValid && btcPrice != bytes32(0)) {\n      uint256 lastClosingPriceDoCMoc = dex.getLastClosingPrice(baseTokenDocMoc, secondaryTokenDocMoc);\n      //uint256 mocPriceBtc = lastClosingPriceDoCMoc.div(uint256(btcPrice));\n      uint256 mocPriceBtc = lastClosingPriceDoCMoc.mul(RATE_PRECISION).div(uint256(btcPrice));\n      return (bytes32(mocPriceBtc), mocPriceBtc != 0);\n    }\n    return (0, false);\n  }\n}\n",
            "file": "TexMocBtcPriceProviderFallback.sol"
        }
    ],
    "libraries": {},
    "constructorArguments": [
        "0x0adb40132cb0ffcef6ed81c26a1881e214100555",
        "0xa066d6e20e122deb1139fa3ae3e96d04578c67b5",
        "0x09b6ca5e4496238a1f176aea6bb607db96c2286e",
        "0x0399c7f7b37e21cb9dae04fb57e24c68ed0b4635",
        "0x489049c48151924c07f86aa1dc6cc3fea91ed963",
        "0x0399c7f7b37e21cb9dae04fb57e24c68ed0b4635"
    ],
    "creationData": {
        "blockHash": "0xb68f6347c1fdce3793eb6b6cbfc6e5b9f30e1615eaac56cd2266ccebf79ca191",
        "blockNumber": 1788112,
        "transactionHash": "0xdbd70f5e8d85b3c5cfffd018082f285b1e38556c8586e7726bd6027865cd812e",
        "timestamp": 1619198507
    }
}